#include "stdafx.h"
#include "Wintempla.h"
/**************************************************************************
   THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
   ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
   THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
   PARTICULAR PURPOSE.  I ACCEPT NO LIABILITY FOR ANY DAMAGE OR LOSS
   OF BUSINESS THAT THIS SOFTWARE MAY CAUSE.

   Wintempla.cpp
 
   © Copyright 2004 - 2013 Sergio Ledesma.  All Rights Reserved.

   THIS CODE IS PROTECTED BY COPYRIGHT LAW AND INTERNATIONAL TREATIES.
	UNAUTHORIZED REPRODUCTION OR DISTRIBUTION OF THIS CODE, OR ANY PORTION
	OF IT, MAY RESULT IN SEVERE CIVIL AND CRIMINAL PENALTIES, AND WILL BE
	PROSECUTED TO THE MAXIMUM EXTENT POSSIBLE UNDER THE LAW.

	ESTE CODIGO ESTA PROTEGIDO POR LAS LEYES Y TRATADOS DE DERECHO AUTOR
	INTERNACIONALES.  LA REPRODUCCION SIN AUTORIZACION O LA DISTRIBUCION
	DE ESTE CODIGO, O CUALQUIER PARTE DE ESTE, RESULTARA EN SEVERA
	PENALIDAD CIVIL Y CRIMINAL, Y SERA PERSEGUIDA HASTA SU MAXIMA 
	EXTENSION BAJO LO QUE PERMITA LA LEY.
***************************************************************************/

namespace Com //_______________________________________ namespace Com::Ini
{

wchar_t* Error::GetDescription(HRESULT hr)
{
	if (hr == DISP_E_BADPARAMCOUNT)
	{
		return L"The number of elements provided to DISPPARAMS is different from the number of arguments accepted by the method or property.";
	}
	else if (hr == DISP_E_BADVARTYPE)
	{
		return L"One of the arguments in rgvarg is not a valid variant type. ";
	}
	else if (hr == DISP_E_EXCEPTION)
	{
		return L"The application raised an exception.";
	}
	else if (hr == DISP_E_MEMBERNOTFOUND)
	{
		return L"The requested member does not exist, or the call to Invoke tried to set the value of a read-only property. ";
	}
	else if (hr == DISP_E_NONAMEDARGS)
	{
		return L"This implementation of IDispatch does not support named arguments.";
	}
	else if (hr == DISP_E_OVERFLOW)
	{
		return L"One of the arguments in rgvarg could not be coerced to the specified type.";
	}
	else if (hr == DISP_E_PARAMNOTFOUND)
	{
		return L"One of the parameter DISPIDs does not correspond to a parameter on the method. In this case, puArgErr should be set to the first argument that contains the error.";
	}
	else if (hr == DISP_E_TYPEMISMATCH)
	{
		return L"One or more of the arguments could not be coerced. The index within rgvarg of the first parameter with the incorrect type is returned in the puArgErr parameter.";
	}
	else if (hr == DISP_E_UNKNOWNINTERFACE)
	{
		return L"The interface identifier passed in riid is not IID_NULL.";
	}
	else if (hr == DISP_E_UNKNOWNLCID)
	{
		return L"The member being invoked interprets string arguments according to the LCID, and the LCID is not recognized. If the LCID is not needed to interpret arguments, this error should not be returned.";
	}
	else if (hr == DISP_E_PARAMNOTOPTIONAL)
	{
		return L"A required parameter was omitted";
	}
	else if (hr == CO_E_CLASSSTRING)
	{
		return L"The registered CLSID for the ProgID is invalid.";
	}
	else if (hr == REGDB_E_WRITEREGDB)
	{
		return L"An error occurred writing the CLSID to the registry.";
	}
	else if (hr == E_OUTOFMEMORY)
	{
		return L"Ran out of memory.";
	}
	else if (hr == E_INVALIDARG)
	{
		return L"One or more arguments are invalid.";
	}
	else if (hr == E_NOINTERFACE)
	{
		return L"No such interface supported.";
	}
	else if (hr == E_POINTER)
	{
		return L"Invalid pointer.";
	}
	else if (hr == E_HANDLE)
	{
		return L"Invalid handle.";
	}
	else if (hr == E_ABORT)
	{
		return L"Operation aborted.";
	}
	else if (hr == E_ACCESSDENIED)
	{
		return L"General access denied error.";
	}
	else if (hr == E_PENDING)
	{
		return L" The data necessary to complete this operation is not yet available.";
	}

	return NULL;
}

//_______________________________________________________________ ActiveXInfo
ActiveXInfo::ActiveXInfo()
{
}

ActiveXInfo::~ActiveXInfo()
{
}

bool ActiveXInfo::operator<(const ActiveXInfo& input) const
{
	return (this->descr < input.descr);
}

//______________________________________________________________ Error
void Error::Display(HWND hWnd, _com_error e, wchar_t* caption)
{
	HRESULT hr = e.Error();
	if (SUCCEEDED(hr)) return;
	wchar_t texto[WINCOM_MAX_ERROR];
	if(hr==DISP_E_EXCEPTION)
	{
		_snwprintf_s(texto, WINCOM_MAX_ERROR, _TRUNCATE,
			L"Source: %s\r\nDescription: %s\r\nHelp File: %s", e.Source(), e.Description(), e.HelpFile());
		::MessageBoxW(hWnd, texto, caption, MB_OK | MB_ICONERROR | MB_SETFOREGROUND);
	}
	else
	{
		wchar_t* lpMsgBuf;
		::FormatMessageW(
			FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, NULL, 
			hr,
			MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
			(wchar_t*)&lpMsgBuf, 0, NULL);
		::MessageBoxW(hWnd, lpMsgBuf, caption, MB_OK | MB_ICONERROR | MB_SETFOREGROUND);
		::LocalFree( lpMsgBuf );
	}
	wchar_t* descr = Com::Error::GetDescription(hr);
	if (descr) ::MessageBoxW(hWnd, descr, caption, MB_OK | MB_ICONERROR | MB_SETFOREGROUND);

//	int n = e.
//	if (this->argError>=0)
//	{
//		_snwprintf_s(texto, WINCOM_MAX_ERROR, _TRUNCATE, L"Error in argument: %d", (int)this->argError);
//		::MessageBoxW(hWnd, texto, caption, MB_OK | MB_ICONERROR | MB_SETFOREGROUND);
//	}
}

void Error::Display(HWND hWnd, HRESULT hr, EXCEPINFO excepInfo, UINT argError, wchar_t * caption)
{
	if (SUCCEEDED(hr)) return;
	wchar_t texto[WINCOM_MAX_ERROR];
	if(hr==DISP_E_EXCEPTION)
	{
		_snwprintf_s(texto, WINCOM_MAX_ERROR, _TRUNCATE,
			L"Source: %s\r\nDescription: %s\r\nHelp File: %s", 
			excepInfo.bstrSource, excepInfo.bstrDescription, excepInfo.bstrSource);
		::MessageBoxW(hWnd, texto, caption, MB_OK | MB_ICONERROR | MB_SETFOREGROUND);
	}
	else
	{
		wchar_t* lpMsgBuf;
		::FormatMessageW(
			FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, NULL, 
			hr,
			MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
			(wchar_t*)&lpMsgBuf, 0, NULL);
		::MessageBoxW(hWnd, lpMsgBuf, caption, MB_OK | MB_ICONERROR | MB_SETFOREGROUND);
		::LocalFree( lpMsgBuf );
	}
	wchar_t* descr = Com::Error::GetDescription(hr);
	if (descr) ::MessageBoxW(hWnd, descr, caption, MB_OK | MB_ICONERROR | MB_SETFOREGROUND);

	if (argError>=0)
	{
		_snwprintf_s(texto, WINCOM_MAX_ERROR, _TRUNCATE, L"Error in argument: %d", (int)argError);
		::MessageBoxW(hWnd, texto, caption, MB_OK | MB_ICONERROR | MB_SETFOREGROUND);
	}
}


//_______________________________________________________________ ExceptionInfo
ExceptionInfo::ExceptionInfo()
{
	this->hr = S_OK;
}

ExceptionInfo::ExceptionInfo(HRESULT hr, const wstring& caption)
{
	this->hr = hr;
	this->caption = caption;
}

ExceptionInfo::~ExceptionInfo()
{
}

//Com::ExceptionInfo& ExceptionInfo::operator =(const Com::ExceptionInfo& ei)
//{
//	if (FAILED(ei.hr))
//	{
//		throw Com::ExceptionInfo(ei.hr, ei.caption);
//	}
//	return *this;
//}

Com::ExceptionInfo& ExceptionInfo::operator =(const HRESULT hr)
{
	this->hr = hr;
	if (FAILED(hr))
	{
		throw Com::ExceptionInfo(hr, this->caption);
	}
	return *this;
}

void ExceptionInfo::GetDescription(wstring& result)
{
	wchar_t* descr = Com::Error::GetDescription(hr);
	//LPVOID lpMsgBuf;
	//::FormatMessage( 
	//	FORMAT_MESSAGE_ALLOCATE_BUFFER | 
	//	FORMAT_MESSAGE_FROM_SYSTEM | 
	//	FORMAT_MESSAGE_IGNORE_INSERTS,
	//	NULL,
	//	::GetLastError(),
	//	MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
	//	(LPTSTR) &lpMsgBuf,
	//	0,
	//	NULL 
	//);
	result = caption + L": ";
	if (descr) result += descr;
	//result += L" ";
	//result += (wchar_t*)lpMsgBuf;
	//::LocalFree( lpMsgBuf );
}


//_______________________________________________________________ Exception
Exception::Exception()
{
}

Exception::~Exception()
{
}

//Exception& Exception::operator= (const Exception& init) //Operator =
//{
//	//Destructor();
//	//Copy(init);
//	return *this;
//}
//
//Exception& Exception::operator= (const HRESULT hr)
//{
//	this->hr = hr;
//	return *this;
//}

Com::ExceptionInfo& Exception::operator[](wchar_t* caption) // Subscript operator
{
	ei.caption = caption;
	return ei;
}


//______________________________________________________________ CDispatchPtr 


} //__________________________________________________ namespace Com::End

namespace Sys //________________________________________ namespace Sys::Ini
{

//_____________________________________________________________________ IError
//_____________________________________________________________________ Sample8
//_____________________________________________________________________ Sample16
//_____________________________________________________________________ IListFileDirectory
//_____________________________________________________________________ IListFileDirRecursive
//_____________________________________________________________________ ITextWriterA
//_____________________________________________________________________ ITextWriterW
//_____________________________________________________________________ IStorer
//_____________________________________________________________________ IVisualStudio
//_____________________________________________________________________ Format
//_____________________________________________________________________ DisplayLastError
//_____________________________________________________________________ GetLastErrorInformation
//_____________________________________________________________________ DisplayLastError
//_____________________________________________________________________ DisplayLastError
//_____________________________________________________________________ Point2D
//_____________________________________________________________________ Bound2D
Bound2D::Bound2D()
{
	x = 0.0f;
	y = 0.0f;
	dx = 0.0f;
	dy = 0.0f;
}

Bound2D::~Bound2D()
{
}

bool Bound2D::DoIntersect(vector<Sys::Bound2D>& bounds1, vector<Sys::Bound2D>& bounds2)
{
	const int size1 = bounds1.size();
	if (size1 == 0) return false;
	const int size2 = bounds2.size();
	if (size2 == 0) return false;
	
	const vector<Sys::Bound2D>::iterator b1End = bounds1.end()-1;
	const vector<Sys::Bound2D>::iterator b2End = bounds2.end()-1;
	vector<Sys::Bound2D>::iterator b1, b2;
	for(b1 = bounds1.begin(); b1 != b1End; b1++)
	{
		for(b2 = bounds2.begin(); b2 != b2End; b2++)
		{
			if (Sys::Bound2D::DoIntersect(*b1, *(b1+1), *b2, *(b2+1)) == true) return true;
		}
	}
	return false;
}

bool Bound2D::DoIntersect(Sys::Bound2D& b1, Sys::Bound2D& b2, Sys::Bound2D& b3, Sys::Bound2D& b4)
{
	const float denominator = (b4.dy)*(b2.dx) - (b4.dx)*(b2.dy);//(y4-y3) * (x2-x1) - (x4-x3) * (y2-y1);
	const float dx = (b1.x - b3.x);
	const float dy = (b1.y - b3.y);
	const float numeratorA = (b4.dx)*dy - (b4.dy)*dx;// (x4-x3) * (y1-y3) - (y4-y3) * (x1-x3);
	const float numeratorB = (b2.dx)*dy - (b2.dy)*dx;//(x2-x1) * (y1-y3) - (y2-y1) * (x1-x3);
	const float zero = 0.00000000001f;

	//_______________________________ coincident
	if (fabs(numeratorA) < zero && fabs(numeratorB) < zero && fabs(denominator) < zero) return true;
	//_______________________________ parallel
	if (fabs(denominator) < zero) return false;
	//__________________________________ intersection along the the segments
	const float mA = numeratorA/denominator;
	const float mB = numeratorB/denominator;
	if (mA < 0 || mA > 1 || mB < 0 || mB > 1)  return false;
	return true;
}

bool Bound2D::DoIntersect(vector<Sys::Bound2D>& bounds1, vector<Sys::Bound2D>& bounds2, Sys::Point2D& out_intersection)
{
	const int size1 = bounds1.size();
	if (size1 == 0) return false;
	const int size2 = bounds2.size();
	if (size2 == 0) return false;
	
	const vector<Sys::Bound2D>::iterator b1End = bounds1.end()-1;
	const vector<Sys::Bound2D>::iterator b2End = bounds2.end()-1;
	vector<Sys::Bound2D>::iterator b1, b2;
	for(b1 = bounds1.begin(); b1 != b1End; b1++)
	{
		for(b2 = bounds2.begin(); b2 != b2End; b2++)
		{
			if (Sys::Bound2D::DoIntersect(*b1, *(b1+1), *b2, *(b2+1), out_intersection) == true) return true;
		}
	}
	return false;
}

bool Bound2D::DoIntersect(Sys::Bound2D& b1, Sys::Bound2D& b2, Sys::Bound2D& b3, Sys::Bound2D& b4, Sys::Point2D& out_intersection)
{
	out_intersection.x = 0.0f;
	out_intersection.y = 0.0f;

	const float denominator = (b4.dy)*(b2.dx) - (b4.dx)*(b2.dy);//(y4-y3) * (x2-x1) - (x4-x3) * (y2-y1);
	const float dx = (b1.x - b3.x);
	const float dy = (b1.y - b3.y);
	const float numeratorA = (b4.dx)*dy - (b4.dy)*dx;// (x4-x3) * (y1-y3) - (y4-y3) * (x1-x3);
	const float numeratorB = (b2.dx)*dy - (b2.dy)*dx;//(x2-x1) * (y1-y3) - (y2-y1) * (x1-x3);
	const float zero = 0.00000000001f;

	//_______________________________ coincident
	if (fabs(numeratorA) < zero && fabs(numeratorB) < zero && fabs(denominator) < zero)
	{
		out_intersection.x = (b1.x + b2.x) / 2.0f;
		out_intersection.y = (b1.y + b2.y) / 2.0f;
		return true;
	}

	//_______________________________ parallel
	if (fabs(denominator) < zero) return false;

	//__________________________________ intersection along the the segments
	const float mA = numeratorA/denominator;
	const float mB = numeratorB/denominator;
	if (mA < 0 || mA > 1 || mB < 0 || mB > 1)  return false;

	out_intersection.x = b1.x + mA * (b2.dx);
	out_intersection.y = b1.y + mA * (b2.dy);
	return true;
}

// Computes the shortest distance from the line segment p1-p2 to any of the the line segments in bounds
float Bound2D::ShortestDistance(Sys::Point2D& p1, Sys::Point2D& p2, vector<Sys::Bound2D>& bounds)
{
	float distance = (float)1.0e30;
	//
	Sys::Bound2D b1;
	b1.x = p1.x;
	b1.y = p1.y;
	b1.dx = 0.0f;
	b1.dy = 0.0f;
	//
	Sys::Bound2D b2;
	b2.x = p2.x;
	b2.y = p2.y;
	b2.dx = p2.x - p1.x;
	b2.dy = p2.y - p1.y;
	//
	const int size = bounds.size();
	if (size == 0) return distance;
	
	const vector<Sys::Bound2D>::iterator bEnd = bounds.end()-1;
	vector<Sys::Bound2D>::iterator b;
	Sys::Point2D intersection;
	float currentDistance = 0.0f;
	for(b = bounds.begin(); b !=  bEnd; b++)
	{
		if (Sys::Bound2D::DoIntersect(b1, b2, *b, *(b+1), intersection) == true)
		{
			currentDistance = Sys::Bound2D::Distance(p1, intersection);
			if (currentDistance < distance) distance = currentDistance;
		}
	}
	return distance;
}

float Bound2D::Distance(Sys::Point2D& p1, Sys::Point2D& p2)
{
	const float dx = p1.x - p2.x;
	const float dy = p1.y - p2.y;
	return sqrt(dx*dx + dy*dy);
}

//_____________________________________________________________________ Point3D
//_____________________________________________________________________ RotatedRectangle
RotatedRectangle::RotatedRectangle()
{
	p1.x = 0.0f;
	p1.y = 0.0f;
	//
	p2.x = 0.0f;
	p2.y = 0.0f;
	//
	p3.x = 0.0f;
	p3.y = 0.0f;
	//
	p4.x = 0.0f;
	p4.y = 0.0f;
}

RotatedRectangle::~RotatedRectangle()
{
}

bool RotatedRectangle::IsInsideRegion(const vector<Rectangle>& regionBig) const
{
	bool isInside = false;
	const int len = regionBig.size();
	if (len == 0) return false;
	int i;
	//
	//________________________ Point1
	isInside = false;
	for(i = 0; i<len; i++)
	{
		if (regionBig[i].IsInside(p1) == true)
		{
			isInside = true;
			break;
		}
	}
	if (isInside == false) return false;
	//
	//________________________ Point2
	isInside = false;
	for(i = 0; i<len; i++)
	{
		if (regionBig[i].IsInside(p2) == true)
		{
			isInside = true;
			break;
		}
	}
	if (isInside == false) return false;
	//
	//________________________ Point3
	isInside = false;
	for(i = 0; i<len; i++)
	{	
		if (regionBig[i].IsInside(p3) == true)
		{
			isInside = true;
			break;
		}
	}
	if (isInside == false) return false;
	//
	//________________________ Point4
	isInside = false;
	for(i = 0; i<len; i++)
	{
		if (regionBig[i].IsInside(p4) == true)
		{
			isInside = true;
			break;
		}
	}
	if (isInside == false) return false;
	return true;
}

//_____________________________________________________________________ Rectangle
Rectangle::Rectangle()
{
	left = 0.0f;
	top = 0.0f;
	right = 0.0f;
	bottom = 0.0f;
}

Rectangle::~Rectangle()
{
}

bool Rectangle::IsInside(const RotatedRectangle& rectSmall) const
{
	if (IsInside(rectSmall.p1) == false) return false;
	if (IsInside(rectSmall.p2) == false) return false;
	if (IsInside(rectSmall.p3) == false) return false;
	if (IsInside(rectSmall.p4) == false) return false;
	return true;
}

bool Rectangle::IsInside(const Sys::Point2D& point) const
{
	if (left < right)
	{
		if (point.x < left) return false;
		if (point.x > right) return false;
	}
	else
	{
		if (point.x < right) return false;
		if (point.x > left) return false;
	}
	if (top < bottom)
	{
		if (point.y < top) return false;
		if (point.y > bottom) return false;
	}
	else
	{
		if (point.y < bottom) return false;
		if (point.y > top) return false;
	}

	return true;
}

bool Rectangle::IsInside(const Rectangle& rectSmall) const
{
	Sys::Point2D point;
	//
	point.x = rectSmall.left;
	point.y = rectSmall.top;
	if (IsInside(point) == false) return false;
	//
	point.x = rectSmall.right;
	point.y = rectSmall.top;
	if (IsInside(point) == false) return false;
	//
	point.x = rectSmall.left;
	point.y = rectSmall.bottom;
	if (IsInside(point) == false) return false;
	//
	point.x = rectSmall.right;
	point.y = rectSmall.bottom;
	if (IsInside(point) == false) return false;
	//
	return true;
}

bool Rectangle::IsIntersected(const Rectangle& rect) const
{
	if (left<=rect.left)
	{
		if (right<rect.left) return false;
	}
	else
	{
		if (rect.right<left) return false;
	}

	if (top<=rect.top)
	{
		if (bottom<rect.top) return false;
	}
	else
	{
		if (rect.bottom<top) return false;
	}
	return true;
}

bool Rectangle::IsInsideRegion(const vector<Rectangle>& regionBig) const
{
	bool isInside = false;
	Sys::Point2D point;
	const int len = regionBig.size();
	if (len == 0) return false;
	int i;
	//
	//________________________ Point1
	isInside = false;
	point.x = left;
	point.y = top;
	for(i = 0; i<len; i++)
	{
		if (regionBig[i].IsInside(point) == true)
		{
			isInside = true;
			break;
		}
	}
	if (isInside == false) return false;
	//
	//________________________ Point2
	isInside = false;
	point.x = right;
	point.y = top;
	for(i = 0; i<len; i++)
	{
		if (regionBig[i].IsInside(point) == true)
		{
			isInside = true;
			break;
		}
	}
	if (isInside == false) return false;
	//
	//________________________ Point3
	isInside = false;
	point.x = left;
	point.y = bottom;
	for(i = 0; i<len; i++)
	{	
		if (regionBig[i].IsInside(point) == true)
		{
			isInside = true;
			break;
		}
	}
	if (isInside == false) return false;
	//
	//________________________ Point4
	isInside = false;
	point.x = right;
	point.y = bottom;
	for(i = 0; i<len; i++)
	{
		if (regionBig[i].IsInside(point) == true)
		{
			isInside = true;
			break;
		}
	}
	if (isInside == false) return false;
	return true;
}

#ifdef WIN_GDI_PLUS_ON
//_____________________________________________________________________ ImageStream
ImageStream::ImageStream()
{
	m_nRefCount = 0;
	m_cb.HighPart = 0;
	m_cb.LowPart = 0;
	SYSTEMTIME st;
	GetSystemTime(&st);
	SystemTimeToFileTime(&st, &m_filetimeCreation);
	SystemTimeToFileTime(&st, &m_filetimeLastWrite);
	SystemTimeToFileTime(&st, &m_filetimeLastRead);
	data = NULL;
}

ImageStream::~ImageStream()
{
}

//BMP 
//GIF 
//JPEG 
//PNG 
//TIFF 
//GDI+ also has built-in decoders that support the following file types: 
//WMF 
//EMF 
//ICON 
int ImageStream::GetEncoderClsid(const wchar_t* format, CLSID* pClsid)
{
	UINT  num = 0;          // number of image encoders
	UINT  size = 0;         // size of the image encoder array in bytes

	Gdiplus::ImageCodecInfo* pImageCodecInfo = NULL;

	Gdiplus::GetImageEncodersSize(&num, &size);
	if(size == 0) return -1;  // Failure

	pImageCodecInfo = (Gdiplus::ImageCodecInfo*)(malloc(size));
	if(pImageCodecInfo == NULL) return -1;  // Failure

	GetImageEncoders(num, size, pImageCodecInfo);
	for(UINT j = 0; j < num; ++j)
	{
		if( wcscmp(pImageCodecInfo[j].MimeType, format) == 0 )
		{
			*pClsid = pImageCodecInfo[j].Clsid;
			free(pImageCodecInfo);
			return j;  // Success
		}    
	}
	free(pImageCodecInfo);
	return -1;  // Failure
}

IStream* ImageStream::CreateAllocator(string* data)
{
	ImageStream * pImgStream = new ImageStream();

	if (pImgStream!=NULL)
	{
		pImgStream->data = data;
		pImgStream->AddRef();
	}
	else
	{
		delete pImgStream;
	}
	return (IStream*)pImgStream;
}

STDMETHODIMP ImageStream::QueryInterface(REFIID riid, LPVOID FAR * ppvObject)
{
	*ppvObject = NULL;
	if (riid==IID_IUnknown) *ppvObject = (LPUNKNOWN)this;
	if (riid==IID_IStream) *ppvObject = (ImageStream*)this;
	if (*ppvObject==NULL) return E_NOINTERFACE;
	
	((LPUNKNOWN)*ppvObject)->AddRef();
	return S_OK;
}

STDMETHODIMP_ (ULONG) ImageStream::AddRef(void)
{
	return ++m_nRefCount;
}

STDMETHODIMP_ (ULONG) ImageStream::Release(void)
{
	--m_nRefCount;
	if (0L != m_nRefCount) return m_nRefCount;
	delete this;
	return 0L;
}

STDMETHODIMP ImageStream::Read (void *pv, ULONG cb, ULONG *pcbRead)
{
	SYSTEMTIME st;
	GetSystemTime(&st);
	SystemTimeToFileTime(&st, &m_filetimeLastRead);
	return S_OK;
}

STDMETHODIMP ImageStream::Write(const void *pv, ULONG cb, ULONG *pcbWritten)
{
	*pcbWritten = cb;
	const int len = cb;
	const char* p = (const char*)pv;
	if (data != NULL)
	{
		data->append(p, len);
	}

	m_cb.LowPart+=(*pcbWritten);
	SYSTEMTIME st;
	GetSystemTime(&st);
	SystemTimeToFileTime(&st, &m_filetimeLastWrite);
	return S_OK;
}

STDMETHODIMP ImageStream::Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition)
{
	return S_OK;
}

STDMETHODIMP ImageStream::SetSize(ULARGE_INTEGER libNewSize)
{
	return S_OK;
}

STDMETHODIMP ImageStream::CopyTo(IStream *pstm, ULARGE_INTEGER cb, 
		ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten)
{
	return E_NOINTERFACE;
}

STDMETHODIMP ImageStream::Commit(DWORD grfCommitFlags)
{
	return E_NOINTERFACE;
}

STDMETHODIMP ImageStream::Revert()
{
	return E_NOINTERFACE;
}

STDMETHODIMP ImageStream::LockRegion( ULARGE_INTEGER libOffset, ULARGE_INTEGER cb,
		DWORD dwLockType)
{
	return E_NOINTERFACE;
}

STDMETHODIMP ImageStream::UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb,
		DWORD dwLockType)
{
	return E_NOINTERFACE;
}

STDMETHODIMP ImageStream::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
	m_sta.type = STGTY_STREAM;
	m_sta.atime = m_filetimeLastRead;
	m_sta.cbSize = m_cb;
	m_sta.clsid = CLSID_NULL; //No used
	m_sta.ctime = m_filetimeCreation;
	m_sta.grfLocksSupported = LOCK_WRITE;
	m_sta.grfMode = 0; // No used
	m_sta.grfStateBits = 0; // No used
	m_sta.mtime = m_filetimeLastWrite;
	m_sta.pwcsName = LPOLESTR("FILESTREAM");
	return E_NOINTERFACE;
}

STDMETHODIMP ImageStream::Clone(IStream **ppstm)
{
	return E_NOINTERFACE;
}
#endif
//_____________________________________________________________________ Stopwatch

//________________________________________ RunProgram
RunProgram::RunProgram(void)
{
	m_pipeRead = NULL;
	ZeroMemory(&m_pi, sizeof(PROCESS_INFORMATION));
}
void RunProgram::Close()
{
	if (m_pipeRead)
	{
		CloseHandle(m_pipeRead);
		m_pipeRead = NULL;
	}
}

RunProgram::~RunProgram(void)
{
	Close();
}

bool RunProgram::OpenFile(const wchar_t* filename)
{
	//::CoInitializeEx(NULL, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE);
	if (ShellExecuteW(NULL, L"open", filename, NULL, NULL, SW_SHOW)<(HANDLE)32)
	{
		//::CoUninitialize();
		return false;
	}
	//::CoUninitialize();
	return true;
}

bool RunProgram::OpenFile(const wchar_t* filename, const wchar_t* workingDirectory)
{
	//::CoInitializeEx(NULL, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE);
	if (ShellExecuteW(NULL, L"open", filename, NULL, workingDirectory, SW_SHOW)<(HANDLE)32)
	{
		//::CoUninitialize();
		return false;
	}
	//::CoUninitialize();
	return true;
}

bool RunProgram::OpenFile(const wstring& filename)
{
	return OpenFile(filename.c_str());
}

bool RunProgram::OpenFile(const wstring& filename, const wstring& workingDirectory)
{
	return OpenFile(filename.c_str(), workingDirectory.c_str());
}

bool RunProgram::Execute(const wchar_t* programName, string& output)
{
	bool bOk = false;
	char sz[1024];
	DWORD dwRead;
	output.clear();

	if (this->Execute(programName))
	{
		while(this->Read(sz, 1023, &dwRead)!=0 && dwRead!=0)
		{
			sz[dwRead] = '\0';
			output+=sz;
		}
		this->Close();
		bOk = true;
	}
	//::ExitProcess(0);
	return bOk;
}

BOOL RunProgram::Read(LPVOID buffer, DWORD numberOfBytesToRead, LPDWORD numberOfBytesRead)
{
	return ::ReadFile(m_pipeRead, buffer, numberOfBytesToRead, numberOfBytesRead, NULL);
}

// You need to use Read to read the output return by the program
bool RunProgram::Execute(const wchar_t* programName)
{
	HANDLE pipeWrite = NULL;
	bool bOk = false;

	Close();
	if (programName)
	{
		wchar_t* psz = new wchar_t[wcslen(programName)+1];
		lstrcpy(psz, programName);
		m_sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		m_sa.lpSecurityDescriptor = NULL;
		m_sa.bInheritHandle = TRUE;
		if (CreatePipe(&m_pipeRead, &pipeWrite, &m_sa, 0) != 0)
		{
			ZeroMemory(&m_si, sizeof(STARTUPINFO));
			m_si.cb = sizeof(STARTUPINFO);
			m_si.dwFlags = STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;
			m_si.hStdInput = NULL;
			m_si.hStdOutput = pipeWrite;
			m_si.hStdError = GetStdHandle(STD_ERROR_HANDLE);
			m_si.wShowWindow = SW_HIDE;

			bOk = (::CreateProcess(NULL, psz, NULL, NULL, TRUE, 0, NULL, NULL, &m_si, &m_pi)!=0);
		}
		if (pipeWrite) CloseHandle(pipeWrite);
		if (psz) delete [] psz;
	}
	return bOk;
}

bool RunProgram::Execute(const wchar_t* programName, const wchar_t* workingDirectory, bool showWindow)
{
	HANDLE pipeWrite = NULL;
	bool bOk = false;

	Close();
	if (programName)
	{
		wchar_t* psz = new wchar_t[wcslen(programName)+1];
		lstrcpy(psz, programName);
		m_sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		m_sa.lpSecurityDescriptor = NULL;
		m_sa.bInheritHandle = TRUE;
		if (CreatePipe(&m_pipeRead, &pipeWrite, &m_sa, 0) != 0)
		{
			ZeroMemory(&m_si, sizeof(STARTUPINFO));
			m_si.cb = sizeof(STARTUPINFO);
			m_si.dwFlags = STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;
			m_si.hStdInput = NULL;
			m_si.hStdOutput = pipeWrite;
			m_si.hStdError = GetStdHandle(STD_ERROR_HANDLE);
			m_si.wShowWindow = showWindow ? SW_SHOWNORMAL : SW_HIDE;

			bOk = (::CreateProcess(NULL, psz, NULL, NULL, TRUE, 0, NULL, workingDirectory, &m_si, &m_pi)!=0);
		}
		if (pipeWrite) CloseHandle(pipeWrite);
		if (psz) delete [] psz;
	}
	return bOk;
}

bool RunProgram::Execute(const wchar_t* programName, const wchar_t* workingDirectory, bool showWindow, string& output)
{
	bool bOk = false;
	char sz[1024];
	DWORD dwRead;
	output.clear();

	if (this->Execute(programName, workingDirectory, showWindow))
	{
		while(this->Read(sz, 1023, &dwRead)!=0 && dwRead!=0)
		{
			sz[dwRead] = '\0';
			output+=sz;
		}
		this->Close();
		bOk = true;
	}
	//::ExitProcess(0);
	return bOk;
}

//________________________________________ Install
Install::Install(void)
{
	buffer[0]='\0';
}

Install::~Install(void)
{
}

const wchar_t* Install::GetCurrentDirectory_(void)
{
	buffer[0]='\0';
	if (::GetCurrentDirectory(SYS_INSTBUFF, buffer)!=0) return buffer;
	return NULL;
}

bool Install::RemoveShortcut(const wchar_t* productName)
{
	wchar_t shortcutFilename[SYS_INSTBUFF];

	_snwprintf_s(shortcutFilename, SYS_INSTBUFF, _TRUNCATE, L"%s\\%s.lnk", GetStartupMenuProgramsPath(), productName);
	shortcutFilename[SYS_INSTBUFF-1]='\0';
	//
	return (::DeleteFile(shortcutFilename)!=0);
}

bool Install::ApplicationFolder(Sys::Install::ProductInfo& pi, Sys::IError& error, bool isInstall)
{
	const wchar_t *programFilesPath = this->GetDestinationDirectory(pi.productName);
	if (programFilesPath==NULL) return false;

	bool ok = false;

	if (isInstall)
	{
		ok = (::CreateDirectoryW(programFilesPath, NULL)!=0);
	}
	else
	{
		ok = (::RemoveDirectoryW(programFilesPath)!=0);
	}
	error.ReportError(!ok,  (wchar_t*)programFilesPath);

	return true;
}

bool Install::ApplicationShortcut(Sys::Install::ProductInfo& pi, Sys::IError& error, bool isInstall)
{
	wchar_t programPath[SYS_INSTBUFF];
	wchar_t shortcutFilename[SYS_INSTBUFF];
	wchar_t workingDirectory[SYS_INSTBUFF];
	const	wchar_t *programFilesPath = this->GetDestinationDirectory(pi.productName);
	if (programFilesPath==NULL) return false;

	_snwprintf_s(workingDirectory, SYS_INSTBUFF, _TRUNCATE, L"%s\\", programFilesPath, pi.productName);
	workingDirectory[SYS_INSTBUFF-1]='\0';

	//************************************ Create shortcut for start menu
	_snwprintf_s(programPath, SYS_INSTBUFF, _TRUNCATE, L"%s\\%s.exe", programFilesPath, pi.productName);
	programPath[SYS_INSTBUFF-1]='\0';
	//
	_snwprintf_s(shortcutFilename, SYS_INSTBUFF, _TRUNCATE, L"%s\\%s.lnk", GetStartupMenuProgramsPath(), pi.productName);
	shortcutFilename[SYS_INSTBUFF-1]='\0';
	//
	bool ok = false;
	if (isInstall)
	{
		ok = Sys::Install::CreateShortCut(programPath, pi.description, shortcutFilename, workingDirectory, NULL, 0); 
	}
	else
	{
		ok = Sys::Install::RemoveShortcut(pi.productName);
	}
	error.ReportError(ok,  (wchar_t*)programFilesPath);
	return true;
}

// pszFileExt and pi.objectType are required only to associated a file extension with the program
// i.e. InstallSoftware(true, L"Stevens", L"Protect", L"1.0", L".enc", L"EncryptedFile");
// Use ONLY numbers in the version
bool Install::InstallSoftware(Sys::Install::ProductInfo& pi, Sys::IError& ierror)
{
	bool ok = true;
	//ok &= CreateApplicationFolderAndShortcut(pi, ierror); 
	//{
	//	::MessageBox(hWnd,  L"The application folder couldn't be created", L"Install", MB_OK | MB_ICONERROR);
	//	ok = false;
	//}
	ok &= InstallSoftware1(pi, ierror, true);
	ok &= InstallSoftware2(pi, ierror, true);
	ok &= InstallSoftware3(pi, ierror, true);
	//ok &= InstallSoftware4(pi, ierror, true, );

	if (pi.fileExtension != NULL && pi.objectType != NULL)
	{
		ok &= InstallSoftware5(pi, ierror, true);
		ok &= InstallSoftware6(pi, ierror, true);
	}
	//CopyRemoverToWindowsFolder(pi.productName);
	return ok;
}

// ProductNameRemove.exe must be distributed with the product packet and copy to the windows folder
//bool Install::CopyRemoverToWindowsFolder(const wchar_t* productName)
//{
//	//****************************************************ProductNameRemove.exe destination path
//	::GetEnvironmentVariable(L"windir", buffer, SYS_INSTBUFF);
//	wchar_t destinationRemoverPath[SYS_INSTBUFF];
//	_snwprintf_s(destinationRemoverPath, SYS_INSTBUFF, _TRUNCATE, L"%s\\%sRemove.exe", buffer, productName); 
//
//	//****************************************************ProductNameRemove.ex_ source path
//	wchar_t removerSourcePath[SYS_INSTBUFF];
//	if (::GetCurrentDirectory(SYS_INSTBUFF, _TRUNCATE, buffer)==0) return false;
//	_snwprintf_s(removerSourcePath, SYS_INSTBUFF, _TRUNCATE, L"%s\\%sRemove.ex_", buffer, productName); 
//	//
//
//	return (::CopyFile(removerSourcePath, destinationRemoverPath, FALSE)!=0);
//}

wchar_t* Install::CopyFileToWindowsFolder(Sys::Install::ProductInfo&pi, HINSTANCE hInst, int resourceId, const wchar_t* destinationFile)
{
	::GetEnvironmentVariable(L"windir", buffer, SYS_INSTBUFF);
	wchar_t destinationFileFullPath[SYS_INSTBUFF];
	_snwprintf_s(destinationFileFullPath, SYS_INSTBUFF, _TRUNCATE, L"%s\\%s", buffer, destinationFile); 
	//

	HRSRC hrsrc = ::FindResource(hInst, MAKEINTRESOURCE(resourceId), L"BIN");
	if (hrsrc==NULL) return L"Unable to find resource";;

	HGLOBAL hResource = ::LoadResource(hInst, hrsrc);
	if (hResource==NULL) return L"Unable to load resource";
	DWORD dwSize = SizeofResource(hInst, hrsrc)+1; 
	BYTE * dataResource = (BYTE*) ::LockResource(hResource);
	BYTE * data = new BYTE[dwSize];
	if (data==NULL)
	{
		::FreeResource(hResource);
		return L"No enough memory to load resource";
	}
	::CopyMemory(data, dataResource, dwSize);
	::FreeResource(hResource);

	DWORD dwWritten;

	HANDLE hFile = ::CreateFile(destinationFileFullPath, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		if (data) delete [] data;
		Sys::GetLastErrorInformation(buffer, SYS_INSTBUFF);
		return buffer;
	}
	
	//_____________________________________________ Write Data
	::WriteFile(hFile, dataResource, dwSize, &dwWritten, NULL);
	if (dwSize!=dwWritten)
	{
		if (data) delete [] data;
		if (hFile != INVALID_HANDLE_VALUE) ::CloseHandle(hFile);
		return L"Unable to write file header";
	}
	
	if (data) delete [] data;
	return NULL;
}

// Destination file must not include path
wchar_t *Install::CopyFileToApplicationFolder(Sys::Install::ProductInfo&pi, HINSTANCE hInst, int resourceId, const wchar_t* destinationFile)
{
	const wchar_t* applicationPath = this->GetDestinationDirectory(pi.productName);
	if (applicationPath==NULL) return L"Unable to get destination directory";

	//
	wchar_t destinationFileFullPath[SYS_INSTBUFF];
	_snwprintf_s(destinationFileFullPath, SYS_INSTBUFF, _TRUNCATE, L"%s\\%s", applicationPath, destinationFile);
	destinationFileFullPath[SYS_INSTBUFF-1]='\0';

	HRSRC hrsrc = ::FindResource(hInst, MAKEINTRESOURCE(resourceId), L"BIN");
	if (hrsrc==NULL) return L"Unable to find resource";;

	HGLOBAL hResource = ::LoadResource(hInst, hrsrc);
	if (hResource==NULL) return L"Unable to load resource";
	DWORD dwSize = SizeofResource(hInst, hrsrc)+1; 
	BYTE * dataResource = (BYTE*) ::LockResource(hResource);
	BYTE * data = new BYTE[dwSize];
	if (data==NULL)
	{
		::FreeResource(hResource);
		return L"No enough memory to load resource";
	}
	::CopyMemory(data, dataResource, dwSize);
	::FreeResource(hResource);

	DWORD dwWritten;

	HANDLE hFile = ::CreateFile(destinationFileFullPath, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		if (data) delete [] data;
		Sys::GetLastErrorInformation(buffer, SYS_INSTBUFF);
		return buffer;
	}
	
	//_____________________________________________ Write Data
	::WriteFile(hFile, dataResource, dwSize, &dwWritten, NULL);
	if (dwSize!=dwWritten)
	{
		if (data) delete [] data;
		if (hFile != INVALID_HANDLE_VALUE) ::CloseHandle(hFile);
		return L"Unable to write file header";
	}
	
	if (data) delete [] data;
	return NULL;
}

wchar_t * Install::CopyDeleteFile(HINSTANCE hInst, int resource_id, const wchar_t* destinationFile, Sys::IError& ierror, bool isInstall)
{
	wchar_t * error = NULL;
	bool ok = false;
	if (isInstall)
	{
		error = this->CopyFileTo(hInst, resource_id, destinationFile);
		ok = (error==NULL);
	}
	else
	{
		ok = (::DeleteFileW(destinationFile)!=0);
		if (ok==false) error = L"Unable to delete file";
	}
	ierror.ReportError(!ok, (wchar_t*)destinationFile);
	return error;
}

// The Destination file must include path
wchar_t * Install::CopyFileTo(HINSTANCE hInst, int resource_id, const wchar_t* destinationFile)
{
	HRSRC hrsrc = ::FindResource(hInst, MAKEINTRESOURCE(resource_id), L"BIN");
	if (hrsrc==NULL) return L"Unable to find resource";

	HGLOBAL hResource = ::LoadResource(hInst, hrsrc);
	if (hResource==NULL) return L"Unable to load resource";
	DWORD dwSize = SizeofResource(hInst, hrsrc); 
	BYTE * dataResource = (BYTE*) ::LockResource(hResource);
	BYTE * data = new BYTE[dwSize];
	if (data==NULL)
	{
		::FreeResource(hResource);
		return L"No enough memory to load resource";
	}
	::CopyMemory(data, dataResource, dwSize);
	::FreeResource(hResource);

	DWORD dwWritten;

	HANDLE hFile = ::CreateFile(destinationFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		if (data) delete [] data;
		Sys::GetLastErrorInformation(buffer, SYS_INSTBUFF);
		return buffer;
	}
	
	//_____________________________________________ Write Data
	::WriteFile(hFile, dataResource, dwSize, &dwWritten, NULL);
	if (dwSize!=dwWritten)
	{
		if (data) delete [] data;
		if (hFile != INVALID_HANDLE_VALUE) ::CloseHandle(hFile);
		return L"Unable to write file header";
	}
	
	if (data) delete [] data;
	if (hFile!=INVALID_HANDLE_VALUE) ::CloseHandle(hFile);
	return NULL;
}

// Files must not include paths
bool Install::CopyFileToApplicationFolder(Sys::Install::ProductInfo& pi, const wchar_t* sourceFile, const wchar_t* destinationFile)
{
	const wchar_t* applicationPath = this->GetDestinationDirectory(pi.productName);
	if (applicationPath==NULL) return false;
	wchar_t currentDirectory[SYS_INSTBUFF];
	if (::GetCurrentDirectory(SYS_INSTBUFF, currentDirectory)==0) return false;
	//
	wchar_t sourceFileFullPath[SYS_INSTBUFF];
	_snwprintf_s(sourceFileFullPath, SYS_INSTBUFF, _TRUNCATE, L"%s\\%s", currentDirectory, sourceFile);
	sourceFileFullPath[SYS_INSTBUFF-1]='\0';
	//
	wchar_t destinationFileFullPath[SYS_INSTBUFF];
	_snwprintf_s(destinationFileFullPath, SYS_INSTBUFF, _TRUNCATE, L"%s\\%s", applicationPath, destinationFile);
	destinationFileFullPath[SYS_INSTBUFF-1]='\0';

	return (::CopyFile(sourceFileFullPath, destinationFileFullPath, FALSE)!=0);
}

bool Install::DeleteFileFromApplicationFolder(Sys::Install::ProductInfo& pi, const wchar_t* destinationFile)
{
	const wchar_t* applicationPath = this->GetDestinationDirectory(pi.productName);
	if (applicationPath==NULL) return false;
	//
	wchar_t destinationFileFullPath[SYS_INSTBUFF];
	_snwprintf_s(destinationFileFullPath, SYS_INSTBUFF, _TRUNCATE, L"%s\\%s", applicationPath, destinationFile);
	destinationFileFullPath[SYS_INSTBUFF-1]='\0';

	return (::DeleteFile(destinationFileFullPath)!=0);
}

bool Install::RegistrySetStringValue(HKEY hkey, PCTSTR pszValueName, PCTSTR pszString)
{
	int nDataSize = sizeof(wchar_t)*(lstrlen(pszString) + 1);
	return (RegSetValueEx(hkey, pszValueName, 0, REG_SZ, (PBYTE)pszString, nDataSize)==ERROR_SUCCESS);
}

// hkey:  HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE, HKEY_USERS, ..
// i.e., key2.ReadString(HKEY_LOCAL_MACHINE, "SOFTWARE\\selo", "descr"
const wchar_t* Install::RegistryReadString(HKEY hkey, LPCTSTR pszPathAndName, LPCTSTR pszValueName)
{
	HKEY hKey;
	unsigned long nDataSize;
	unsigned long nDataType;
	DWORD dwResult = 0;
	bool bOk = false;
	DWORD keySize= SYS_INSTBUFF;
	
	buffer[0] = '\0';

	if (RegOpenKeyEx(hkey, pszPathAndName, 0, KEY_ALL_ACCESS, &hKey)==ERROR_SUCCESS)
	{
		nDataSize=254;
		bOk = (RegQueryValueEx(hKey, pszValueName, NULL, &nDataType, (LPBYTE)&buffer, &keySize)
			== ERROR_SUCCESS);
		RegCloseKey(hKey);
		if (bOk == false) return NULL;
	}
	return buffer;
}

// pszFileExt and pi.objectType are required only to remove an associated file extension with the program
bool Install::RemoveSoftware(Sys::Install::ProductInfo& pi, Sys::IError& ierror)
{
	bool bOk = true;
	bOk &= InstallSoftware1(pi, ierror, false);
	bOk &= InstallSoftware2(pi, ierror, false);
	bOk &= InstallSoftware3(pi, ierror, false);
	bOk &= InstallSoftware6(pi, ierror, false);

	if (pi.fileExtension != NULL && pi.objectType != NULL)
	{
		bOk &= InstallSoftware5(pi, ierror, false);
		bOk &= InstallSoftware6(pi, ierror, false);
	}
	bOk &= RemoveShortcut(pi.productName);
	return bOk;
}

 //Installs ..SOFTWARE\CompanyName\ProductName\\Version
bool Install::InstallSoftware1(Sys::Install::ProductInfo& pi, Sys::IError& ierror, bool isInstall)
{
	wchar_t sz[SYS_INSTBUFF];
	Sys::Key key(HKEY_LOCAL_MACHINE, ierror);

	if (isInstall)
	{
		_snwprintf_s(sz, SYS_INSTBUFF, _TRUNCATE, L"SOFTWARE\\%s\\%s\\%d.%d", pi.companyName, 
			pi.productName, pi.versionMayor, pi.versionMinor);
		key.Create(sz);
	}
	else
	{
		//*************************************************************************open
		key.Open(L"SOFTWARE");

		//*************************************************************************delete Version
		_snwprintf_s(sz, SYS_INSTBUFF, _TRUNCATE, L"%s\\%s\\%d.%d", pi.companyName, 
			pi.productName, pi.versionMayor, pi.versionMinor);
		key.DeleteSubkey(sz);

		//*************************************************************************delete Product Name
		_snwprintf_s(sz, SYS_INSTBUFF, _TRUNCATE, L"%s\\%s", pi.companyName, pi.productName);
		key.DeleteSubkey(sz);

		//*************************************************************************delete Company Name
		key.DeleteSubkey(pi.companyName);
	}
	return true;
}


// Installs ..SOFTWARE\\Classes\\Applications\\Product.exe\\shell\\Open\\command
//    (default,  RG_SZ, Full path\\Program.exe)
bool Install::InstallSoftware2(Sys::Install::ProductInfo& pi, Sys::IError& ierror, bool isInstall)
{
	wchar_t sz[SYS_INSTBUFF];
	Sys::Key key(HKEY_LOCAL_MACHINE, ierror);

	const wchar_t* applicationPath = this->GetDestinationDirectory(pi.productName);
	if (applicationPath==NULL) return false;

	if (isInstall)
	{

		_snwprintf_s(sz, SYS_INSTBUFF, _TRUNCATE, L"SOFTWARE\\Classes\\Applications\\%s.exe\\shell\\Open\\command", 
			pi.productName);
		key.Create(sz);

		_snwprintf_s(sz, SYS_INSTBUFF, _TRUNCATE, L"\"%s\\%s.exe\" \"%%1\"", applicationPath, pi.productName);
		key.Set(L"", sz);
	}
	else
	{
		//*************************************************************************open
		key.Open(L"SOFTWARE\\Classes\\Applications");

		//*************************************************************************delete command
		_snwprintf_s(sz, SYS_INSTBUFF, _TRUNCATE, L"%s.exe\\shell\\Open\\command", pi.productName);
		sz[SYS_INSTBUFF-1]='\0';
		key.DeleteSubkey(sz);

		//*************************************************************************delete Open
		_snwprintf_s(sz, SYS_INSTBUFF, _TRUNCATE, L"%s.exe\\shell\\Open", pi.productName);
		key.DeleteSubkey(sz);

		//*************************************************************************delete shell
		_snwprintf_s(sz, SYS_INSTBUFF, _TRUNCATE, L"%s.exe\\shell", pi.productName);
		key.DeleteSubkey(sz);

		//*************************************************************************delete Product.exe
		_snwprintf_s(sz, SYS_INSTBUFF, _TRUNCATE, L"%s.exe", pi.productName);
		key.DeleteSubkey(sz);
	}

	return true;
}

/* Returns C:\\Program Files\\Application\\  */
const wchar_t* Install::GetDestinationDirectory(const wchar_t* productName)
{
	HKEY hKey;
	unsigned long nDataSize;
	unsigned long nDataType;
	DWORD dwResult = 0;
	bool bOk = false;
	DWORD keySize= SYS_INSTBUFF;
	wchar_t destinationDir[SYS_INSTBUFF];
	
	buffer[0] = '\0';

	if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\Windows\\CurrentVersion\\", 0, KEY_ALL_ACCESS, &hKey)==ERROR_SUCCESS)
	{
		nDataSize=254;
		bOk = (RegQueryValueEx(hKey, L"ProgramFilesDir", NULL, &nDataType, (LPBYTE)&destinationDir, &keySize)
			== ERROR_SUCCESS);
		RegCloseKey(hKey);
		if (bOk == false) return NULL;
	}
	_snwprintf_s(buffer, SYS_INSTBUFF, _TRUNCATE, L"%s\\%s", destinationDir, productName);
	buffer[SYS_INSTBUFF-1]='\0';
	return buffer;
}

// Installs ..SOFTWARE\\Classes\\.ext\\
//    (default,  RG_SZ, ProductName.ObjectType.Version)
bool Install::InstallSoftware5(Sys::Install::ProductInfo& pi, Sys::IError& ierror, bool isInstall)
{
	wchar_t sz[SYS_INSTBUFF];
	Sys::Key key(HKEY_LOCAL_MACHINE, ierror);

	if (isInstall)
	{
		_snwprintf_s(sz, SYS_INSTBUFF, _TRUNCATE, L"SOFTWARE\\Classes\\%s", pi.fileExtension);
		key.Create(sz);
		//
		_snwprintf_s(sz, SYS_INSTBUFF, _TRUNCATE, L"%s.%s.%d", pi.productName, pi.objectType, pi.versionMayor);
		key.Set(L"", sz);
	}
	else
	{
		key.Open(L"SOFTWARE\\Classes");
		key.DeleteSubkey(pi.fileExtension);
		key.DeleteSubkey(L"");
	}

	return true;
}

// Installs 
//  ..SOFTWARE\\Classes\\ProductName.ObjectType.Version\\shell\\Open\\command
//    (default,  RG_SZ, Full path\\Program.exe)
//
//  ..SOFTWARE\\Classes\\ProductName.ObjectType.Version\\DefaultIcon
//    (default,  RG_SZ, Full path\\Program.exe,0)
bool Install::InstallSoftware6(Sys::Install::ProductInfo& pi, Sys::IError& ierror, bool isInstall)
{
	wchar_t sz[SYS_INSTBUFF];
	Sys::Key key(HKEY_LOCAL_MACHINE, ierror);
	const wchar_t* applicationPath = this->GetDestinationDirectory(pi.productName);
	if (applicationPath==NULL) return false;

	if (isInstall)
	{
		//************************************************************************************ shell
		_snwprintf_s(sz, SYS_INSTBUFF, _TRUNCATE, L"SOFTWARE\\Classes\\%s.%s.%d\\shell\\Open\\command", pi.productName,
			pi.objectType, pi.versionMayor);
		key.Create(sz);
		//
		_snwprintf_s(sz, SYS_INSTBUFF, _TRUNCATE, L"\"%s\\%s.exe\" \"%%1\"", applicationPath, pi.productName);
		key.Set(L"", sz);

		//************************************************************************************ DefaultIcon
		_snwprintf_s(sz, SYS_INSTBUFF, _TRUNCATE, L"SOFTWARE\\Classes\\%s.%s.%d\\DefaultIcon", pi.productName,
			pi.objectType, pi.versionMayor);
		key.Create(sz);
		//
		_snwprintf_s(sz, SYS_INSTBUFF, _TRUNCATE, L"%s\\%s.exe,%d", applicationPath, pi.productName, pi.objectIconIndex);
		key.Set(L"", sz);

		//************************************************************************************ Description
		_snwprintf_s(sz, SYS_INSTBUFF, _TRUNCATE, L"SOFTWARE\\Classes\\%s.%s.%d", pi.productName, pi.objectType, pi.versionMayor);
		key.Open(sz);
		key.Set(L"", pi.objectDescription);
	}
	else
	{
		key.Open(L"SOFTWARE\\Classes");

		//*************************************************************************delete command
		_snwprintf_s(sz, SYS_INSTBUFF, _TRUNCATE, L"%s.%s.%d\\shell\\Open\\command", pi.productName, 
			pi.objectType, pi.versionMayor);
		key.DeleteSubkey(sz);

		//*************************************************************************delete Open
		_snwprintf_s(sz, SYS_INSTBUFF, _TRUNCATE, L"%s.%s.%d\\shell\\Open", pi.productName, pi.objectType, pi.versionMayor);
		key.DeleteSubkey(sz);

		//*************************************************************************delete shell
		_snwprintf_s(sz, SYS_INSTBUFF, _TRUNCATE, L"%s.%s.%d\\shell", pi.productName, pi.objectType, pi.versionMayor);
		key.DeleteSubkey(sz);

		//*************************************************************************delete DefaultIcon
		_snwprintf_s(sz, SYS_INSTBUFF, _TRUNCATE, L"%s.%s.%d\\DefaultIcon", pi.productName, pi.objectType, pi.versionMayor);
		key.DeleteSubkey(sz);

		//*************************************************************************delete Product.exe
		_snwprintf_s(sz, SYS_INSTBUFF, _TRUNCATE, L"%s.%s.%d", pi.productName, pi.objectType, pi.versionMayor);
		key.DeleteSubkey(sz);
	}

	return true;
}

// Installs ..SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\Program.exe\\
//    (default,  RG_SZ, Full path\\Program.exe)
//    (Path,  RG_SZ, Full path)
bool Install::InstallSoftware3(Sys::Install::ProductInfo& pi, Sys::IError& ierror, bool isInstall)
{
	Sys::Key key(HKEY_LOCAL_MACHINE, ierror);
	wchar_t sz[SYS_INSTBUFF];
	const wchar_t * applicationPath = this->GetDestinationDirectory(pi.productName);
	if (applicationPath==NULL) return false;

	if (isInstall)
	{
		_snwprintf_s(sz, SYS_INSTBUFF, _TRUNCATE, L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\%s.exe", 
			pi.productName);
		key.Create(sz);
		//
		_snwprintf_s(sz, SYS_INSTBUFF, _TRUNCATE, L"%s\\%s.exe", applicationPath, pi.productName);
		key.Set(L"", sz);
		//
		key.Set(L"Path", (wchar_t *)applicationPath);
	}
	else
	{
		wchar_t executableName[SYS_INSTBUFF];

		_snwprintf_s(executableName, SYS_INSTBUFF, _TRUNCATE, L"%s.exe", pi.productName);
		executableName[SYS_INSTBUFF-1]='\0';

		//*************************************************************************open
		key.Open(L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths");

		//*************************************************************************delete Program.exe
		key.DeleteSubkey(executableName);
	}
	return true;
}

//Sys::Install::CreateShortCut(L"C:\\Program Files\\Corel\\Corel Graphics 12\\Programs\\CorelPP.exe", 
//		L"Photo Paint", L"C:\\PhotPaint.lnk");
bool Install::CreateShortCut(const wchar_t* destinationFileName,  const wchar_t* description, 
							 const wchar_t* shortcutFilename, const wchar_t* workingDirectory, const wchar_t* fileNameIco_exe, int iIcon)
{ 
	bool ok = false;
	IShellLink* pShellLink = NULL;
	IPersistFile* pPersistFile = NULL;
	::CoInitialize(NULL);
	HRESULT hr = ::CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, IID_IShellLink,
		(void**)&pShellLink);
	if (SUCCEEDED(hr))
	{
		hr = pShellLink->QueryInterface(IID_IPersistFile, (void**)&pPersistFile);
		if (SUCCEEDED(pShellLink->SetPath(destinationFileName)))
		{
			if (SUCCEEDED(pShellLink->SetDescription(description)))
			{
				if (SUCCEEDED(pShellLink->SetWorkingDirectory(workingDirectory)))
				{
					if (fileNameIco_exe!=NULL)
					{
						if (SUCCEEDED(pShellLink->SetIconLocation(fileNameIco_exe, iIcon)))
						{
							ok = false;
						}
					}

					if (SUCCEEDED(pPersistFile->Save(shortcutFilename, TRUE)))
					{
						ok = true;
					}
				}
			}
		}
	}

	if (pPersistFile) pPersistFile->Release();
	if (pShellLink) pShellLink->Release();
	::CoUninitialize();
	return ok;
}

bool Install::CanAccessRegistry()
{
	bool ok = false;
	HKEY hKey;
	unsigned long nDataSize;
	unsigned long nDataType;
	DWORD dwResult = 0;
	DWORD keySize= SYS_INSTBUFF;
	
	buffer[0] = '\0';

	ok = (::RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\Windows\\CurrentVersion\\", 0, KEY_ALL_ACCESS, &hKey)==ERROR_SUCCESS);
	if (ok == false) return false;

	nDataSize=254;
	ok = (::RegQueryValueEx(hKey, L"ProgramFilesDir", NULL, &nDataType, (LPBYTE)&buffer, &keySize) == ERROR_SUCCESS);
	::RegCloseKey(hKey);
	return ok;
}

const wchar_t* Install::GetProgramFilesPath(void)
{
	// puedes usar el registro HKEY_LOCAL_MACHINE/Software/Microsoft/Windows/CurrentVersion/ProgramFilesDir
	// puedes usar el registro HKEY_LOCAL_MACHINE/Software/Microsoft/Windows/CurrentVersion/Explorer/ShellFolders
	//wchar_t * variableName = L"ProgramFiles";
	//int n = ::GetEnvironmentVariable(variableName, NULL, 0);
	//::GetEnvironmentVariable(variableName, this->buffer, SYS_INSTBUFF);

	return this->RegistryReadString(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\Windows\\CurrentVersion\\",
		L"ProgramFilesDir");
}

const wchar_t* Install::GetWindowsFolder()
{
	if (::GetWindowsDirectoryW(buffer, SYS_INSTBUFF)==0) return NULL;
	//if (::GetEnvironmentVariableW(L"windir", this->buffer, SYS_INSTBUFF)==0) return NULL;
	return buffer;
}

const wchar_t* Install::GetDesktopPath(void)
{
	return this->RegistryReadString(HKEY_LOCAL_MACHINE, 
		L"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders",
		L"Common Desktop");
}

const wchar_t* Install::GetMyDocumentsPath(void)
{
	return this->RegistryReadString(HKEY_LOCAL_MACHINE, 
		L"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders",
		L"Personal");
}

const wchar_t* Install::GetStartupMenuProgramsPath(void)
{
	return this->RegistryReadString(HKEY_LOCAL_MACHINE, 
		L"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders",
		L"Common Programs");
}

// It creates
//HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\WindowsCurrentVersion\Uninstall\ProductName
//REG_SZ	DisplayIcon "C:\Program Files\ProductName\ProductName.exe",0
//REG_SZ	DisplayName ProductName
//REG_SZ	DisplayVersion 1.0
//REG_SZ	HelpLink http://www.fimee.ugto.mx
//REG_SZ	UninstallString "C:\Windows\RemoveProductName"
bool Install::InstallSoftware4(Sys::Install::ProductInfo& pi, Sys::IError& ierror, bool isInstall, const wchar_t* fileNameIco_exe, int iIcon)
{
	wchar_t sz[SYS_INSTBUFF];
	Sys::Key key(HKEY_LOCAL_MACHINE, ierror);
	const wchar_t* applicationPath = this->GetDestinationDirectory(pi.productName);
	if (applicationPath==NULL) return false;

	if (isInstall)
	{
		_snwprintf_s(sz, SYS_INSTBUFF, _TRUNCATE, L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\%s", 
			pi.productName);
		key.Create(sz);
		//_______________________________DisplayIcon "C:\Program Files\ProductName\ProductName.exe",0
		_snwprintf_s(sz, SYS_INSTBUFF, _TRUNCATE, L"\"%s\\%s\",%d", applicationPath, fileNameIco_exe, iIcon);
		key.Set(L"DisplayIcon", sz);
		//_______________________________ DisplayName
		key.Set( L"DisplayName", pi.productName);
		//DisplayVersion 1.0
		_snwprintf_s(sz, SYS_INSTBUFF, _TRUNCATE, L"%d.%d", pi.versionMayor, pi.versionMinor);
		key.Set(L"DisplayVersion", sz);

		if (pi.helpLink)  //HelpLink http://www.fimee.ugto.mx
		{	
			key.Set(L"HelpLink",pi.helpLink);
		}

		//UninstallString "C:\Windows\ProdutNameRemove"
		wchar_t destPath[SYS_INSTBUFF];
		::GetEnvironmentVariable(L"windir", destPath, SYS_INSTBUFF);
		_snwprintf_s(sz, SYS_INSTBUFF, _TRUNCATE, L"\"%s\\%sRemove.exe\"", destPath, pi.productName);
		key.Set(L"UninstallString", sz);
		//
		key.Set(L"Publisher", pi.companyName);
	}
	else
	{
		_snwprintf_s(sz, SYS_INSTBUFF, _TRUNCATE, L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\%s", 
			pi.productName);
		key.Open(sz);

		//*************************************************************************delete DisplayIcon
		key.DeleteSubkey(L"DisplayIcon");

		//*************************************************************************delete DisplayName
		key.DeleteSubkey(L"DisplayName");

		//*************************************************************************delete DisplayVersion
		key.DeleteSubkey(L"DisplayVersion");

		//*************************************************************************delete HelpLink
		key.DeleteSubkey(L"HelpLink");

		//*************************************************************************delete UninstallString
		key.DeleteSubkey(L"UninstallString");

		//*******************************delete SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\ProductName
		key.Open(L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall");
		key.DeleteSubkey(pi.productName);
	}

	return true;
}

//_____________________________________________________________________ Key
Key::Key(HKEY type, Sys::IError& ierror)
{
	this->type = type;
	this->hkey = NULL;
	this->name[0]='\0';
	this->ierror = &ierror;
}

Key::Key(HKEY type)
{
	this->type = type;
	this->hkey = NULL;
	this->name[0]='\0';
	this->ierror = NULL;
}

Key::~Key(void)
{
	::RegCloseKey(hkey);
}

bool Key::Create(wchar_t* name)
{
	this->Close();
	bool ok = (::RegCreateKeyEx(type, name, 0, NULL,
			REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkey, NULL)== ERROR_SUCCESS);
	if (ierror) ierror->ReportError(!ok, name);
	lstrcpyn(this->name, name, SYS_INSTBUFF);
	this->name[SYS_INSTBUFF-1]='\0';
	return ok;
}

bool Key::Open(wchar_t* name)
{
	return Open(name, KEY_ALL_ACCESS);
}

bool Key::Open(wchar_t* name, REGSAM access)
{
	this->Close();
	bool ok = (::RegOpenKeyEx(type, name, 0, access, &hkey)== ERROR_SUCCESS);
	if (ierror) ierror->ReportError(!ok, name);
	lstrcpyn(this->name, name, SYS_INSTBUFF);
	this->name[SYS_INSTBUFF-1]='\0';
	return ok;
}

wchar_t* Key::ReadStringValue(const wchar_t* valueName)
{
	//::RegGetValue(hkey, 
 // __in          HKEY hkey,
 // __in_opt      LPCTSTR lpSubKey,
 // __in_opt      LPCTSTR lpValue,
 // __in_opt      DWORD dwFlags,
 // __out_opt     LPDWORD pdwType,
 // __out_opt     PVOID pvData,
 // __in_out_opt  LPDWORD pcbData

	unsigned long dataSize = SYS_INSTBUFF;
	unsigned long dataType = 0;
	DWORD keySize= SYS_INSTBUFF;
	
	name[0] = '\0';

	bool ok = (::RegQueryValueEx(hkey, valueName, NULL, &dataType, (LPBYTE)&name, &dataSize) == ERROR_SUCCESS);
	if (dataType != REG_SZ) return NULL;
	if (ierror) ierror->ReportError(!ok, name);
	if (ok) return name;
	return NULL;
}


//bool Key::Close(wchar_t* caption, Win::ListView& listView)
//{
//	bool ok = true;
//	this->name[0]='\0';
//	if (hkey)
//	{
//		ok = (::RegCloseKey(hkey)== ERROR_SUCCESS);
//		hkey = NULL;
//	}
//	if (listView) listView->InsertItem(SYS_INSTALL_LVINDEX, caption, ok ? 0 : 1);	
//	return ok;
//}

bool Key::Close()
{
	bool ok = true;
	this->name[0]='\0';
	if (hkey)
	{
		ok = (::RegCloseKey(hkey)== ERROR_SUCCESS);
		hkey = NULL;
	}
	return ok;
}

bool Key::Set(wchar_t* name, wchar_t* value)
{
	if (hkey==NULL) return false;
	bool ok = (::RegSetValueEx(hkey, name, 0, REG_SZ, (PBYTE)value, sizeof(wchar_t)*(lstrlen(value) + 1))==ERROR_SUCCESS);

	if (name==NULL) name = L"(default)";
	if (lstrlen(name)<=0) name = L"(default)";
	wchar_t caption[SYS_INSTBUFF];
	_snwprintf_s(caption, SYS_INSTBUFF, _TRUNCATE, L"%s\\%s", this->name, name);
	if (ierror) ierror->ReportError(!ok, caption);
	return ok;
}

bool Key::Set(wchar_t* name, DWORD value)
{
	if (hkey==NULL) return false;
	bool ok = (::RegSetValueEx(hkey, name, 0, REG_DWORD, (PBYTE)&value, sizeof(DWORD))==ERROR_SUCCESS);

	if (name==NULL) name = L"(default)";
	if (lstrlen(name)<=0) name = L"(default)";
	wchar_t caption[SYS_INSTBUFF];
	_snwprintf_s(caption, SYS_INSTBUFF, _TRUNCATE, L"%s\\%s", this->name, name);
	if (ierror) ierror->ReportError(!ok, caption);
	return ok;
}


bool Key::DeleteSubkey(wchar_t* name)
{
	if (hkey==NULL) return false;
	bool ok = (::RegDeleteKeyW(hkey, name)== ERROR_SUCCESS);
	ok = true;

	if (name==NULL) name = L"(default)";
	if (lstrlen(name)<=0) name = L"(default)";
	wchar_t caption[SYS_INSTBUFF];
	_snwprintf_s(caption, SYS_INSTBUFF, _TRUNCATE, L"%s\\%s", this->name, name);
	if (ierror) ierror->ReportError(!ok, caption);
	return ok;
}

// wchar_t * name;
// int i = 0;
// do
//{
//		name = key.Enumerate(i++);
//}
//while(name != NULL);
wchar_t* Key::Enumerate(int index)
{
	name[0] = '\0';
	DWORD lpcbName=SYS_INSTBUFF;

	if (RegEnumKeyEx(hkey, (DWORD)index, name, &lpcbName, NULL, NULL, NULL, NULL)== ERROR_SUCCESS)//&fTime) == ERROR_SUCCESS)
	{
		return name;
	}
	return NULL;
}

//_____________________________________________________________________ FileDirectoy
bool FileDirectory::IsDirectory(_tfinddata_t& fd)
{
	if (fd.attrib & _A_SUBDIR) return true;
	return false;
}

//You cannot specify target attributes (such as _A_RDONLY) by which to limit the find operation. 
//This attribute is returned in the attrib field of the _finddata_t structure and can have the following
//values (defined in IO.H). Users should not rely on these being the only values possible for 
//the attrib field. 
//
//_A_ARCH 
//Archive. Set whenever the file is changed, and cleared by the BACKUP command. Value: 0x20. 
//_A_HIDDEN 
//Hidden file. Not normally seen with the DIR command, unless the /AH option is used. 
//Returns information about normal files as well as files with this attribute. Value: 0x02. 
//_A_NORMAL 
//Normal. File has no other attributes set, and can be read or written to without restriction. 
//Value: 0x00. 
//_A_RDONLY 
//Read-only. File cannot be opened for writing, and a file with the same name cannot 
//be created. Value: 0x01. 
//_A_SUBDIR 
//Subdirectory. Value: 0x10. 
//_A_SYSTEM 
//System file. Not normally seen with the DIR command, unless the /A or /A:S option 
//is used. Value: 0x04. 
//GetFileList(L"c:\\*.txt", this) -> gets the files with name *.txt 
int FileDirectory::GetFileList(const wchar_t* path, Sys::IListFileDirectory* ilfd)
{
	struct _tfinddata_t item;
	intptr_t sequence=0;
	int count = 0;

	sequence=_tfindfirst((wchar_t*)path, &item);
	if (sequence!=-1)
	{
		count++;
		if (ilfd->Enumerate(item)==false) 
		{
			_findclose(sequence);
			return count;
		}
		while(_tfindnext(sequence, &item)==0)
		{
			count++;
			if (ilfd->Enumerate(item)==false)
			{
				_findclose(sequence);
				return count;
			}
		}
	}
	_findclose(sequence);
	return count;
}

// path = L"C:\\Documents\\*.*
int FileDirectory::GetFileList(const wchar_t* path, vector<_tfinddata_t>& result)
{
	struct _tfinddata_t item;
	intptr_t sequence=0;
	int count = 0;

	sequence=_tfindfirst((wchar_t*)path, &item);
	if (sequence!=-1)
	{
		count++;
		result.push_back(item);
		while(_tfindnext(sequence, &item)==0)
		{
			count++;
			result.push_back(item);
		}
	}
	_findclose(sequence);
	return count;
}

//GetFileList(L"c:\\", L"*.txt", this) -> gets the files with name *.txt 
int FileDirectory::GetFileListRecursive(const wchar_t* path, const wchar_t* filter, Sys::IListFileDirRecursive* ilfd)
{
	struct _tfinddata_t item;
	intptr_t sequence=0;
	int count = 0;
	wchar_t currentPath[1024];
	wchar_t nextPath[1024];
	//______________________________________ First we search for files in the current folder
	_snwprintf_s(currentPath, 1024, _TRUNCATE, L"%s\\%s", path, filter);

	sequence=_tfindfirst(currentPath, &item);
	if (sequence!=-1)
	{
		if (Sys::FileDirectory::IsDirectory(item)==false)
		{
			if (ilfd->Enumerate(path, item)==false) 
			{
				_findclose(sequence);
				return 1;
			}
		}
		while(_tfindnext(sequence, &item)==0)
		{
			if (Sys::FileDirectory::IsDirectory(item)==false)
			{
				count++;
				if (ilfd->Enumerate(path, item)==false) 
				{
					_findclose(sequence);
					return count;
				}
			}
		}
	}

	//______________________________________ Get search for sub directories
	_snwprintf_s(currentPath, 1024, _TRUNCATE, L"%s\\*.*", path);

	sequence=_tfindfirst(currentPath, &item);
	if (sequence!=-1)
	{
		if (Sys::FileDirectory::IsDirectory(item) && lstrlen(item.name)>2)
		{
		_snwprintf_s(nextPath, 1024, _TRUNCATE, L"%s\\%s", path, item.name);
			count += Sys::FileDirectory::GetFileListRecursive(nextPath, filter, ilfd);
		}
		while(_tfindnext(sequence, &item)==0)
		{
			if (Sys::FileDirectory::IsDirectory(item) && lstrlen(item.name)>2)
			{
				_snwprintf_s(nextPath, 1024, L"%s\\%s", path, item.name);
				count += Sys::FileDirectory::GetFileListRecursive(nextPath, filter, ilfd);
			}
		}
	}
	_findclose(sequence);
	return count;
}

int FileDirectory::GetFileListRecursive(const wchar_t* path, const wchar_t* filter, vector<FileInfo>& result)
{
	//struct _tfinddata_t item;
	intptr_t sequence=0;
	int count = 0;
	wchar_t currentPath[1024];
	wchar_t nextPath[1024];
	FileInfo fi;
	//______________________________________ First we search for files in the current folder
	_snwprintf_s(currentPath, 1024, _TRUNCATE, L"%s\\%s", path, filter);

	sequence=_tfindfirst(currentPath, &fi.findData);
	if (sequence!=-1)
	{
		if (Sys::FileDirectory::IsDirectory(fi.findData)==false) 
		{
			count++;
			fi.path = path;
			//_snwprintf_s(fi.path, 1024, _TRUNCATE, L"%s", path);
			//fi.path[1023]='\0';
			result.push_back(fi);
		}
		while(_tfindnext(sequence, &fi.findData)==0)
		{
			if (Sys::FileDirectory::IsDirectory(fi.findData)==false)
			{
				count++;
				fi.path = path;
				//_snwprintf_s(fi.path, 1024, _TRUNCATE, L"%s", path);
				//fi.path[1023]='\0';
				result.push_back(fi);
			}
		}
	}

	//______________________________________ Get search for sub directories
	_snwprintf_s(currentPath, 1024, _TRUNCATE, L"%s\\*.*", path);

	sequence=_tfindfirst(currentPath, &fi.findData);
	if (sequence!=-1)
	{
		if (Sys::FileDirectory::IsDirectory(fi.findData) && lstrlen(fi.findData.name)>2)
		{
		_snwprintf_s(nextPath, 1024, _TRUNCATE, L"%s\\%s", path, fi.findData.name);
			count += Sys::FileDirectory::GetFileListRecursive(nextPath, filter, result);
		}
		while(_tfindnext(sequence, &fi.findData)==0)
		{
			if (Sys::FileDirectory::IsDirectory(fi.findData) && lstrlen(fi.findData.name)>2)
			{
				_snwprintf_s(nextPath, 1024, L"%s\\%s", path, fi.findData.name);
				count += Sys::FileDirectory::GetFileListRecursive(nextPath, filter, result);
			}
		}
	}
	_findclose(sequence);
	return count;
}

bool FileDirectory::DeleteFolder(const wchar_t* folder)
{	
	struct _tfinddata_t item;
	intptr_t sequence=0;
	int count = 0;
	wchar_t next[1024];
	//______________________________________ First we search for files and folders in the current folder
	_snwprintf_s(next, 1024, _TRUNCATE, L"%s\\*.*", folder);
	sequence=_tfindfirst(next, &item);
	if (sequence == -1) 
	{
		_findclose(sequence);
		::RemoveDirectory(folder);
		return false;
	}
	do
	{
		_snwprintf_s(next, 1024, _TRUNCATE, L"%s\\%s", folder, item.name);
		if (Sys::FileDirectory::IsDirectory(item)==true) 
		{
			if (wcscmp(item.name, L".")==0) continue;
			if (wcscmp(item.name, L"..")==0) continue;	
			FileDirectory::DeleteFolder(next);
		}
		else
		{
			::DeleteFile(next);
		}
	}
	while(_tfindnext(sequence, &item)==0);
	_findclose(sequence);
	::RemoveDirectory(folder);
	return true;
}

// i.e. CopyFolderStructure(L"C:\\Data", L"D:\\Data");
bool FileDirectory::CopyFolderStructure(const wchar_t* sourcePath, const wchar_t* destinationPath)
{
	::CreateDirectoryW(destinationPath, NULL);
	struct _tfinddata_t item;
	intptr_t sequence=0;
	int count = 0;
	wchar_t nextSourcePath[1024];
	wchar_t nextDestinationPath[1024];
	//______________________________________ First we search for files and folders in the current folder
	_snwprintf_s(nextSourcePath, 1024, _TRUNCATE, L"%s\\*.*", sourcePath);
	sequence=_tfindfirst(nextSourcePath, &item);
	if (sequence == -1) return false;
	do
	{
		if (Sys::FileDirectory::IsDirectory(item)==true) 
		{
			if (wcscmp(item.name, L".")==0) continue;
			if (wcscmp(item.name, L"..")==0) continue;
			_snwprintf_s(nextSourcePath, 1024, _TRUNCATE, L"%s\\%s", sourcePath, item.name);
			_snwprintf_s(nextDestinationPath, 1024, _TRUNCATE, L"%s\\%s", destinationPath, item.name);
			FileDirectory::CopyFolderStructure(nextSourcePath, nextDestinationPath);
		}
	}
	while(_tfindnext(sequence, &item)==0);
	return true;
}

//_____________________________________________________________________ Time
Time::Time()
{
	::GetLocalTime(this);
}

Time::Time(SYSTEMTIME st)
{
	wYear = st.wYear;
	wMonth = st.wMonth;
	wDayOfWeek = st.wDayOfWeek;
	wDay = st.wDay;
	wHour = st.wHour;
	wMinute = st.wMinute;
	wSecond = st.wSecond;
	wMilliseconds = st.wMilliseconds;
}

Time::~Time()
{
}

Sys::Time Time::Now()
{
	Sys::Time tmp;
	return tmp;
}

Time::Time(const Sys::Time& init)
{
	wYear = init.wYear;
	wMonth = init.wMonth;
	wDayOfWeek = init.wDayOfWeek;
	wDay = init.wDay;
	wHour = init.wHour;
	wMinute = init.wMinute;
	wSecond = init.wSecond;
	wMilliseconds = init.wMilliseconds;
}

Time& Time::operator=(const Sys::Time& init)
{
	wYear = init.wYear;
	wMonth = init.wMonth;
	wDayOfWeek = init.wDayOfWeek;
	wDay = init.wDay;
	wHour = init.wHour;
	wMinute = init.wMinute;
	wSecond = init.wSecond;
	wMilliseconds = init.wMilliseconds;
	return *this;
}

void Time::SetToLocalTime()
{
	::GetLocalTime(this);
}

void Time::SetToUtcTime()
{
	::GetSystemTime(this);
}

void Time::Set(int day, int month, int year, int hour, int minute, int second, int milliseconds)
{
	this->wYear = year;
	this->wMonth = month;
	this->wDayOfWeek = 0;
	this->wDay = day;
	this->wHour = hour;
	this->wMinute = minute;
	this->wSecond = second;
	this->wMilliseconds = milliseconds;
	//__________________________________________ Try to fill wDayOfWeek
	FILETIME ft; 
	::SystemTimeToFileTime(this, &ft ); 
	::FileTimeToSystemTime(&ft, this); 
}

double Time::GetSeconds() const //Since January 1, 1601.
{
	FILETIME ft;
	SYSTEMTIME st = *this;
	if (::SystemTimeToFileTime(&st, &ft) == 0) return -9.99e300; // Error
	//__________________________________
	ULARGE_INTEGER nano100;
	nano100.HighPart = ft.dwHighDateTime;
	nano100.LowPart = ft.dwLowDateTime;
	//__int64 * nano100 = (__int64 *)&ft;
	//return (*nano100)/(double)10000000.0;
	return nano100.QuadPart/(double)(10000000.0);
}

Sys::Time& Time::AddSeconds(double seconds)
{
	FILETIME ft;
	::SystemTimeToFileTime(this, &ft);
	ULARGE_INTEGER nano100;
	nano100.HighPart = ft.dwHighDateTime;
	nano100.LowPart = ft.dwLowDateTime;
	//__int64 * nano100 = (__int64 *)&ft;
	//(*nano100) += (__int64)(seconds*10000000);
	nano100.QuadPart += (__int64)(seconds*10000000);
	ft.dwHighDateTime = nano100.HighPart;
	ft.dwLowDateTime = nano100.LowPart;
	::FileTimeToSystemTime (&ft, this); 
	return *this;
}

Sys::Time& Time::AddMinutes(double minutes)
{
	return AddSeconds(minutes*60.0);
}

Sys::Time& Time::AddHours(double hours)
{
	return AddSeconds(hours*3600.0);
}

Sys::Time& Time::AddDays(double days)
{
	return AddSeconds(days*86400);
}

bool Time::operator==(const Sys::Time& st) const
{
	FILETIME ft1, ft2;
	::SystemTimeToFileTime(this, &ft1);
	::SystemTimeToFileTime(&st, &ft2);
	return (::CompareFileTime(&ft1, &ft2)==0);
}

bool Time::operator!=(const Sys::Time& st) const
{
	FILETIME ft1, ft2;
	::SystemTimeToFileTime(this, &ft1);
	::SystemTimeToFileTime(&st, &ft2);
	return (::CompareFileTime(&ft1, &ft2)!=0);
}

bool Time::operator<(const Sys::Time& st) const
{
	FILETIME ft1, ft2;
	::SystemTimeToFileTime(this, &ft1);
	::SystemTimeToFileTime(&st, &ft2);
	return (::CompareFileTime(&ft1, &ft2)==-1);
}

bool Time::operator<=(const Sys::Time& st) const
{
	FILETIME ft1, ft2;
	::SystemTimeToFileTime(this, &ft1);
	::SystemTimeToFileTime(&st, &ft2);
	return (::CompareFileTime(&ft1, &ft2)<=0);
}

bool Time::operator>(const Sys::Time& st) const
{
	FILETIME ft1, ft2;
	::SystemTimeToFileTime(this, &ft1);
	::SystemTimeToFileTime(&st, &ft2);
	return (::CompareFileTime(&ft1, &ft2)==1);
}

bool Time::operator>=(const Sys::Time& st) const
{
	FILETIME ft1, ft2;
	::SystemTimeToFileTime(this, &ft1);
	::SystemTimeToFileTime(&st, &ft2);
	return (::CompareFileTime(&ft1, &ft2)>=0);
}

//_____________________________________________________________________ SqlTime
SqlTime::SqlTime()
{
	//year = 0;
	//month = 0;
	//day = 0;
	//hour = 0;
	//minute = 0;
	//second = 0;
	//milliseconds = 0;
	year = systime.wYear;
	month = systime.wMonth;
	day = systime.wDay;
	hour = systime.wHour;
	minute = systime.wMinute;
	second = systime.wSecond;
	milliseconds = systime.wMilliseconds;
}
	
SqlTime::~SqlTime()
{
} 

SqlTime::operator Sys::Time&()
{
	systime.wYear = year;
	systime.wMonth = month;
	systime.wDayOfWeek = 0;
	systime.wDay = day;
	systime.wHour = hour;
	systime.wMinute = minute;
	systime.wSecond = second;
	systime.wMilliseconds = milliseconds;
	return systime;
}

//_____________________________________________________________________ LowResStopwatch
LowResStopwatch::LowResStopwatch()
{
	Start();
}

LowResStopwatch::~LowResStopwatch()
{
}

void LowResStopwatch::Start()
{
	start.SetToLocalTime();
}

double LowResStopwatch::GetSeconds()
{
	Sys::Time now;
	return now.GetSeconds() - start.GetSeconds();
}

//_________________________________________________________ Socket
#ifdef WIN_SOCKETS_SUPPORT
int Socket::objectCount  = 0;
WSADATA Socket::wsdata;

Socket::Socket()
{
	Constructor();
}

void Socket::Constructor()
{
	if (objectCount == 0)
	{
		if (WSAStartup(MAKEWORD(2, 1), &wsdata)!=0)
		{
			throw L"WSAStartup error";
		}
	}
	objectCount++;
	hsocket = INVALID_SOCKET;
	//isCopy = false;
}

void Socket::Attach(SOCKET& inputSocket)
{
	Disconnect();
	hsocket = inputSocket;
}

//Socket::Socket(const Socket& init) // Copy constructor
//{
//	Constructor();
//	hsocket = init.hsocket;
//	isCopy = true;
//}

//Socket& Socket::operator =(const Socket& init) //Operator =
//{
//	//Destructor();
//	hsocket = init.hsocket;
//	isCopy = true;
//	return *this;
//}

wchar_t* Socket::Connect(const wchar_t* serverName, unsigned short port)
{
	//ADDRINFOW hints;
	//ZeroMemory( &hints, sizeof(hints) );
	//hints.ai_family = AF_UNSPEC;
	//hints.ai_socktype = SOCK_STREAM;
	//hints.ai_protocol = IPPROTO_TCP;

	//ADDRINFOW *result = NULL;
	//SOCKADDR_IN sa;

	//if (GetAddrInfoW(L"www.yahoo.com", L"80", &hints, &result) != 0) return L"Socket::Connect unable to get address info";
	//for(ADDRINFOW *ptr = result; ptr != NULL ; ptr = ptr->ai_next) 
	//{
	//	switch (ptr->ai_family) 
	//	{
	//	case AF_UNSPEC:
	//		break;
	//	case AF_INET: //(IPv4)
	//		sa.sin_addr = *((LPIN_ADDR)*ptr->ai_addr);
	//		break;
	//	case AF_INET6://(IPv6)
	//		break;
	//	}
	//}
	//FreeAddrInfoW(result);

	if (serverName == NULL) return L"Socket::Connect: server name is NULL";
	string server_name;
	Sys::Convert::WstringToString(serverName, server_name);

	LPHOSTENT lpHostEntry=gethostbyname(server_name.c_str());
	if (lpHostEntry==NULL) return L"Socket::Connect: name cannot be resolved by DNS";

	SOCKADDR_IN sa;
	sa.sin_family=AF_INET;
	sa.sin_port=htons(port);
	sa.sin_addr=*((LPIN_ADDR)*lpHostEntry->h_addr_list);
	return Connect(sa);
}

//Connect((unsigned short)80), L"66.94.230.44", )
wchar_t* Socket::Connect(unsigned short port, const wchar_t* ipAddress)
{
	SOCKADDR_IN sa;
	IN_ADDR ia;
	string ip_address;
	Sys::Convert::WstringToString(ipAddress, ip_address);
	unsigned long uia = inet_addr(ip_address.c_str());
	
	if (uia == INADDR_NONE) return L"Socket::Connect: invalid IP address";

	ia.S_un.S_addr = uia;
	sa.sin_family=AF_INET;
	sa.sin_port=htons(port);
	sa.sin_addr=ia;
	return Connect(sa);
}

wchar_t* Socket::Connect(SOCKADDR_IN& sockAddr)
{
	Disconnect();

	hsocket = (SOCKET)socket(PF_INET, SOCK_STREAM, 0);
	if (hsocket==INVALID_SOCKET) return L"Socket::Connect: unable to open socket";

	if (connect(hsocket, (PSOCKADDR)&sockAddr, sizeof(SOCKADDR_IN))) return L"Socket::Connect: unable to connect";
	return NULL;
}

void Socket::Close()
{
	if (hsocket != INVALID_SOCKET)
	{
		closesocket(hsocket);
		hsocket = INVALID_SOCKET;
	}
}
	
SOCKET Socket::Accept()
{
	return accept(hsocket, 0, 0);
}

void Socket::Disconnect()
{
	if (hsocket != INVALID_SOCKET)
	{
		shutdown(hsocket, SD_BOTH);
		closesocket(hsocket);
		hsocket = INVALID_SOCKET;
	}
}

Socket::~Socket(void)
{
	Disconnect();
	objectCount--;
	if (objectCount == 0) WSACleanup();
}

wchar_t* Socket::GetLastErrorDesc()
{
	const int error = WSAGetLastError();
	return GetErrorDescr(error);
}

char* Socket::GetStatus()
{
	return wsdata.szSystemStatus;
}
	
char* Socket::GetVersion()
{
	return wsdata.szDescription;
}

//void Socket::GetAddressInfo()
//{
//	addrinfo info;
//
//	info.ai_addr = 0;
//	info.ai_addrlen = 0;
//	info.ai_canonname = 0;
//	info.ai_family = PF_INET; // IPV4
//	//::getaddrinfo(
//}

// Returns IP of host, NULL if error
LPHOSTENT Socket::GetHostByName(const wchar_t* serverName)
{
	string server_name;
	Sys::Convert::WstringToString(serverName, server_name);
	return ::gethostbyname(server_name.c_str());
}

// Returns IP of host, NULL if error
LPSTR Socket::GetIpAddressByName(const wchar_t* serverName)
{
	string server_name;
	Sys::Convert::WstringToString(serverName, server_name);

	LPHOSTENT p = ::gethostbyname(server_name.c_str());
	if (p==NULL) return NULL;
	return inet_ntoa( *(LPIN_ADDR) * (p->h_addr_list));
}

// Returns port number for the service in host format
// ServiceName: telnet, ftp, mail, http
int Socket::GetServicePortByName(const wchar_t* serviceName)
{
	string service_name;
	Sys::Convert::WstringToString(serviceName, service_name);
	LPSERVENT lpServEntry=getservbyname(service_name.c_str(), 0);
	int port; 

	if (lpServEntry==NULL)
	{
		if (wcscmp(serviceName, L"telnet") == 0)	port= IPPORT_TELNET;
		if (wcscmp(serviceName, L"echo") == 0) 	port= IPPORT_ECHO;
		if (wcscmp(serviceName, L"discard") == 0)	port= IPPORT_DISCARD;
		if (wcscmp(serviceName, L"systat") == 0)	port= IPPORT_SYSTAT;
		if (wcscmp(serviceName, L"daytime") == 0)	port= IPPORT_DAYTIME;
		if (wcscmp(serviceName, L"netstat") == 0)	port= IPPORT_NETSTAT;
		if (wcscmp(serviceName, L"ftp") == 0)	port= IPPORT_FTP;
		if (wcscmp(serviceName, L"smtp") == 0)	port= IPPORT_SMTP;
		if (wcscmp(serviceName, L"timeserver") == 0)	port= IPPORT_TIMESERVER;
		if (wcscmp(serviceName, L"nameserver") == 0)	port= IPPORT_NAMESERVER;
		if (wcscmp(serviceName, L"whois") == 0)	port= IPPORT_WHOIS;
		if (wcscmp(serviceName, L"mtp") == 0)	port= IPPORT_MTP;
		if (wcscmp(serviceName, L"http") == 0)	port= 80;
	}
	else
	{
		port=ntohs(lpServEntry->s_port);
	}
	return port;
}

//int Socket::Send(char *textToSend, bool removeReturn, bool addCtrl)
//{
//	//	SO_MAX_MSG_SIZE
//	if (textToSend == NULL) return 0;
//	char szData[512];
//	strncpy_s(szData, textToSend, 512);
//	szData[512-1]='\0';
//
//	if (removeReturn) RemoveReturn(szData);
//
//	//****************************************************** CTRL
//	if (addCtrl)  strcat_s(szData, "\r\n");
//
//	return send(hsocket, szData, (int)strlen(szData), 0);// == INVALID_SOCKET)
//}

int Socket::Send(const char *buffer)
{
	//The WSASend function sends data on a connected socket using overlapped I/O
	return send(hsocket, buffer, strlen(buffer), 0);// != INVALID_SOCKET;
}

int Socket::Send(const char *buffer, int bufferSize, int flags)
{
	//	SO_MAX_MSG_SIZE
	return send(hsocket, buffer, bufferSize, flags);// != INVALID_SOCKET;
}

void Socket::RemoveReturn(char* text)
{
	if (text==NULL) return;
	int i=0;
	int j=0;
	bool bOk=false;
	char last;
	const int len = (int)strlen(text);

	for (i=0; i<len; i++)
	{
		switch(text[i])
		{
		case '\r':
			break;
		case '.':
			if (last=='\n')
			{
				text[j++]='.';
				last='.';
				text[j++]='.';
				last='.';
			}
			else
			{
				text[j++]='.';
				last='.';
			}
			break;
		default:
			text[j++]=text[i];
			last=text[i];
		}
	}
	text[j]='\0';
}

int Socket::ReceiveCodeAsync()
{
	char buffer[512];
	if (::recv(hsocket, buffer, 511, MSG_PEEK)<=0) return -1;
	const int bytes = ::recv(hsocket, buffer, 511, 0);
	if (bytes == 0) return -1;
	buffer[bytes] = '\0';
	//________________________________________ See if there is another line
	//while (buffer[3] == '-')
	//{
	//	bytes = ::recv(hsocket, buffer, 511, 0);
	//	if (bytes == 0) return -1;
	//	buffer[bytes] = '\0';
	//}

	const int len = strlen(buffer);
	char cnumber[6];
	cnumber[0] = '\0';
	int i = 0, j = 0;
	for(i = 0; i<len; i++)
	{
		if (Sys::TextAssistant::IsDigit(buffer[i]) == true)
		{
			cnumber[j++] = buffer[i];
			if (j >= 6 -1)
			{
				cnumber[j] = '\0';
				break;
			}
		}
		else if (Sys::TextAssistant::IsSeparator(buffer[i]) == true)
		{
			cnumber[j] = '\0';
			break;
		}
	}

	return atoi(cnumber);
}

int Socket::ReceiveCode()
{
	char buffer[512];
	int bytes = ::recv(hsocket, buffer, 511, 0);
	if (bytes == 0) return -1;
	buffer[bytes] = '\0';
	//________________________________________ See if there is another line
	while (buffer[3] == '-')
	{
		bytes = ::recv(hsocket, buffer, 511, 0);
		if (bytes == 0) return -1;
		buffer[bytes] = '\0';
	}

	const int len = strlen(buffer);
	char cnumber[6];
	cnumber[0] = '\0';
	int i = 0, j = 0;
	for(i = 0; i<len; i++)
	{
		if (Sys::TextAssistant::IsDigit(buffer[i]) == true)
		{
			cnumber[j++] = buffer[i];
			if (j >= 6 -1)
			{
				cnumber[j] = '\0';
				break;
			}
		}
		else if (Sys::TextAssistant::IsSeparator(buffer[i]) == true)
		{
			cnumber[j] = '\0';
			break;
		}
	}

	//int code = atoi(cnumber);
	//if (code == 334)
	//{
	//	string tmp;
	//	Sys::Convert::Base64BitDecode((const char*)buffer+4, tmp);
	//}

	return atoi(cnumber);
}

int Socket::Receive(char* buffer, int bufferSize)
{
	return recv(hsocket, buffer, bufferSize, 0);
}

int Socket::Receive(char* buffer, int bufferSize, int flags)
{
	return recv(hsocket, buffer, bufferSize, flags);
}

int Socket::ReceiveLine(string& buffer)
{
	char c;
	buffer.clear();
	while (true) 
	{
		if (recv(hsocket, &c, 1, 0) == 0) break;
		if (c == '\n') break;
		buffer += c;  
   }
	return buffer.length();
}

// You don't need to call Connect to execute this function
// uri is the location to open, i.e.  index2.htm
wchar_t* Socket::ReadHttp(const wchar_t* serverName, const wchar_t* uri, wstring& result)
{
	Sys::Socket socket;
	char sz[255];

	// ************************************************** Form URI
	if (uri==NULL)
	{
		strcpy_s(sz, 255, "GET / HTTP/1.0\r\n");
	}
	else
	{
		string auri;
		Sys::Convert::WstringToString(uri, auri);
		_snprintf_s(sz, 255, _TRUNCATE, "GET %s HTTP/1.0\r\n\r\n", auri.c_str());
	}

	wchar_t* error = socket.Connect(serverName, 80);
	if (error) return error;
	int bytes = 0;
	char data[512];
	wstring wdata; 

	if (socket.Send(sz)) // Follow by two returns
	{
		do
		{
			bytes = socket.Receive(data, 512-1);
			if (bytes == SOCKET_ERROR) break;
			if (bytes == 0) break;
			data[bytes] = '\0';
			Sys::Convert::UTF8ToWstring(data, wdata);
			result += wdata;
			if (result.length() > 65536) break;
		}
		while (bytes > 0);
	}
	socket.Disconnect();
	return NULL;
}

wchar_t* Socket::GetErrorDescr(WORD error)
{
	switch(error)
	{
	case 10004: return L"Interrupted function call. This error is returned when a socket is closed or a process is terminated, on a pending Winsock operation for that socket.";
	case 10013: return L"Permission denied. An attempt was made to access a socket in a way forbidden by its access permissions.";
	case 10014: return L"Bad address. The system detected an invalid pointer address in attempting to use a pointer argument of a call. This error occurs if an application passes an invalid pointer value, or if the length of the buffer is too small. For instance, if the length of an argument, which is a sockaddr structure, is smaller than the sizeof(SOCKADDR).";
	case 10022: return L"Invalid argument. Some invalid argument was supplied (for example, specifying an invalid level to the setsockopt (Windows Sockets) function). In some instances, it also refers to the current state of the socket  for instance, calling accept (Windows Sockets) on a socket that is not listening. ";
	case 10024: return L"Invalid argument. Some invalid argument was supplied (for example, specifying an invalid level to the setsockopt (Windows Sockets) function). In some instances, it also refers to the current state of the socket  for instance, calling accept (Windows Sockets) on a socket that is not listening. ";
	case 10035: return L"Resource temporarily unavailable. This error is returned from operations on nonblocking sockets that cannot be completed immediately, for example recv when no data is queued to be read from the socket. It is a nonfatal error, and the operation should be retried later. It is normal for WSAEWOULDBLOCK to be reported as the result from calling connect (Windows Sockets) on a nonblocking SOCK_STREAM socket, since some time must elapse for the connection to be established. ";
	case 10036: return L"Operation now in progress. A blocking operation is currently executing. Windows Sockets only allows a single blocking operation  per task or thread  to be outstanding, and if any other function call is made (whether or not it references that or any other socket) the function fails with the WSAEINPROGRESS error. ";
	case 10037: return L"Operation already in progress. An operation was attempted on a nonblocking socket with an operation already in progress  that is, calling connect a second time on a nonblocking socket that is already connecting, or canceling an asynchronous request (WSAAsyncGetXbyY) that has already been canceled or completed. ";
	case 10038: return L"Socket operation on nonsocket. An operation was attempted on something that is not a socket. Either the socket handle parameter did not reference a valid socket, or for the select function, a member of an fd_set structure was not valid. ";
	case 10039: return L"Destination address required. A required address was omitted from an operation on a socket. For example, this error is returned if sendto is called with the remote address of ADDR_ANY. ";
	case 10040: return L"Message too long. A message sent on a datagram socket was larger than the internal message buffer or some other network limit, or the buffer used to receive a datagram was smaller than the datagram itself. ";
	case 10041: return L"Protocol wrong type for socket. A protocol was specified in the socket function call that does not support the semantics of the socket type requested. For example, the ARPA Internet UDP protocol cannot be specified with a socket type of SOCK_STREAM. ";
	case 10042: return L"Bad protocol option. An unknown, invalid or unsupported option or level was specified in a getsockopt (Windows Sockets) or setsockopt (Windows Sockets) call. ";
	case 10043: return L"Protocol not supported. The requested protocol has not been configured into the system, or no implementation for it exists. For example, a socket call requests a SOCK_DGRAM socket, but specifies a stream protocol. ";
	case 10044: return L"Socket type not supported. The support for the specified socket type does not exist in this address family. For example, the optional type SOCK_RAW might be selected in a socket call, and the implementation does not support SOCK_RAW sockets at all. Also, this error code maybe returned for SOCK_RAW if the caller application is not trusted.";
	case 10045: return L"Operation not supported. The attempted operation is not supported for the type of object referenced. Usually this occurs when a socket descriptor to a socket that cannot support this operation is trying to accept a connection on a datagram socket. ";
	case 10046: return L"Protocol family not supported. The protocol family has not been configured into the system or no implementation for it exists. This message has a slightly different meaning from WSAEAFNOSUPPORT. However, it is interchangeable in most cases, and all Windows Sockets functions that return one of these messages also specify WSAEAFNOSUPPORT. ";
	case 10047: return L"Address family not supported by protocol family. An address incompatible with the requested protocol was used. All sockets are created with an associated address family (that is, AF_INET for Internet protocols) and a generic protocol type (that is, SOCK_STREAM). This error is returned if an incorrect protocol is explicitly requested in the socket call, or if an address of the wrong family is used for a socket, for example, in sendto. ";
	case 10048: return L"Address already in use. Typically, only one usage of each socket address (protocol/IP address/port) is permitted. This error occurs if an application attempts to bind a socket to an IP address/port that has already been used for an existing socket, or a socket that was not closed properly, or one that is still in the process of closing. For server applications that need to bind multiple sockets to the same port number, consider using setsockopt (Windows Sockets)(SO_REUSEADDR). Client applications usually need not call bind at all  connect chooses an unused port automatically. When bind is called with a wildcard address (involving ADDR_ANY), a WSAEADDRINUSE error could be delayed until the specific address is committed. This could happen with a call to another function later, including connect, listen, WSAConnect, or WSAJoinLeaf. ";
	case 10049: return L"Cannot assign requested address. The requested address is not valid in its context. This normally results from an attempt to bind to an address that is not valid for the local machine. This can also result from connect (Windows Sockets), sendto, WSAConnect, WSAJoinLeaf, or WSASendTo when the remote address or port is not valid for a remote machine (for example, address or port 0). ";
	case 10050: return L"Network is down. A socket operation encountered a dead network. This could indicate a serious failure of the network system (that is, the protocol stack that the Windows Sockets DLL runs over), the network interface, or the local network itself. ";
	case 10051: return L"Network is unreachable. A socket operation was attempted to an unreachable network. This usually means the local software knows no route to reach the remote host.";
	case 10052: return L"Network dropped connection on reset. The connection has been broken due to keep-alive activity detecting a failure while the operation was in progress. It can also be returned by setsockopt (Windows Sockets) if an attempt is made to set SO_KEEPALIVE on a connection that has already failed. ";
	case 10053: return L"Software caused connection abort. An established connection was aborted by the software in your host machine, possibly due to a data transmission time-out or protocol error. ";
	case 10054: return L"Connection reset by peer. An existing connection was forcibly closed by the remote host. This normally results if the peer application on the remote host is suddenly stopped, the host is rebooted, or the remote host uses a hard close (see setsockopt (Windows Sockets) for more information on the SO_LINGER option on the remote socket.) This error may also result if a connection was broken due to keep-alive activity detecting a failure while one or more operations are in progress. Operations that were in progress fail with WSAENETRESET. Subsequent operations fail with WSAECONNRESET. ";
	case 10055: return L"No buffer space available. An operation on a socket could not be performed because the system lacked sufficient buffer space or because a queue was full.";
	case 10056: return L"Socket is already connected. A connect request was made on an already-connected socket. Some implementations also return this error if sendto is called on a connected SOCK_DGRAM socket (for SOCK_STREAM sockets, the to parameter in sendto is ignored) although other implementations treat this as a legal occurrence. ";
	case 10057: return L"Socket is not connected. A request to send or receive data was disallowed because the socket is not connected and (when sending on a datagram socket using sendto) no address was supplied. Any other type of operation might also return this error  for example, setsockopt (Windows Sockets) setting SO_KEEPALIVE if the connection has been reset.";
	case 10058: return L"Cannot send after socket shutdown. A request to send or receive data was disallowed because the socket had already been shut down in that direction with a previous shutdown call. By calling shutdown a partial close of a socket is requested, which is a signal that sending or receiving, or both have been discontinued. ";
	case 10060: return L"Connection timed out. A connection attempt failed because the connected party did not properly respond after a period of time, or the established connection failed because the connected host has failed to respond. ";
	case 10061: return L"Connection refused. No connection could be made because the target machine actively refused it. This usually results from trying to connect to a service that is inactive on the foreign host  that is, one with no server application running. ";
	case 10064: return L"Host is down. A socket operation failed because the destination host is down. A socket operation encountered a dead host. Networking activity on the local host has not been initiated. These conditions are more likely to be indicated by the error WSAETIMEDOUT. ";
	case 10065: return L"No route to host. A socket operation was attempted to an unreachable host. See WSAENETUNREACH.";
	case 10067: return L"Too many processes. A Windows Sockets implementation may have a limit on the number of applications that can use it simultaneously. WSAStartup may fail with this error if the limit has been reached. ";
	case 10091: return L"Network subsystem is unavailable. This error is returned by WSAStartup if the Windows Sockets implementation cannot function at because the underlying system it uses to provide network services is currently unavailable. Users should check: That the appropriate Windows Sockets DLL file is in the current path. That they are not trying to use more than one Windows Sockets implementation simultaneously. If there is more than one Winsock DLL on your system, be sure the first one in the path is appropriate for the network subsystem currently loaded. The Windows Sockets implementation documentation to be sure all necessary components are currently installed and configured correctly.";
	case 10092: return L"Winsock.dll version out of range. The current Windows Sockets implementation does not support the Windows Sockets specification version requested by the application. Check that no old Windows Sockets DLL files are being accessed. ";
	case 10093: return L"Successful WSAStartup not yet performed. Either the application has not called WSAStartup or WSAStartup failed. The application may be accessing a socket that the current active task does not own (that is, trying to share a socket between tasks), or WSACleanup has been called too many times. ";
	case 10101: return L"Graceful shutdown in progress. Returned by WSARecv and WSARecvFrom to indicate that the remote party has initiated a graceful shutdown sequence. ";
	case 10109: return L"Class type not found. The specified class was not found. ";
	case 11001: return L"Host not found. No such host is known. The name is not an official host name or alias, or it cannot be found in the database(s) being queried. This error may also be returned for protocol and service queries, and means that the specified name could not be found in the relevant database. ";
	case 11002: return L"Nonauthoritative host not found. This is usually a temporary error during host name resolution and means that the local server did not receive a response from an authoritative server. A retry at some time later may be successful. ";
	case 11003: return L"This is a nonrecoverable error. This indicates some sort of nonrecoverable error occurred during a database lookup. This may be because the database files (for example, BSD-compatible HOSTS, SERVICES, or PROTOCOLS files) could not be found, or a DNS request was returned by the server with a severe error. ";
	case 11004: return L"Valid name, no data record of requested type. The requested name is valid and was found in the database, but it does not have the correct associated data being resolved for. ";
	}
	return L"No error description available";
}

Socket::operator SOCKET() 
{
	return hsocket;
}

wchar_t* Socket::ConnectAsync(HWND hWnd, const wchar_t* serverName, unsigned short port)
{
	if (serverName == NULL) return L"Socket::ConnectAsync: server name is NULL";
	char *ipAddress = this->GetIpAddressByName(serverName);
	if (ipAddress == NULL) return L"Socket::ConnectAsync: IP address is NULL";
	wstring ip_address;
	Sys::Convert::StringToWstring(ipAddress, ip_address);

	return ConnectAsync(hWnd, port, ip_address.c_str());
}

// hWnd will receive a WM_SOCKETNOTIFY message when completion of the call
wchar_t* Socket::ConnectAsyncServer(HWND hWnd, unsigned short port, int numbClients)
{
	Disconnect();

	//__________________________________________ socket
	hsocket = (SOCKET)socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (hsocket == INVALID_SOCKET) return L"Socket::ConnectAsyncServer: unable to create socket";

	//__________________________________________ bind
	SOCKADDR_IN sa;
	sa.sin_family = AF_INET;
	sa.sin_addr.s_addr  = INADDR_ANY;
	sa.sin_port = htons(port);
	if (::bind(hsocket, (PSOCKADDR)&sa, sizeof(SOCKADDR_IN))) return L"Socket::ConnectAsyncServer > Could not bind socket";


	//__________________________________________ listen
	if (::listen(hsocket, numbClients)) return L"Socket::ConnectAsyncServer: socket cannot listen";

	//__________________________________________ AsyncSelect
	int nError = WSAAsyncSelect (hsocket, hWnd, WM_SOCKETNOTIFY,
		FD_CONNECT | FD_READ | FD_WRITE | FD_CLOSE | FD_ACCEPT);
	if (nError ==SOCKET_ERROR) return L"Socket::ConnectAsyncServer: call to WSAAsyncSelect was not successful";

	//__________________________________________________________ accept
	//m_sockTmp = ::accept(hsocket, NULL, 0); // This will block
	::accept(hsocket, NULL, 0);
	if (WSAEWOULDBLOCK!=(nError=WSAGetLastError())) return L"Socket::ConnectAsyncServer: socket could not accept connection";

	//m_bConnected = true;  //We should wait for the Windows Message to set this flag
	return NULL;
}

// After calling this function, you must call Accept
// Accept will block until a new request is received
// Accept will return a new sockect that can be used to handle the request
// You may optionally Close the socket when it is not needed
wchar_t* Socket::StartServer(unsigned short port, int numbClients)
{
	Disconnect();
	//__________________________________________ socket
	//hsocket = (SOCKET)socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
	hsocket = (SOCKET)socket(AF_INET, SOCK_STREAM, IPPROTO_IP);
	if (hsocket == INVALID_SOCKET) return L"Socket::ConnectSyncServer: unable to create socket";

	//__________________________________________ bind
	SOCKADDR_IN sa;
	sa.sin_family = AF_INET;
	sa.sin_addr.s_addr  = INADDR_ANY;
	sa.sin_port = htons(port);
	if (::bind(hsocket, (PSOCKADDR)&sa, sizeof(SOCKADDR_IN))) return L"Socket::ConnectSyncServer > Could not bind socket";
	//__________________________________________ listen
	if (::listen(hsocket, numbClients)) return L"Socket::ConnectSyncServer: socket cannot listen";
	return NULL;
}

// hWnd will receive a WM_SOCKETNOTIFY message when completion of the call
wchar_t* Socket::ConnectAsyncClient(HWND hWnd, unsigned short port, const wchar_t* ipAddress)
{
	Disconnect();
	//_________________________________________________________  socket
	hsocket = (SOCKET)socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (hsocket == INVALID_SOCKET) return L"Socket::ConnectAsyncClient: unable to create socket";

	//________________________________________________________ AsyncSelect
	int nError = WSAAsyncSelect (hsocket, hWnd, WM_SOCKETNOTIFY,
		FD_CONNECT | FD_READ | FD_WRITE | FD_CLOSE);
	if (nError ==SOCKET_ERROR) return L"Socket::ConnectAsyncClient : call to WSAAsyncSelect was not successful";

	//_______________________________________________________ Async connect
	string ip_address;
	Sys::Convert::WstringToString(ipAddress, ip_address);
	SOCKADDR_IN sa;
	sa.sin_family = AF_INET;
	sa.sin_port = htons(port);
	sa.sin_addr.S_un.S_addr = inet_addr(ip_address.c_str());
	connect(hsocket, (SOCKADDR*)&sa, sizeof(SOCKADDR_IN));
	if (WSAEWOULDBLOCK!=(nError=WSAGetLastError())) return L"Socket::ConnectAsyncServer: unable to connect asynchronously";

	//m_bConnected = true;  //We should wait for the Windows Message to set this flag
	return NULL;
}

// hWnd will receive a nMssg message when completion of the call
wchar_t* Socket::ConnectAsync(HWND hWnd, unsigned short port, const wchar_t* ipAddress)
{
	Disconnect();
	//______________________________________________ socket
	hsocket = (SOCKET)::socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (hsocket == INVALID_SOCKET) return L"Socket::ConnectAsync: unable to create socket";

	//_____________________________________________AsyncSelect
	int nError = WSAAsyncSelect (hsocket, hWnd, WM_SOCKETNOTIFY,
		FD_CONNECT | FD_READ | FD_WRITE | FD_CLOSE);
	if (nError ==SOCKET_ERROR) return L"Socket::ConnectAsync:: call to WSAAsyncSelect was not successful";

	//_____________________________________________ Async connect
	string ip_address;
	Sys::Convert::WstringToString(ipAddress, ip_address);
	SOCKADDR_IN sa;
	sa.sin_family = AF_INET;
	sa.sin_port = htons(port);
	sa.sin_addr.S_un.S_addr = inet_addr(ip_address.c_str());
	::connect(hsocket, (SOCKADDR*)&sa, sizeof(SOCKADDR_IN));
	if (WSAEWOULDBLOCK!=(nError=WSAGetLastError())) return L"Socket::ConnectAsync: unable to connect asynchronously";
	//m_bConnected = true;  //We should wait for the Windows Message to set this flag
	return NULL;
}

//LRESULT Socket::OnSocketNotify(HWND hWnd, WPARAM wParam, LPARAM lParam)
//{
//	WORD wEvent = WSAGETSELECTEVENT(lParam); // LOWORD
//	WORD wError = WSAGETSELECTERROR(lParam); // HIWORD
//
//	if (wError)
//	{
//		OnError(wEvent, wError, L"SocketAsync::OnSocketNotify error during processing:", 
//			Sys::SocketAsync::GetFdText(wEvent));
//		this->Close();
//		return FALSE;
//	}
//
//	switch(wEvent)
//	{
//	case FD_ACCEPT: 
//{
//	SOCKET sockTmp = (SOCKET)::accept(m_socket, NULL, 0);
//	closesocket(m_socket);
//	m_socket = sockTmp;
//	return TRUE;
//}
//		return OnFdAccept();
//	case FD_CONNECT: 
//		m_bConnected = true;
//		return OnFdConnect();
//	case FD_READ: 
//		return OnFdRead();
//	case FD_WRITE: 
//		return OnFdWrite();
//	case FD_CLOSE: 
//		m_bConnected = false;
//		m_socket = INVALID_SOCKET;
//		return OnFdClose();
//	}
//	return FALSE;
//}

#endif


//_____________________________________________________________________ Brushes

HBRUSH Brushes::WhiteBrush() 
{
	return (HBRUSH)::GetStockObject(WHITE_BRUSH);
}

HBRUSH Brushes::DkGrayBrush() 
{
	return (HBRUSH)::GetStockObject(DKGRAY_BRUSH);
}

HBRUSH Brushes::HollowBrush() 
{
	return (HBRUSH)::GetStockObject(HOLLOW_BRUSH);
}

HBRUSH Brushes::LtGrayBrush() 
{
	return (HBRUSH)::GetStockObject(LTGRAY_BRUSH);
}

HBRUSH Brushes::GrayBrush() 
{
	return (HBRUSH)::GetStockObject(GRAY_BRUSH);
}

HBRUSH Brushes::BlackBrush() 
{
	return (HBRUSH)::GetStockObject(BLACK_BRUSH);
}

HBRUSH Brushes::NullBrush() 
{
	return (HBRUSH)::GetStockObject(NULL_BRUSH);
}

//_____________________________________________________________________ Colors
COLORREF Colors::WindowColor() 
{
	return ::GetSysColor(COLOR_WINDOW);
}

COLORREF Colors::ActiveBorderColor() 
{
	return ::GetSysColor(COLOR_ACTIVEBORDER);
}

COLORREF Colors::ActiveCaptionColor() 
{
	return ::GetSysColor(COLOR_ACTIVECAPTION);
}

COLORREF Colors::AppWorkspaceColor() 
{
	return ::GetSysColor(COLOR_APPWORKSPACE);
}

COLORREF Colors::BackgroundColor() 
{
	return ::GetSysColor(COLOR_BACKGROUND);
}

COLORREF Colors::BtnFaceColor() 
{
	return ::GetSysColor(COLOR_BTNFACE);
}

COLORREF Colors::BtnShadowColor() 
{
	return ::GetSysColor(COLOR_BTNSHADOW);
}

COLORREF Colors::BtnTextColor() 
{
	return ::GetSysColor(COLOR_BTNTEXT);
}

COLORREF Colors::BtnHighLightColor() 
{
	return ::GetSysColor(COLOR_BTNHIGHLIGHT);
}

COLORREF Colors::ThreeDDkShadowColor() 
{
	return ::GetSysColor(COLOR_3DDKSHADOW);
}

COLORREF Colors::ThreeDLightColor() 
{
	return ::GetSysColor(COLOR_3DLIGHT);
}

COLORREF Colors::InfoTextColor() 
{
	return ::GetSysColor(COLOR_INFOTEXT);
}

COLORREF Colors::InfoBkColor() 
{
	return ::GetSysColor(COLOR_INFOBK);
}

COLORREF Colors::CaptionTextColor() 
{
	return ::GetSysColor(COLOR_CAPTIONTEXT);
}

COLORREF Colors::InactiveCaptionTextColor() 
{
	return ::GetSysColor(COLOR_INACTIVECAPTIONTEXT);
}

COLORREF Colors::GrayTextColor() 
{
	return ::GetSysColor(COLOR_GRAYTEXT);
}

COLORREF Colors::HighLightColor() 
{
	return ::GetSysColor(COLOR_HIGHLIGHT);
}

COLORREF Colors::HighLightTextColor() 
{
	return ::GetSysColor(COLOR_HIGHLIGHTTEXT);
}

COLORREF Colors::InactiveBorderColor() 
{
	return ::GetSysColor(COLOR_INACTIVEBORDER);
}

COLORREF Colors::InactiveCaptionColor() 
{
	return ::GetSysColor(COLOR_INACTIVECAPTION);
}

COLORREF Colors::MenuColor() 
{
	return ::GetSysColor(COLOR_MENU);
}

COLORREF Colors::MenuTextColor() 
{
	return ::GetSysColor(COLOR_MENUTEXT);
}

COLORREF Colors::ScrollbarColor() 
{
	return ::GetSysColor(COLOR_SCROLLBAR);
}

COLORREF Colors::WindowFrameColor() 
{
	return ::GetSysColor(COLOR_WINDOWFRAME);
}

COLORREF Colors::WindowTextColor() 
{
	return ::GetSysColor(COLOR_WINDOWTEXT);
}

COLORREF Colors::HotLightColor() 
{
	return ::GetSysColor(COLOR_HOTLIGHT);
}

COLORREF Colors::GradientActiveCatpionColor() 
{
	return ::GetSysColor(COLOR_GRADIENTACTIVECAPTION);
}

COLORREF Colors::GradientInactiveCaptionColor() 
{
	return ::GetSysColor(COLOR_GRADIENTINACTIVECAPTION);
}

//_____________________________________________________________________ Metrics
int Metrics::GetMinimizedWindowType()
{
	return ::GetSystemMetrics(SM_ARRANGE);
}

int Metrics::GetSystemStartedType()//0 Normal boot,1 Fail-safe boot, 2 Fail-safe with network boot
{
	return ::GetSystemMetrics(SM_CLEANBOOT);
}

int Metrics::GetMonitorCount()
{
	return ::GetSystemMetrics(SM_CMONITORS);
}

int Metrics::GetMouseButtonsCount()
{
	return ::GetSystemMetrics(SM_CMOUSEBUTTONS);
}

int Metrics::GetWindowBorderWidth()
{
	return ::GetSystemMetrics(SM_CXBORDER);
}

int Metrics::GetWindow3DBorderWidth()
{
	return ::GetSystemMetrics(SM_CXEDGE);
}

int Metrics::GetCursorWidth()
{
	return ::GetSystemMetrics(SM_CXCURSOR);
}

int Metrics::GetDoubleClickWidth()
{
	return ::GetSystemMetrics(SM_CXDOUBLECLK);
}

int Metrics::GetDragWidth()
{
	return ::GetSystemMetrics(SM_CXDRAG);
}

int Metrics::GetFixedFrameThickness()
{
	return ::GetSystemMetrics(SM_CXFIXEDFRAME);
}

int Metrics::GetFocusBorderWidth()
{
	return ::GetSystemMetrics(SM_CXFOCUSBORDER);
}

int Metrics::GetFullScreenWidth()
{
	return ::GetSystemMetrics(SM_CXFULLSCREEN);
}

int Metrics::GetScreenWidth()
{
	return ::GetSystemMetrics(SM_CXSCREEN);
}

int Metrics::GetHScrollWidth()
{
	return ::GetSystemMetrics(SM_CXHSCROLL);
}

int Metrics::GetHScrollThumbWidth()
{
	return ::GetSystemMetrics(SM_CXHTHUMB);
}

int Metrics::GetIconWidth()
{
	return ::GetSystemMetrics(SM_CXICON);
}

int Metrics::GetIconSpacingWidth()
{
	return ::GetSystemMetrics(SM_CXICONSPACING);
}

int Metrics::GetMaximinizedWindowWidth()
{
	return ::GetSystemMetrics(SM_CXMAXIMIZED);
}

int Metrics::GetMaxTrackWidth()
{
	return ::GetSystemMetrics(SM_CXMAXTRACK);
}

int Metrics::GetMenuCheckWidth()
{
	return ::GetSystemMetrics(SM_CXMENUCHECK);
}

int Metrics::GetMenuWidth()
{
	return ::GetSystemMetrics(SM_CXMENUSIZE);
}

int Metrics::GetMinWindowWidth()
{
	return ::GetSystemMetrics(SM_CXMIN);
}

int Metrics::GetMinimizedWindowWidth()
{
	return ::GetSystemMetrics(SM_CXMINIMIZED);
}

int Metrics::GetMinSpacingWidth()
{
	return ::GetSystemMetrics(SM_CXMINSPACING);
}

int Metrics::GetMinTrackWidth()
{
	return ::GetSystemMetrics(SM_CXMINTRACK);
}

//int Metrics::GetPaddedBorderWidth(){return ::GetSystemMetrics(SM_CXPADDEDBORDER);}
int Metrics::GetTitleBarButtonWidth()
{
	return ::GetSystemMetrics(SM_CXSIZE);
}

int Metrics::GetSizeFrameWidth()
{
	return ::GetSystemMetrics(SM_CXSIZEFRAME);
}

int Metrics::GetSmallIconWidth()
{
	return ::GetSystemMetrics(SM_CXSMICON);
}

int Metrics::GetSmallCaptionButtonWidth()
{
	return ::GetSystemMetrics(SM_CXSMSIZE);
}

int Metrics::GetVirtualScreenWidth()
{
	return ::GetSystemMetrics(SM_CXVIRTUALSCREEN);
}

int Metrics::GetVScrollWidth()
{
	return ::GetSystemMetrics(SM_CXVSCROLL);
}

int Metrics::GetWindowBorderHeight()
{
	return ::GetSystemMetrics(SM_CYBORDER);
}

int Metrics::GetWindow3DBorderHeight()
{
	return ::GetSystemMetrics(SM_CYEDGE);
}

int Metrics::GetCaptionHeight()
{
	return ::GetSystemMetrics(SM_CYCAPTION);
}

int Metrics::GetCursorHeight()
{
	return ::GetSystemMetrics(SM_CYCURSOR);
}

int Metrics::GetDlgFrameHeight()
{
	return ::GetSystemMetrics(SM_CYDLGFRAME);
}

int Metrics::GetDoubleClickHeight()
{
	return ::GetSystemMetrics(SM_CYDOUBLECLK);
}

int Metrics::GetDragHeight()
{
	return ::GetSystemMetrics(SM_CYDRAG);
}

int Metrics::GetFixedFrameHeight()
{
	return ::GetSystemMetrics(SM_CYFIXEDFRAME);
}

int Metrics::GetFocusBorderHeight()
{
	return ::GetSystemMetrics(SM_CYFOCUSBORDER);
}

int Metrics::GetFullScreenHeight()
{
	return ::GetSystemMetrics(SM_CYFULLSCREEN);
}

int Metrics::GetHScrollHeight()
{
	return ::GetSystemMetrics(SM_CYHSCROLL);
}

int Metrics::GetIconHeight()
{
	return ::GetSystemMetrics(SM_CYICON);
}

int Metrics::GetIconSpacingHeight()
{
	return ::GetSystemMetrics(SM_CYICONSPACING);
}

int Metrics::GetKanjiWindowHeight()
{
	return ::GetSystemMetrics(SM_CYKANJIWINDOW);
}

int Metrics::GetMaximinzedWindowHeight()
{
	return ::GetSystemMetrics(SM_CYMAXIMIZED);
}

int Metrics::GetMaxTrackHeight()
{
	return ::GetSystemMetrics(SM_CYMAXTRACK);
}

int Metrics::GetMenuHeight()
{
	return ::GetSystemMetrics(SM_CYMENU);
}

int Metrics::GetMenuCheckHeight()
{
	return ::GetSystemMetrics(SM_CYMENUCHECK);
}

int Metrics::GetMenuSizeHeight()
{
	return ::GetSystemMetrics(SM_CYMENUSIZE);
}

int Metrics::GetMinWindowHeight()
{
	return ::GetSystemMetrics(SM_CYMIN);
}

int Metrics::GetMinimizedWindowHeight()
{
	return ::GetSystemMetrics(SM_CYMINIMIZED);
}

int Metrics::GetMinSpacingHeight()
{
	return ::GetSystemMetrics(SM_CYMINSPACING);
}

int Metrics::GetMinTrackHeight()
{
	return ::GetSystemMetrics(SM_CYMINTRACK);
}

int Metrics::GetScreenHeight()
{
	return ::GetSystemMetrics(SM_CYSCREEN);
}

int Metrics::GetTitleBarHeight()
{
	return ::GetSystemMetrics(SM_CYSIZE);
}

int Metrics::GetSizeFrameHeight()
{
	return ::GetSystemMetrics(SM_CYSIZEFRAME);
}

int Metrics::GetSmallCaptionHeight()
{
	return ::GetSystemMetrics(SM_CYSMCAPTION);
}

int Metrics::GetSmallIconHeight()
{
	return ::GetSystemMetrics(SM_CYSMICON);
}

int Metrics::GetSmallCaptionButtonHeight()
{
	return ::GetSystemMetrics(SM_CYSMSIZE);
}

int Metrics::GetVirtualScreenHeight()
{
	return ::GetSystemMetrics(SM_CYVIRTUALSCREEN);
}

int Metrics::GetVScrollHeight()
{
	return ::GetSystemMetrics(SM_CYVSCROLL);
}

int Metrics::GetVScroolThumbHeight()
{
	return ::GetSystemMetrics(SM_CYVTHUMB);
}

bool Metrics::IsShuttingDown()
{
	return (::GetSystemMetrics(SM_SHUTTINGDOWN)!=0);
}

void Metrics::GetTextMetricsFromDisplay(TEXTMETRIC& result)
{
	HDC hdc = ::CreateIC(L"DISPLAY", NULL, NULL, NULL);
	HFONT font = (HFONT)::GetStockObject(SYSTEM_FONT);
	HFONT tmp  = (HFONT)::SelectObject(hdc, font);
	::GetTextMetrics(hdc, &result);
	::SelectObject(hdc, tmp);
	::DeleteDC(hdc);
}

void Metrics::GetTextMetricsFromDisplay(const wchar_t* fontname, int fontsize, TEXTMETRIC& result)
{
	HDC hdc = ::CreateIC(L"DISPLAY", NULL, NULL, NULL);
	HFONT font = ::CreateFont(-abs(fontsize), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, fontname);
	HFONT tmp  = (HFONT)::SelectObject(hdc, font);
	::GetTextMetrics(hdc, &result);
	::SelectObject(hdc, tmp);
	::DeleteObject(font);
	::DeleteDC(hdc);
}

void Metrics::GetTextMetricsFromDisplay(const wstring& fontname, int fontsize, TEXTMETRIC& result)
{
	Sys::Metrics::GetTextMetricsFromDisplay(fontname.c_str(), fontsize, result);
}

//_____________________________________________________________________ Convert
Convert::Convert()
{
}

Convert::~Convert()
{
}

wchar_t* Convert::ToHtml(wchar_t c)
{
	switch(c)
	{
	case '"': return L"&quot;";
	case '&': return L"&amp;";
	case '<': return L"&lt;";
	case '>': return L"&gt;";
	case ' ': return L"&nbsp;";
	case '¡': return L"&iexcl;";
	case '¢': return L"&cent;";
	case '£': return L"&pound;";
	case '¤': return L"&curren;";
	case '¥': return L"&yen;";
	case '¦': return L"&brvbar;";
	case '§': return L"&sect;";
	case '¨': return L"&uml;";
	case '©': return L"&copy;";
	case 'ª': return L"&ordf;";
	case '«': return L"&laquo;";
	case '¬': return L"&no;";
	//case '­': return L"&shy;";
	case '®': return L"&reg;";
	//case '¯': return L"&macr;";
	//case '°': return L"&deg;";
	//case '±': return L"&plusmn;";
	//case '²': return L"&sup2;";
	//case '³': return L"&sup3;";
	//case '´': return L"&acute;";
	//case 'µ': return L"&micro;";
	//case '¶': return L"&para;";
	//case '·': return L"&middot;";
	//case '¸': return L"&cedil;";
	//case '¹': return L"&sup1;";
	//case 'º': return L"&ordm;";
	//case '»': return L"&raquo;";
	//case '¼': return L"&frac14;";
	//case '½': return L"&frac12;";
	//case '¾': return L"&frac34;";
	case '¿': return L"&iques;t";
	case 'À': return L"&Agrave;";
	case 'Á': return L"&Aacute;";
	case 'Â': return L"&Acirc;";
	case 'Ã': return L"&Atilde;";
	case 'Ä': return L"&Auml;";
	case 'Å': return L"&Aring;";
	case 'Æ': return L"&AElig;";
	case 'Ç': return L"&Ccedil;";
	case 'È': return L"&Egrave;";
	case 'É': return L"&Eacute;";
	case 'Ê': return L"&Ecirc;";
	case 'Ë': return L"&Euml;";
	case 'Ì': return L"&Igrave;";
	case 'Í': return L"&Iacute;";
	case 'Î': return L"&Icirc;";
	case 'Ï': return L"&Iuml;";
	case 'Ð': return L"&ETH;";
	case 'Ñ': return L"&Ntilde;";
	case 'Ò': return L"&Ograve;";
	case 'Ó': return L"&Oacute;";
	case 'Ô': return L"&Ocirc;";
	case 'Õ': return L"&Otilde;";
	case 'Ö': return L"&Ouml;";
	case '×': return L"&times;";
	case 'Ø': return L"&Oslash;";
	case 'Ù': return L"&Ugrave;";
	case 'Ú': return L"&Uacute;";
	case 'Û': return L"&Ucirc;";
	case 'Ü': return L"&Uuml;";
	case 'Ý': return L"&Yacute;";
	case 'Þ': return L"&THORN;";
	case 'ß': return L"&szlig;";
	case 'à': return L"&agrave;";
	case 'á': return L"&aacut;e";
	case 'â': return L"&acirc;";
	case 'ã': return L"&atilde;";
	case 'ä': return L"&auml;";
	case 'å': return L"&aring;";
	case 'æ': return L"&aelig;";
	case 'ç': return L"&ccedil;";
	case 'è': return L"&egrave;";
	case 'é': return L"&eacute;";
	case 'ê': return L"&ecirc;";
	case 'ë': return L"&euml;";
	case 'ì': return L"&igrave;";
	case 'í': return L"&iacute;";
	case 'î': return L"&icirc;";
	case 'ï': return L"&iuml;";
	case 'ð': return L"&eth;";
	case 'ñ': return L"&ntilde;";
	case 'ò': return L"&ograve;";
	case 'ó': return L"&oacute;";
	case 'ô': return L"&ocirc;";
	case 'õ': return L"&otilde;";
	case 'ö': return L"&ouml;";
	case '÷': return L"&divide;";
	case 'ø': return L"&oslash;";
	case 'ù': return L"&ugrave;";
	case 'ú': return L"&uacute;";
	case 'û': return L"&ucirc;";
	case 'ü': return L"&uuml;";
	case 'ý': return L"&yacute;";
	case 'þ': return L"&thorn;";
	case 'ÿ'	: return L"&yuml;";
	}
	return NULL;
}

void Convert::ToHtml(const wchar_t * input, wstring& output)
{
	wchar_t * html;
	const int len = wcslen(input);
	output.reserve(len);

	for(wchar_t* p = (wchar_t*)input; *p != '\0'; p++)
	{
		html = Sys::Convert::ToHtml(*p);
		if (html == NULL)
		{
			output += *p;
		}
		else
		{
			output += html;
		}
	}
}

wchar_t* Convert::ToXml(wchar_t c)
{
	switch(c)
	{
	case '&': return L"&amp;";
	case '<': return L"&lt;";
	case '>': return L"&gt;";
	case '%': return L"&#37;";
	}
	return NULL;
}

void Convert::ToXml(const wchar_t * input, wstring& output)
{
	wchar_t * xmlTmp;
	const int len = wcslen(input);
	output.clear();
	output.reserve(len);

	for(wchar_t* p = (wchar_t*)input; *p != '\0'; p++)
	{
		xmlTmp = Sys::Convert::ToXml(*p);
		if (xmlTmp == NULL)
		{
			output += *p;
		}
		else
		{
			output += xmlTmp;
		}
	}
}

void Convert::ToXml(const wstring& input, wstring& output)
{
	wchar_t * xmlTmp;
	const int len = input.length();
	output.clear();
	output.reserve(len);
	wchar_t p;

	for(int i = 0; i<len; i++)
	{
		p = input[i];
		xmlTmp = Sys::Convert::ToXml(p);
		if (xmlTmp == NULL)
		{
			output += p;
		}
		else
		{
			output += xmlTmp;
		}
	}
}

bool Convert::HexRequiresCoding(char input)
{
	if ('a' <= input && input <= 'z') return false;
	if ('A' <= input && input <='Z') return false;
	if ('0' <= input && input <='9') return false;
	//if (input == '.') return false;
	//if (input == '-') return false;
	//if (input == '~') return false;
	//if (input == '_') return false;
	return true;
}

bool Convert::HexRequiresCoding(wchar_t input)
{
	if ('a' <= input && input <= 'z') return false;
	if ('A' <= input && input <='Z') return false;
	if ('0' <= input && input <='9') return false;
	//if (input == '.') return false;
	//if (input == '-') return false;
	//if (input == '~') return false;
	//if (input == '_') return false;
	return true;
}

int Convert::HexComputeLength(const char* input)
{
	int len = 0;
	for(char* p = (char*)input; *p != '\0'; p++)
	{
		//___________________________________ space uses one character, but requires coding
		if (*p == ' ')
		{
			len++;
			continue;
		}
		if (Sys::Convert::HexRequiresCoding(*p) == true)
		{
			len += 3;
		}
		else
		{
			len++;
		}
	}
	return len;
}

int Convert::HexComputeLength(const wchar_t* input)
{
	int len = 0;
	for(wchar_t* p = (wchar_t*)input; *p != '\0'; p++)
	{
		//___________________________________ space uses one character, but requires coding
		if (*p == ' ')
		{
			len++;
			continue;
		}
		if (Sys::Convert::HexRequiresCoding(*p) == true)
		{
			len += 3;
		}
		else
		{
			len++;
		}
	}
	return len;
}

// Converts a string to its equivalent hexadecimal
bool Convert::WstringToHex(const wchar_t* input, wstring& output)
{
	const wchar_t * hex =L"0123456789ABCDEF";
	//__________________________________ Compute Length
	const int len = Sys::Convert::HexComputeLength(input);
	if (len == 0)
	{
		output.clear();
		return true;
	}
	//_________________________________ Memory Allocation
	try
	{
		output.resize(len);
	}
	catch(const std::bad_alloc&)
	{
		output.clear();
		return false;
	}
	int i = 0;
	//__________________________________ Convert
	for(wchar_t* p = (wchar_t*)input; *p != '\0'; p++)
	{
		//______________________________________ Check for spaces
		if (*p == ' ')
		{
			output[i] = '+';
			i++;
			continue;
		}
		if (Sys::Convert::HexRequiresCoding(*p) == true)
		{
			output[i] = '%';
			i++;
			output[i] = hex[*p/16];	
			i++;
			output[i] = hex[*p%16];
			i++;
		}
		else
		{
			output[i] = *p;
			i++;
			continue;
		}
	}
	return true;
}

// Converts a UTF8 string to its equivalent hexadecimal
bool Convert::UTF8ToHex(const char* input, string& output)
{
	const char * hex ="0123456789ABCDEF";
	//__________________________________ Compute Length
	const int len = Sys::Convert::HexComputeLength(input);
	if (len == 0)
	{
		output.clear();
		return true;
	}
	//_________________________________ Memory Allocation
	try
	{
		output.resize(len);
	}
	catch(const std::bad_alloc&)
	{
		output.clear();
		return false;
	}
	int i = 0;
	//__________________________________ Convert
	for(char* p = (char*)input; *p != '\0'; p++)
	{
		//______________________________________ Check for spaces
		if (*p == ' ')
		{
			output[i] = '+';
			i++;
			continue;
		}
		if (Sys::Convert::HexRequiresCoding(*p) == true)
		{
			output[i] = '%';
			i++;
			output[i] = hex[*p/16];	
			i++;
			output[i] = hex[*p%16];
			i++;
		}
		else
		{
			output[i] = *p;
			i++;
			continue;
		}
	}
	return true;
}

// Converts a hexadecimal string to its equivalent  UTF8
bool Convert::HexToUTF8(const char* input, string& output)
{
	output.clear();
	const int len = strlen(input);
	if (len == 0) return true;
	output.reserve(len);
	int decimalValue;
	bool decode1 = false;
	bool decode2 = false;
	for(char* p = (char*)input; *p != '\0'; p++)
	{
		if (decode1 == false && decode2 == false)
		{
			if (*p == '%')
			{
				decode1 = true;
				decode2 = false;
				continue;
			}
			else if (*p == '+')
			{
				output += ' ';
			}
			else
			{
				output += (*p);
			}		
		}
		else if (decode1 == true && decode2 == false)//________ We process first letter after %
		{
			if ('0' <= *p  && *p <= '9')
			{
				decimalValue = (*p - '0') * 16;
			}
			else if ('A' <= *p && *p<='F') // Upper Case
			{
				decimalValue = (( *p - 'A') + 10) * 16;
			}
			else if ('a' <= *p && *p<='f') // Lower Case
			{
				decimalValue = ((*p - 'a') + 10) * 16;
			}
			decode1 = true;
			decode2 = true;
		}
		else if (decode1 == true && decode2 == true)//_________We process second letter after %
		{
			if ('0' <= *p  && *p <= '9')
			{
				decimalValue += (*p-'0');
			}
			else if ('A' <= *p && *p<='F') // Upper Case
			{
				decimalValue += (( *p - 'A') + 10);
			}
			else if ('a' <= *p && *p<='f') // Lower Case
			{
				decimalValue += (( *p - 'a') + 10);
			}
			output += ((char)(decimalValue));
			decode1 = false;
			decode2 = false;
		}
	}
	return true;
}


double Convert::MseToGrade(const double mse) //Mean squared error to Grade [0 to 100]
{
	double value = 20.0*fabs(log10(fabs(sqrt(mse))));
	if (value<0.0) value = 0.0;
	if (value>100.0) value = 100.0;
	return value;
}

COLORREF Convert::TextToColorRef(const wchar_t* text)
{
	if (text == NULL) return RGB (0, 0, 0);
	const int len = wcslen(text);
	if (len<6) return RGB (0, 0, 0);
	int next = 0;
	int red = 0, green = 0, blue = 0;
	
	wchar_t tmp[16];
	int i, j;

	while ( (text[next]<'0' || text[next]>'9') && next<len) next++;
	//________________________________ red
	for(i = 0, j=next; i<16 && j<len; i++, j++)
	{
		tmp[i] = text[j];
		if (tmp[i]<'0' || tmp[i]>'9')
		{
			tmp[i] = '\0';
			tmp[15] = '\0';
			red = _wtoi(tmp);
			next = j;
			break;
		}
	}
	while ( (text[next]<'0' || text[next]>'9') && next<len) next++;
	//________________________________ green
	for(i = 0, j=next; i<16 && j<len; i++, j++)
	{
		tmp[i] = text[j];
		if (tmp[i]<'0' || tmp[i]>'9')
		{
			tmp[i] = '\0';
			tmp[15] = '\0';
			green = _wtoi(tmp);
			next = j;
			break;
		}
	}
	while ( (text[next]<'0' || text[next]>'9') && next<len) next++;
	//________________________________ blue
	for(i = 0, j=next; i<16 && j<len; i++, j++)
	{
		tmp[i] = text[j];
		if (j==len-1)
		{
			if ( (i+1)<16)
			{
				tmp[i+1] = '\0';
				tmp[15] = '\0';
				blue = _wtoi(tmp);
				break;
			}
		}
		if (tmp[i]<'0' || tmp[i]>'9')
		{
			tmp[i] = '\0';
			tmp[15] = '\0';
			blue = _wtoi(tmp);
			break;
		}
	}

	return RGB(red, green, blue);
}

COLORREF Convert::TextToColorRef(const wstring& text)
{
	return Sys::Convert::TextToColorRef(text.c_str());
}

COLORREF Convert::OleColorToColorRef(const OLE_COLOR input)
{
	const long red = input & 0x000000FF;
	const long green = (input & 0x0000FF00)>>8;
	const long blue = (input & 0x00FF0000)>>16;
	return RGB(red, green, blue);
}

OLE_COLOR Convert::ColorRefToOleColor(const COLORREF input)
{
	return (OLE_COLOR)input;
}

bool Convert::HiMetricToPixel(const SIZEL& inputHiMetric, SIZEL& resultPix)
{
	HDC hdc = ::GetDC(NULL);
	if (hdc==NULL) return false;
	const int nPixelsPerInchX = ::GetDeviceCaps(hdc, LOGPIXELSX);// Pixels per logical inch along width
	const int nPixelsPerInchY = ::GetDeviceCaps(hdc, LOGPIXELSY);// Pixels per logical inch along height
	::ReleaseDC(NULL, hdc);

	//#define MAP_LOGHIM_TO_PIX(x,ppli)   MulDiv((ppli), (x), 2540)
	//lpSizeInPix->cx = MAP_LOGHIM_TO_PIX(lpSizeInHiMetric->cx, nPixelsPerInchX);
	//lpSizeInPix->cy = MAP_LOGHIM_TO_PIX(lpSizeInHiMetric->cy, nPixelsPerInchY);
	resultPix.cx = MulDiv(nPixelsPerInchX, inputHiMetric.cx, 2540);
	resultPix.cy = MulDiv(nPixelsPerInchY, inputHiMetric.cy, 2540);
	return true;
}

bool Convert::PixelToHiMetric(const SIZEL& inputPix, SIZEL& resultHiMetric)
{
	HDC hdc = ::GetDC(NULL);
	if (hdc==NULL) return false;
	const int nPixelsPerInchX = ::GetDeviceCaps(hdc, LOGPIXELSX);// Pixels per logical inch along width
	const int nPixelsPerInchY = ::GetDeviceCaps(hdc, LOGPIXELSY);// Pixels per logical inch along height
	::ReleaseDC(NULL, hdc);

	//#define MAP_PIX_TO_LOGHIM(x,ppli)   MulDiv(2540, (x), (ppli))
	//MAP_PIX_TO_LOGHIM(lpSizeInPix->cx, nPixelsPerInchX);
	//MAP_PIX_TO_LOGHIM(lpSizeInPix->cy, nPixelsPerInchY);
	resultHiMetric.cx = MulDiv(2540, inputPix.cx, nPixelsPerInchX);  
	resultHiMetric.cy = MulDiv(2540, inputPix.cy, nPixelsPerInchY); 
	return true;
}

int Convert::DlgUnitToPixelX(int dialogUnits)
{
	return (int)( (dialogUnits*LOWORD(::GetDialogBaseUnits())) /4.0+0.5);
}

int Convert::PixelToDlgUnitX(int pixels)
{
	return (int)(4.0*pixels/LOWORD(::GetDialogBaseUnits())+0.5);
}

int Convert::DlgUnitToPixelY(int dialogUnits)
{
	return (int)( (dialogUnits*HIWORD(::GetDialogBaseUnits())) /8.0+0.5);
}

int Convert::PixelToDlgUnitY(int pixels)
{
	return (int)(8.0*pixels/HIWORD(::GetDialogBaseUnits())+0.5);
}

int Convert::FontPointToLogicUnits(HDC hdc, double fontPoints)
{
	const double cyDpi = (double)::GetDeviceCaps(hdc, LOGPIXELSY);
	return (int)(cyDpi*fontPoints/72.0+0.5); 	// 1 inch = 72 points
}

int Convert::FontPointToLogicUnits(double fontPoints)
{
	HDC hdc = ::CreateIC(L"DISPLAY", NULL, NULL, NULL);
	const int logicUnits = Sys::Convert::FontPointToLogicUnits(hdc, fontPoints);
	if (hdc) ::DeleteDC(hdc);
	return logicUnits;
}

double Convert::LogicUnitsToFontPoint(int logicUnits)
{
	HDC hdc = ::CreateIC(L"DISPLAY", NULL, NULL, NULL);
	const double fontPoints = Sys::Convert::LogicUnitsToFontPoint(hdc, logicUnits);
	if (hdc) ::DeleteDC(hdc);
	return fontPoints;
}

double Convert::LogicUnitsToFontPoint(HDC hdc, int logicUnits)
{
	const double cyDpi = (double)::GetDeviceCaps(hdc, LOGPIXELSY);
	return (logicUnits*72.0/cyDpi);	// 1 inch = 72 points
}

int Convert::ToInt(const wchar_t* input)
{
	if (input==NULL) return 0;
	// We allow just numbers and -
	int j=0;
	wchar_t cValue[32];
	const int length = MINIMUM(32, wcslen(input));
	for(int i=0; i<length; i++)
	{
		if (input[i]=='\0' || input[i]=='.') break;
		if (input[i]<'0' && input[i] != '-') continue;
		if (input[i]>'9' && input[i] != 0x2212) continue;
		cValue[j]=input[i];
		if (cValue[j]==0x2212) cValue[j] = '-';
		j++;
	}
	cValue[j]='\0';
	if (cValue[0]=='\0') return 0;
	return _wtoi(cValue);
	//return _wtoi(input);
}

int Convert::ToInt(const wstring& input)
{
	return Sys::Convert::ToInt(input.c_str());
}

double Convert::ToDouble(const wchar_t* input)
{
	if (input==NULL) return 0.0;
	wchar_t cValue[32];
	const int length = MINIMUM(32, wcslen(input));
	int i, j=0;
	for(i=0; i<length; i++)
	{
		cValue[j]=input[i];
		if (input[i]=='\0') break;
		if ('0'<=input[i] && input[i]<='9') ++j;
		if (input[i]=='-') ++j;
		if (input[i]==0x2212) ++j;
		if (input[i]=='+') ++j;
		if (input[i]=='e') ++j;
		if (input[i]=='E') ++j;
		if (input[i]=='.') ++j;
	}
	cValue[j]='\0';
	if (cValue[0]=='\0') return 0.0;
	for(i=0; i<j; i++)
	{
		if (cValue[i]==0x2212) cValue[i]='-';
	}

	return _wtof(cValue);
}

double Convert::ToDouble(const wstring& input)
{
	return Sys::Convert::ToDouble(input.c_str());
}

bool Convert::ToBool(const wchar_t* input)
{
	if (input ==NULL) return false;
	if (wcslen(input) == 0) return false;
	if (input[0]=='1') return true;
	if (input[0]=='0') return false;
	if (lstrcmp(input, L"true")==0) return true;
	if (lstrcmp(input, L"TRUE")==0) return true;
	if (lstrcmp(input, L"on")==0) return true;
	if (lstrcmp(input, L"ON")==0) return true;
	if (lstrcmp(input, L"false")==0) return false;
	if (lstrcmp(input, L"FALSE")==0) return false;
	if (lstrcmp(input, L"off")==0) return false;
	if (lstrcmp(input, L"OFF")==0) return false;
	return false;
}

bool Convert::ToBool(const wstring& input)
{
	return ToBool(input.c_str());
}

complex<double> Convert::ToComplex(const wstring& input)
{
	complex<double> result(0.0, 0.0);
	const int len = input.length();
	
	if (len<=0) return result;
	wchar_t tmp[32];
	wchar_t letter;
	int k = 0;
	int i = 0;
	//___________________________ Find real part
	for(i=0; i<len; i++)
	{
		letter = input[i];
		if ((letter>='0' && letter<='9') || letter=='E' || letter=='e' || letter==',' || letter=='-' || letter=='+' || letter=='.' || letter=='j' || letter=='i')
		{
			if (letter=='+' || letter=='-')
			{
				tmp[k] = '\0';
				result._Val[_RE] =  _wtof(tmp);
				break;
			}	
			else
			{
				tmp[k++] = letter;
				if (k>=32) 
				{
					tmp[k] = '\0';
					result._Val[_RE] =  _wtof(tmp);
					break;
				}
			}
		}
	}
	//___________________________ Find imag part
	for(k=0; i<len && k<32; i++)
	{
		letter = input[i];
		if ((letter>='0' && letter<='9') || letter=='E' || letter=='e' || letter=='-' || letter=='+' || letter=='.')
		{
			tmp[k++] = letter;
		}
	}
	tmp[k] ='\0';
	result._Val[_IM] =  _wtof(tmp);
	return result;
}

complex<double> Convert::ToComplex(const string& input)
{
	complex<double> result(0.0, 0.0);
	const int len = input.length();
	
	if (len<=0) return result;
	char tmp[32];
	char letter;
	int k = 0;
	int i = 0;
	//___________________________ Find real part
	for(i=0; i<len; i++)
	{
		letter = input[i];
		if ((letter>='0' && letter<='9') || letter=='E' || letter=='e' || letter==',' || letter=='-' || letter=='+' || letter=='.' || letter=='j' || letter=='i')
		{
			if (letter=='+' || letter=='-')
			{
				tmp[k] = '\0';
				result._Val[_RE] =  atof(tmp);
				break;
			}	
			else
			{
				tmp[k++] = letter;
				if (k>=32) 
				{
					tmp[k] = '\0';
					result._Val[_RE] =  atof(tmp);
					break;
				}
			}
		}
	}
	//___________________________ Find imag part
	for(k=0; i<len && k<32; i++)
	{
		letter = input[i];
		if ((letter>='0' && letter<='9') || letter=='E' || letter=='e' || letter=='-' || letter=='+' || letter=='.')
		{
			tmp[k++] = letter;
		}
	}
	tmp[k] ='\0';
	result._Val[_IM] =  atof(tmp);
	return result;
}

MATRIX& Convert::ToMatrix(const valarray<double>& input, MATRIX& output)
{
	const int rows = input.size();
	output.resize(rows);
	for(int i = 0; i<rows; i++)
	{
		output[i].resize(1);
		output[i][0] = input[i];
	}
	return output;
}

MATRIXC& Convert::ToMatrix(const valarray<complex<double> >& input, MATRIXC& output)
{
	const int rows = input.size();
	output.resize(rows);
	for(int i = 0; i<rows; i++)
	{
		output[i].resize(1);
		output[i][0] = input[i];
	}
	return output;
}

MATRIX& Convert::ToMatrix(const wchar_t* input, MATRIX& output)
{
	if (input==NULL)
	{
		output.clear();
		return output;
	}
	const int len = wcslen(input);
	if (len <= 0)
	{
		output.clear();
		return output;
	}
	vector<wstring> lista;
	Sys::Convert::ToVectorOfStrings(input, lista);
	const int rows = lista.size();
	if (rows==0)
	{
		output.clear();
		return output;
	}
	output.resize(rows);

	for(int i=0; i<rows; i++)
	{
		ToVector(lista[i], output[i]);
	}
	return output;
}

MATRIX& Convert::ToMatrix(const wstring& input, MATRIX& output)
{
	return ToMatrix(input.c_str(), output);
}

MATRIX& Convert::ToMatrix(const char* input, MATRIX& output)
{
	if (input==NULL)
	{
		output.clear();
		return output;
	}
	const int len = strlen(input);
	if (len <= 0)
	{
		output.clear();
		return output;
	}
	vector<string> lista;
	Sys::Convert::ToVectorOfStrings(input, lista);
	const int rows = lista.size();
	if (rows==0)
	{
		output.clear();
		return output;
	}
	try
	{
		output.resize(rows);
		int cols = 0;
		for(int i=0; i<rows; i++)
		{
			ToVector(lista[i], output[i]);
			if (i == 0) //___________________ Save the number of columns in the first row
			{
				cols = output[i].size();
			}
			else //________________________ Enforce the same number of columns in the other rows
			{
				if (cols != output[i].size()) output[i].resize(cols);
			}
		}
	}
	catch(const std::bad_alloc& )
	{
		//output.clear();
	}
	return output;
}

MATRIX& Convert::ToMatrix(const string& input, MATRIX& output)
{
	return ToMatrix(input.c_str(), output);
}

MATRIXC& Convert::ToMatrix(const wchar_t* input, MATRIXC& output)
{
	if (input==NULL)
	{
		output.clear();
		return output;
	}
	const int len = wcslen(input);
	if (len <= 0)
	{
		output.clear();
		return output;
	}
	vector<wstring> lista;
	Sys::Convert::ToVectorOfStrings(input, lista);
	const int rows = lista.size();
	if (rows==0)
	{
		output.clear();
		return output;
	}
	try
	{
		output.resize(rows);
		int cols = 0;
		for(int i=0; i<rows; i++)
		{
			ToVector(lista[i], output[i]);
			if (i == 0) //___________________ Save the number of columns in the first row
			{
				cols = output[i].size();
			}
			else //________________________ Enforce the same number of columns in the other rows
			{
				if (cols != output[i].size()) output[i].resize(cols);
			}
		}
	}
	catch(const std::bad_alloc& )
	{
		//output.clear();
	}
	return output;
}

MATRIXC& Convert::ToMatrix(const wstring& input, MATRIXC& output)
{
	return ToMatrix(input.c_str(), output);
}

MATRIXC& Convert::ToMatrix(const char* input, MATRIXC& output)
{
	if (input==NULL)
	{
		output.clear();
		return output;
	}
	const int len = strlen(input);
	if (len <= 0)
	{
		output.clear();
		return output;
	}
	vector<string> lista;
	Sys::Convert::ToVectorOfStrings(input, lista);
	const int rows = lista.size();
	if (rows==0)
	{
		output.clear();
		return output;
	}
	//________________  Create the rows
	output.resize(rows);
	for(int i=0; i<rows; i++)
	{
		ToVector(lista[i], output[i]);
	}
	return output;
}

MATRIXC& Convert::ToMatrix(const string& input, MATRIXC& output)
{
	return ToMatrix(input.c_str(), output);
}

wchar_t* Convert::ToVector(const MATRIX& input, int col_index, valarray<double>& output)
{
	const int rows = input.size();
	const int cols = rows == 0 ? 0 : input[0].size();
	if (col_index<0) return L"The column index must be bigger than or equal to zero";
	if (col_index>=cols) return L"The column index is bigger than or equal to the number of columns in the matrix";
	output.resize(rows);
	for(int i = 0; i<rows; i++)
	{
		output[i] = input[i][col_index];
	}
	return NULL;
}

wchar_t* Convert::ToVector(const MATRIXC& input, int col_index, valarray<complex<double> >& output)
{
	const int rows = input.size();
	const int cols = rows == 0 ? 0 : input[0].size();
	if (col_index<0) return L"The column index must be bigger than or equal to zero";
	if (col_index>=cols) return L"The column index is bigger than or equal to the number of columns in the matrix";
	output.resize(rows);
	for(int i = 0; i<rows; i++)
	{
		output[i] = input[i][col_index];
	}
	return NULL;
}

//__________________________________________________________________ valarray
valarray<double>& Convert::ToVector(const wchar_t* input, valarray<double>& output)
{
	if (input==NULL)
	{
		output.resize(0);
		return output;
	}
	const int len = wcslen(input);
	if (len <= 0)
	{
		output.resize(0);
		return output;
	}

	//_________________ Try to get the number of cols
	int cols = 1;
	int i;
	for(i=0; i<len; i++)
	{
		if (input[i] == ',') cols++;
	}

	output.resize(cols);
	int k = 0;
	int col_count = 0;
	wchar_t tmp[32];
	wchar_t letter;
	for(i=0; i<len; i++)
	{
		letter = input[i];
		if ((letter>='0' && letter<='9') || letter=='E' || letter=='e' || letter==',' || letter=='-' || letter=='+' || letter=='.')
		{
			if (letter==',' || k>=31 || i==len-1)
			{
				if (i==len-1) 
				{
					tmp[k++] = letter;
				}
				tmp[k] = '\0';
				output[col_count] =  _wtof(tmp);
				col_count++;
				k = 0;
				continue;
			}
			else
			{
				tmp[k++] = letter;
			}
		}
	}
	return output;
}

valarray<double>& Convert::ToVector(const wstring& input, valarray<double>& output)
{
	return ToVector(input.c_str(), output);
}

valarray<double>& Convert::ToVector(const char* input, valarray<double>& output)
{
	if (input==NULL)
	{
		output.resize(0);
		return output;
	}
	const int len = strlen(input);
	if (len <= 0)
	{
		output.resize(0);
		return output;
	}

	//_________________ Try to get the number of cols
	int cols = 1;
	int i;
	for(i=0; i<len; i++)
	{
		if (input[i] == ',') cols++;
	}

	output.resize(cols);
	int k = 0;
	int col_count = 0;
	char tmp[32];
	char letter;
	for(i=0; i<len; i++)
	{
		letter = input[i];
		if ((letter>='0' && letter<='9') || letter=='E' || letter=='e' || letter==',' || letter=='-' || letter=='+' || letter=='.')
		{
			if (letter==',' || k>=31 || i==len-1)
			{
				if (i==len-1) 
				{
					tmp[k++] = letter;
				}
				tmp[k] = '\0';
				output[col_count] =  atof(tmp);
				col_count++;
				k = 0;
				continue;
			}
			else
			{
				tmp[k++] = letter;
			}
		}
	}
	return output;
}

valarray<double>& Convert::ToVector(const string& input, valarray<double>& output)
{
	return ToVector(input.c_str(), output);
}

//_____________________________________________________________________ Vector
vector<double>& Convert::ToVector(const wchar_t* input, vector<double>& output)
{
	if (input==NULL)
	{
		output.resize(0);
		return output;
	}
	const int len = wcslen(input);
	if (len <= 0)
	{
		output.resize(0);
		return output;
	}

	//_________________ Try to get the number of cols
	int cols = 1;
	int i;
	for(i=0; i<len; i++)
	{
		if (input[i] == ',') cols++;
	}

	output.resize(cols);
	int k = 0;
	int col_count = 0;
	wchar_t tmp[32];
	wchar_t letter;
	for(i=0; i<len; i++)
	{
		letter = input[i];
		if ((letter>='0' && letter<='9') || letter=='E' || letter=='e' || letter==',' || letter=='-' || letter=='+' || letter=='.')
		{
			if (letter==',' || k>=31 || i==len-1)
			{
				if (i==len-1) 
				{
					tmp[k++] = letter;
				}
				tmp[k] = '\0';
				output[col_count] =  _wtof(tmp);
				col_count++;
				k = 0;
				continue;
			}
			else
			{
				tmp[k++] = letter;
			}
		}
	}
	return output;
}

vector<double>& Convert::ToVector(const wstring& input, vector<double>& output)
{
	return ToVector(input.c_str(), output);
}

vector<double>& Convert::ToVector(const char* input, vector<double>& output)
{
	if (input==NULL)
	{
		output.resize(0);
		return output;
	}
	const int len = strlen(input);
	if (len <= 0)
	{
		output.resize(0);
		return output;
	}

	//_________________ Try to get the number of cols
	int cols = 1;
	int i;
	for(i=0; i<len; i++)
	{
		if (input[i] == ',') cols++;
	}

	output.resize(cols);
	int k = 0;
	int col_count = 0;
	char tmp[32];
	char letter;
	for(i=0; i<len; i++)
	{
		letter = input[i];
		if ((letter>='0' && letter<='9') || letter=='E' || letter=='e' || letter==',' || letter=='-' || letter=='+' || letter=='.')
		{
			if (letter==',' || k>=31 || i==len-1)
			{
				if (i==len-1) 
				{
					tmp[k++] = letter;
				}
				tmp[k] = '\0';
				output[col_count] =  atof(tmp);
				col_count++;
				k = 0;
				continue;
			}
			else
			{
				tmp[k++] = letter;
			}
		}
	}
	return output;
}

vector<double>& Convert::ToVector(const string& input, vector<double>& output)
{
	return ToVector(input.c_str(), output);
}

//________________________________________________________________________ valarray<complex<double> >
valarray<complex<double> >& Convert::ToVector(const wchar_t* input, valarray<complex<double> >& output)
{
	if (input==NULL)
	{
		output.resize(0);
		return output;
	}
	const int len = wcslen(input);
	if (len <= 0)
	{
		output.resize(0);
		return output;
	}

	//_________________ Try to get the number of cols
	int cols = 1;
	int i;
	for(i=0; i<len; i++)
	{
		if (input[i] == ',') cols++;
	}

	output.resize(cols);
	int k = 0;
	int col_count = 0;
	wchar_t tmp[32];
	wchar_t letter;
	for(i=0; i<len; i++)
	{
		letter = input[i];
		if ((letter>='0' && letter<='9') || letter=='E' || letter=='e' || letter==',' || letter=='-' || letter=='+' || letter=='.' || letter=='j'  || letter=='i')
		{
			if (letter==',' || k>=31 || i==len-1)
			{
				if (i==len-1) 
				{
					tmp[k++] = letter;
				}
				tmp[k] = '\0';
				output[col_count] =  Sys::Convert::ToComplex(tmp);
				col_count++;
				k = 0;
				continue;
			}
			else
			{
				tmp[k++] = letter;
			}
		}
	}
	return output;
}

valarray<complex<double> >& Convert::ToVector(const wstring& input, valarray<complex<double> >& output)
{
	return ToVector(input.c_str(), output);
}

valarray<complex<double> >& Convert::ToVector(const char* input, valarray<complex<double> >& output)
{
	if (input==NULL)
	{
		output.resize(0);
		return output;
	}
	const int len = strlen(input);
	if (len <= 0)
	{
		output.resize(0);
		return output;
	}

	//_________________ Try to get the number of cols
	int cols = 1;
	int i;
	for(i=0; i<len; i++)
	{
		if (input[i] == ',') cols++;
	}

	output.resize(cols);
	int k = 0;
	int col_count = 0;
	char tmp[32];
	char letter;
	for(i=0; i<len; i++)
	{
		letter = input[i];
		if ((letter>='0' && letter<='9') || letter=='E' || letter=='e' || letter==',' || letter=='-' || letter=='+' || letter=='.' || letter=='j' || letter=='i')
		{
			if (letter==',' || k>=31 || i==len-1)
			{
				if (i==len-1) 
				{
					tmp[k++] = letter;
				}
				tmp[k] = '\0';
				output[col_count] =  Sys::Convert::ToComplex(tmp);
				col_count++;
				k = 0;
				continue;
			}
			else
			{
				tmp[k++] = letter;
			}
		}
	}
	return output;
}

valarray<complex<double> >& Convert::ToVector(const string& input, valarray<complex<double> >& output)
{
	return ToVector(input.c_str(), output);
}

Sys::Time& Convert::ToTime(const wchar_t* input, Sys::Time& output)
{
	output.wHour = 0;
	output.wMilliseconds = 0;
	output.wDay = 0;
	output.wDayOfWeek = 0;
	output.wMinute = 0;
	output.wMonth = 0;
	output.wSecond = 0;
	output.wYear = 0;
	if (input==NULL) return output;
	const int len = wcslen(input);
	if (len<=0) return output;
	int i = 0;
	//________________________ separate the tokens
	vector<wstring> elements;
	vector<bool> elements_used;
	wstring element;
	bool used = false;
	for(i=0; i<len; i++)
	{
		if (isalnum(input[i]))
		{
			element+=input[i];
		}
		else
		{
			elements.push_back(element);
			elements_used.push_back(used);
			element.clear();
		}
	}
	elements.push_back(element);
	elements_used.push_back(used);
	element.clear();

	//_______________________ find the month
	const int count = elements.size();
	int tmp;
	for(i=0; i<count; i++)
	{
		tmp = ToMonth(elements[i]);
		if (tmp!=-1)
		{
			elements_used[i] = true;
			output.wMonth = tmp;
			break;
		}
	}

	//_______________________ find the year
	for(i=0; i<count; i++)
	{
		if (elements_used[i] == true) continue;
		tmp = ToYear(elements[i]);
		if (tmp!=-1)
		{
			elements_used[i] = true;
			output.wYear = tmp;
			break;
		}
	}

	//_______________________ find the day
	for(i=0; i<count; i++)
	{
		if (elements_used[i] == true) continue;
		tmp = ToMonthDay(elements[i]);
		if (tmp!=-1)
		{
			elements_used[i] = true;
			output.wDay = tmp;
			break;
		}
	}
	return output;
}


Sys::Time& Convert::ToTime(const wstring& input, Sys::Time& output)
{
	return ToTime(input.c_str(), output);
}

void Convert::SqlTimeToSysTime(const Sys::SqlTime& input, Sys::Time& output)
{
	output.wYear = input.year;
	output.wMonth = input.month;
	output.wDayOfWeek = 0;
	output.wDay = input.day;
	output.wHour = input.hour;
	output.wMinute = input.minute;
	output.wSecond = input.second;
	output.wMilliseconds = input.milliseconds;
	//__________________________________________ Try to fill wDayOfWeek
	FILETIME ft; 
	::SystemTimeToFileTime( &output, &ft ); 
	::FileTimeToSystemTime( &ft, &output); 
}

void Convert::SysTimeToSqlTime(const Sys::Time& input, Sys::SqlTime& output)
{
	output.year = input.wYear;
	output.month = input.wMonth;
	output.day = input.wDay;
	output.hour = input.wHour;
	output.minute = input.wMinute;
	output.second = input.wSecond;
	output.milliseconds = input.wMilliseconds;
}

// returns -1 if error
int Convert::ToYear(wstring& text)
{
	if (text.length() != 4) return -1;
	for(int i=0; i<4; i++)
	{
		if (text[i]<'0') return -1;
		if (text[i]>'9') return -1;
	}
	int tmp = _tstoi(text.c_str());
	if (tmp<1000) return -1;
	if (tmp>4000) return -1;
	return tmp;
}

// returns -1 if error
int Convert::ToMonth(wstring& text)
{
	const int len = text.length();
	if (len<=1) return -1;

	wstring tmp;
	int i;
	tmp.resize(len);
	for(i=0; i<len; i++)
	{
		tmp[i] = toupper(text[i]);
	}
	size_t found;

  found=tmp.find(L"ENE");
  if (found!=string::npos) return 1;
  //
  found=tmp.find(L"JAN");
  if (found!=string::npos) return 1;
  //
  found=tmp.find(L"FEB");
  if (found!=string::npos) return 2;
  //
  found=tmp.find(L"MAR");
  if (found!=string::npos) return 3;
  //
  found=tmp.find(L"ABR");
  if (found!=string::npos) return 4;
  //
  found=tmp.find(L"APR");
  if (found!=string::npos) return 4;
  //
  found=tmp.find(L"MAY");
  if (found!=string::npos) return 5;
  //
  found=tmp.find(L"JUN");
  if (found!=string::npos) return 6;
  //
  found=tmp.find(L"JUL");
  if (found!=string::npos) return 7;
  //
  found=tmp.find(L"AGO");
  if (found!=string::npos) return 8;
  //
  found=tmp.find(L"AUG");
  if (found!=string::npos) return 8;
  //
  found=tmp.find(L"SEP");
  if (found!=string::npos) return 9;
  //
  found=tmp.find(L"OCT");
  if (found!=string::npos) return 10;
  //
  found=tmp.find(L"NOV");
  if (found!=string::npos) return 11;
  //
  found=tmp.find(L"DIC");
  if (found!=string::npos) return 12;
  //
  found=tmp.find(L"DEC");
  if (found!=string::npos) return 12;

  return -1;

}

int Convert::ToMonthDay(wstring& text)
{
	const int len = text.length();
	if (len<=0) return -1;
	if (len>2) return -1;
	for(int i=0; i<len; i++)
	{
		if (text[i]<'0') return -1;
		if (text[i]>'9') return -1;
	}
	int tmp = _tstoi(text.c_str());
	if (tmp<0) return -1;
	if (tmp>31) return -1;
	return tmp;
}

#ifdef WIN_SOCKETS_SUPPORT
Sys::Time& Convert::InternetTimeToSystemTime(unsigned int inputInternetTime, Sys::Time& output)
{
	inputInternetTime = ntohl(inputInternetTime); //swapt bytes
	//TCHAR sz[512];
	FILETIME fileTime;
	LARGE_INTEGER li;
	SYSTEMTIME sysTime;
	//TCHAR szDate[64], szTime[64];

	//_sntprintf(sz, 512, _T("Received current time of %u seconds since Jan. 1 1900.\r\n"), ulTime);
	//this->MessageBox_(sz, _T("Displaying time"));

	// ******************* Transform for seconds since Jan. 1 1900 to SYSTEMTIME
	sysTime.wYear         = 1900 ;
	sysTime.wMonth        = 1 ;
	sysTime.wDay          = 1 ;
	sysTime.wHour         = 0 ;
	sysTime.wMinute       = 0 ;
	sysTime.wSecond       = 0 ;
	sysTime.wMilliseconds = 0 ;

	SystemTimeToFileTime (&sysTime, &fileTime);
	li = * (LARGE_INTEGER *) &fileTime;
	li.QuadPart += (LONGLONG) 10000000 * inputInternetTime; 
	fileTime = * (FILETIME *) &li;
	FileTimeToSystemTime (&fileTime, &sysTime);
	SystemTimeToTzSpecificLocalTime(NULL, &sysTime, &sysTime);  // Adjust time zone

  //   GetDateFormat (LOCALE_USER_DEFAULT, LOCALE_NOUSEROVERRIDE | DATE_SHORTDATE,
  //                  &sysTime, NULL, szDate, sizeof (szDate)) ;
  //   
  //   GetTimeFormat (LOCALE_USER_DEFAULT, LOCALE_NOUSEROVERRIDE | 
  //                       TIME_NOTIMEMARKER | TIME_FORCE24HOURFORMAT,
  //                  &sysTime, NULL, szTime, sizeof (szTime)) ;

	 //this->MessageBox_(szDate, szTime);
	return output;
}
#endif

//_________________________ ToString
wstring Convert::ToString(int input)
{
	wchar_t text[32];
	Sys::Convert::ToString(input, text, 32);
	return text;
}

const wchar_t* Convert::ToString(bool input)
{
	if (input == true) return L"true";
	return L"false";
}

void Convert::ToString(int input, wchar_t* output, int output_size)
{
	//if (input>=0)
		_snwprintf_s(output, output_size, _TRUNCATE, L"%d", input);
	//else
	//	_snwprintf_s(output, output_size, _TRUNCATE, L"%c%d", 0x2212, abs(input));
}

wstring Convert::ToString(double input)
{
	return Convert::ToString(input, L"%g");
}

wstring Convert::ToString(double input, const wchar_t* format)
{
	wchar_t text[32];
	Sys::Convert::ToString(input, format, text, 32);
	return text;
}

void Convert::ToString(double input, wchar_t* output, int output_size, bool compactFormat)
{
	//frexp
	//fmod(
	if (compactFormat == false)
	{
		_snwprintf_s(output, output_size, _TRUNCATE, L"%g", input);
		return;
	}
	//_______________________________ Compact Format
	const double absinput = fabs(input);

	
	double integer_part = 0.0;
	double fraction_part = modf(input, &integer_part);
	if (fraction_part == 0.0)
	{
		_snwprintf_s(output, output_size, _TRUNCATE, L"%.0f", integer_part);
	}
	else if (input == 0.0)
	{
		_snwprintf_s(output, output_size, _TRUNCATE, L"0");
	}
	else if (absinput < 0.1)
	{
		const int exponent = (int)(fabs(log10(absinput))+0.99999999999);
		const double based = pow(10.0, -exponent);
		const double mantissa = input/based;
		double integer_mantissa= 0.0;
		double fraction_mantissa = modf(mantissa, &integer_mantissa);
		if (integer_mantissa == 0.0)
		{
			_snwprintf_s(output, output_size, _TRUNCATE, L"%.0f-e%d", mantissa, exponent);
		}
		else
		{
			const int decimal = (int)(fraction_mantissa*10);
			if (10*decimal == 0)
			{
				_snwprintf_s(output, output_size, _TRUNCATE, L"%.0f-e%d", mantissa, exponent);
			}
			else
			{
				_snwprintf_s(output, output_size, _TRUNCATE, L"%.1f-e%d", mantissa, exponent);
			}
		}
	}
	else if (absinput < 1.0)
	{
		const int len = _snwprintf_s(output, output_size, _TRUNCATE, L"%.4f", input);
		if (output[len-1] != '0') return;
		output[len-1] = '\0';
		if (output[len-2] != '0') return;
		output[len-2] = '\0';
		if (output[len-3] != '0') return;
		output[len-3] = '\0';
	}
	else if (absinput < 10.0)
	{
		const int len = _snwprintf_s(output, output_size, _TRUNCATE, L"%.3f", input);
		if (output[len-1] != '0') return;
		output[len-1] = '\0';
		if (output[len-2] != '0') return;
		output[len-2] = '\0';
	}
	else if (absinput < 100.0)
	{
		const int len = _snwprintf_s(output, output_size, _TRUNCATE, L"%.2f", input);
		if (output[len-1] != '0') return;
		output[len-1] = '\0';
	}
	else if (absinput < 1000.0)
	{
		_snwprintf_s(output, output_size, _TRUNCATE, L"%.1f", input);
	}
	else
	{
		const int exponent = (int)(log10(absinput));
		const double based = pow(10.0, exponent);
		const double mantissa = input/based;
		double integer_mantissa= 0.0;
		double fraction_mantissa = modf(mantissa, &integer_mantissa);

		if (integer_mantissa == 0.0)
		{
			_snwprintf_s(output, output_size, _TRUNCATE, L"%.0fe%d", mantissa, exponent);
		}
		else
		{
			const int decimal = (int)(fraction_mantissa*10);
			if (10*decimal == 0)
			{
				_snwprintf_s(output, output_size, _TRUNCATE, L"%.0fe%d", mantissa, exponent);
			}
			else
			{
				_snwprintf_s(output, output_size, _TRUNCATE, L"%.1fe%d", mantissa, exponent);
			}
			//_snwprintf_s(output, output_size, _TRUNCATE, L"%.1fe%d", mantissa, exponent);
		}
	}
}

void Convert::ToString(double input, const wchar_t* format, wchar_t* output, int output_size)
{
	const int length = _snwprintf_s(output, output_size, _TRUNCATE, format, input);
	//for(int i=0; i<length; i++) 
	//{
	//	if (output[i]=='-') output[i]=0x2212;
	//}
}

wstring Convert::ToStringCommaSeparated(int input)
{
	wchar_t out[64];
	Sys::Convert::ToStringCommaSeparated(input, out, 64);
	return out;
}

void Convert::ToStringCommaSeparated(int input, wchar_t* output, int output_size)
{
	const int fvalue = abs(input);
	int low;
	int hi;
	int length = 0;
	if (fvalue<1000)
	{
		length = _snwprintf_s(output, output_size, _TRUNCATE, L"%d", input);
	}
	else if (fvalue<1000000)
	{
		hi = input/1000;
		low = fvalue%1000;
		if (low<10) length = _snwprintf_s(output, output_size, _TRUNCATE, L"%d,00%d", hi, low);
		else if (low<100) length =_snwprintf_s(output, output_size, _TRUNCATE, L"%d,0%d", hi, low);
		else if (low<1000) length =_snwprintf_s(output, output_size, _TRUNCATE, L"%d,%d", hi, low);
	}
	else if (fvalue<1000000000)
	{
		int lowA = input/1000000;
		hi = (fvalue%1000000)/1000;
		low = (fvalue%1000000)%1000;
		if (low<10)
		{
			if (hi<10) length =_snwprintf_s(output, output_size, _TRUNCATE, L"%d,00%d,00%d", lowA, hi, low);
			else if (hi<100) length =_snwprintf_s(output, output_size, _TRUNCATE, L"%d,0%d,00%d", lowA, hi, low);
			else if (hi<1000) length =_snwprintf_s(output, output_size, _TRUNCATE, L"%d,%d,00%d", lowA, hi, low);
		}
		else if (low<100) 
		{
			if (hi<10) length =_snwprintf_s(output, output_size, _TRUNCATE, L"%d,00%d,0%d", lowA, hi, low);
			else if (hi<100) length =_snwprintf_s(output, output_size, _TRUNCATE, L"%d,0%d,0%d", lowA, hi, low);
			else if (hi<1000) length =_snwprintf_s(output, output_size, _TRUNCATE, L"%d,%d,0%d", lowA, hi, low);
		}
		else if (low<1000)
		{
			if (hi<10) length =_snwprintf_s(output, output_size, _TRUNCATE, L"%d,00%d,%d", lowA, hi, low);
			else if (hi<100) length =_snwprintf_s(output, output_size, _TRUNCATE, L"%d,0%d,%d", lowA, hi, low);
			else if (hi<1000) length =_snwprintf_s(output, output_size, _TRUNCATE, L"%d,%d,%d", lowA, hi, low);
		}
	}
	else
	{
		length =_snwprintf_s(output, output_size, _TRUNCATE, L"%d", input);
	}
	//for(int i=0; i<length; i++) 
	//{
	//	if (output[i]=='-') out[i]=0x2212;
	//}
}

wstring Convert::ToStringUsingCurrencyFormat(double input)
{
	wchar_t text[32];
	Sys::Convert::ToStringUsingCurrencyFormat(input, text, 32);
	return text;
}

void Convert::ToStringUsingCurrencyFormat(double input, wchar_t* output, int output_size)
{
	const int fvalue = abs((int)input);
	const double diff = (fabs(input)-fvalue)+0.00000001;
	const int fracc= (int)(100.0*diff);

	wchar_t tmp[32];
	Sys::Convert::ToStringCommaSeparated((int)input, tmp, 32);
	_snwprintf_s(output, output_size, _TRUNCATE, L"%s.%02d", tmp, fracc);
}


//_____________________________________________________________ MATRIX
wstring& Convert::ToString(const MATRIX& input, wstring& output)
{
	const int rows = input.size();
	if (rows<=0)
	{
		output.clear();
		return output;
	}
	const int cols = input[0].size();
	int i, j;
	wchar_t text[64];
	for(i = 0; i<rows; i++)
	{
		for(j= 0; j<cols; j++)
		{
			if (j==cols-1)
			{
				if (i == rows-1)
				{
					_snwprintf_s(text, 64, _TRUNCATE, L"%g", input[i][j]);
				}
				else
				{
					_snwprintf_s(text, 64, _TRUNCATE, L"%g\r\n", input[i][j]);
				}
			}
			else
			{
				_snwprintf_s(text, 64, _TRUNCATE, L"%g, ", input[i][j]);
			}
			output += text;
		}
	}
	return output;
}

string& Convert::ToString(const MATRIX& input, string& output)
{
	const int rows = input.size();
	if (rows<=0)
	{
		output.clear();
		return output;
	}
	const int cols = input[0].size();
	int i, j;
	char text[64];
	for(i = 0; i<rows; i++)
	{
		for(j= 0; j<cols; j++)
		{
			if (j==cols-1)
			{
				if (i == rows-1)
				{
					_snprintf_s(text, 64, _TRUNCATE, "%g", input[i][j]);
				}
				else
				{
					_snprintf_s(text, 64, _TRUNCATE, "%g\r\n", input[i][j]);
				}
			}
			else
			{
				_snprintf_s(text, 64, _TRUNCATE, "%g, ", input[i][j]);
			}
			output += text;
		}
	}
	return output;
}

wstring& Convert::ToString(const MATRIXC& input, wstring& output)
{
	const int rows = input.size();
	if (rows<=0) 
	{
		output.clear();
		return output;
	}
	const int cols = input[0].size();
	int i, j;
	wchar_t text[64];
	for(i = 0; i<rows; i++)
	{
		for(j= 0; j<cols; j++)
		{
			if (j==cols-1)
			{
				if (i == rows-1)
				{
					if (input[i][j].imag()>0)
					{
						_snwprintf_s(text, 64, _TRUNCATE, L"%g + %gi", input[i][j].real(), input[i][j].imag());
					}
					else
					{
						_snwprintf_s(text, 64, _TRUNCATE, L"%g - %gi", input[i][j].real(), -input[i][j].imag());
					}
				}
				else
				{
					if (input[i][j].imag()>0)
					{
						_snwprintf_s(text, 64, _TRUNCATE, L"%g + %gi\r\n", input[i][j].real(), input[i][j].imag());
					}
					else
					{
						_snwprintf_s(text, 64, _TRUNCATE, L"%g - %gi\r\n", input[i][j].real(), -input[i][j].imag());
					}
				}
			}
			else
			{
				if (input[i][j].imag()>0)
				{
					_snwprintf_s(text, 64, _TRUNCATE, L"%g + %gi, ", input[i][j].real(), input[i][j].imag());
				}
				else
				{
					_snwprintf_s(text, 64, _TRUNCATE, L"%g - %gi, ", input[i][j].real(), -input[i][j].imag());
				}
			}
			output+= text;
		}
	}
	return output;
}

string& Convert::ToString(const MATRIXC& input, string& output)
{
	const int rows = input.size();
	if (rows<=0) 
	{
		output.clear();
		return output;
	}
	const int cols = input[0].size();
	int i, j;
	char text[64];
	for(i = 0; i<rows; i++)
	{
		for(j= 0; j<cols; j++)
		{
			if (j==cols-1)
			{
				if (i == rows-1)
				{
					if (input[i][j].imag()>0)
					{
						_snprintf_s(text, 64, _TRUNCATE, "%g + %gi", input[i][j].real(), input[i][j].imag());
					}
					else
					{
						_snprintf_s(text, 64, _TRUNCATE, "%g - %gi", input[i][j].real(), -input[i][j].imag());
					}
				}
				else
				{
					if (input[i][j].imag()>0)
					{
						_snprintf_s(text, 64, _TRUNCATE, "%g + %gi\r\n", input[i][j].real(), input[i][j].imag());
					}
					else
					{
						_snprintf_s(text, 64, _TRUNCATE, "%g - %gi\r\n", input[i][j].real(), -input[i][j].imag());
					}
				}
			}
			else
			{
				if (input[i][j].imag()>0)
				{
					_snprintf_s(text, 64, _TRUNCATE, "%g + %gi, ", input[i][j].real(), input[i][j].imag());
				}
				else
				{
					_snprintf_s(text, 64, _TRUNCATE, "%g - %gi, ", input[i][j].real(), -input[i][j].imag());
				}
			}
			output+= text;
		}
	}
	return output;
}

//_____________________________________________________________ valarray
wstring& Convert::ToString(const valarray<double>& input, wstring& output)
{
	const int size = input.size();
	output.clear();
	wchar_t text[64];
	for(int i= 0; i < size; i++)
	{
		if (i == size-1)
		{
			_snwprintf_s(text, 64, _TRUNCATE, L"%g", input[i]);
		}
		else
		{
			_snwprintf_s(text, 64, _TRUNCATE, L"%g, ", input[i]);
		}
		output += text;
	}
	return output;
}

string& Convert::ToString(const valarray<double>& input, string& output)
{
	const int size = input.size();
	output.clear();
	char text[64];
	for(int i= 0; i < size; i++)
	{
		if (i == size-1)
		{
			_snprintf_s(text, 64, _TRUNCATE, "%g", input[i]);
		}
		else
		{
			_snprintf_s(text, 64, _TRUNCATE, "%g, ", input[i]);
		}
		output += text;
	}
	return output;
}

wstring& Convert::ToString(const valarray<complex<double> >& input, wstring& output)
{
	const int size = input.size();
	output.clear();
	wchar_t text[64];
	for(int i= 0; i < size; i++)
	{
		if (i == size-1)
		{
			if (input[i].imag() > 0.0)
			{
				_snwprintf_s(text, 64, _TRUNCATE, L"%g + %gi", input[i].real(), input[i].imag());
			}
			else
			{
				_snwprintf_s(text, 64, _TRUNCATE, L"%g - %gi", input[i].real(), -input[i].imag());
			}
		}
		else
		{
			if (input[i].imag() > 0.0)
			{
				_snwprintf_s(text, 64, _TRUNCATE, L"%g + %gi, ", input[i].real(), input[i].imag());
			}
			else
			{
				_snwprintf_s(text, 64, _TRUNCATE, L"%g - %gi, ", input[i].real(), -input[i].imag());
			}
		}
	}
	return output;
}

string& Convert::ToString(const valarray<complex<double> >& input, string& output)
{
	const int size = input.size();
	output.clear();
	char text[64];
	for(int i= 0; i < size; i++)
	{
		if (i == size-1)
		{
			if (input[i].imag()>0)
			{
				_snprintf_s(text, 64, _TRUNCATE, "%g + %gi", input[i].real(), input[i].imag());
			}
			else
			{
				_snprintf_s(text, 64, _TRUNCATE, "%g - %gi", input[i].real(), -input[i].imag());
			}
		}
		else
		{
			if (input[i].imag()>0)
			{
				_snprintf_s(text, 64, _TRUNCATE, "%g + %gi, ", input[i].real(), input[i].imag());
			}
			else
			{
				_snprintf_s(text, 64, _TRUNCATE, "%g - %gi, ", input[i].real(), -input[i].imag());
			}
		}
	}
	return output;
}

//_____________________________________________________________ vector
wstring& Convert::ToString(const vector<double>& input, wstring& output)
{
	const int size = input.size();
	output.clear();
	wchar_t text[64];
	for(int i= 0; i < size; i++)
	{
		if (i == size-1)
		{
			_snwprintf_s(text, 64, _TRUNCATE, L"%g", input[i]);
		}
		else
		{
			_snwprintf_s(text, 64, _TRUNCATE, L"%g, ", input[i]);
		}
		output += text;
	}
	return output;
}

string& Convert::ToString(const vector<double>& input, string& output)
{
	const int size = input.size();
	output.clear();
	char text[64];
	for(int i= 0; i < size; i++)
	{
		if (i == size-1)
		{
			_snprintf_s(text, 64, _TRUNCATE, "%g", input[i]);
		}
		else
		{
			_snprintf_s(text, 64, _TRUNCATE, "%g, ", input[i]);
		}
		output += text;
	}
	return output;
}

wstring& Convert::ToString(const vector<complex<double> >& input, wstring& output)
{
	const int size = input.size();
	output.clear();
	wchar_t text[64];
	for(int i= 0; i < size; i++)
	{
		if (i == size-1)
		{
			if (input[i].imag() > 0.0)
			{
				_snwprintf_s(text, 64, _TRUNCATE, L"%g + %gi", input[i].real(), input[i].imag());
			}
			else
			{
				_snwprintf_s(text, 64, _TRUNCATE, L"%g - %gi", input[i].real(), -input[i].imag());
			}
		}
		else
		{
			if (input[i].imag() > 0.0)
			{
				_snwprintf_s(text, 64, _TRUNCATE, L"%g + %gi, ", input[i].real(), input[i].imag());
			}
			else
			{
				_snwprintf_s(text, 64, _TRUNCATE, L"%g - %gi, ", input[i].real(), -input[i].imag());
			}
		}
	}
	return output;
}

string& Convert::ToString(const vector<complex<double> >& input, string& output)
{
	const int size = input.size();
	output.clear();
	char text[64];
	for(int i= 0; i < size; i++)
	{
		if (i == size-1)
		{
			if (input[i].imag()>0)
			{
				_snprintf_s(text, 64, _TRUNCATE, "%g + %gi", input[i].real(), input[i].imag());
			}
			else
			{
				_snprintf_s(text, 64, _TRUNCATE, "%g - %gi", input[i].real(), -input[i].imag());
			}
		}
		else
		{
			if (input[i].imag()>0)
			{
				_snprintf_s(text, 64, _TRUNCATE, "%g + %gi, ", input[i].real(), input[i].imag());
			}
			else
			{
				_snprintf_s(text, 64, _TRUNCATE, "%g - %gi, ", input[i].real(), -input[i].imag());
			}
		}
	}
	return output;
}

// format day: d, dd, ddd  or dddd
// format month: M, MM, MMM or MMMM
// format year: y, yy, yyy or yyyy
// format:  L"ddd',' MMM dd yyyy"
wstring& Convert::DateToString(const Sys::Time& input, const wchar_t* format, wstring& output)
{
	int length = ::GetDateFormat(NULL, NULL, &input, format, NULL, 0);
	output.resize(length);

	::GetDateFormat(NULL, NULL, &input, format, (LPWSTR)output.data(), length);
	output.resize(length-1);

	 //GetDateFormat (LOCALE_USER_DEFAULT, LOCALE_NOUSEROVERRIDE | DATE_SHORTDATE,
  //                  &sysTime, NULL, szDate, sizeof (szDate)) ;
  //   
  //   GetTimeFormat (LOCALE_USER_DEFAULT, LOCALE_NOUSEROVERRIDE | 
  //                       TIME_NOTIMEMARKER | TIME_FORCE24HOURFORMAT,
  //                  &sysTime, NULL, szTime, sizeof (szTime)) ;
	return output;
}

// format day: d, dd, ddd  or dddd
// format month: M, MM, MMM or MMMM
// format year: y, yy, yyy or yyyy
// format:  L"ddd',' MMM dd yyyy"
wstring Convert::ToString(const Sys::Time& input, const wchar_t* format)
{
	wstring output;
	int length = ::GetDateFormat(NULL, NULL, &input, format, NULL, 0);
	output.resize(length);

	::GetDateFormat(NULL, NULL, &input, format, (LPWSTR)output.data(), length);
	output.resize(length-1);
	return output;
}

// format: L"hh':'mm':'ss tt"
wstring& Convert::TimeToString(const Sys::Time& input, const wchar_t* format, wstring& output)
{
	int length = ::GetTimeFormat(NULL, NULL, &input, format, NULL, 0);
	output.resize(length+1);

	::GetTimeFormat(NULL, NULL, &input, format, (LPWSTR)output.data(), length+1);
	output.resize(length);
	return output;
}

string& Convert::WstringToString(const wchar_t* input, string& output)
{
	if (input==NULL) 
	{
		output.clear();
		return output;
	}
	const int lenW = wcslen(input);
	if (lenW<=0)
	{
		output.clear();
		return output;
	}
	
	const int lenA = ::WideCharToMultiByte(CP_ACP, 0, input, lenW, 0, 0, NULL, NULL);
	if (lenA<=0)
	{
		output.clear();
		return output;
	}
	output.resize(lenA+1);
	::WideCharToMultiByte(CP_ACP, 0, input, lenW, (LPSTR)output.data(), lenA, NULL, NULL);
	output.resize(lenA);
	return output;
}

string& Convert::WstringToString(const wstring& input, string& output)
{
	return WstringToString(input.c_str(), output);
}

wstring& Convert::StringToWstring(const char* input, wstring& output)
{
	if (input==NULL) 
	{
		output.clear();
		return output;
	}
	const int lenA = strlen(input);
	if (lenA<=0)
	{
		output.clear();
		return output;
	}

	const int lenW = ::MultiByteToWideChar(CP_ACP, 0, input, lenA, 0, 0);
	if (lenW <= 0)
	{
		output.clear();
		return output;
	}
	output.resize(lenW+1);
	::MultiByteToWideChar(CP_ACP, 0, input, lenA, (LPWSTR)output.data(), lenW);
	output.resize(lenW);
	return output;
}

wstring& Convert::StringToWstring(const string& input, wstring& output)
{
	return StringToWstring(input.c_str(), output);
}


vector<wstring>& Convert::ToVectorOfStrings(const wchar_t* input, vector<wstring>& output)
{
	if (input==NULL)
	{
		output.clear();
		return output;
	}
	const int len = wcslen(input);
	if (len <= 0)
	{
		output.clear();
		return output;
	}
	wstring tmp;
	for(int i=0; i<len; i++)
	{
		if (input[i]=='\r') continue;
		if (input[i]=='\n')
		{
			output.push_back(tmp);
			tmp.clear();
		}
		else
		{
			tmp+=input[i];
			if (i==len-1 && tmp.length()>0)
			{
				output.push_back(tmp);
			}
		}
	}
	return output;
}

vector<wstring>& Convert::ToVectorOfStrings(const wstring& input, vector<wstring>& output)
{
	return ToVectorOfStrings(input.c_str(), output);
}

vector<string>& Convert::ToVectorOfStrings(const char* input, vector<string>& output)
{
	if (input==NULL)
	{
		output.clear();
		return output;
	}
	const int len = strlen(input);
	if (len <= 0)
	{
		output.clear();
		return output;
	}
	string tmp;
	for(int i=0; i<len; i++)
	{
		if (input[i]=='\r') continue;
		if (input[i]=='\n')
		{
			output.push_back(tmp);
			tmp.clear();
		}
		else if (i==len-1 && tmp.length()>0)
		{
			tmp+=input[i];
			output.push_back(tmp);
			break;
		}
		else
		{
			tmp+=input[i];
			if (i==len-1 && tmp.length()>0)
			{
				output.push_back(tmp);
				break;
			}
		}
	}
	return output;
}

vector<string>& Convert::ToVectorOfStrings(const string& input, vector<string>& output)
{
	return ToVectorOfStrings(input.c_str(), output);
}

vector<wstring>& Convert::PathToVectorOfStrings(const wchar_t* input, vector<wstring>& output)
{
	if (input==NULL)
	{
		output.clear();
		return output;
	}
	const int len = wcslen(input);
	if (len <= 0)
	{
		output.clear();
		return output;
	}
	wstring tmp;
	for(int i=0; i<len; i++)
	{
		if (input[i]=='\\')
		{
			output.push_back(tmp);
			tmp.clear();
		}
		else if (i==len-1 && tmp.length()>0)
		{
			tmp+=input[i];
			output.push_back(tmp);
			tmp.clear();
		}
		else
		{
			tmp+=input[i];
		}
	}
	return output;
}

vector<wstring>& Convert::PathToVectorOfStrings(const wstring& input, vector<wstring>& output)
{
	return PathToVectorOfStrings(input.c_str(), output);
}

bool Convert::UTF8ToWstring(const string& input, wstring& output)
{
	size_t lengthUTF8 = input.length();
    if (lengthUTF8<=0)
    {
        output = L"";
		return true;
	}
    ++lengthUTF8;
    int cbUTF8 = static_cast<int>( lengthUTF8 );
    int cchUTF16 = ::MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, 
        input.c_str(), cbUTF8, NULL, 0);
    if ( cchUTF16 == 0 ) return false;

	output.resize(cchUTF16);
    int result = ::MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS,   // error on invalid chars
                input.c_str(),   cbUTF8, (wchar_t*)output.c_str(), cchUTF16);
	output.resize(cchUTF16-1);
    if (result == 0) return false;
	return true;
}

bool Convert::WstringToUTF8(const wstring& input, string& output)
{
	size_t lengthUTF16 = input.length();
	if (lengthUTF16<=0) 
	{
		output.clear();
		return true;
	}
	lengthUTF16++;

    // WC_ERR_INVALID_CHARS flag is set to fail if invalid input character is encountered.
    // This flag is supported on Windows Vista and later.
    // Don't use it on Windows XP and previous.
    //
	DWORD dwConversionFlags = 0;
	OSVERSIONINFO osvi;
	ZeroMemory(&osvi, sizeof(OSVERSIONINFO));
	osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	::GetVersionEx(&osvi);
	if (osvi.dwMajorVersion > 5)
	{
#ifdef WC_ERR_INVALID_CHARS
		dwConversionFlags = WC_ERR_INVALID_CHARS;
#endif
	}
    // Get size of destination UTF-8 buffer, in CHAR's (= bytes)
    //
    int cbUTF8 = ::WideCharToMultiByte(CP_UTF8,  dwConversionFlags,
		input.c_str(), static_cast<int>( lengthUTF16 ), NULL,  0, NULL, NULL);
	if (cbUTF8==0) return false;

	output.resize(cbUTF8);
    int cchUTF8 = cbUTF8; // sizeof(CHAR) = 1 byte
    //CHAR * pszUTF8 = strUTF8.GetBuffer( cchUTF8 );
    ////
    //// Do the conversion from UTF-16 to UTF-8
    ////

    int result = ::WideCharToMultiByte(CP_UTF8, dwConversionFlags,      // specify conversion behavior
		input.c_str(), static_cast<int>( lengthUTF16 ), (char*)output.c_str(), cbUTF8, NULL, NULL);  
	output.resize(cbUTF8-1);

    if  (result == 0) return false;
    return true;
}

void Convert::CppToHtml(const wchar_t* input_cppLine, wstring& output_html, bool indent, bool includeNeuralLabVariables)
{
	// It converts one line of code written in cpp to html
	if (input_cppLine==NULL)
	{
		output_html.clear();
		return;
	}
	const int length = wcslen(input_cppLine);
	if (length<=0)
	{
		//output_html = L"<br />";
		output_html.clear();
		return;
	}

	//____________________________ Check for empty code line
	bool IsEmpty = true;
	for(int i = 0; i < length; i++)
	{
		if (input_cppLine[i] != ' ' && input_cppLine[i] != '\t' && input_cppLine[i] != '\r' && input_cppLine[i] != '\n')
		{
			IsEmpty = false;
			break;
		}
	}
	if (IsEmpty == true)
	{
		//output_html = L"<br />";
		output_html.clear();
		return;
	}

	//_______________________________ Normal code line
	wstring cppCode;

	const wchar_t* pComment = wcsstr(input_cppLine, L"//");
	bool isCommentOnly = false;

	if (pComment != NULL)
	{
		for(int i=0; i<length; i++)
		{
			if (input_cppLine[i] == ' ' || input_cppLine[i]=='\t') continue;
			if (input_cppLine[i] != '/')
			{
				isCommentOnly = false;
				break;
			}
			if (input_cppLine[i] == '/')
			{
				isCommentOnly = true;
				break;
			}
		}
	}

	if (pComment==NULL) //______________________________________________ only code
	{
		Sys::TextAssistant::ReplaceBiggerLessThan(input_cppLine, cppCode);
		if (indent) Sys::TextAssistant::ReplaceWord(cppCode, L"\t", L"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;", false);
		CppToHtml(cppCode, indent, includeNeuralLabVariables);
		output_html = cppCode;
	}
	else if (isCommentOnly) //________________________________________ only comment
	{
		Sys::TextAssistant::ReplaceBiggerLessThan(input_cppLine, cppCode);
		if (indent) Sys::TextAssistant::ReplaceWord(cppCode, L"\t", L"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;", false);
		output_html = L"<span style=\"color:#009000\">";
		output_html += cppCode;
		output_html += L"</span>";
	}
	else //________________________________________ comment and code
	{
		wstring comment;
		const int commentLength = wcslen(pComment);
		comment.assign(pComment, commentLength);
		//_______________________  code
		wstring tmp;
		tmp.assign(input_cppLine, length-commentLength);
		if (indent) Sys::TextAssistant::ReplaceWord(tmp, L"\t", L"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;", false);
		Sys::TextAssistant::ReplaceBiggerLessThan(tmp.c_str(), cppCode);
		CppToHtml(cppCode, indent, includeNeuralLabVariables);
		output_html = cppCode;
		//_______________________ comment
		output_html += L"<span style=\"color:#009000\">";
		output_html += comment;
		output_html += L"</span>";	
	}
}

void Convert::CppToHtml(wstring& in_out, bool indent, bool includeNeuralLabVariables)
{
	//_________________________________________________ Strings
	wstring input(in_out);
	wstring output;
	Sys::Convert::QuotedCppToHtml(input.c_str(), L"color:#CF0000", output);
	in_out = output;
	//
	Sys::TextAssistant::ReplaceWord(in_out, L"class", L"<span style=\"color:#0000ff\">class</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"unsigned", L"<span style=\"color:#0000ff\">unsigned</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"#include", L"<span style=\"color:#0000ff\">#include</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"#define", L"<span style=\"color:#0000ff\">#define</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"#pragma once", L"<span style=\"color:#0000ff\">#pragma once</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"#pragma code_page", L"<span style=\"color:#0000ff\">#pragma code_page</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"int", L"<span style=\"color:#0000ff\">int</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"double", L"<span style=\"color:#0000ff\">double</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"public", L"<span style=\"color:#0000ff\">public</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"protected", L"<span style=\"color:#0000ff\">protected</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"private", L"<span style=\"color:#0000ff\">private</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"return", L"<span style=\"color:#0000ff\">return</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"const", L"<span style=\"color:#0000ff\">const</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"for", L"<span style=\"color:#0000ff\">for</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"while", L"<span style=\"color:#0000ff\">while</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"#ifdef", L"<span style=\"color:#0000ff\">#ifdef</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"#ifndef", L"<span style=\"color:#0000ff\">#ifndef</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"#undef", L"<span style=\"color:#0000ff\">#undef</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"#if", L"<span style=\"color:#0000ff\">#if</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"#endif", L"<span style=\"color:#0000ff\">#endif</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"#else", L"<span style=\"color:#0000ff\">#else</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"switch", L"<span style=\"color:#0000ff\">switch</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"if", L"<span style=\"color:#0000ff\">if</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"case ", L"<span style=\"color:#0000ff\">case</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"default", L"<span style=\"color:#0000ff\">default</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"break", L"<span style=\"color:#0000ff\">break</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"continue", L"<span style=\"color:#0000ff\">continue</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"false", L"<span style=\"color:#0000ff\">false</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"true", L"<span style=\"color:#0000ff\">true</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"else", L"<span style=\"color:#0000ff\">else</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"else if", L"<span style=\"color:#0000ff\">else if</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"this", L"<span style=\"color:#0000ff\">this</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"new", L"<span style=\"color:#0000ff\">new</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"void", L"<span style=\"color:#0000ff\">void</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"inline", L"<span style=\"color:#0000ff\">inline </span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"bool", L"<span style=\"color:#0000ff\">bool </span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"virtual", L"<span style=\"color:#0000ff\">virtual</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"static", L"<span style=\"color:#0000ff\">static</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"struct", L"<span style=\"color:#0000ff\">struct</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"operator", L"<span style=\"color:#0000ff\">operator</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"namespace", L"<span style=\"color:#0000ff\">namespace</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"using", L"<span style=\"color:#0000ff\">using</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"wchar_t", L"<span style=\"color:#0000ff\">wchar_t</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"case", L"<span style=\"color:#0000ff\">case</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"try", L"<span style=\"color:#0000ff\">try</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"catch", L"<span style=\"color:#0000ff\">catch</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"do", L"<span style=\"color:#0000ff\">do</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"finally", L"<span style=\"color:#0000ff\">finally</span>", true);
	if (includeNeuralLabVariables == true)
	{
		Sys::TextAssistant::ReplaceWord(in_out, L"Matrix", L"<span style=\"color:#0000ff\">Matrix</span>", true);
		Sys::TextAssistant::ReplaceWord(in_out, L"Vector", L"<span style=\"color:#0000ff\">Vector</span>", true);
		Sys::TextAssistant::ReplaceWord(in_out, L"Complex", L"<span style=\"color:#0000ff\">Complex</span>", true);
		Sys::TextAssistant::ReplaceWord(in_out, L"ComplexVector", L"<span style=\"color:#0000ff\">ComplexVector</span>", true);
		Sys::TextAssistant::ReplaceWord(in_out, L"ComplexMatrix", L"<span style=\"color:#0000ff\">ComplexMatrix</span>", true);
		Sys::TextAssistant::ReplaceWord(in_out, L"LayerNet", L"<span style=\"color:#0000ff\">LayerNet</span>", true);
		Sys::TextAssistant::ReplaceWord(in_out, L"KohoNet", L"<span style=\"color:#0000ff\">KohoNet</span>", true);
		Sys::TextAssistant::ReplaceWord(in_out, L"ProbNet", L"<span style=\"color:#0000ff\">ProbNet</span>", true);
		Sys::TextAssistant::ReplaceWord(in_out, L"sin", L"<span style=\"color:#ff00ff\">sin</span>", true);
		Sys::TextAssistant::ReplaceWord(in_out, L"cos", L"<span style=\"color:#ff00ff\">cos</span>", true);
		Sys::TextAssistant::ReplaceWord(in_out, L"tan", L"<span style=\"color:#ff00ff\">tan</span>", true);
		Sys::TextAssistant::ReplaceWord(in_out, L"asin", L"<span style=\"color:#ff00ff\">asin</span>", true);
		Sys::TextAssistant::ReplaceWord(in_out, L"acos", L"<span style=\"color:#ff00ff\">acos</span>", true);
		Sys::TextAssistant::ReplaceWord(in_out, L"atan", L"<span style=\"color:#ff00ff\">atan</span>", true);
		Sys::TextAssistant::ReplaceWord(in_out, L"sinh", L"<span style=\"color:#ff00ff\">sinh</span>", true);
		Sys::TextAssistant::ReplaceWord(in_out, L"cosh", L"<span style=\"color:#ff00ff\">cosh</span>", true);
		Sys::TextAssistant::ReplaceWord(in_out, L"tanh", L"<span style=\"color:#ff00ff\">tanh</span>", true);
		Sys::TextAssistant::ReplaceWord(in_out, L"sqrt", L"<span style=\"color:#ff00ff\">sqrt</span>", true);
		Sys::TextAssistant::ReplaceWord(in_out, L"log10", L"<span style=\"color:#ff00ff\">log10</span>", true);
		Sys::TextAssistant::ReplaceWord(in_out, L"log", L"<span style=\"color:#ff00ff\">log</span>", true);
		Sys::TextAssistant::ReplaceWord(in_out, L"exp", L"<span style=\"color:#ff00ff\">exp</span>", true);
		Sys::TextAssistant::ReplaceWord(in_out, L"abs", L"<span style=\"color:#ff00ff\">abs</span>", true);
		Sys::TextAssistant::ReplaceWord(in_out, L"sinc", L"<span style=\"color:#ff00ff\">sinc</span>", true);
		Sys::TextAssistant::ReplaceWord(in_out, L"triang", L"<span style=\"color:#ff00ff\">triang</span>", true);
		Sys::TextAssistant::ReplaceWord(in_out, L"saw", L"<span style=\"color:#ff00ff\">saw</span>", true);
		Sys::TextAssistant::ReplaceWord(in_out, L"rect", L"<span style=\"color:#ff00ff\">rect</span>", true);
		Sys::TextAssistant::ReplaceWord(in_out, L"ceil", L"<span style=\"color:#ff00ff\">ceil</span>", true);
		Sys::TextAssistant::ReplaceWord(in_out, L"floor", L"<span style=\"color:#ff00ff\">floor</span>", true);
		Sys::TextAssistant::ReplaceWord(in_out, L"toint", L"<span style=\"color:#ff00ff\">toint</span>", true);
		Sys::TextAssistant::ReplaceWord(in_out, L"rand", L"<span style=\"color:#ff00ff\">rand</span>", true);
		Sys::TextAssistant::ReplaceWord(in_out, L"randi", L"<span style=\"color:#ff00ff\">randi</span>", true);
		Sys::TextAssistant::ReplaceWord(in_out, L"isprime", L"<span style=\"color:#ff00ff\">isprime</span>", true);
		Sys::TextAssistant::ReplaceWord(in_out, L"fft", L"<span style=\"color:#ff00ff\">fft</span>", true);
		Sys::TextAssistant::ReplaceWord(in_out, L"ifft", L"<span style=\"color:#ff00ff\">ifft</span>", true);
		Sys::TextAssistant::ReplaceWord(in_out, L"realfft", L"<span style=\"color:#ff00ff\">realfft</span>", true);
		Sys::TextAssistant::ReplaceWord(in_out, L"irealfft", L"<span style=\"color:#ff00ff\">irealfft</span>", true);
		Sys::TextAssistant::ReplaceWord(in_out, L"spectrum", L"<span style=\"color:#ff00ff\">spectrum</span>", true);
		Sys::TextAssistant::ReplaceWord(in_out, L"FirFilter", L"<span style=\"color:#ff00ff\">FirFilter</span>", true);
		Sys::TextAssistant::ReplaceWord(in_out, L"ComputeMse", L"<span style=\"color:#ff00ff\">ComputeMse</span>", true);
		Sys::TextAssistant::ReplaceWord(in_out, L"ConfusionMatrix", L"<span style=\"color:#ff00ff\">ConfusionMatrix</span>", true);
	}

	if (indent) Sys::TextAssistant::ReplaceWord(in_out, L"\t", L"&nbsp;&nbsp;&nbsp;", false);
}

void Convert::SqlToHtml(const wchar_t* input_sqlLine, wstring& output_html, bool indent)
{
	// It converts one line of code written in sql to html
	if (input_sqlLine==NULL)
	{
		output_html.clear();
		return;
	}
	const int length = wcslen(input_sqlLine);
	if (length<=0)
	{
		//output_html = L"<br />";
		output_html.clear();
		return;
	}

	//____________________________ Check for empty code line
	bool IsEmpty = true;
	for(int i = 0; i < length; i++)
	{
		if (input_sqlLine[i] != ' ' && input_sqlLine[i] != '\t' && input_sqlLine[i] != '\r' && input_sqlLine[i] != '\n')
		{
			IsEmpty = false;
			break;
		}
	}
	if (IsEmpty == true)
	{
		//output_html = L"<br />";
		output_html.clear();
		return;
	}

	//_______________________________ Normal code line

	wstring sqlCode;

	const wchar_t* pComment = wcsstr(input_sqlLine, L"--");
	bool isCommentOnly = false;
	for(int i=0; i<length-1; i++)
	{
		if (input_sqlLine[i]==' ' || input_sqlLine[i]=='\t') continue;
		if (input_sqlLine[i]!=' ' && input_sqlLine[i]!='\t')
		{
			if (input_sqlLine[i]!='-') break;
		}
		if (input_sqlLine[i]=='-' && input_sqlLine[i]=='-') 
		{
			isCommentOnly =true;
			break;
		}
	}

	if (pComment==NULL) //______________________________________________ only code
	{
		Sys::TextAssistant::ReplaceBiggerLessThan(input_sqlLine, sqlCode);
		SqlToHtml(sqlCode, indent);
		output_html = sqlCode;
	}
	else if (isCommentOnly) //________________________________________ only comment
	{
		Sys::TextAssistant::ReplaceBiggerLessThan(input_sqlLine, sqlCode);
		if (indent) Sys::TextAssistant::ReplaceWord(sqlCode, L"\t", L"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;", false);
		output_html = L"<span style=\"color:#009000\">";
		output_html += sqlCode;
		output_html += L"</span>";
	}
	else //________________________________________ comment and code
	{
		wstring comment;
		const int commentLength = wcslen(pComment);
		comment.assign(pComment, commentLength);
		//_______________________  code
		wstring tmp;
		tmp.assign(input_sqlLine, length-commentLength);
		Sys::TextAssistant::ReplaceBiggerLessThan(tmp.c_str(), sqlCode);
		if (indent) Sys::TextAssistant::ReplaceWord(sqlCode, L"\t", L"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;", false);
		SqlToHtml(sqlCode, indent);
		output_html = sqlCode;
		//_______________________ comment
		output_html += L"<span style=\"color:#009000\">";
		output_html += comment;
		output_html += L"</span>";	
	}
}

void Convert::SqlToHtml(wstring& in_out, bool indent)
{
	//_________________________________________________ Strings
	wstring input(in_out);
	wstring output;
	Sys::Convert::QuotedSqlToHtml(input.c_str(), L"color:#FF0000", output);
	in_out = output;
	//
	Sys::TextAssistant::ReplaceWord(in_out, L"SELECT", L"<span style=\"color:#0000ff\">SELECT</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"FROM", L"<span style=\"color:#0000ff\">FROM</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"WHERE", L"<span style=\"color:#0000ff\">WHERE</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"HAVING", L"<span style=\"color:#0000ff\">HAVING</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"AND", L"<span style=\"color:#0000ff\">AND</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"OR", L"<span style=\"color:#0000ff\">OR</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"CREATE", L"<span style=\"color:#0000ff\">CREATE</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"DELETE", L"<span style=\"color:#0000ff\">DELETE</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"VIEW", L"<span style=\"color:#0000ff\">VIEW</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"INSERT", L"<span style=\"color:#0000ff\">INSERT</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"ALTER", L"<span style=\"color:#0000ff\">ALTER</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"UPDATE", L"<span style=\"color:#0000ff\">UPDATE</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"PROCEDURE", L"<span style=\"color:#0000ff\">PROCEDURE</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"DROP", L"<span style=\"color:#0000ff\">DROP</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"INT", L"<span style=\"color:#0000ff\">INT</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"INTEGER", L"<span style=\"color:#0000ff\">INTEGER</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"DECIMAL", L"<span style=\"color:#0000ff\">DECIMAL</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"NUMBER", L"<span style=\"color:#0000ff\">NUMBER</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"NUMERIC", L"<span style=\"color:#0000ff\">NUMERIC</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"UNION", L"<span style=\"color:#0000ff\">UNION</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"VARCHAR", L"<span style=\"color:#0000ff\">VARCHAR</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"NVARCHAR", L"<span style=\"color:#0000ff\">NVARCHAR</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"VARCHAR2", L"<span style=\"color:#0000ff\">VARCHAR2</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"DATE", L"<span style=\"color:#0000ff\">DATE</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"DATETIME", L"<span style=\"color:#0000ff\">DATETIME</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"SMALLDATETIME", L"<span style=\"color:#0000ff\">SMALLDATETIME</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"CHAR", L"<span style=\"color:#0000ff\">CHAR</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"NCHAR", L"<span style=\"color:#0000ff\">NCHAR</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"REPLACE", L"<span style=\"color:#0000ff\">REPLACE</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"TRIGGER", L"<span style=\"color:#0000ff\">TRIGGER</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"TABLE", L"<span style=\"color:#0000ff\">TABLE</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"INTO", L"<span style=\"color:#0000ff\">INTO</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"VALUES", L"<span style=\"color:#0000ff\">VALUES</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"PRIMARY KEY", L"<span style=\"color:#0000ff\">PRIMARY KEY</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"REFERENCES", L"<span style=\"color:#0000ff\">REFERENCES</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"USE", L"<span style=\"color:#0000ff\">USE</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"EXECUTE", L"<span style=\"color:#0000ff\">EXECUTE</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"BEGIN", L"<span style=\"color:#0000ff\">BEGIN</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"END", L"<span style=\"color:#0000ff\">END</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"DISTINCT", L"<span style=\"color:#0000ff\">DISTINCT</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"LIKE", L"<span style=\"color:#0000ff\">LIKE</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"CHECK", L"<span style=\"color:#0000ff\">CHECK</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"READ ONLY", L"<span style=\"color:#0000ff\">READ ONLY</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"OPTION", L"<span style=\"color:#0000ff\">OPTION</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"GRANT", L"<span style=\"color:#0000ff\">GRANT</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"REVOKE", L"<span style=\"color:#0000ff\">REVOKE</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"ROLLBACK", L"<span style=\"color:#0000ff\">ROLLBACK</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"SAVEPOINT", L"<span style=\"color:#0000ff\">SAVEPOINT</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"TRANSACTION", L"<span style=\"color:#0000ff\">TRANSACTION</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"COMMIT", L"<span style=\"color:#0000ff\">COMMIT</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"SET", L"<span style=\"color:#0000ff\">SET</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"GROUP BY", L"<span style=\"color:#0000ff\">GROUP BY</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"AS", L"<span style=\"color:#0000ff\">AS</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"IF", L"<span style=\"color:#0000ff\">IF</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"DATABASE", L"<span style=\"color:#0000ff\">DATABASE</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"WITH", L"<span style=\"color:#0000ff\">WITH</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"RAISERROR", L"<span style=\"color:#0000ff\">RAISERROR</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"GO", L"<span style=\"color:#0000ff\">GO</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"DECLARE", L"<span style=\"color:#0000ff\">DECLARE</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"CURSOR", L"<span style=\"color:#0000ff\">CURSOR</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"READ_ONLY", L"<span style=\"color:#0000ff\">READ_ONLY</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"FOR", L"<span style=\"color:#0000ff\">FOR</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"OPEN", L"<span style=\"color:#0000ff\">OPEN</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"CLOSE", L"<span style=\"color:#0000ff\">CLOSE</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"WHILE", L"<span style=\"color:#0000ff\">WHILE</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"NEXT", L"<span style=\"color:#0000ff\">NEXT</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"FETCH", L"<span style=\"color:#0000ff\">FETCH</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"DEALLOCATE", L"<span style=\"color:#0000ff\">DEALLOCATE</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"RETURN", L"<span style=\"color:#0000ff\">RETURN</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"ORDER", L"<span style=\"color:#0000ff\">RETURN</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"CONSTRAINT", L"<span style=\"color:#0000ff\">CONSTRAINT</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"IDENTITY", L"<span style=\"color:#0000ff\">IDENTITY</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"AUTO_INCREMENT", L"<span style=\"color:#0000ff\">AUTO_INCREMENT</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"INNER", L"<span style=\"color:#0000ff\">INNER</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"JOIN", L"<span style=\"color:#0000ff\">JOIN</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"ON", L"<span style=\"color:#0000ff\">ON</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"UNIQUE", L"<span style=\"color:#0000ff\">UNIQUE</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"FOREIGN", L"<span style=\"color:#0000ff\">FOREIGN</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"INTERSECT", L"<span style=\"color:#0000ff\">INTERSECT</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"ALTER", L"<span style=\"color:#0000ff\">ALTER</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"ADD", L"<span style=\"color:#0000ff\">ADD</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"MODIFY", L"<span style=\"color:#0000ff\">MODIFY</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"DEFAULT", L"<span style=\"color:#0000ff\">DEFAULT</span>", true);
	//
	Sys::TextAssistant::ReplaceWord(in_out, L"@@IDENTITY", L"<span style=\"color:#C000C0\">@@IDENTITY</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"@@FETCH_STATUS", L"<span style=\"color:#C000C0\">@@FETCH_STATUS</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"ABS", L"<span style=\"color:#C000C0\">ABS</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"MOD", L"<span style=\"color:#C000C0\">MOD</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"TRUNCATE", L"<span style=\"color:#C000C0\">TRUNCATE</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"POWER", L"<span style=\"color:#C000C0\">POWER</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"ROUND", L"<span style=\"color:#C000C0\">ROUND</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"AVG", L"<span style=\"color:#C000C0\">AVG</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"MIN", L"<span style=\"color:#C000C0\">MIN</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"MAX", L"<span style=\"color:#C000C0\">MAX</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"AVG", L"<span style=\"color:#C000C0\">AVG</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"SUM", L"<span style=\"color:#C000C0\">SUM</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"NVL", L"<span style=\"color:#C000C0\">NVL</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"TO_NUMBER", L"<span style=\"color:#C000C0\">TO_NUMBER</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"TO_CHAR", L"<span style=\"color:#C000C0\">TO_CHAR</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"TO_DATE", L"<span style=\"color:#C000C0\">TO_DATE</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"DATEFORMAT", L"<span style=\"color:#C000C0\">DATEFORMAT</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"DATEPART", L"<span style=\"color:#C000C0\">DATEPART</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"DATEDIFF", L"<span style=\"color:#C000C0\">DATEPART</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"ISDATE", L"<span style=\"color:#C000C0\">ISDATE</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"GETDATE", L"<span style=\"color:#C000C0\">GETDATE</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"CONVERT", L"<span style=\"color:#C000C0\">CONVERT</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"CAST", L"<span style=\"color:#C000C0\">CAST</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"db_name", L"<span style=\"color:#C000C0\">db_name</span>", true);
	//
	Sys::TextAssistant::ReplaceWord(in_out, L"EXISTS", L"<span style=\"color:#707070\">EXISTS</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"NOT", L"<span style=\"color:#707070\">NOT</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"NULL", L"<span style=\"color:#707070\">NULL</span>", true);
	Sys::TextAssistant::ReplaceWord(in_out, L"(", L"<span style=\"color:#707070\">(</span>", false);
	Sys::TextAssistant::ReplaceWord(in_out, L")", L"<span style=\"color:#707070\">)</span>", false);
	//Sys::TextAssistant::ReplaceWord(in_out, L"*", L"<span style=\"color:#707070\">*</span>", false);
	//
	if (indent) Sys::TextAssistant::ReplaceWord(in_out, L"\t", L"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;", false);
}

void Convert::QuotedSqlToHtml(const wchar_t* input, const wchar_t* cssStyle, wstring& output_html)
{
	const int len = wcslen(input);
	if (len == 0)
	{
		output_html.clear();
		return;
	}
	try
	{
		output_html.reserve(len);
	}
	catch(const std::bad_alloc& )
	{
		return;
	}
	bool isInsideQuotes = false;
	for(int i = 0; i<len; i++)
	{
		if (isInsideQuotes == true)//_______________ Quoted text
		{
			if (input[i] == '\'')
			{
				if (i > 0) 
				{
					if (input[i-1] == '\\')
					{
						output_html += input[i]; // scape sequence
						continue;
					}
				}
				output_html += L"'</span>";
				isInsideQuotes = false;
			}
			else
			{
				output_html += input[i]; 
			}
		}
		else//_______________________________ Regular code
		{
			if (input[i] == '\'')
			{
				output_html += L"<span style=\"";
				output_html += cssStyle;
				output_html += L"\">'";
				isInsideQuotes = true;
			}
			else
			{
				output_html += input[i]; 
			}
		}
	}
}

void Convert::QuotedCppToHtml(const wchar_t* input, const wchar_t* cssStyle, wstring& output_html)
{
	const int len = wcslen(input);
	if (len == 0)
	{
		output_html.clear();
		return;
	}
	try
	{
		output_html.reserve(len);
	}
	catch(const std::bad_alloc& )
	{
		return;
	}
	bool isInsideQuotes = false;
	for(int i = 0; i<len; i++)
	{
		if (isInsideQuotes == true)//_______________ Quoted text
		{
			if (input[i] == '\"')
			{
				if (i > 0) 
				{
					if (input[i-1] == '\\')
					{
						output_html += input[i]; // scape sequence
						continue;
					}
				}
				output_html += L"\"</span>";
				isInsideQuotes = false;
			}
			else
			{
				output_html += input[i]; 
			}
		}
		else//_______________________________ Regular code
		{
			if (input[i] == '\"')
			{
				output_html += L"<span style=\"";
				output_html += cssStyle;
				output_html += L"\">\"";
				isInsideQuotes = true;
			}
			else
			{
				output_html += input[i]; 
			}
		}
	}
}

bool Convert::ValarrayToVectorInt(const valarray<double>& input, valarray<int>& output)
{
	const int len = input.size();
	if (len == 0)
	{
		output.free();
		return true;
	}
	try
	{
		output.resize(len);
	}
	catch(const std::bad_alloc& )
	{
		return false;
	}
	for(int i = 0; i<len; i++)
	{
		output[i] = (int)input[i];
	}
	return true;
}

//bool Convert::Base64BitEncrypt(const wchar_t* input, wstring& output)
//{
//	const int len = wcslen(input);
//	if (len == 0)
//	{
//		output.clear();
//		return false;
//	}
//	const int bitsLen = len*8;
//	const int residue = bitsLen%6;
//	const int out_len = (residue == 0) ? bitsLen/6 : bitsLen/6+1;
//	//_____________________________________________ Memory allocation
//	try
//	{
//		output.resize(out_len);
//	}
//	catch(const std::bad_alloc )
//	{
//		return false;
//	}
//	unsigned char * data = new unsigned char[len]; 
//	if (data == NULL) return false;
//	//____________________________________________ Convert to 8 bits
//	int i;
//	for(i = 0; i<len; i++)
//	{
//		data[i] = (unsigned char)input[i];
//	}
//
//	//____________________________________________ Read in groups of 6 bits
//	char value = 0;
//	int index;
//	//int borrar;
//
//	for(i = 0; i<out_len; i++)
//	{
//		index = i*6/8;
//		switch(i%4)
//		{
//		case 0:   // First six bits from current
//			value = (data[index] & 0xFC)>>2;
//			output[i] = (wchar_t)value;
//			break;
//		case 1:  // 2 bits from current, 4 bits from next
//			if (i == out_len-1)
//			{
//				value = (data[index] & 0x03);
//			}
//			else
//			{
//				value = ((data[index] & 0x03)>>4) | ((data[index+1] & 0xF0)>>4);
//			}
//			output[i] = (wchar_t)value;
//			break;
//		case 2: //4 bits from current, 2 bits from next
//			if (i == out_len-1)
//			{
//				value = (data[index] & 0x0F);
//			}
//			else
//			{
//				value = ((data[index] & 0x0F)<<2) | ((data[index+1] & 0xC0)>>6);
//			}
//			output[i] = (wchar_t)value;
//			break;
//		case 3: //last six bits from current
//			value = (data[index] & 0x3F);
//			output[i] = (wchar_t)value;
//			break;
//		}
//		//borrar = (int)value;
//	}
//	if (data) delete [] data;
//	return true;
//}

bool Convert::IsBase64(unsigned char input) 
{
	if (isalnum(input)) return true;
	if (input == '+') return true;
	if (input == '/') return true;
	return false;
}

bool Convert::Base64BitEncode(const char* input, const int inputLen, string& output)
{
	output.clear();
	if (inputLen == 0)
	{
		output.clear();
		return true;
	}

	output.reserve((int)(4*ceil(inputLen/3.0)));
	const char * table  = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	unsigned char in[3], out[4];
	int i = 0;
	for(int k = 0; k<inputLen; k++)
	{
		in[i] = input[k];
		i++;
		if (i == 3) 
		{
			out[0] = (in[0] & 0xFC) >> 2;
			out[1] = ((in[0] & 0x03) << 4) | ((in[1] & 0xF0) >> 4);
			out[2] = ((in[1] & 0x0F) << 2) | ((in[2] & 0xC0) >> 6);
			out[3] = in[2] & 0x3F;

			for(i = 0; (i <4) ; i++)
			{
				output += table[out[i]];
			}
			i = 0;
		}
	}

	if (i != 0)
	{
		int j = 0;
		for(j = i; j < 3; j++)
		{
			in[j] = '\0';
		}
		//____________________________________
		out[0] = (in[0] & 0xFC) >> 2;
		out[1] = ((in[0] & 0x03) << 4) | ((in[1] & 0xF0) >> 4);
		out[2] = ((in[1] & 0x0F) << 2) | ((in[2] & 0xC0) >> 6);
		out[3] = in[2] & 0x3F;
		//_____________________________________
		for (j = 0; j < i + 1; j++)
		{
			output += table[out[j]];
		}

		while(i < 3)
		{
			output += '=';
			i++;
		}
	}
	return true;
	//const int len = strlen(input);
	//if (len == 0)
	//{
	//	output.clear();
	//	return true;
	//}
	//const int bitsLen = len*8;
	//const int residue = bitsLen%6;
	//const int out_len = (residue == 0) ? bitsLen/6 : bitsLen/6+1;
	////_____________________________________________ Memory allocation
	//try
	//{
	//	output.resize(out_len);
	//}
	//catch(const std::bad_alloc )
	//{
	//	return false;
	//}

	////____________________________________________ Read in groups of 6 bits
	//int value = 0;
	//int index;

	//for(int i = 0; i<out_len; i++)
	//{
	//	index = i*6/8;
	//	switch(i%4)
	//	{
	//	case 0:   // First six bits from current
	//		value = (input[index] & 0xFC)>>2;
	//		break;
	//	case 1:  // 2 bits from current, 4 bits from next
	//		if (i == out_len-1)
	//		{
	//			value = (input[index] & 0x03);
	//		}
	//		else
	//		{
	//			value = ((input[index] & 0x03)>>4) | ((input[index+1] & 0xF0)>>4);
	//		}
	//		break;
	//	case 2: //4 bits from current, 2 bits from next
	//		if (i == out_len-1)
	//		{
	//			value = (input[index] & 0x0F);
	//		}
	//		else
	//		{
	//			value = ((input[index] & 0x0F)<<2) | ((input[index+1] & 0xC0)>>6);
	//		}
	//		break;
	//	case 3: //last six bits from current
	//		value = (input[index] & 0x3F);
	//		break;
	//	}
	//	output[i] = key[value];
	//}
	//return true;
}

bool Convert::Base64BitDecode(const char* input, const int inputLen, string& output)
{
	const char * table  = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	//const int len = strlen(input);
	if (inputLen == 0)
	{
		output.clear();
		return true;
	}
	output.reserve((int)(3.0*ceil(inputLen/4.0)));
	int i = 0, s = 0;
	const int keylen = strlen(table);
	unsigned char a[3], b[4];
	for(int k = 0; k < inputLen; k++)
	{
		if (input[k] == '=') break;
		if (Sys::Convert::IsBase64((unsigned char)input[k]) == false) break;
		b[i] = input[k];
		i++;
		if (i ==4) 
		{
			for(i = 0; i <4; i++)
			{
				for(s = 0; s<keylen; s++)
				{
					if (b[i] == table[s])
					{
						b[i] = s;
						break;
					}
				}
			}

			a[0] = (b[0] << 2) + ((b[1] & 0x30) >> 4);
			a[1] = ((b[1] & 0x0F) << 4) + ((b[2] & 0x3C) >> 2);
			a[2] = ((b[2] & 0x3) << 6) + b[3];

			for(i = 0; i < 3; i++)
			{
				output += a[i];
			}
			i = 0;
		}
	}

	if (i != 0) 
	{
		int j = 0;
		for (j = i; j <4; j++)
		{
			b[j] = 0;
		}

		for (j = 0; j <4; j++)
		{
			for(s = 0; s<keylen; s++)
			{
				if (b[j] == table[s])
				{
					b[j] = s;
					break;
				}
			}
		}

		a[0] = (b[0] << 2) + ((b[1] & 0x30) >> 4);
		a[1] = ((b[1] & 0x0F) << 4) + ((b[2] & 0x3C) >> 2);
		a[2] = ((b[2] & 0x3) << 6) + b[3];

		for (j = 0; (j < i - 1); j++)
		{
			output += a[j];
		}
	}
	return true;
}

//_____________________________________________________________________ Information

//_____________________________________________________________________ Region
Region::Region()
{
	hrgn = NULL;
}

Region::~Region()
{
	Delete();
}

bool Region::CreatePolygon(LPPOINT lpPoints, int count, int mode)
{
	Delete();
	hrgn = ::CreatePolygonRgn(lpPoints, count, mode);
	return (hrgn != 0);
}

bool Region::CreatePolyPolygon(const POINT *lppt, const int *polyCounts, int count, int polyFillMode)
{
	Delete();
	hrgn = ::CreatePolyPolygonRgn(lppt, polyCounts, count, polyFillMode);
	return (hrgn != 0);
}

bool Region::CreateElliptic(int x1, int y1, int x2, int y2)
{
	Delete();
	hrgn = ::CreateEllipticRgn(x1, y1, x2, y2);
	return (hrgn != 0);
}

bool Region::CreateRect(int x1, int y1, int x2, int y2)
{
	Delete();
	hrgn = ::CreateRectRgn(x1, y1, x2, y2);
	return (hrgn != 0);
}

bool Region::CreateRoundRect(int x1, int y1, int x2, int y2, int x3, int y3)
{
	Delete();
	hrgn = ::CreateRoundRectRgn(x1, y1, x2, y2, x3, y3);
	return (hrgn != 0);
}

// ::BeginPath() > Gdi painting functions > EndPath() > CreateFromPath > 
bool Region::CreateFromPath(HDC hdc)
{
	Delete();
	hrgn = ::PathToRegion(hdc);
	return (hrgn != 0);
}

void Region::Delete()
{
	if (hrgn)
	{
		::DeleteObject(hrgn);
		hrgn = NULL;
	}
}

//_____________________________________________________________________ TextBufferA
TextBufferA::TextBufferA()
{
}

TextBufferA::~TextBufferA()
{
}

bool TextBufferA::WriteText(const string& source)
{
	buffer+=source;
	return true;
}

//_____________________________________________________________________ TextBufferW
TextBufferW::TextBufferW()
{
}

TextBufferW::~TextBufferW()
{
}

bool TextBufferW::WriteText(const wstring& source)
{
	buffer+=source;
	return true;
}

//_____________________________________________________________________ ByteBuffer
ByteBuffer::ByteBuffer()
{
	position = 0;
}

ByteBuffer::~ByteBuffer()
{
}

int ByteBuffer::Write(const void* data, int  bytesToWrite) // returns number of bytes written
{
	buffer.append((unsigned char*)data, bytesToWrite);
	return bytesToWrite;
}

int ByteBuffer::Read(void *data, int  bytesToRead)  // returns number of bytes read
{
	const int length = buffer.length();
	if (position>=length) return 0;
	int count = MINIMUM(bytesToRead, length-position);
	const unsigned char * p = buffer.data()+position;
	::memcpy(data, (void*)p, count);
	position += count;
	return count;
}

void ByteBuffer::Reset()
{
	position = 0;
}

//Returns items read count
int ByteBuffer::Fread(void* data, size_t itemSizeInBytes, size_t maxItemsToRead)
{
	return this->Read(data, itemSizeInBytes*maxItemsToRead);
	//m_bError = false;
	//if (m_p==NULL) 
	//{
	//	//m_bError = true;
	//	return 0;
	//}
	//if (m_nUsed == 0)
	//{
	//	//m_bError = true;
	//	return 0;
	//}
	//if (m_nReaderCount>=m_nUsed) 
	//{
	//	m_bError = true;
	//	return 0;
	//}
	//unsigned long nBytes = (unsigned long)itemSizeInBytes*maxItemsToRead;
	//unsigned long available = (m_nUsed>m_nReaderCount) ? m_nUsed-m_nReaderCount : 0;
	//size_t bytesRead = (available>=nBytes) ? nBytes : available;

	//if (bytesRead>0)
	//{
	//	CopyMemory(pData, m_p+m_nReaderCount, bytesRead);
	//	m_nReaderCount+=bytesRead;
	//}

	//return bytesRead;
}

//Returns items written count
int ByteBuffer::Fwrite(void* data, size_t itemSizeInBytes, size_t ItemsToWriteCount)
{
	position = 0;// Reset reader position so you never reach end of file while writting
	return this->Write(data, itemSizeInBytes*ItemsToWriteCount);
}

////returns zero if current position is not at the end
//int ByteBuffer::Feof()
//{
//	return (this->m_nUsed<=this->m_nReaderCount) ? 1 : 0;
//}
//
////returns zero if no error	
//int ByteBuffer::Ferror()
//{
//	return m_bError ? 1 : 0;
//}


//_____________________________________________________________________ File
File::File(void)
{
	hFile = INVALID_HANDLE_VALUE;
}

File::~File(void)
{
	this->Close();
}

HANDLE File::GetHandle()
{
	return hFile;
}

int File::Write(const void* data, int bytesToWrite)
{
	DWORD written;
	::WriteFile(hFile, data, bytesToWrite, &written, NULL);
	return (int)written;
}

int File::Read(void *data, int bytesToRead)
{
	DWORD dwRead;
	::ReadFile(hFile, data, bytesToRead, &dwRead, NULL);
	return (int)dwRead;
}

bool File::Write(int data)
{
	DWORD written;
	DWORD bytesToWrite = sizeof(int);
	::WriteFile(hFile, &data, bytesToWrite, &written, NULL);
	return (written == bytesToWrite);
}

bool File::Read(int& data)
{
	DWORD dwRead;
	DWORD bytesToRead = sizeof(int);
	::ReadFile(hFile, &data, bytesToRead, &dwRead, NULL);
	return (dwRead == bytesToRead);
}

bool File::Write(double data)
{
	DWORD written;
	DWORD bytesToWrite = sizeof(double);
	::WriteFile(hFile, &data, bytesToWrite, &written, NULL);
	return (written == bytesToWrite);
}

bool File::Read(double& data)
{
	DWORD dwRead;
	DWORD bytesToRead = sizeof(double);
	::ReadFile(hFile, &data, bytesToRead, &dwRead, NULL);
	return (dwRead == bytesToRead);
}

bool File::Write(const wstring& data)
{
	return Sys::SerialAssistant::Save(*this, data);
}

bool File::Read(wstring& data)
{
	return Sys::SerialAssistant::Load(*this, data);
}

bool File::Write(bool data)
{
	DWORD written;
	DWORD bytesToWrite = sizeof(bool);
	::WriteFile(hFile, &data, bytesToWrite, &written, NULL);
	return (written == bytesToWrite);
}

bool File::Read(bool& data)
{
	DWORD dwRead;
	DWORD bytesToRead = sizeof(bool);
	::ReadFile(hFile, &data, bytesToRead, &dwRead, NULL);
	return (dwRead == bytesToRead);
}

bool File::Write(const Sys::Time& data)
{
	DWORD written;
	DWORD bytesToWrite = sizeof(Sys::Time);
	::WriteFile(hFile, &data, bytesToWrite, &written, NULL);
	return (written == bytesToWrite);
}

bool File::Read(Sys::Time& data)
{
	DWORD dwRead;
	DWORD bytesToRead = sizeof(Sys::Time);
	::ReadFile(hFile, &data, bytesToRead, &dwRead, NULL);
	return (dwRead == bytesToRead);
}

bool File::CreateForWritting(const wstring& filename)
{
	return this->CreateForWritting(filename.c_str());
}

bool File::CreateForWritting(const wchar_t* filename)
{
	this->Close();
	hFile = ::CreateFile(filename, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
	return (hFile!=INVALID_HANDLE_VALUE);
}

bool File::CreateForReading(const wstring& filename)
{
	return this->CreateForReading(filename.c_str());
}

bool File::CreateForReading(const wchar_t* filename)
{
	this->Close();
	hFile = ::CreateFile(filename, GENERIC_READ, FILE_SHARE_READ, 
		NULL, OPEN_EXISTING, 0, NULL);
	return (hFile!=INVALID_HANDLE_VALUE);
}

void File::Close()
{
	if (hFile!=INVALID_HANDLE_VALUE) ::CloseHandle(hFile);
	hFile = INVALID_HANDLE_VALUE;
}

bool File::IsOpen()
{
	return (hFile!=INVALID_HANDLE_VALUE);
}

int File::GetSizeInBytes()
{
	DWORD highSize;
	return (int)::GetFileSize(hFile, &highSize);
}

bool File::WriteText(const wchar_t* source)
{
	if (source==NULL) return true;
	const int bytes = sizeof(wchar_t)*wcslen(source);
	if (bytes == 0) return true;
	if (Write(source, bytes)!=bytes) return false;
	return true;
}

//___________________ITextWriterA
bool File::WriteText(const string& source)
{
	const int bytes = source.length();
	if (bytes == 0) return true;
	if (Write(source.data(), bytes)!=bytes) return false;
	return true;
}

//___________________ITextWriterW
bool File::WriteText(const wstring& source)
{
	const int bytes = source.length()*sizeof(wchar_t);
	if (bytes == 0) return true;
	if (Write(source.data(), bytes)!=bytes) return false;
	return true;
}

//_____________________________________________________________________ TextAssistant
TextAssistant::TextAssistant(void)
{
}

TextAssistant::~TextAssistant(void)
{
}

bool TextAssistant::IsSeparator(const wstring& input, int index)
{
	const size_t len = input.length();
	if (index<0) return true;
	if (index >= (int)len) return true;
	return Sys::TextAssistant::IsSeparator(input[index]);
}

bool TextAssistant::IsSeparator(const string& input, int index)
{
	const size_t len = input.length();
	if (index<0) return true;
	if (index >= (int)len) return true;
	return Sys::TextAssistant::IsSeparator(input[index]);
}

bool TextAssistant::IsSeparator(wchar_t input)
{
	if (input == '\t') return true;
	if (input == ' ') return true;
	if (input == '\r') return true;
	if (input == '\n') return true;
	if (input == '(') return true;
	if (input == ')') return true;
	if (input == '[') return true;
	if (input == ']') return true;
	if (input == '{') return true;
	if (input == '}') return true;
	if (input == '+') return true;
	if (input == '-') return true;
	if (input == '*') return true;
	if (input == '/') return true;
	if (input == '>') return true;
	if (input == '<') return true;
	if (input == '=') return true;
	if (input == '%') return true;
	if (input == ':') return true;
	if (input == ';') return true;
	if (input == '.') return true;
	if (input == ',') return true;
	if (input == '¡') return true;
	if (input == '!') return true;
	if (input == '?') return true;
	if (input == '¿') return true;
	if (input == '|') return true;
	if (input == '&') return true;
	if (input == '\"') return true;
	return false;
}

bool TextAssistant::IsSeparator(char input)
{
	if (input == '\t') return true;
	if (input == ' ') return true;
	if (input == '\r') return true;
	if (input == '\n') return true;
	if (input == '(') return true;
	if (input == ')') return true;
	if (input == '[') return true;
	if (input == ']') return true;
	if (input == '{') return true;
	if (input == '}') return true;
	if (input == '+') return true;
	if (input == '-') return true;
	if (input == '*') return true;
	if (input == '/') return true;
	if (input == '>') return true;
	if (input == '<') return true;
	if (input == '=') return true;
	if (input == '%') return true;
	if (input == ':') return true;
	if (input == ';') return true;
	if (input == '.') return true;
	if (input == ',') return true;
	if (input == '¡') return true;
	if (input == '!') return true;
	if (input == '?') return true;
	if (input == '¿') return true;
	if (input == '|') return true;
	if (input == '&') return true;
	if (input == '\"') return true;
	return false;
}

bool TextAssistant::IsDigit(const wchar_t input)
{
	if (input < '0') return false;
	if (input > '9') return false;
	return true;
}

bool TextAssistant::IsDigit(const char input)
{
	if (input < '0') return false;
	if (input > '9') return false;
	return true;
}

bool TextAssistant::IsChar(wchar_t input)
{
	if (input < 'A') return false;
	if ('Z' < input && input < 'a') return false;
	if ('z' < input) return false;
	return true;
}

bool TextAssistant::IsChar(char input)
{
	if (input < 'A') return false;
	if ('Z' < input && input < 'a') return false;
	if ('z' < input) return false;
	return true;
}

bool TextAssistant::IsValidIdChar(wchar_t letter)
{
	if (letter == '_') return true;
	if ('a'<=letter && letter<='z') return true;
	if ('A'<=letter && letter<='Z') return true;
	if ('0'<=letter && letter<='9') return true;
	return false;
}

bool TextAssistant::IsValidIdChar(char letter)
{
	if (letter == '_') return true;
	if ('a'<=letter && letter<='z') return true;
	if ('A'<=letter && letter<='Z') return true;
	if ('0'<=letter && letter<='9') return true;
	return false;
}

bool TextAssistant::IsDouble(const wchar_t* input)
{
	const int len = wcslen(input);
	if (len == 0) return false;
	for(int i = 0; i<len; i++)
	{
		if (input[i] == '+') continue;
		if (input[i] == '/') return false;
		if (input[i] < '-') return false;
		if (input[i] > '9')
		{
			if (input[i] == 'e') continue;
			if (input[i] == 'E') continue;
			return false;
		}
	}
	return true;
}

bool TextAssistant::IsDouble(const char* input)
{
	const int len = strlen(input);
	if (len == 0) return false;
	for(int i = 0; i<len; i++)
	{
		if (input[i] < '+') continue;
		if (input[i] < '/') return false;
		if (input[i] < '-') return false;
		if (input[i] > 9)
		{
			if (input[i] == 'e') continue;
			if (input[i] == 'E') continue;
			return false;
		}
	}
	return true;
}


// Deletes all ocurrecences of the the string that begins with start and ends with end
int TextAssistant::SmartDelete(wstring& in_out, const wstring& start, const wstring& end)
{
	const int lenStart = start.length();
	if (lenStart<=0) return 0;
	const int lenEnd = end.length();
	if (lenEnd<=0) return 0;
	int len = in_out.length();
	if (len<=0) return 0;
	int count=0;
	int q = 0;
	int pStart = 0;
	int pEnd = 0;
	while(true)
	{
		pStart = in_out.find(start, pStart);
		if (pStart == std::wstring::npos) break;
		//
		pEnd = in_out.find(end, pStart);
		if (pEnd == std::wstring::npos) break;
		//
		q = 0;
		while(pEnd+lenEnd+q <= len)
		{
			in_out[pStart+q] = in_out[pEnd+lenEnd+q];
			q++;
		}
		len = len- (pEnd+lenEnd-pStart);
		in_out.resize(len);
		count++;
	}
	return count;
}

// Deletes all ocurrecences of the the string that begins with start and ends with end
int TextAssistant::SmartDelete(string& in_out, const string& start, const string& end)
{
	const int lenStart = start.length();
	if (lenStart<=0) return 0;
	const int lenEnd = end.length();
	if (lenEnd<=0) return 0;
	int len = in_out.length();
	if (len<=0) return 0;
	int count=0;
	int q = 0;
	int pStart = 0;
	int pEnd = 0;
	while(true)
	{
		pStart = in_out.find(start, pStart);
		if (pStart == std::string::npos) break;
		//
		pEnd = in_out.find(end, pStart);
		if (pEnd == std::string::npos) break;
		//
		q = 0;
		while(pEnd+lenEnd+q <= len)
		{
			in_out[pStart+q] = in_out[pEnd+lenEnd+q];
			q++;
		}
		len = len- (pEnd+lenEnd-pStart);
		in_out.resize(len);
		count++;
	}
	return count;
}

int TextAssistant::DeleteAfter(wstring& in_out, const wchar_t character)
{
	int pos = in_out.find(character);
	if (pos == std::wstring::npos) return 0;
	in_out.resize(pos);
	return pos;
}

int TextAssistant::DeleteAfter(string& in_out, const char character)
{
	int pos = in_out.find(character);
	if (pos == std::string::npos) return 0;
	in_out.resize(pos);
	return pos;
}

wstring& TextAssistant::TruncateToFit(HDC hdc, const wstring& input, wstring& output, int width, bool appendEllipses)
{
	SIZE size;
	TEXTMETRIC tm;
	::GetTextMetrics(hdc, &tm);
	const int i = width/tm.tmAveCharWidth;
	int j = 2;
	const int len = input.length();

	output = input;
	::GetTextExtentPoint32W(hdc, output.c_str(), len, &size);
	if (width>size.cx) return output;

	do
	{
		output.assign(input, 0, i-j);
		if (appendEllipses) output += L"...";
		::GetTextExtentPoint32W(hdc, output.c_str(), output.length(), &size);
		j++;
	}
	while (width<size.cx);
	return output;
}

string& TextAssistant::TruncateToFit(HDC hdc, const string& input, string& output, int width, bool appendEllipses)
{
	SIZE size;
	TEXTMETRIC tm;
	::GetTextMetrics(hdc, &tm);
	const int i = width/tm.tmAveCharWidth;
	int j = 2;
	const int len = input.length();

	output = input;
	::GetTextExtentPoint32A(hdc, output.c_str(), len, &size);
	if (width>size.cx) return output;

	do
	{
		output.assign(input, 0, i-j);
		if (appendEllipses) output += "...";
		::GetTextExtentPoint32A(hdc, output.c_str(), output.length(), &size);
		j++;
	}
	while (width<size.cx);
	return output;
}

bool TextAssistant::LoadFromResource(HINSTANCE hInst, int resource_id, wstring& output)
{
	HRSRC hrsrc = ::FindResource(hInst, MAKEINTRESOURCE(resource_id), L"BIN");
	if (hrsrc==NULL) return false;

	HGLOBAL hResource = ::LoadResource(hInst, hrsrc);
	if (hResource==NULL) return false;
	DWORD dwSize = SizeofResource(hInst, hrsrc); 
	BYTE * dataResource = (BYTE*) ::LockResource(hResource);
	output.resize(dwSize/sizeof(wchar_t));
	::CopyMemory((void*)output.data(), dataResource, dwSize);
	::FreeResource(hResource);
	return true;
}

bool TextAssistant::LoadFromResource(HINSTANCE hInst, int resource_id, string& output)
{
	HRSRC hrsrc = ::FindResource(hInst, MAKEINTRESOURCE(resource_id), L"BIN");
	if (hrsrc==NULL) return false;

	HGLOBAL hResource = ::LoadResource(hInst, hrsrc);
	if (hResource==NULL) return false;
	DWORD dwSize = SizeofResource(hInst, hrsrc); 
	BYTE * dataResource = (BYTE*) ::LockResource(hResource);
	output.resize(dwSize/sizeof(char));
	::CopyMemory((void*)output.data(), dataResource, dwSize);
	::FreeResource(hResource);
	return true;
}

wstring& TextAssistant::RemoveTrailingSpaces(wstring& in_out)
{
	int len = in_out.length();
	if (len<=0) return in_out;
	int n = 0;
	int i = 0;
	//___________ delete spaces, tabs, line returns or line carriage at the beginning
	while ( (in_out[i]==' ' || in_out[i]=='\t' || in_out[i]=='\r'|| in_out[i]=='\n') && i<len) 
	{
		n++;
		i++;
	}
	in_out.erase(0, n);
	//___________ delete spaces, tabs, line returns or line carriage at the end
	len = in_out.length();
	n = 0;
	i = len -1;
	while ( (in_out[i]==' ' || in_out[i]=='\t' || in_out[i]=='\r' || in_out[i]=='\n') && i>=0) 
	{
		n++;
		i--;
	}
	in_out.erase(i+1, n);
	return in_out;
}

wstring& TextAssistant::ToUpper(wstring& in_out)
{
	transform(in_out.begin(), in_out.end(), in_out.begin(), toupper);
	return in_out;
}

wstring& TextAssistant::ToLower(wstring& in_out)
{
	transform(in_out.begin(), in_out.end(), in_out.begin(), tolower);
	return in_out;
}

int TextAssistant::DeleteChar(wstring& in_out, wchar_t remove)
{
	const int len = in_out.length();
	if (len<=0) return 0;
	int count = 0;
	int i, j;

	for(i=0; i<len; i++)
	{
		if (in_out[i] == remove) count++;
	}

	wstring tmp(in_out);
	in_out.resize(len-count);

	for(i=0, j= 0; i<len; i++)
	{
		if (tmp[i] == remove) continue;
		in_out[j++] = tmp[i];
	}
	return count;
}

int TextAssistant::ReplaceChar(wstring& in_out, wchar_t oldChar, wchar_t newChar)
{
	const int len = in_out.length();
	if (len<=0) return 0;
	int count = 0;
	for(int i=0; i<len; i++)
	{
		if (in_out[i] == oldChar)
		{
			in_out[i] = newChar;
			count++;
		}
	}
	return count;
}

int TextAssistant::DeleteWord(wstring& in_out, const wstring& word, bool matchWholeWord)
{
	const size_t len = in_out.length();
	if (len<=0) return 0;
	const size_t lenWord = word.length();
	if (lenWord<=0) return 0;

	const int count = GetWordCount(in_out, word, matchWholeWord);
	if (count<=0) return 0;

	size_t pos = 0; 
	if (matchWholeWord == true)
	{
		while((pos = in_out.find(word, pos)) != std::string::npos) 
		{ 
			if (Sys::TextAssistant::IsSeparator((const wstring&)in_out, pos-1) && Sys::TextAssistant::IsSeparator((const wstring&)in_out, pos+lenWord))
			{
				in_out.erase(pos, lenWord); 
			}
		} 
	}
	else
	{
		while((pos = in_out.find(word, pos)) != std::wstring::npos) 
		{ 
			in_out.erase(pos, lenWord); 
		} 
	}
	return count;
}

int TextAssistant::ReplaceWord(wstring& in_out, const wstring& oldWord, const wstring& newWord, bool matchWholeWord)
{
	const int len = in_out.length();
	if (len<=0) return 0;
	const size_t lenOldWord = oldWord.length();
	if (lenOldWord<=0) return 0;
	const size_t lenNewWord = newWord.length();

	const int count = GetWordCount(in_out, oldWord, matchWholeWord);
	if (count<=0) return 0;
	const int newLen = len + count * (lenNewWord-lenOldWord);
	in_out.reserve(newLen);

	size_t pos = 0; 
	if (matchWholeWord == true)
	{
		while((pos = in_out.find(oldWord, pos)) != std::string::npos) 
		{ 
			if (Sys::TextAssistant::IsSeparator((const wstring&)in_out, pos-1) && Sys::TextAssistant::IsSeparator((const wstring&)in_out, pos+lenOldWord))
			{
				in_out.replace(pos, lenOldWord, newWord); 
				pos += lenNewWord; 
			}
			else
			{
				pos += lenOldWord; 
			}
		} 
	}
	else
	{
		while((pos = in_out.find(oldWord, pos)) != std::wstring::npos) 
		{ 
			in_out.replace(pos, lenOldWord, newWord); 
			pos += lenNewWord; 
		} 
	}
	return count;
}

int TextAssistant::ReplaceBiggerLessThan(const wchar_t* input, wstring& output)
{
	const int len = wcslen(input);
	if (len<=0)
	{
		output.clear();
		return 0;
	}
	int i;
	int count = 0;
	for(i = 0; i < len; i++)
	{
		if (input[i] == '<' || input[i] == '>') count++;
	}
	if (count<=0)
	{
		output = input;
		return 0;
	}
	const int newLen = len + count * (3);
	output.reserve(newLen);
	for(i = 0; i<len; i++)
	{
		if (input[i] == '<')
		{
			output += L"&lt;";
		}
		else if (input[i] == '>')
		{
			output += L"&gt;";
		}
		else
		{
			output += input[i];
		}
	}
	
	return count;
}

wstring& TextAssistant::FirstUppercase(wstring& in_out)
{
	const int len = in_out.length();
	if (len<=0) return in_out;
	in_out[0] = toupper(in_out[0]);
	if (len==1) return in_out;
	for(int i=1; i<len; i++)
	{
		if ( in_out[i-1]==' ')
		{
			in_out[i] = toupper(in_out[i]);
		}
		else
		{
			in_out[i] = tolower(in_out[i]);
		}
	}
	return in_out;
}

int TextAssistant::GetWordCount(const wstring& input, const wstring& word, bool matchWholeWord)
{
	if (input.length()<=0) return 0;
	int count = 0;
	int pos = 0;
	const int len = word.length();

	while(true)
	{
		pos = input.find(word, pos);
		if (pos == std::wstring::npos) 
		{
			break;
		}
		else
		{
			if (matchWholeWord == true)
			{
				if (Sys::TextAssistant::IsSeparator(input, pos-1)==true && Sys::TextAssistant::IsSeparator(input, pos+len)==true) count++;
			}
			else
			{
				count++;
			}
		}
		pos+=len;
	}
	return count;
}

int TextAssistant::GetWordCount(const string& input, const string& word, bool matchWholeWord)
{
	if (input.length()<=0) return 0;
	int count = 0;
	int pos = 0;
	const int len = word.length();

	while(true)
	{
		pos = input.find(word, pos);
		if (pos == std::string::npos) 
		{
			break;
		}
		else
		{
			if (matchWholeWord == true)
			{
				if (Sys::TextAssistant::IsSeparator(input, pos-1)==true && Sys::TextAssistant::IsSeparator(input, pos+len)==true) count++;
			}
			else
			{
				count++;
			}
		}
		pos+=len;
	}
	return count;
}


string& TextAssistant::RemoveTrailingSpaces(string& in_out)
{
	int len = in_out.length();
	if (len<=0) return in_out;
	int n = 0;
	int i = 0;
	//___________ delete spaces at the beginning
	while (in_out[i]==' ' && i<len) 
	{
		n++;
		i++;
	}
	in_out.erase(0, n);
	//___________ delete spaces at the end
	len = in_out.length();
	n = 0;
	i = len -1;
	while (in_out[i]==' ' && i>=0) 
	{
		n++;
		i--;
	}
	in_out.erase(i+1, n);
	return in_out;
}

// Removes carriage returns, tabs and extra spaces
wstring& TextAssistant::RemoveExtraSpaces(wstring& in_out)
{
	wstring tmp(in_out);
	const size_t len = tmp.length();
	size_t i;
	for(i = 0; i < len; i++)
	{
		if (tmp[i] == '\r' || tmp[i] == '\n' || tmp[i] == '\t')
		{
			tmp[i] = ' ';
		}
	}
	size_t spaceCount = 0;
	in_out.clear();
	for(i = 0; i < len; i++)
	{
		if (tmp[i] == ' ')
		{
			if (spaceCount == 0)
			{
				in_out += ' ';
			}
			spaceCount++;
		}
		else
		{
			in_out += tmp[i];
			spaceCount = 0;
		}
	}
	return in_out;
}

// Removes carriage returns, tabs and extra spaces
string& TextAssistant::RemoveExtraSpaces(string& in_out)
{
	string tmp(in_out);
	const size_t len = tmp.length();
	size_t i;
	for(i = 0; i < len; i++)
	{
		if (tmp[i] == '\r' || tmp[i] == '\n' || tmp[i] == '\t')
		{
			tmp[i] = ' ';
		}
	}
	size_t spaceCount = 0;
	in_out.clear();
	for(i = 0; i < len; i++)
	{
		if (tmp[i] == ' ')
		{
			if (spaceCount == 0)
			{
				in_out += ' ';
			}
			spaceCount++;
		}
		else
		{
			in_out += tmp[i];
			spaceCount = 0;
		}
	}
	return in_out;
}

string& TextAssistant::ToUpper(string& in_out)
{
	transform(in_out.begin(), in_out.end(), in_out.begin(), toupper);
	return in_out;
}

string& TextAssistant::ToLower(string& in_out)
{
	transform(in_out.begin(), in_out.end(), in_out.begin(), tolower);
	return in_out;
}

int TextAssistant::DeleteChar(wchar_t* in_out, wchar_t remove)
{
	const int len = wcslen(in_out);
	if (len<=0) return 0;
	int count = 0;
	int i, j;

	for(i=0, j= 0; i<len; i++)
	{
		if (in_out[i] == remove) continue;
		in_out[j++] = in_out[i];
	}
	in_out[j] = '\0';
	return count;
}

int TextAssistant::DeleteChar(string& in_out, char remove)
{
	const int len = in_out.length();
	if (len<=0) return 0;
	int count = 0;
	int i, j;

	for(i=0; i<len; i++)
	{
		if (in_out[i] == remove) count++;
	}

	string tmp(in_out);
	in_out.resize(len-count);

	for(i=0, j= 0; i<len; i++)
	{
		if (tmp[i] == remove) continue;
		in_out[j++] = tmp[i];
	}
	return count;
}

int TextAssistant::ReplaceChar(wchar_t* in_out, wchar_t oldChar, wchar_t newChar)
{
	const int len = wcslen(in_out);
	int count = 0;
	if (len<=0) return 0;
	for(int i=0; i<len; i++)
	{
		if (in_out[i] == oldChar) 
		{
			in_out[i] = newChar;
			count++;
		}
	}
	return count;
}

int TextAssistant::ReplaceChar(string& in_out, char oldChar, char newChar)
{
	const int len = in_out.length();
	int count = 0;
	if (len<=0) return 0;
	for(int i=0; i<len; i++)
	{
		if (in_out[i] == oldChar) 
		{
			in_out[i] = newChar;
			count++;
		}
	}
	return count;
}

int TextAssistant::DeleteWord(string& in_out, const string& word, bool matchWholeWord)
{
	const size_t len = in_out.length();
	if (len<=0) return 0;
	const size_t lenWord = word.length();
	if (lenWord<=0) return 0;

	const int count = GetWordCount(in_out, word, matchWholeWord);
	if (count<=0) return 0;

	size_t pos = 0; 
	if (matchWholeWord == true)
	{
		while((pos = in_out.find(word, pos)) != std::string::npos) 
		{ 
			if (Sys::TextAssistant::IsSeparator((const string&)in_out, pos-1) && Sys::TextAssistant::IsSeparator((const string&)in_out, pos+lenWord))
			{
				in_out.erase(pos, lenWord); 
			}
		} 
	}
	else
	{
		while((pos = in_out.find(word, pos)) != std::string::npos) 
		{ 
			in_out.erase(pos, lenWord); 
		} 
	}
	return count;
}

int TextAssistant::ReplaceWord(string& in_out, const string& oldWord, const string& newWord, bool matchWholeWord)
{
	const int len = in_out.length();
	if (len<=0) return 0;
	const size_t lenOldWord = oldWord.length();
	if (lenOldWord<=0) return 0;
	const size_t lenNewWord = newWord.length();

	const int count = GetWordCount(in_out, oldWord, matchWholeWord);
	if (count<=0) return 0;
	const int newLen = len + count * (lenNewWord-lenOldWord);
	in_out.reserve(newLen);

	size_t pos = 0; 
	if (matchWholeWord == true)
	{
		while((pos = in_out.find(oldWord, pos)) != std::string::npos) 
		{ 
			if (Sys::TextAssistant::IsSeparator((const string&)in_out, pos-1) && Sys::TextAssistant::IsSeparator((const string&)in_out, pos+lenOldWord))
			{
				in_out.replace(pos, lenOldWord, newWord); 
				pos += lenNewWord; 
			}
			else
			{
				pos += lenOldWord; 
			}
		} 
	}
	else
	{
		while((pos = in_out.find(oldWord, pos)) != std::string::npos) 
		{ 
			in_out.replace(pos, lenOldWord, newWord); 
			pos += lenNewWord; 
		} 
	}
	return count;
}

int TextAssistant::ExpandEscapeSequences(const wstring& input, wstring& output)
{
	output.clear();
	int count = 0;
	const int len = input.length();
	for(int i = 0; i<len; i++)
	{
		if (input[i] == '"')
		{
			output += L"\\\"";
			count++;
		}
		else if (input[i] == '\\')
		{
			output += L"\\\\";
			count++;
		}
		else
		{
			output += input[i];
		}
	}
	return count;
}

string& TextAssistant::FirstUppercase(string& in_out)
{
	const int len = in_out.length();
	if (len<=0) return in_out;
	in_out[0] = toupper(in_out[0]);
	if (len==1) return in_out;
	for(int i=1; i<len; i++)
	{
		if ( in_out[i-1]==' ')
		{
			in_out[i] = toupper(in_out[i]);
		}
		else
		{
			in_out[i] = tolower(in_out[i]);
		}
	}
	return in_out;
}

bool TextAssistant::IsUnicode(const void* input, int inputSize)
{
	int nUnicodeTest = IS_TEXT_UNICODE_SIGNATURE | IS_TEXT_UNICODE_REVERSE_SIGNATURE;
	if (IsTextUnicode (input, inputSize, &nUnicodeTest) == TRUE) return true;
		
	//BYTE bySwap;
	//if (nUnicodeTest & IS_TEXT_UNICODE_REVERSE_SIGNATURE)
	//{
	//	for (i = 0 ; i < n / 2 ; i++)
	//	{
	//		bySwap = ((BYTE *) pText) [2 * i] ;
	//		((BYTE *) pText) [2 * i] = ((BYTE *) pText) [2 * i + 1] ;
	//		((BYTE *) pText) [2 * i + 1] = bySwap ;
	//	}
	//}
	return false;
}

// input: fileName with full path
//Output: file extension in buffer
bool TextAssistant::ExtractFileExt(const wchar_t* input, wchar_t * buffer, int bufferSize)
{
	buffer[0] = '\0';
	const int len = wcslen(input);
	if (len < 3 ) return false;

	int i, j;
	int position = -1;

	//_____________________________ Find last dot
	for(i = len-1; i>=0; i--)
	{
		if (input[i] == '.')
		{
			position = i;
			break;
		}
	}
	if (position <= 0) return false;
	//_____________________________ Copy Result
	for(i = position+1, j = 0; i<len && j<bufferSize; i++, j++)
	{
		buffer[j] = tolower(input[i]);
	}
	if (i == len && j < bufferSize-1)
	{
		buffer[j] = '\0';
		return true;
	}
	buffer[bufferSize-1] = '\0';
	return false;
}

// // input: fileName with full path, bufferSize, fileExt = L".LAB"
// output: the filename in the buffer
//bool TextAssistant::ExtractFileName(const wchar_t* input, wchar_t * buffer, int bufferSize, const wchar_t* fileExt)
//{
//	//***************** Extract file name
//	if (input && wcslen(input)>4)
//	{
//		const int length = wcslen(input)+1;
//		wchar_t * name = new wchar_t[length];
//		lstrcpy(name, input);
//		 _wcsupr_s(name, length);
//		wchar_t * p = wcsstr (name, fileExt);
//		wchar_t * q = NULL;
//		wchar_t * w = NULL;
//		int i = 0;
//		if (p!=NULL)
//		{	
//			w = (wchar_t*) input - (name-p);
//			q=p;
//			while(*q!='\\' && i<bufferSize)
//			{
//				q--;
//				w--;
//				i++;
//			}
//			if (*q=='\\')
//			{
//				lstrcpyn(buffer, w+1, bufferSize);
//				buffer[bufferSize-1]='\0';
//			}
//		}
//		if (name) delete [] name;
//	}
//	return true;
//}

// // input: fileName with full path,  bufferSize
// output: the filename with its extension in the buffer
bool TextAssistant::ExtractFileName(const wchar_t* input, bool keepFileExt, wchar_t * buffer, int bufferSize)
{
	buffer[0] = '\0';
	const int len = wcslen(input);
	if (len < 4 ) return false;
	int i, j;
	int position = -1;

	//_____________________________ Find last back slash
	for(i = len-1; i>=0; i--)
	{
		if (input[i] == '\\')
		{
			position = i;
			break;
		}
	}
	if (position <= 0) return false;
	//_____________________________ Copy Result
	for(i = position+1, j = 0; i<len && j<bufferSize; i++, j++)
	{
		buffer[j] = input[i];
		if (keepFileExt ==false)
		{
			if (buffer[j] == '.')
			{
				buffer[j] = '\0';
				return true;
			}
		}
	}
	if (i == len && j < bufferSize-1)
	{
		buffer[j] = '\0';
		return true;
	}
	buffer[bufferSize-1] = '\0';
	return false;
}

// input: fileName with full path
// output: the file path in the buffer
bool TextAssistant::ExtractFilePath(const wchar_t* input, wchar_t * buffer, int bufferSize)
{
	const int len = wcslen(input);
	if (len < 5 ) return false;
	int i;
	int position = -1;

	//_____________________________ Find last back slash
	for(i = 0; i<len; i++)
	{
		if (input[i] == '\\') position = i;
	}
	if (position <= 0) return false;
	//_____________________________ Copy Result
	for(i = 0; i<len && i<bufferSize; i++)
	{
		buffer[i] = input[i];
		if (i == position)
		{
			buffer[i] = '\0';
			return true;
		}
	}
	buffer[bufferSize-1] = '\0';
	return false;
}

//_____________________________________________________________________ SerialAssistant
SerialAssistant::SerialAssistant(void)
{
}

SerialAssistant::~SerialAssistant(void)
{
}

bool SerialAssistant::Save(Sys::IStorer& destination, double source)
{
	int bytes = sizeof(double);
	if (destination.Write(&source, bytes)!=bytes) return false;
	return true;
}

bool SerialAssistant::Load(Sys::IStorer& source, double& destination)
{
	int bytes = sizeof(double);
	if (source.Read(&destination, bytes)!=bytes) return false;
	return true;
}

bool SerialAssistant::Save(Sys::IStorer& destination, int source)
{
	int bytes = sizeof(int);
	if (destination.Write(&source, bytes)!=bytes) return false;
	return true;
}

bool SerialAssistant::Load(Sys::IStorer& source, int& destination)
{
	int bytes = sizeof(int);
	if (source.Read(&destination, bytes)!=bytes) return false;
	return true;
}

bool SerialAssistant::Save(Sys::IStorer& destination, const wstring& source)
{
	const int length = source.length();
	int bytes = sizeof(int);
	if (destination.Write(&length, bytes)!=bytes) return false;
	//
	bytes = length*sizeof(wchar_t);
	if (destination.Write(source.data(), bytes)!=bytes) return false;
	return true;
}

bool SerialAssistant::Save(Sys::IStorer& destination, const string& source)
{
	const int length = source.length();
	int bytes = sizeof(int);
	if (destination.Write(&length, bytes)!=bytes) return false;
	//
	bytes = length;
	if (destination.Write(source.data(), bytes)!=bytes) return false;
	return true;
}

bool SerialAssistant::Load(Sys::IStorer& source, wstring& destination)
{
	int bytes = sizeof(int);
	int length = 0;
	if (source.Read(&length, bytes)!=bytes) return false;
	//
	destination.resize(length);
	bytes = length*sizeof(wchar_t);
	if (source.Read((void*)destination.data(), bytes)!=bytes) return false;
	return true;
}

bool SerialAssistant::Load(Sys::IStorer& source, string& destination)
{
	int bytes = sizeof(int);
	int length = 0;
	if (source.Read(&length, bytes)!=bytes) return false;
	//
	destination.resize(length);
	bytes = length;
	if (source.Read((void*)destination.data(), bytes)!=bytes) return false;
	return true;
}

bool SerialAssistant::Save(Sys::IStorer& destination, const MATRIX& source)
{
	const int size = source.size();
	int bytes = sizeof(int);
	if (destination.Write(&size, bytes)!=bytes) return false;
	for(int i=0; i<size; i++)
	{
		if (Save(destination, source[i])==false) return false;
	}
	return true;
}

bool SerialAssistant::Save(Sys::IStorer& destination, const valarray<double>& source)
{
	const int size = source.size();
	int bytes = sizeof(int);
	if (destination.Write(&size, bytes)!=bytes) return false;
	bytes = sizeof(double);
	double tmp = 0.0;
	for(int i=0; i<size; i++)
	{
		tmp = source[i];
		if (destination.Write(&tmp, bytes)!=bytes) return false;
	}
	return true;
}

bool SerialAssistant::Load(Sys::IStorer& source, MATRIX& destination)
{
	int size = 0;
	int bytes = sizeof(int);
	if (source.Read(&size, bytes)!=bytes) return false;
	destination.resize(size);

	for(int i=0; i<size; i++)
	{
		if (Load(source, destination[i])==false) return false;
	}
	return true;
}

bool SerialAssistant::Load(Sys::IStorer& source, valarray<double>& destination)
{
	int size = 0;
	int bytes = sizeof(int);
	if (source.Read(&size, bytes)!=bytes) return false;
	destination.resize(size);
	double tmp = 0.0;
	bytes = sizeof(double);
	for(int i=0; i<size; i++)
	{
		if (source.Read(&tmp, bytes)!=bytes) return false;
		destination[i] = tmp;
	}
	return true;
}

//______________________________complex
bool SerialAssistant::Save(Sys::IStorer& destination, const MATRIXC& source)
{
	const int size = source.size();
	int bytes = sizeof(int);
	if (destination.Write(&size, bytes)!=bytes) return false;
	for(int i=0; i<size; i++)
	{
		if (Save(destination, source[i])==false) return false;
	}
	return true;
}

bool SerialAssistant::Save(Sys::IStorer& destination, const valarray<complex<double> >& source)
{
	const int size = source.size();
	int bytes = sizeof(int);
	if (destination.Write(&size, bytes)!=bytes) return false;
	bytes = sizeof(complex<double>);
	complex<double> tmp = 0.0;
	for(int i=0; i<size; i++)
	{
		tmp = source[i];
		if (destination.Write(&tmp, bytes)!=bytes) return false;
	}
	return true;
}

bool SerialAssistant::Load(Sys::IStorer& source, MATRIXC& destination)
{
	int size = 0;
	int bytes = sizeof(int);
	if (source.Read(&size, bytes)!=bytes) return false;
	destination.resize(size);

	for(int i=0; i<size; i++)
	{
		if (Load(source, destination[i])==false) return false;
	}
	return true;
}

bool SerialAssistant::Load(Sys::IStorer& source, valarray<complex<double> >& destination)
{
	int size = 0;
	int bytes = sizeof(int);
	if (source.Read(&size, bytes)!=bytes) return false;
	destination.resize(size);
	complex<double> tmp = 0.0;
	bytes = sizeof(complex<double>);
	for(int i=0; i<size; i++)
	{
		if (source.Read(&tmp, bytes)!=bytes) return false;
		destination[i] = tmp;
	}
	return true;
}

//_____________________________________________________________________ FileAssistant
FileAssistant::FileAssistant(void)
{
}

FileAssistant::~FileAssistant(void)
{
}

bool FileAssistant::Save(const wchar_t* filename, const wstring& input)
{
	Sys::File file;
	if (file.CreateForWritting(filename)==false) return false;
	return Sys::SerialAssistant::Save(file, input);
}

bool FileAssistant::Save(const wstring& filename, const wstring& input)
{
	return Save(filename.c_str(), input);
}

bool FileAssistant::Save(const wchar_t* filename, const string& input)
{
	Sys::File file;
	if (file.CreateForWritting(filename)==false) return false;
	return Sys::SerialAssistant::Save(file, input);
}

bool FileAssistant::Save(const wstring& filename, const string& input)
{
	return Save(filename.c_str(), input);
}

bool FileAssistant::Load(const wchar_t* filename, wstring& output)
{
	Sys::File file;
	if (file.CreateForReading(filename)==false) return false;
	return Sys::SerialAssistant::Load(file, output);
}

bool FileAssistant::Load(const wstring& filename, wstring& output)
{
	return Load(filename.c_str(), output);
}

bool FileAssistant::Load(const wchar_t* filename, string& output)
{
	Sys::File file;
	if (file.CreateForReading(filename)==false) return false;
	return Sys::SerialAssistant::Load(file, output);
}

bool FileAssistant::Load(const wstring& filename, string& output)
{
	return Load(filename.c_str(), output);
}

bool FileAssistant::TextSave(const wchar_t* filename, const wstring& input, bool writeOrderByte)
{
	Sys::File file;
	if (file.CreateForWritting(filename)==false) return false;
	const int bytes = input.length()*sizeof(wchar_t);
	if (bytes<=0) return true;
	if (writeOrderByte)
	{
		WORD wByteOrderMark = 0xFEFF;
		if (file.Write(&wByteOrderMark, sizeof(WORD))!=sizeof(WORD)) return false;
	}
	if (file.Write((void*)input.data(), bytes) != bytes) return false;
	return true;
}

bool FileAssistant::TextSave(const wstring& filename, const wstring& input, bool writeOrderByte)
{
	return TextSave(filename.c_str(), input, writeOrderByte);
}

bool FileAssistant::TextSave(const wchar_t* filename, const string& input)
{
	Sys::File file;
	if (file.CreateForWritting(filename)==false) return false;
	const int bytes = input.length()*sizeof(char);
	if (bytes<=0) return true;
	if (file.Write((void*)input.data(), bytes) != bytes) return false;
	return true;
}

bool FileAssistant::TextSave(const wstring& filename, const string& input)
{
	return TextSave(filename.c_str(), input);
}

bool FileAssistant::TextLoad(const wchar_t* filename, wstring& output)
{
	Sys::File file;
	if (file.CreateForReading(filename)==false) return false;
	const int bytes = file.GetSizeInBytes();
	if (bytes<=0) return true;
	output.resize(bytes/sizeof(wchar_t));
	if (file.Read((void*)output.data(), bytes) != bytes) return false;
	return true;
}
bool FileAssistant::TextLoad(const wstring& filename, wstring& output)
{
	return TextLoad(filename.c_str(), output);
}

bool FileAssistant::TextLoad(const wchar_t* filename, string& output)
{
	Sys::File file;
	if (file.CreateForReading(filename)==false) return false;
	const int bytes = file.GetSizeInBytes();
	if (bytes<=0) return true;
	output.resize(bytes/sizeof(char));
	if (file.Read((void*)output.data(), bytes) != bytes) return false;
	return true;
}

bool FileAssistant::TextLoad(const wstring& filename, string& output)
{
	return TextLoad(filename.c_str(), output);
}

bool FileAssistant::Save(const wchar_t* filename, const MATRIX& input)
{
	Sys::File file;
	if (file.CreateForWritting(filename)==false) return false;
	return Sys::SerialAssistant::Save(file, input);
}

bool FileAssistant::Save(const wstring& filename, const MATRIX& input)
{
	return Save(filename.c_str(), input);
}

bool FileAssistant::Save(const wchar_t* filename, const valarray<double>& input)
{
	Sys::File file;
	if (file.CreateForWritting(filename)==false) return false;
	return Sys::SerialAssistant::Save(file, input);
}

bool FileAssistant::Save(const wstring& filename, const valarray<double>& input)
{
	return Save(filename.c_str(), input);
}

bool FileAssistant::Load(const wchar_t* filename, MATRIX& output)
{
	Sys::File file;
	if (file.CreateForReading(filename)==false) return false;
	return Sys::SerialAssistant::Load(file, output);
}

bool FileAssistant::Load(const wstring& filename, MATRIX& output)
{
	return Load(filename.c_str(), output);
}

bool FileAssistant::Load(const wchar_t* filename, valarray<double>& output)
{
	Sys::File file;
	if (file.CreateForReading(filename)==false) return false;
	return Sys::SerialAssistant::Load(file, output);
}

bool FileAssistant::Load(const wstring& filename, valarray<double>& output)
{
	return Load(filename.c_str(), output);
}

bool FileAssistant::CsvSave(const wchar_t* filename, const MATRIX& input)
{
	Sys::File file;
	if (file.CreateForWritting(filename)==false) return false;
	const int rows = input.size();
	if (rows<=0) return true;
	const int cols = input[0].size();
	int i, j;
	char text[64];
	int bytes = 0;
	for(i = 0; i<rows; i++)
	{
		for(j= 0; j<cols; j++)
		{
			if (j==cols-1)
			{
				bytes = sizeof(char) * _snprintf_s(text, 64, _TRUNCATE, "%g", input[i][j]);
			}
			else
			{
				bytes = sizeof(char) * _snprintf_s(text, 64, _TRUNCATE, "%g, ", input[i][j]);
			}
			if (file.Write(text, bytes)!=bytes) return false;
		}
		if (i!=rows-1)
		{
			const char* terminator = "\r\n";
			bytes = 2*sizeof(char);
			if (file.Write(terminator, bytes)!=bytes) return false;
		}
	}
	return true;
}

bool FileAssistant::CsvSave(const wstring& filename, const MATRIX& input)
{
	return CsvSave(filename.c_str(), input);
}

bool FileAssistant::CsvSave(const wchar_t* filename, const valarray<double>& input, bool isRow)
{
	Sys::File file;
	if (file.CreateForWritting(filename)==false) return false;
	const int len = input.size();
	if (len<=0) return true;
	char text[64];
	int bytes = 0;
	int i = 0;
	if (isRow == true)
	{
		for(i = 0; i<len; i++)
		{
			if (i==len-1)
			{
				bytes = sizeof(char) * _snprintf_s(text, 64, _TRUNCATE, "%g", input[i]);
			}
			else
			{
				bytes = sizeof(char) * _snprintf_s(text, 64, _TRUNCATE, "%g, ", input[i]);
			}
			if (file.Write(text, bytes)!=bytes) return false;
		}
	}
	else
	{
		for(i = 0; i<len; i++)
		{
			if (i==len-1)
			{
				bytes = sizeof(char) * _snprintf_s(text, 64, _TRUNCATE, "%g", input[i]);
			}
			else
			{
				bytes = sizeof(char) * _snprintf_s(text, 64, _TRUNCATE, "%g\r\n", input[i]);
			}
			if (file.Write(text, bytes)!=bytes) return false;
		}
	}
	return true;
}

bool FileAssistant::CsvSave(const wstring& filename, const valarray<double>& input, bool isRow)
{
	return CsvSave(filename.c_str(), input, isRow);
}

bool FileAssistant::CsvLoad(const wchar_t* filename, MATRIX& output)
{
	string data;
	Sys::File file;
	if (file.CreateForReading(filename)==false) return false;
	const int bytes = file.GetSizeInBytes();
	data.resize(bytes/sizeof(char));
	if (file.Read((void*)data.data(), bytes)!=bytes) return false;
	Sys::Convert::ToMatrix(data, output);
	return true;
}

bool FileAssistant::CsvLoad(const wstring& filename, MATRIX& output)
{
	return CsvLoad(filename.c_str(), output);
}

bool FileAssistant::CsvLoad(const wchar_t* filename, valarray<double>& output)
{
	string data;
	Sys::File file;
	if (file.CreateForReading(filename)==false) return false;
	const int bytes = file.GetSizeInBytes();
	data.resize(bytes/sizeof(char));
	if (file.Read((void*)data.data(), bytes)!=bytes) return false;
	Sys::Convert::ToVector(data, output);
	return true;
}

bool FileAssistant::CsvLoad(const wstring& filename, valarray<double>& output)
{
	return CsvLoad(filename.c_str(), output);
}

//_________________________________________ complex
bool FileAssistant::Save(const wchar_t* filename, const MATRIXC& input)
{
	Sys::File file;
	if (file.CreateForWritting(filename)==false) return false;
	return Sys::SerialAssistant::Save(file, input);
}

bool FileAssistant::Save(const wstring& filename, const MATRIXC& input)
{
	return Save(filename.c_str(), input);
}

bool FileAssistant::Save(const wchar_t* filename, const valarray<complex<double> >& input)
{
	Sys::File file;
	if (file.CreateForWritting(filename)==false) return false;
	return Sys::SerialAssistant::Save(file, input);
}

bool FileAssistant::Save(const wstring& filename, valarray<complex<double> >& input)
{
	Sys::File file;
	if (file.CreateForWritting(filename.c_str())==false) return false;
	return Sys::SerialAssistant::Save(file, input);
}

bool FileAssistant::Load(const wchar_t* filename, MATRIXC& output)
{
	Sys::File file;
	if (file.CreateForReading(filename)==false) return false;
	return Sys::SerialAssistant::Load(file, output);
}

bool FileAssistant::Load(const wstring& filename, MATRIXC& output)
{
	return Load(filename.c_str(), output);
}

bool FileAssistant::Load(const wchar_t* filename, valarray<complex<double> >& output)
{
	Sys::File file;
	if (file.CreateForReading(filename)==false) return false;
	return Sys::SerialAssistant::Load(file, output);
}

bool FileAssistant::Load(const wstring& filename, valarray<complex<double> >& output)
{
	return Load(filename.c_str(), output);
}

bool FileAssistant::CsvSave(const wchar_t* filename, const MATRIXC& input)
{
	Sys::File file;
	if (file.CreateForWritting(filename)==false) return false;
	const int rows = input.size();
	if (rows<=0) return true;
	const int cols = input[0].size();
	int i, j;
	char text[64];
	int bytes = 0;
	for(i = 0; i<rows; i++)
	{
		for(j= 0; j<cols; j++)
		{
			if (j==cols-1)
			{
				if (input[i][j].imag()>0)
				{
					bytes = sizeof(char) * _snprintf_s(text, 64, _TRUNCATE, "%g + i %g", input[i][j].real(), input[i][j].imag());
				}
				else
				{
					bytes = sizeof(char) * _snprintf_s(text, 64, _TRUNCATE, "%g - i %g", input[i][j].real(), -input[i][j].imag());
				}
			}
			else
			{
				if (input[i][j].imag()>0)
				{
					bytes = sizeof(char) * _snprintf_s(text, 64, _TRUNCATE, "%g + i %g, ", input[i][j].real(), input[i][j].imag());
				}
				else
				{
					bytes = sizeof(char) * _snprintf_s(text, 64, _TRUNCATE, "%g - i %g, ", input[i][j].real(), -input[i][j].imag());
				}
			}
			if (file.Write(text, bytes)!=bytes) return false;
		}
		if (i!=rows-1)
		{
			const char * terminator = "\r\n";
			bytes = 2*sizeof(char);
			if (file.Write(terminator, bytes)!=bytes) return false;
		}
	}
	return true;
}

bool FileAssistant::CsvSave(const wstring& filename, const MATRIXC& input)
{
	return CsvSave(filename.c_str(), input);
}

bool FileAssistant::CsvSave(const wchar_t* filename, valarray<complex<double> >& input, bool isRow)
{
	Sys::File file;
	if (file.CreateForWritting(filename)==false) return false;
	const int len = input.size();
	if (len<=0) return true;
	char text[64];
	int bytes = 0;
	int i = 0;
	if (isRow == true)
	{
		for(int i = 0; i<len; i++)
		{
			if (i==len-1)
			{
				if (input[i].imag()>0)
				{
					bytes = sizeof(char) * _snprintf_s(text, 64, _TRUNCATE, "%g + i %g", input[i].real(), input[i].imag());
				}
				else
				{
					bytes = sizeof(char) * _snprintf_s(text, 64, _TRUNCATE, "%g - i %g", input[i].real(), -input[i].imag());
				}
			}
			else
			{
				if (input[i].imag()>0)
				{
					bytes = sizeof(char) * _snprintf_s(text, 64, _TRUNCATE, "%g + i %g, ", input[i].real(), input[i].imag());
				}
				else
				{
					bytes = sizeof(char) * _snprintf_s(text, 64, _TRUNCATE, "%g - i %g, ", input[i].real(), -input[i].imag());
				}
			}
			if (file.Write(text, bytes)!=bytes) return false;
		}
	}
	else
	{
		for(int i = 0; i<len; i++)
		{
			if (i==len-1)
			{
				if (input[i].imag()>0)
				{
					bytes = sizeof(char) * _snprintf_s(text, 64, _TRUNCATE, "%g + i %g", input[i].real(), input[i].imag());
				}
				else
				{
					bytes = sizeof(char) * _snprintf_s(text, 64, _TRUNCATE, "%g - i %g", input[i].real(), -input[i].imag());
				}
			}
			else
			{
				if (input[i].imag()>0)
				{
					bytes = sizeof(char) * _snprintf_s(text, 64, _TRUNCATE, "%g + i %g\r\n", input[i].real(), input[i].imag());
				}
				else
				{
					bytes = sizeof(char) * _snprintf_s(text, 64, _TRUNCATE, "%g - i %g\r\n", input[i].real(), -input[i].imag());
				}
			}
			if (file.Write(text, bytes)!=bytes) return false;
		}
	}
	return true;
}

bool FileAssistant::CsvSave(const wstring& filename, valarray<complex<double> >& input, bool isRow)
{
	return CsvSave(filename.c_str(), input, isRow);
}

bool FileAssistant::CsvLoad(const wchar_t* filename, MATRIXC& output)
{
	string data;
	Sys::File file;
	if (file.CreateForReading(filename)==false) return false;
	const int bytes = file.GetSizeInBytes();
	data.resize(bytes/sizeof(char));
	if (file.Read((void*)data.data(), bytes)!=bytes) return false;
	Sys::Convert::ToMatrix(data, output);
	return true;
}

bool FileAssistant::CsvLoad(const wstring& filename, MATRIXC& output)
{
	return CsvLoad(filename.c_str(), output);
}

bool FileAssistant::CsvLoad(const wchar_t* filename, valarray<complex<double> >& output)
{
	string data;
	Sys::File file;
	if (file.CreateForReading(filename)==false) return false;
	const int bytes = file.GetSizeInBytes();
	data.resize(bytes/sizeof(char));
	if (file.Read((void*)data.data(), bytes)!=bytes) return false;
	Sys::Convert::ToVector(data, output);
	return true;
}

bool FileAssistant::CsvLoad(const wstring& filename, valarray<complex<double> >& output)
{
	return CsvLoad(filename.c_str(), output);
}

//_____________________________________________________________________ DLLibrary
DLLibray::DLLibray(void)
{
	hLibrary = NULL;
}

DLLibray::~DLLibray(void)
{
	this->Free();
}

void DLLibray::Free(void)
{
	if (hLibrary)
	{
		::FreeLibrary(hLibrary);
		hLibrary = NULL;
	}
}

HINSTANCE DLLibray::GetHinstance()
{
	return hLibrary;
}

bool DLLibray::Load(wchar_t* dllName)
{
	this->Free();
	hLibrary = ::LoadLibrary(dllName);
	return (hLibrary!=NULL);
}

FARPROC DLLibray::GetProcAddress(LPCSTR functionName)
{
	return ::GetProcAddress(hLibrary, functionName);
}

//_____________________________________________________________________EncryptedFile
EncryptedFile::EncryptedFile(void)
{
	Clear();
}

void EncryptedFile::Clear()
{
	m_bRestore = false;
	m_nKey = 0;
	m_nKeySize = 0;
	m_pszKey = NULL;
}

EncryptedFile::~EncryptedFile(void)
{
}

bool EncryptedFile::Encrypt(LPCTSTR lpOriginalFile, LPCTSTR lpDestinationFile, const char* pszKey)
{
	this->m_bRestore = false;
	return this->Encryption(lpOriginalFile, lpDestinationFile, pszKey);
}

bool EncryptedFile::DeEncrypt(LPCTSTR lpOriginalFile, LPCTSTR lpDestinationFile, const char* pszKey)
{
	this->m_bRestore = true;
	return this->Encryption(lpOriginalFile, lpDestinationFile, pszKey);
}

bool EncryptedFile::Encryption(LPCTSTR lpOriginalFile, LPCTSTR lpDestinationFile, const char* pszKey)
{
	DWORD i=0;
	//BYTE pByte[1];
	DWORD dwRead, dwWritten;
	DWORD dwToBeRead = 1;
	Sys::File fileOriginal;
	Sys::File fileDestination;
	BOOL bReadOk= false;
	BOOL bDone=false;
	BOOL bWrittenOk = false;
	int nCoded = 0;
	char buffer[256];

	m_nKey=0;
	if (pszKey==NULL) return false;
	m_pszKey = (char*)pszKey;
	m_nKeySize = (int)strlen(pszKey);

	if (fileOriginal.CreateForReading(lpOriginalFile))
	{
		if (fileDestination.CreateForWritting(lpDestinationFile))
		{
			for(;;)
			{
				dwToBeRead = 256;
				dwRead = fileOriginal.Read(buffer, dwToBeRead);
				if (dwRead == 0) break;
				for(i=0; i<dwRead; i++) buffer[i] = Code(buffer[i]);
				dwWritten = fileDestination.Write(buffer, dwRead);
				if (dwRead != dwWritten ==0) return false;
			}
		}
	}
	Clear();

	return true;
}

/* You must initialize m_nKey before using Code */
unsigned char EncryptedFile::Code(unsigned char nOneLetter)
{
	int nEncryptedData=nOneLetter;
	int nKey=0;
	int nOffset=DATA_LAST_CODE-DATA_FIRST_CODE+1;

	if ((DATA_FIRST_CODE<=nOneLetter) && (nOneLetter<=DATA_LAST_CODE))
	{
		nKey=m_pszKey[m_nKey];
		if (m_bRestore==false)
		{
			nEncryptedData+=nKey;
			while (nEncryptedData>DATA_LAST_CODE)
				nEncryptedData=nEncryptedData-nOffset;					
		}
		else
		{
			nEncryptedData-=nKey;
			while (nEncryptedData<DATA_FIRST_CODE)
				nEncryptedData=nEncryptedData+nOffset;	
		}
		m_nKey++;
		if (m_nKey>=m_nKeySize)
			m_nKey=0;
	}
	return (unsigned char)nEncryptedData;
}

//_____________________________________________________________________Pipe
Pipe::Pipe(void)
{
	m_handle = INVALID_HANDLE_VALUE;
}

// lpName = L"\\\\.\\pipe\\TimeService");
// lpName = L"\\\\ServerName\\pipe\\TimeService");
// nTimeout = 1000 millisec
// nBufferSize = sizeof(struct to move through the pipe)
// You may implement a Server as a Service
bool Pipe::CreateServer(const wchar_t * lpName, DWORD nBufferSize, DWORD nTimeout)
{
	Close();
	m_handle = ::CreateNamedPipe(lpName, 
		PIPE_ACCESS_OUTBOUND | FILE_FLAG_OVERLAPPED,
		PIPE_TYPE_BYTE, 1, nBufferSize, nBufferSize, nTimeout, NULL);
	return (m_handle != INVALID_HANDLE_VALUE);
}

Pipe::~Pipe(void)
{
	Close();
}

bool Pipe::IsOpen()
{
	return (m_handle != INVALID_HANDLE_VALUE);
}

HANDLE Pipe::GetHandle()
{
	return m_handle;
}

bool Pipe::Connect()
{
	ZeroMemory(&m_o, sizeof(OVERLAPPED));
	return (::ConnectNamedPipe(m_handle, &m_o)!=0);
}

BOOL Pipe::Flush()
{
	return (::FlushFileBuffers(m_handle));
}

BOOL Pipe::Disconnect()
{
	return ::DisconnectNamedPipe(m_handle);
}

void Pipe::Close()
{
	if (m_handle != INVALID_HANDLE_VALUE)
	{
		::CloseHandle(m_handle);
		m_handle = INVALID_HANDLE_VALUE;
	}
}

// tienes que pasar un pointer DWORD a lpNumberofBytesWritten 
// nNumberOfBytesToWrite = sizeof(wchar_t)*lstrlen(sz);
BOOL Pipe::Write(LPCVOID lpBuffer, DWORD nNumbOfBytesToWrite, LPDWORD lpNumbOfBytesWritten)
{
	return ::WriteFile(m_handle, lpBuffer, nNumbOfBytesToWrite, lpNumbOfBytesWritten, NULL);
}

BOOL Pipe::Read(LPVOID lpBuffer, DWORD nNumbOfBytesToRead, LPDWORD lpNumbOfBytesRead)
{
	return ::ReadFile(m_handle, lpBuffer, nNumbOfBytesToRead, lpNumbOfBytesRead, NULL);
}

Pipe::operator HANDLE() 
{
	return m_handle;
}

//_____________________________________________________________________ SvgReader
SvgReader::SvgReader(void)
{
}

SvgReader::~SvgReader(void)
{
}

bool SvgReader::CreateFromFile(const wstring& filename)
{
	Sys::File file;
	string asciiText;
	if (Sys::FileAssistant::TextLoad(filename, asciiText) == false) return false;
	Sys::Convert::StringToWstring(asciiText, svgText);
	return true;
}

void SvgReader::CreateFromText(const wchar_t* svgText)
{
	this->svgText = svgText;
}

// the resource must be a UNICODE resource
bool SvgReader::CreateFromResource(HINSTANCE hInst, int resource_id)
{
	string asciiText;
	if (Sys::TextAssistant::LoadFromResource(hInst, resource_id, asciiText)== false) return false;
	Sys::Convert::StringToWstring(asciiText, svgText);
	return true;
}

bool SvgReader::GetBezierPoints(const wchar_t* svg_id, vector<Sys::Point2D>& out_points)
{
	out_points.clear();
	size_t p = FindSvgObject(L"<path ", L" d=\"", svg_id);
	if (p == 0) return false;
	return GetPoints(p, out_points);
}

bool SvgReader::GetPolylinePoints(const wchar_t* svg_id, vector<Sys::Point2D>& out_points)
{
	out_points.clear();
	size_t p = FindSvgObject(L"<polyline ", L" points=\"", svg_id);
	if (p == 0) return false;
	return GetPoints(p, out_points);
}

bool SvgReader::GetPolygonPoints(const wchar_t* svg_id, vector<Sys::Point2D>& out_points)
{
	out_points.clear();
	size_t p = FindSvgObject(L"<polygon ", L" points=\"", svg_id);
	if (p == 0) return false;
	return GetPoints(p, out_points);
}

size_t SvgReader::FindSvgObject(const wchar_t* type, const wchar_t* beginToken, const wchar_t* svg_id)
{
	size_t begin = 0;
	size_t end = 0;
	wstring token;
	bool found = false;

	do
	{
		begin = svgText.find(type, begin);
		if (begin != std::wstring::npos)
		{
			begin += wcslen(type);
			end = svgText.find(L"/>", begin);
			if (end != std::wstring::npos)// ___________________________ We found <type ...  />
			{
				token = L"id=\"";
				token += svg_id;
				token += L"\"";
				begin = svgText.find(token, begin);
				if (begin != std::wstring::npos)
				{
					if (begin < end) // We found <type id="..."  />
					{
						begin += token.length();
						found = true;
						break;
					}
					else
					{
						begin = end; /// This id belongs to next tag. Go to next tag
					}
				}
			}
			else
			{
				begin = end; // Go to next tag
			}
		}
	}
	while (begin != std::wstring::npos);

	//_______________________________________ Get to the beginToken
	if (beginToken == NULL)
	{
		if (found) return begin;
	}
	else
	{
		if (found)
		{
			begin = svgText.find(beginToken, begin);
			if (begin != std::wstring::npos)
			{
				if (begin < end)
				{
					begin += wcslen(beginToken);
					return begin;
				}
			}
		}
	}
	//_________________________ We get here during an error
	return 0;
}

bool SvgReader::GetPoints(size_t begin, vector<Sys::Point2D>& out_points)
{
	//______________________________________ Find end of Svg Object
	size_t end = svgText.find(L"/>", begin);
	if (end == std::wstring::npos) return false;

	//______________________________________ Get the points
	wchar_t text[32];
	bool isRelative = false;
	bool storePoint = false;
	int k = 0;
	wchar_t c;
	int count = 0;
	Sys::Point2D origin;
	Sys::Point2D point;
	double value;

	for(size_t i = begin; i <= end; i++)
	{
		//if (count == 44)
		//{
		//	int x = 10;
		//	x++;
		//}
		c = svgText[i];
		if (k == 32) k = 0;
		if (c == 'M')
		{
			isRelative = false;
		}
		else if (c == 'm')
		{
			storePoint = true;
			isRelative = true;
		}
		else if (c == 'C')
		{
			isRelative = false;
		}
		else if (c == 'c')
		{
			storePoint = true;
			isRelative = true;
			//
			text[k] = '\0';
			k = 0;
			value = _wtof(text);
			ProcessValue(isRelative, value, count, point, origin, storePoint, out_points);
			count++;
		}
		else if (c == 'l')
		{
			storePoint = true;
			isRelative = true;
			//
			text[k] = '\0';
			k = 0;
			value = _wtof(text);
			ProcessValue(isRelative, value, count, point, origin, storePoint, out_points);
			count++;
		}
		else if (c == 'z' || c == 'Z') // Close curve
		{
			// Process last point
			text[k] = '\0';
			k = 0;
			value = _wtof(text);
			ProcessValue(isRelative, value, count, point, origin, storePoint, out_points);
			break;
		}
		else if (IsNumericValid(c))
		{
			text[k++] = c;
		}
		else
		{
			text[k] = '\0';
			if (k == 0) break;
			k = 0;
			value = _wtof(text);
			ProcessValue(isRelative, value, count, point, origin, storePoint, out_points);
			count++;
		}	
	}
	return (count>0);
}

void SvgReader::ProcessValue(bool isRelative, double value, int count, Sys::Point2D& point, Sys::Point2D& origin, bool& storePoint, vector<Sys::Point2D>& out_points)
{
	if (count%2 == 0)
	{
		point.x = (float)value;
	}
	else
	{
		point.y = (float)value;
		//____________________________________ First point is origin
		if (out_points.size() == 0 && storePoint)
		{
			origin = point;
			out_points.push_back(origin);
			return;
		}
		//____________________________________ Move origin
		if (out_points.size()%3 == 0 && storePoint)
		{
			origin.x += point.x;
			origin.y += point.y;
			out_points.push_back(origin);
			return;
		}
		//____________________________________ Add origin to the point
		if (isRelative && out_points.size()%3 != 0)
		{
			point.x += origin.x;
			point.y += origin.y;
		}
		out_points.push_back(point);
	}
}

bool SvgReader::GetRectangle(const wchar_t* svg_id, Sys::Point2D& out_position, Sys::Point2D& out_size)
{
	//_____________________________________ Clear return value
	out_position.x = 0;
	out_position.y = 0;
	out_size.x = 0;
	out_size.y = 0;
	//
	size_t begin = FindSvgObject(L"<rect ", NULL, svg_id);
	if (begin == 0) return false;

	//______________________________________ Find end of Svg Object
	size_t end = svgText.find(L"/>", begin);
	if (end == std::wstring::npos) return false;

	out_position.x = (float)GetDouble(begin, end, L"x=\"");
	out_position.y = (float)GetDouble(begin, end, L"y=\"");
	out_size.x = (float)GetDouble(begin, end, L"width=\"");
	out_size.y = (float)GetDouble(begin, end, L"height=\"");
	return true;
}

double SvgReader::GetDouble(size_t& begin, size_t end, const wchar_t* key)
{
	begin = svgText.find(key, begin);
	if (begin == std::wstring::npos) return 0.0;
	if (begin > end) return 0.0; // invalid object
	begin += wcslen(key);
	wchar_t text[32];
	wchar_t c;
	int k = 0;
	for(size_t i = begin; i<end; i++)
	{
		if (k >=32) k = 0;
		c = svgText[i];
		if (IsNumericValid(c))
		{
			text[k++] = c;
		}
		else
		{
			text[k] = '\0';
			begin = i;
			return _wtof(text);
		}
	}

	return 0.0;
}

bool SvgReader::IsNumericValid(wchar_t c)
{
	if (c == '.') return true;
	if (c == 'E') return true;
	if (c == 'e') return true;
	if (c == '-') return true;
	if ('0' <= c && c <= '9') return true;
	return false;
}


////_____________________________________________________________________XmlNode
//XmlNode::XmlNode(void)
//{
//	m_pszNode = NULL;
//	m_nLength = 0;
//}
//
//XmlNode::~XmlNode(void)
//{
//
//}
//
//bool XmlNode::GetTagName(Data::String& ds)
//{
//	ds.Clear();
//	if (m_pszNode == NULL) return false;
//	wchar_t* p = wcschr (m_pszNode, _T('>'));
//	if (p == NULL) return false;
//	return ds.Set(m_pszNode+1, (int)(p-m_pszNode));
//}
//
//void XmlNode::GetXml(Data::String& ds)
//{
//	ds.Clear();
//	if (m_pszNode!= NULL && m_nLength>0)
//	{
//		ds.Set(m_pszNode, m_nLength);
//	}
//}
//
//bool XmlNode::GetValue(const wchar_t* pszTagName, Data::String& ds, bool bRemoveTags)
//{
//	int nSize = 0;
//	bool bOk = false;
//	ds.Clear();
//	if (pszTagName != NULL)
//	{
//		int nTagLength = lstrlen(pszTagName)+3;
//		wchar_t* pszTagIni = new wchar_t[nTagLength];
//		wchar_t* pszTagEnd = new wchar_t[nTagLength+1];
//		wchar_t* pBegin = NULL;
//		wchar_t* pEnd = NULL;
//
//		lstrcpy(pszTagIni, "<"));
//		lstrcat(pszTagIni, pszTagName);
//		lstrcat(pszTagIni, ">"));
//
//		lstrcpy(pszTagEnd, "</"));
//		lstrcat(pszTagEnd, pszTagName);
//		lstrcat(pszTagEnd, ">"));
//
//		pBegin=wcsstr(m_pszNode, pszTagIni);
//		if (pBegin != NULL)
//		{
//			if (pBegin<(m_pszNode+m_nLength))
//			{
//				pEnd=wcsstr(pBegin+nTagLength, pszTagEnd);
//				if (pEnd!=NULL)
//				{
//					if (pEnd<(m_pszNode+m_nLength))
//					{			
//						if (pEnd>pBegin)
//						{
//							nSize = (int)(pEnd-pBegin-nTagLength+2);
//							if (bRemoveTags)
//							{
//								
//								wchar_t* tmp = new wchar_t[nSize+1];
//								lstrcpyn(tmp, pBegin+nTagLength-1, nSize);
//								tmp[nSize-1]= '\0';
//								CleanValue(tmp, "&lt;"), '<');
//								CleanValue(tmp, "&amp;"), '&');
//								CleanValue(tmp, "&gt;"), '>');
//								CleanValue(tmp, "&quot;"), '"');
//								CleanValue(tmp, "&apos;"), '\'');
//								ds.Set(tmp);
//								bOk = true;
//							}
//							else
//							{
//								ds.Set(pBegin+nTagLength-1, nSize);
//								bOk = true;
//							}
//						}
//					}
//				}
//			}
//		}
//
//		if (pszTagIni) delete [] pszTagIni;
//		if (pszTagEnd) delete [] pszTagEnd;
//	}
//	return bOk;
//}
//
//void XmlNode::Create(const wchar_t* pszNode, int nNodeLength)
//{
//	this->m_pszNode = (wchar_t*)pszNode;
//	this->m_nLength = nNodeLength;
//}
//
//void XmlNode::CleanValue(wchar_t* pszData, const wchar_t* pszReplaceThis, wchar_t cWithThis) 
//{
//	wchar_t* pA=NULL;
//	int i=0, nA=0, nB=0, nReplaceThis=0;
//
//	if (pszReplaceThis!= NULL && pszData!=NULL)
//	{
//		nReplaceThis=lstrlen(pszReplaceThis);
//
//		pA=wcsstr(pszData, pszReplaceThis);
//		while(pA!=NULL)
//		{
//			nA=lstrlen(pA);
//			nB=lstrlen(pszData) - nA;
//			pszData[nB]=cWithThis;
//			for (i=0; i<nA-nReplaceThis+1; i++)
//				pszData[nB+i+1]=pszData[nB+i+nReplaceThis];
//			pA=wcsstr(pszData, pszReplaceThis);
//		}
//	}
//}
//
//int XmlNode::GetChildNodeCount(const wchar_t* pszTagName)
//{
//	int n = 0;
//	if (m_pszNode == NULL) return 0;
//	if (pszTagName == NULL) return 0;
//	if (m_nLength <= 0) return 0;
//
//	int nTagLength = lstrlen(pszTagName)+3;
//	wchar_t* pszTag = new wchar_t[nTagLength];
//	wchar_t* p = NULL;
//	lstrcpy(pszTag, "<"));
//	lstrcat(pszTag, pszTagName);
//	lstrcat(pszTag, ">"));
//	p=wcsstr(m_pszNode, pszTag);
//	if (p == NULL) return 0;
//	if (p>(m_pszNode+m_nLength)) return 0;
//	while(p != NULL && p<(m_pszNode+m_nLength)) 
//	{
//		n++;
//		p+=nTagLength;
//		p=wcsstr(p, pszTag);
//	}
//
//	if (pszTag) delete [] pszTag;
//	return n;
//}
//
//// Returns the number of nodes in the list
//int XmlNode::GetChildNodeList(Data::XmlNodeList& xmlnl, const wchar_t* pszTagName)
//{
//	int n = 0;
//	if (m_pszNode == NULL) return 0;
//	if (pszTagName == NULL) return 0;
//	if (m_nLength == 0) return 0;
//
//	int nTagLength = lstrlen(pszTagName)+3;
//	wchar_t* pszTagIni = new wchar_t[nTagLength];
//	wchar_t* pszTagEnd = new wchar_t[nTagLength+1];
//	wchar_t* pBegin = NULL;
//	wchar_t* pEnd = NULL;
//
//	lstrcpy(pszTagIni, "<"));
//	lstrcat(pszTagIni, pszTagName);
//	lstrcat(pszTagIni, ">"));
//
//	lstrcpy(pszTagEnd, "</"));
//	lstrcat(pszTagEnd, pszTagName);
//	lstrcat(pszTagEnd, ">"));
//
//	//******************************************************** Node Count
//	pBegin=wcsstr(m_pszNode, pszTagIni);
//	if (pBegin == NULL) return 0;
//	if (pBegin>(m_pszNode+m_nLength)) return 0;
//	while(pBegin != NULL && pBegin<(m_pszNode+m_nLength)) 
//	{
//		n++;
//		pBegin+=nTagLength;
//		pBegin=wcsstr(pBegin, pszTagIni);
//	}
//	xmlnl.Create(n);
//	//******************************************************** Setting Nodes
//	n = 0;
//	pBegin=wcsstr(m_pszNode, pszTagIni);
//	if (pBegin == NULL) return 0;
//	if (pBegin>(m_pszNode+m_nLength)) return 0;
//	while(pBegin != NULL && pBegin<(m_pszNode+m_nLength))  
//	{
//		pEnd=wcsstr(pBegin+nTagLength, pszTagEnd);
//		if (pEnd!=NULL)
//		{
//			if (pEnd>pBegin && pEnd<(m_pszNode+m_nLength))
//			{
//				xmlnl.Set(n, pBegin, (int)(pEnd-pBegin+1));
//				n++;
//			}
//		}
//		pBegin+=nTagLength;
//		pBegin=wcsstr(pBegin, pszTagIni);
//	}
//
//	if (pszTagIni) delete [] pszTagIni;
//	if (pszTagEnd) delete [] pszTagEnd;
//	return n;
//}
////_____________________________________________________________________XmlNodeList
//XmlNodeList::XmlNodeList(void)
//{
//	m_pNodes = NULL;
//	m_nCount = 0;
//}
//
//bool XmlNodeList::Create(int size)
//{
//	Clear();
//	if (size<=0) return false;
//	m_pNodes = new Data::XmlNode[size];
//	m_nCount = (m_pNodes == NULL) ? 0 : size; 
//	return (m_pNodes == NULL);
//}
//
//void XmlNodeList::Clear()
//{
//	if (m_pNodes) delete [] m_pNodes;
//	m_pNodes = NULL;
//
//	m_nCount = 0;
//}
//
////_____________________________________________________________________XmlReader
//bool XmlReader::CreateFromFile(const wchar_t* pszFileName)
//{
//	DWORD dwRead = 0;
//	m_psz = (wchar_t*)m_file.Read(pszFileName, dwRead);
//	return (m_psz != NULL);
//}
//
//int XmlReader::GetChildNodeCount(const wchar_t* pszTagName)
//{
//	int n = 0;
//	if (m_psz == NULL) return 0;
//	if (pszTagName == NULL) return 0;
//
//	int nTagLength = lstrlen(pszTagName)+3;
//	wchar_t* pszTag = new wchar_t[nTagLength];
//	wchar_t* pszTagEnd = new wchar_t[nTagLength+1];
//	wchar_t* p = NULL;
//	wchar_t* q = NULL;
//	lstrcpy(pszTag, "<"));
//	lstrcat(pszTag, pszTagName);
//	lstrcat(pszTag, ">"));
//	//
//	lstrcpy(pszTagEnd, "</"));
//	lstrcat(pszTagEnd, pszTagName);
//	lstrcat(pszTagEnd, ">"));
//	//
//	p=wcsstr(m_psz, pszTag);
//	if (p == NULL) return 0;
//	while(p != NULL) 
//	{
//		p+=nTagLength;
//		q = wcsstr(p, pszTagEnd);
//		if (q!=NULL) n++;
//		p=wcsstr(p, pszTag);
//	}
//
//	if (pszTag) delete [] pszTag;
//	if (pszTagEnd) delete [] pszTagEnd;
//	return n;
//}
//
//// Returns the number of nodes in the list
//int XmlReader::GetChildNodeList(Data::XmlNodeList& xmlnl, const wchar_t* pszTagName)
//{
//	int n = 0;
//	if (m_psz == NULL) return 0;
//	if (pszTagName == NULL) return 0;
//
//	int nTagLength = lstrlen(pszTagName)+3;
//	wchar_t* pszTagIni = new wchar_t[nTagLength];
//	wchar_t* pszTagEnd = new wchar_t[nTagLength+1];
//	wchar_t* pBegin = NULL;
//	wchar_t* pEnd = NULL;
//
//	lstrcpy(pszTagIni, "<"));
//	lstrcat(pszTagIni, pszTagName);
//	lstrcat(pszTagIni, ">"));
//
//	lstrcpy(pszTagEnd, "</"));
//	lstrcat(pszTagEnd, pszTagName);
//	lstrcat(pszTagEnd, ">"));
//
//	//******************************************************** Node Count
//	pBegin=wcsstr(m_psz, pszTagIni);
//	if (pBegin == NULL) return 0;
//	while(pBegin != NULL) 
//	{
//		n++;
//		pBegin+=nTagLength;
//		pBegin=wcsstr(pBegin, pszTagIni);
//	}
//	xmlnl.Create(n);
//	//******************************************************** Setting Nodes
//	n = 0;
//	pBegin=wcsstr(m_psz, pszTagIni);
//	if (pBegin == NULL) return 0;
//	while(pBegin != NULL) 
//	{
//		pEnd=wcsstr(pBegin+nTagLength, pszTagEnd);
//		if (pEnd!=NULL)
//		{
//			if (pEnd>pBegin)
//			{
//				xmlnl.Set(n, pBegin, (int)(pEnd-pBegin+1));
//				n++;
//			}
//		}
//		pBegin+=nTagLength;
//		pBegin=wcsstr(pBegin, pszTagIni);
//	}
//
//	if (pszTagIni) delete [] pszTagIni;
//	if (pszTagEnd) delete [] pszTagEnd;
//	return n;
//}

//_____________________________________________________________________ BoolArray

BoolArray::BoolArray(void)
{
	data =NULL;
	count = 0;
}

BoolArray::BoolArray(int bitCount)
{
	data =NULL;
	count = 0;
	this->Create(bitCount);
}

BoolArray::~BoolArray(void)
{
	Delete();
}

int BoolArray::GetCount() const
{
	return count;
}

BoolArray::BoolArray(const BoolArray& init) // Copy constructor
{
	data =NULL;
	count = 0;
	Copy(init);
}

BoolArray& BoolArray::operator =(const BoolArray& init) //Operator =
{
	Delete();
	Copy(init);
	return *this;
}

void BoolArray::Copy(const BoolArray &init)
{
	if (init.data)
	{
		this->Create(init.count);
		const int bytes = count/8 + 1;
		memcpy(data, init.data, bytes);
	}
}

void BoolArray::Delete(void)
{
	if (data) delete [] data;
	data = NULL;
	count = 0;
}

int BoolArray::GetActiveBitCount()
{
	int n = 0;
	for(int i=0; i<count; i++)
		if (GetBit(i)==1) n++;
	return n;
}

void BoolArray::GetString(wchar_t* buffer, int bufferSize)
{
	buffer[0]='\0';

	for(int i=0; i<count && i<bufferSize-1; i++)
	{
		if (GetBit(i)==1)
			lstrcat(buffer, L"1");
		else
			lstrcat(buffer, L"0");
	}
}

void BoolArray::Show(HWND hWnd, const wchar_t* caption)
{
	if (count<=0)
	{
		::MessageBoxW(hWnd, L"-", caption, MB_OK | MB_ICONINFORMATION);
		return;
	}

	wchar_t *texto = new wchar_t[count+1 + count/8 +1];
	texto[0]='\0';
	for(int i=0; i<count; i++)
	{
		if (i%8 == 0 && i>0) lstrcatW(texto, L" "); // a space between each byte
		if (GetBit(i)==1)
			lstrcatW(texto, L"1");
		else
			lstrcatW(texto, L"0");
	}

	::MessageBoxW(hWnd, texto, caption, MB_OK | MB_ICONINFORMATION);
	if (texto) delete [] texto;
}

bool BoolArray::Create(int bitCount)
{
	Delete();
	this->count = bitCount;
	int bytes = count/8 + 1;
	data = new char[bytes];
	if (data) memset(data, 0, bytes);
	return (data!=NULL);
}

bool BoolArray::IsOk()
{
	return data!=NULL;
}

__int8 BoolArray::GetInt8(int arrayIndex) const
{
	if (arrayIndex < 0)  throw L"Sys::BoolArray::GetInt8 invalid index";
	if (arrayIndex >= count/8) throw L"Sys::BoolArray::GetInt8 invalid index";
	__int8 value = -1;
	memcpy(&value, &data[arrayIndex], 1);
	return value;
}

__int16 BoolArray::GetInt16(int arrayIndex) const
{
	if (arrayIndex < 0)  throw L"Sys::BoolArray::GetInt16 invalid index";
	if (arrayIndex >= count/16) throw L"Sys::BoolArray::GetInt16 invalid index";
	__int16 value = -1;
	memcpy(&value, &data[arrayIndex*2], 2);
	return value;
}

__int32 BoolArray::GetInt32(int arrayIndex) const
{
	if (arrayIndex < 0) throw L"Sys::BoolArray::GetInt32 invalid index";
	if (arrayIndex >= count/32) throw L"Sys::BoolArray::GetInt32 invalid index";
	__int32 value = -1;
	memcpy(&value, &data[arrayIndex*4], 4);
	return value;
}

__int64 BoolArray::GetInt64(int arrayIndex) const
{
	if (arrayIndex < 0) throw L"Sys::BoolArray::GetInt64 invalid index";
	if (arrayIndex >= count/64) throw L"Sys::BoolArray::GetInt64 invalid index";
	__int64 value = -1;
	memcpy(&value, &data[arrayIndex*8], 8);
	return value;
}

void BoolArray::SetInt8(int arrayIndex, __int8 value)
{
	if (arrayIndex < 0) throw L"Sys::BoolArray::SetInt8 invalid index";
	if (arrayIndex >= count/8) throw L"Sys::BoolArray::SetInt8 invalid index";
	memcpy(&data[arrayIndex], &value, 1);
}

void BoolArray::SetInt16(int arrayIndex, __int16 value)
{
	if (arrayIndex < 0)  throw L"Sys::BoolArray::SetInt16 invalid index";
	if (arrayIndex >= count/16) throw L"Sys::BoolArray::SetInt16 invalid index";
	memcpy(&data[arrayIndex*2], &value, 2);
}

void BoolArray::SetInt32(int arrayIndex, __int32 value)
{
	if (arrayIndex < 0) throw L"Sys::BoolArray::SetInt32 invalid index";
	if (arrayIndex >= count/32) throw L"Sys::BoolArray::SetInt32 invalid index";
	memcpy(&data[arrayIndex*4], &value, 4);
}

void BoolArray::SetInt64(int arrayIndex, __int64 value)
{
	if (arrayIndex < 0) throw L"Sys::BoolArray::SetInt64 invalid index";
	if (arrayIndex >= count/64) throw L"Sys::BoolArray::SetInt64 invalid index";
	memcpy(&data[arrayIndex*8], &value, 8);
}

// It copies the specified bits from one array to the other one in the same position in both arrays
bool BoolArray::CopyBits(const BoolArray& source, int indexStart, int indexEnd)
{
	if (indexStart < 0) return false;
	if (indexEnd >= count ) return false;
	if (indexStart > indexEnd) return false;
	if (source.GetCount() <= indexEnd) return false;
	const int nstart = indexStart/8;
	const int rstart = indexStart%8;
	const int nend = indexEnd/8;
	const int rend = indexEnd%8;
	const int ndelta = nend-nstart;

	int i;

	if (ndelta == 0) //______________________________ In the same byte block
	{
		if (rstart == 0 && rend == 7) // One block
		{
			data[nstart] = source.data[nstart];
		}
		else
		{
			for(i = indexStart; i <= indexEnd; i++) // bit a bit
			{
				SetBit(i, source.GetBit(i));
			}
		}
	}
	else if (ndelta == 1)//____________________________ In two consecutive byte blocks
	{
		//_________________ First Bits
		if (rstart == 0) // One block
		{
			data[nstart] = source.data[nstart];
		}
		else
		{
			for(i = indexStart; i%8 != 0; i++)
			{
				SetBit(i, source.GetBit(i));
			}
		}
		//_________________ Last Bits
		if (rend == 7) // One block
		{
			data[nend] = source.data[nend];
		}
		else
		{
			for(i = indexEnd; i >0; i--)
			{
				SetBit(i, source.GetBit(i));
				if (i%8 == 0) break;
			}
		}
	}
	else //________________________________________ In three or more consecutive byte blocks
	{
		//_________________ First Bits
		if (rstart == 0) // One block
		{
			data[nstart] = source.data[nstart];
		}
		else
		{
			for(i = indexStart; i%8 != 0; i++)
			{
				SetBit(i, source.GetBit(i));
			}
		}
		//_______________ Copy Byte to Byte
		for(i = nstart+1; i < nend; i++)
		{
			data[i] = source.data[i];
		}
		//_________________ Last Bits
		if (rend == 7) // One block
		{
			data[nend] = source.data[nend];
		}
		else
		{
			for(i = indexEnd; i >0; i--)
			{
				SetBit(i, source.GetBit(i));
				if (i%8 == 0) break;
			}
		}
	}
	return true;
}

bool BoolArray::GetBit(int bitIndex) const
{
	const int n = bitIndex/8;
	const int r = bitIndex%8;
	char c = data[n];
	char tmp = (1<<r);
	return ( (c & tmp) != 0);
}

void BoolArray::SetBit(int bitIndex, bool value)
{
	const int n = bitIndex/8;
	const int r = bitIndex%8;
	if (value)
		data[n] = data[n] | (1<<r);
	else
		data[n] = data[n] & ~(1<<r);
}

void BoolArray::FlipBit(int bitIndex)
{
	const int n = bitIndex/8;
	const int r = bitIndex%8;
	const char c = data[n];
	const char tmp = (1<<r);
	bool value =  ( (c & tmp) != 0);

	if (value==false)
		data[n] = data[n] | (1<<r);
	else
		data[n] = data[n] & ~(1<<r);
}

bool BoolArray::operator==(const Sys::BoolArray& init) const
{
	if (this->count != init.count) return false;
	int n = count/8+1;
	for(int i = 0; i<n; i++)
	{
		if (data[i]!=init.data[i]) return false;
	}
	return true;
}

//______________________________________________________________________ HhpFile
HhpFile::HhpFile()
{
}

HhpFile::~HhpFile()
{
	file.WriteText("\r\n[INFOTYPES]");
}

bool HhpFile::Create(const wchar_t* path, const wchar_t* productName, const wchar_t* title)
{
	wchar_t text[1024];
	string asciiText;
	_snwprintf_s(text, 1024, _TRUNCATE, L"%s\\%s.hhp", path, productName);
	if (file.CreateForWritting(text) == false) return false;

	file.WriteText("[OPTIONS]\r\n");
	file.WriteText("Compatibility=1.1 or later\r\n");
	Sys::Convert::WstringToString(productName, asciiText);
	//________________________________________ Compiled file
	file.WriteText("Compiled file=");
	file.WriteText(asciiText);
	file.WriteText(".chm\r\n");
	//________________________________________ Contents file
	file.WriteText("Contents file=");
	file.WriteText(asciiText);
	file.WriteText(".hhc\r\n");
	//
	file.WriteText("Default topic=index.htm\r\n");
	file.WriteText("Display compile progress=No\r\n");
	file.WriteText("Full-text search=Yes\r\n");
	file.WriteText("Language=0x409 English (United States)\r\n");
	//_______________________________________ Title
	Sys::Convert::WstringToString(title, asciiText);
	file.WriteText("Title=");
	file.WriteText(asciiText);
	file.WriteText("\r\n\r\n[FILES]\r\n");
	return true;
}

bool HhpFile::Create(const wstring& path, const wstring& productName, const wstring& title)
{
	return Create(path.c_str(), productName.c_str(), title.c_str());
}

void HhpFile::AddItem(const wchar_t* filename)
{
	string asciiFilename;
	Sys::Convert::WstringToString(filename, asciiFilename);
	file.WriteText(asciiFilename);
	file.WriteText("\r\n");
}

void HhpFile::AddItem(const wstring& filename)
{
	AddItem(filename.c_str());
}

//______________________________________________________________________ HhcFile
HhcFile::HhcFile()
{
	indentLevel = 0;
}

HhcFile::~HhcFile()
{
	file.WriteText("</UL>\r\n</BODY>\r\n</HTML>");
}

bool HhcFile::Create(const wchar_t* filename, bool useFolderImage)
{
	indentLevel = 0;
	char * head = "<HTML>\r\n\
<HEAD>\r\n\
<meta name=\"GENERATOR\" content=\"Microsoft&reg; HTML Help Workshop 4.1\">\r\n\
<!-- Sitemap 1.0 -->\r\n\
</HEAD><BODY>\r\n\
<OBJECT type=\"text/site properties\">\r\n\
	<param name=\"ImageType\" value=\"Folder\">\r\n\
</OBJECT>\r\n\
<UL>\r\n";
	if (file.CreateForWritting(filename) == false) return false;
	if (file.WriteText(head)==false) return false;
	indentLevel++;
	return true;
}

void HhcFile::AddTabs()
{
	for(int i=0; i<indentLevel; i++) file.WriteText("\t");
}

bool HhcFile::Create(const wstring& filename, bool useFolderImage)
{
	return Create(filename.c_str(), useFolderImage);
}

void HhcFile::AddFolder(const wchar_t* name)
{
	ListItem(name, NULL);
	AddTabs();
	file.WriteText("<UL>\r\n");
	indentLevel++;
}
	
void HhcFile::AddFolderItem(const wchar_t* name, const wchar_t* filename)
{
	ListItem(name, filename);
}

void HhcFile::CloseFolder()
{
	AddTabs();
	file.WriteText("</UL>\r\n");  
	indentLevel--;
}

void HhcFile::ListItem(const wchar_t* itemName, const wchar_t* filename)
{
	AddTabs();
	wchar_t buffer[1024];
	string asciiText;

	_snwprintf_s(buffer, 1024, _TRUNCATE, L"<LI><OBJECT type=\"text/sitemap\">\r\n");
	Sys::Convert::WstringToString(buffer, asciiText);
	file.WriteText(asciiText);
	//___________________________________________________________________ itemName
	AddTabs();
	_snwprintf_s(buffer, 1024, _TRUNCATE, L"\t<param name=\"Name\" value=\"%s\">\r\n", itemName);
	Sys::Convert::WstringToString(buffer, asciiText);
	file.WriteText(asciiText);
	//___________________________________________________________________ filename
	if (filename != NULL)
	{	
		AddTabs();
		_snwprintf_s(buffer, 1024, _TRUNCATE, L"\t<param name=\"Local\" value=\"%s\">\r\n", filename);
		Sys::Convert::WstringToString(buffer, asciiText);
		file.WriteText(asciiText);
	}
	//
	AddTabs();
	file.WriteText("</OBJECT>\r\n");
}

} //____________________________________________________ namespace Sys::End

namespace Mt //________________________________________ namespace Mt::Ini
{
//__________________________________________OverlappedE

//__________________________________________Deque
int Deque::Insert(char *data, int count)
{
	::EnterCriticalSection(&cs);
	int actual = MT_DEQUE_MAX_SIZE-(int)queue.size();
	actual = (actual<0) ? 0 : count;
	for(int i = 0; i<actual; i++) queue.push_back(*data++);
	::LeaveCriticalSection(&cs);
	return actual;
}

int Deque::Extract(char *data, int MAXIMUM)
{
	int i = 0;
	::EnterCriticalSection(&cs);
	while(i<MAXIMUM && queue.size())
	{
		data[i++]=queue.front();
		queue.pop_front();
	}
	::LeaveCriticalSection(&cs);
	return i;
}

int Deque::Peek(char *data, int MAXIMUM)
{
	int i = 0;
	::EnterCriticalSection(&cs);
	if (MAXIMUM>(int)queue.size()) MAXIMUM = (int)queue.size();
	for(i=0; i<MAXIMUM; i++) data[i]=queue.begin()[i];
	::LeaveCriticalSection(&cs);
	return i;
}

int Deque::Extract()
{
	int value = -1;
	::EnterCriticalSection(&cs);
	if (queue.size())
	{
		value = queue.front() & 0xff;
		queue.pop_front();
	}
	::LeaveCriticalSection(&cs);
	return value;
}
//____________________________________________________________EventI

void DisplayLastError(HWND hWnd, wchar_t* pWhere)
{
	if (pWhere==NULL) pWhere = L"Error";
	LPVOID lpMsgBuf;
	FormatMessage( 
		FORMAT_MESSAGE_ALLOCATE_BUFFER | 
		FORMAT_MESSAGE_FROM_SYSTEM | 
		FORMAT_MESSAGE_IGNORE_INSERTS,
		NULL,
		GetLastError(),
		MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
		(LPTSTR) &lpMsgBuf,
		0,
		NULL 
	);
	MessageBox(hWnd, (LPCTSTR)lpMsgBuf, pWhere, MB_OK | MB_ICONERROR);
	LocalFree( lpMsgBuf );
}
//____________________________________________________________CriticalSection
//____________________________________________________________EventI
//____________________________________________________________Gate
//____________________________________________________________MultipleObjects
//____________________________________________________________Long
//____________________________________________________________Bool
//____________________________________________________________IOCport
//____________________________________________________________IOCportTimer
	IOCportTimer::IOCportTimer(void)
{
	m_h = NULL;
	m_group.completionKey = 0;
	m_group.iocp = NULL;
	m_group.running = false;
	m_group.handle = NULL;
}

IOCportTimer::~IOCportTimer(void)
{

}

bool IOCportTimer::Start(Mt::IOCport* iocp, ULONG_PTR completionKey, int iniMillisec, int repeatMillisec)
{
	if (m_group.running) return false;

	LARGE_INTEGER li;
	Destructor();

	m_h = CreateWaitableTimer(NULL, FALSE, NULL);
	if (m_h == NULL) return false;

	li.QuadPart = (-10000)*iniMillisec;
	SetWaitableTimer(m_h, &li, repeatMillisec, NULL, NULL, FALSE);
	m_group.completionKey = completionKey;
	m_group.iocp = iocp;
	m_group.running = true;
	m_group.handle = m_h;
	_beginthread(Repeat, 0, &m_group);

	return true;
}

void IOCportTimer::Repeat(PVOID pvoid)
{
	IOCportTimer::group_* pGroup = (IOCportTimer::group_*)pvoid;
	DWORD dwResult = 0;

	while(pGroup->running)
	{
		dwResult = WaitForSingleObject(pGroup->handle, INFINITE);
		{
			switch(dwResult)
			{
			case WAIT_OBJECT_0:
				pGroup->iocp->PostStatus(pGroup->completionKey);
				break;
			case WAIT_ABANDONED:
				break;
			case WAIT_TIMEOUT:
				break;
//			default:
//				Mt::IOCportTimer::DisplayLastError(L"IOCportTimer::Repeat", false);
			}
		}
	}
	if (pGroup->handle)
	{
		CloseHandle(pGroup->handle);
	}
}

void IOCportTimer::DisplayLastError(const wchar_t* pszWhere, bool bServiceNotification)
{
	LPVOID lpMsgBuf;

	FormatMessage( 
		FORMAT_MESSAGE_ALLOCATE_BUFFER | 
		FORMAT_MESSAGE_FROM_SYSTEM | 
		FORMAT_MESSAGE_IGNORE_INSERTS,
		NULL,
		GetLastError(),
		MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
		(LPTSTR) &lpMsgBuf,
		0,
		NULL 
	);
	MessageBox( NULL, (LPCTSTR)lpMsgBuf, pszWhere, 
		bServiceNotification ? MB_SERVICE_NOTIFICATION : MB_OK | MB_ICONERROR);
	LocalFree( lpMsgBuf );
}

void IOCportTimer::Stop()
{
	m_group.running = false;
	m_h = NULL;
}

void IOCportTimer::Destructor()
{
	if (m_h)
	{
		CloseHandle(m_h);
		m_h = NULL;
	}
}

//____________________________________________________________StringTs
StringTs::StringTs(void)
{
	pData = NULL;
	InitializeCriticalSection(&cs);
}

StringTs::~StringTs(void)
{
	EnterCriticalSection(&cs);
	if (pData) delete [] pData;
	LeaveCriticalSection(&cs);
	//
	DeleteCriticalSection(&cs);
}

bool StringTs::Set(const wchar_t* text)
{
	bool ok = false;
	if (text==NULL) return false;
	EnterCriticalSection(&cs);
	if (pData) delete [] pData;
	pData = new wchar_t[lstrlen(text)+1];
	if (pData) ok = true;
	lstrcpy(pData, text);
	LeaveCriticalSection(&cs);
	return ok;
}

int StringTs::GetLength()
{
	if (pData==NULL) return 0;
	int n;
	EnterCriticalSection(&cs);
	n = lstrlen(pData);
	LeaveCriticalSection(&cs);
	return n;
}

bool StringTs::CopyData(wchar_t* buffer, int bufferSize)
{
	if (buffer==NULL) return false;
	if (pData==NULL)
	{
		buffer[0]='\0';
		return true;
	}
	int n;
	EnterCriticalSection(&cs);
	n = lstrlen(pData)+1;
	if (bufferSize<n) n = bufferSize;
	lstrcpyn(buffer, pData, n);
	LeaveCriticalSection(&cs);
	return true;
}



//Example:
//	wchar_t *info=NULL;
//	stringts.CreateCopyData(&info);
//	edit.SetWindowText(info);
//	if (info) delete [] info;
int StringTs::CreateCopyData(wchar_t** buffer) //It allocates new memory that must be released manually
{
	int length = 0;
	EnterCriticalSection(&cs);
	if (pData)
	{
		length = lstrlen(pData);
		*buffer = new wchar_t[length+1];
		lstrcpy(*buffer, pData);
	}
	LeaveCriticalSection(&cs);
	return length;
}

//Example:
//	wchar_t *info=NULL;
//	stringts.ExtractCopyData(&info);
//	edit.SetWindowText(info);
//	if (info) delete [] info;
int StringTs::ExtractCopyData(wchar_t** buffer) //It allocates new memory that must be released manually
{
	int length = 0;
	EnterCriticalSection(&cs);
	if (pData)
	{
		length = lstrlen(pData);
		*buffer = new wchar_t[length+1];
		lstrcpy(*buffer, pData);
		delete [] pData;
		pData = NULL;
	}
	LeaveCriticalSection(&cs);
	return length;
}
//____________________________________________________________Service
int Service::m_nObjectCount = 0;
bool Service::m_bFirstService = true;

Service::Service(void)
{
	m_nObjectCount++;
	m_bDebug = false;
	m_type = 0;
	m_pData = NULL;
	ZeroMemory(&m_ServiceStatus, sizeof(SERVICE_STATUS));
}

Service::~Service(void)
{
}

bool Service::Remove() 
{
	SC_HANDLE hSCM = NULL;
	SC_HANDLE hService = NULL;
   
	hSCM =  OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
	if (hSCM==NULL)
	{
		DisplayLastError_(L"Remove::OpenSCManager(...)");
		return false;
	}  

   hService = OpenService(hSCM, GetName(), DELETE);
   if (hService==NULL)
	{
		DisplayLastError_(L"Remove::OpenService(...)");
		return false;
	}
	DeleteService(hService);
   CloseServiceHandle(hService);
   CloseServiceHandle(hSCM);
   return true;
}

void Service::DisplayLastError_(const wchar_t* pszWhere)
{
	wchar_t sz[512];
	LPVOID lpMsgBuf;

	if (pszWhere) 
	{
		_snwprintf_s(sz, 512, _TRUNCATE, L"%s %s", GetName(), pszWhere);
	}
	else
	{
		_snwprintf_s(sz, 512, _TRUNCATE, L"%s", GetName());
	}

	FormatMessage( 
		FORMAT_MESSAGE_ALLOCATE_BUFFER | 
		FORMAT_MESSAGE_FROM_SYSTEM | 
		FORMAT_MESSAGE_IGNORE_INSERTS,
		NULL,
		GetLastError(),
		MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
		(LPTSTR) &lpMsgBuf,
		0,
		NULL 
	);
	MessageBox( NULL, (LPCTSTR)lpMsgBuf, sz, MB_OK | MB_ICONERROR);
	LocalFree( lpMsgBuf );
}

void Service::DisplayLastError(const wchar_t* pszWhere, bool bServiceNotification)
{
	LPVOID lpMsgBuf;

	FormatMessage( 
		FORMAT_MESSAGE_ALLOCATE_BUFFER | 
		FORMAT_MESSAGE_FROM_SYSTEM | 
		FORMAT_MESSAGE_IGNORE_INSERTS,
		NULL,
		GetLastError(),
		MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
		(LPTSTR) &lpMsgBuf,
		0,
		NULL 
	);
	MessageBox( NULL, (LPCTSTR)lpMsgBuf, pszWhere, 
		bServiceNotification ? MB_SERVICE_NOTIFICATION : MB_OK | MB_ICONERROR);
	LocalFree( lpMsgBuf );
}

wchar_t* Service::GetDisplayName()
{
	return L"Unknown Service Display Name.";
}

wchar_t* Service::GetName()
{
	return L"UnknownServiceName.";
}

wchar_t* Service::GetDescription()
{
	return L"Provides unknown services.";
}

// pszUserName => DomainName\UserName
bool Service::Install(const wchar_t* pszUserName, const wchar_t* pszPassword) 
{
	wchar_t szModulePathname[512];
	SC_HANDLE hSCM = NULL;
	SC_HANDLE hService = NULL;
	SERVICE_DESCRIPTION sd;
   
	hSCM =  OpenSCManager(NULL, NULL, SC_MANAGER_CREATE_SERVICE);
	if (hSCM==NULL)
	{
		DisplayLastError_(L"Install::OpenSCManager(...)");
		return false;
	}
   GetModuleFileName(NULL, szModulePathname, 512);
   lstrcat(szModulePathname, L" -service");   

   hService = CreateService(hSCM, GetName(), GetDisplayName(),
         SERVICE_ALL_ACCESS,//  SERVICE_CHANGE_CONFIG
		 (m_nObjectCount == 1) ? SERVICE_WIN32_OWN_PROCESS : SERVICE_WIN32_SHARE_PROCESS, 
         SERVICE_AUTO_START, // SERVICE_DEMAND_START
		 SERVICE_ERROR_IGNORE,
         szModulePathname, NULL, NULL, NULL, pszUserName, pszPassword);
   if (hService==NULL)
	{
		DisplayLastError_(L"Install::CreateService(...)");
		return false;
	}
	sd.lpDescription 	= GetDescription();
	ChangeServiceConfig2(hService, SERVICE_CONFIG_DESCRIPTION, &sd);
	CloseServiceHandle(hService);
	CloseServiceHandle(hSCM);
   return true;
}

DWORD WINAPI Service::HandlerEx(DWORD control, DWORD type, PVOID pData, PVOID pContext) 
{
	DWORD result = ERROR_CALL_NOT_IMPLEMENTED;
	Mt::Service* pService = (Mt::Service*)pContext;

   switch (control) 
   {
   case SERVICE_CONTROL_STOP:
	   result = pService->OnControlStop(type, pData);
	   break;
   case SERVICE_CONTROL_SHUTDOWN:
		result = pService->OnControlShutdown(type, pData);
		break;
   case SERVICE_CONTROL_PAUSE:
		result = pService->OnControlPause(type, pData);
		break;
   case SERVICE_CONTROL_CONTINUE:
		result = pService->OnControlContinue(type, pData);
		break;
   case SERVICE_CONTROL_INTERROGATE:
		result = pService->OnControlInterrogate(type, pData);
	   break;
   case SERVICE_CONTROL_PARAMCHANGE:
		result = pService->OnControlParamChange(type, pData);
		break;
   case SERVICE_CONTROL_DEVICEEVENT:
	   result = pService->OnControlDeviceEvent(type, pData);
	   break;
   case SERVICE_CONTROL_HARDWAREPROFILECHANGE:
	   result = pService->OnControlHardwareProfileChange(type, pData);
	   break;
   case SERVICE_CONTROL_POWEREVENT:
	   result = pService->OnControlPowerEvent(type, pData);
	   break;
	//case 128:   // User-define code just for testing
	//   break; ...
	//case 255:   // User-define code just for testing
	//   break;
   }

   return result;
}

DWORD Service::OnControlStop(DWORD type, PVOID pData)
{
	if (m_ServiceStatus.dwCurrentState == SERVICE_STOPPED) return NO_ERROR;
	if (m_ServiceStatus.dwCurrentState == SERVICE_STOP_PENDING) return NO_ERROR;
	m_type = type;
	m_pData = pData;
	m_gate.WaitToOpen();
	m_ServiceStatus.dwCurrentState = SERVICE_STOP_PENDING;
	m_ServiceStatus.dwWin32ExitCode = NO_ERROR;
	m_ServiceStatus.dwServiceSpecificExitCode = 0;
	m_ServiceStatus.dwCheckPoint = 1; 
	m_ServiceStatus.dwWaitHint = 2000;
	if (m_bDebug==false) ::SetServiceStatus(m_hss, &m_ServiceStatus);
	inputOutputCompletionPort.PostStatus(Mt::Service::Control, SERVICE_CONTROL_STOP);
	return NO_ERROR;
}

DWORD Service::OnControlPause(DWORD type, PVOID pData)
{
	if (m_ServiceStatus.dwCurrentState == SERVICE_PAUSED) return NO_ERROR;
	if (m_ServiceStatus.dwCurrentState == SERVICE_PAUSE_PENDING) return NO_ERROR;
	m_type = type;
	m_pData = pData;
	m_gate.WaitToOpen();
	m_ServiceStatus.dwCurrentState = SERVICE_PAUSE_PENDING;
	m_ServiceStatus.dwWin32ExitCode = NO_ERROR;
	m_ServiceStatus.dwServiceSpecificExitCode = 0;
	m_ServiceStatus.dwCheckPoint = 1; 
	m_ServiceStatus.dwWaitHint = 2000;
	if (m_bDebug==false) ::SetServiceStatus(m_hss, &m_ServiceStatus);
	inputOutputCompletionPort.PostStatus(Mt::Service::Control, SERVICE_CONTROL_PAUSE);
	return NO_ERROR;
}

DWORD Service::OnControlContinue(DWORD type, PVOID pData)
{
	if (m_ServiceStatus.dwCurrentState == SERVICE_RUNNING) return NO_ERROR;
	if (m_ServiceStatus.dwCurrentState == SERVICE_CONTINUE_PENDING) return NO_ERROR;
	m_type = type;
	m_pData = pData;
	m_gate.WaitToOpen();
	m_ServiceStatus.dwCurrentState = SERVICE_CONTINUE_PENDING;
	m_ServiceStatus.dwWin32ExitCode = NO_ERROR;
	m_ServiceStatus.dwServiceSpecificExitCode = 0;
	m_ServiceStatus.dwCheckPoint = 1; 
	m_ServiceStatus.dwWaitHint = 2000;
	if (m_bDebug==false) ::SetServiceStatus(m_hss, &m_ServiceStatus);
	inputOutputCompletionPort.PostStatus(Mt::Service::Control, SERVICE_CONTROL_CONTINUE);
	return NO_ERROR;
}

DWORD Service::OnControlShutdown(DWORD type, PVOID pData)
{
	if (m_ServiceStatus.dwCurrentState == SERVICE_STOPPED) return NO_ERROR;
	if (m_ServiceStatus.dwCurrentState == SERVICE_STOP_PENDING) return NO_ERROR;
	m_type = type;
	m_pData = pData;
	m_gate.WaitToOpen();
	m_ServiceStatus.dwCurrentState = SERVICE_STOP_PENDING;
	m_ServiceStatus.dwWin32ExitCode = NO_ERROR;
	m_ServiceStatus.dwServiceSpecificExitCode = 0;
	m_ServiceStatus.dwCheckPoint = 1; 
	m_ServiceStatus.dwWaitHint = 2000;
	if (m_bDebug==false) ::SetServiceStatus(m_hss, &m_ServiceStatus);
	inputOutputCompletionPort.PostStatus(Mt::Service::Control, SERVICE_CONTROL_SHUTDOWN);
	return NO_ERROR;
}

DWORD Service::OnControlInterrogate(DWORD type, PVOID pData)
{
	::SetServiceStatus(m_hss, &m_ServiceStatus);
	return NO_ERROR;
}

DWORD Service::OnControlParamChange(DWORD type, PVOID pData)
{
	return ERROR_CALL_NOT_IMPLEMENTED;
}

DWORD Service::OnControlDeviceEvent(DWORD type, PVOID pData)
{
	return ERROR_CALL_NOT_IMPLEMENTED;
}

DWORD Service::OnControlHardwareProfileChange(DWORD type, PVOID pData)
{
	return ERROR_CALL_NOT_IMPLEMENTED;
}

DWORD Service::OnControlPowerEvent(DWORD type, PVOID pData)
{
	return ERROR_CALL_NOT_IMPLEMENTED;
}

void WINAPI Service::ServiceMain(DWORD dwArgc, PTSTR* pszArgv)
{
	DWORD dwControl = 0;
	OVERLAPPED *po = NULL;
	Mt::Service::CompletionKey ck = Mt::Service::Control;

	m_ServiceStatus.dwCurrentState = SERVICE_START_PENDING;
	m_ServiceStatus.dwWin32ExitCode = NO_ERROR;
	m_ServiceStatus.dwServiceSpecificExitCode = 0;
	m_ServiceStatus.dwCheckPoint = 1; 
	m_ServiceStatus.dwWaitHint = 2000;

	if (m_bDebug == false) 
	{
		m_hss = RegisterServiceCtrlHandlerEx(GetName(), HandlerEx, this);
		if (m_hss == 0) 
		{
			m_ServiceStatus.dwCurrentState = SERVICE_STOPPED;
			m_ServiceStatus.dwWin32ExitCode = ERROR_INVALID_HANDLE;
			m_ServiceStatus.dwServiceSpecificExitCode = 0;
			m_ServiceStatus.dwCheckPoint = 0; 
			m_ServiceStatus.dwWaitHint = 0;
			if (m_bDebug==false) ::SetServiceStatus(m_hss, &m_ServiceStatus);
		return;
		}
	}
	m_ServiceStatus.dwControlsAccepted 
		= SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_SHUTDOWN; // | SERVICE_ACCEPT_PAUSE_CONTINUE
	m_ServiceStatus.dwServiceType 
		= (m_nObjectCount == 1) ? SERVICE_WIN32_OWN_PROCESS : SERVICE_WIN32_SHARE_PROCESS;

	m_ServiceStatus.dwCurrentState = SERVICE_START_PENDING;
	m_ServiceStatus.dwWin32ExitCode = NO_ERROR;
	m_ServiceStatus.dwServiceSpecificExitCode = 0;
	m_ServiceStatus.dwCheckPoint = 1; 
	m_ServiceStatus.dwWaitHint = 2000;
	if (m_bDebug==false) ::SetServiceStatus(m_hss, &m_ServiceStatus);
	OnStart(dwArgc, pszArgv);
	m_ServiceStatus.dwCurrentState = SERVICE_RUNNING;
	m_ServiceStatus.dwWin32ExitCode = NO_ERROR;
	m_ServiceStatus.dwServiceSpecificExitCode = 0;
	m_ServiceStatus.dwCheckPoint = 0; 
	m_ServiceStatus.dwWaitHint = 0;
	if (m_bDebug==false) ::SetServiceStatus(m_hss, &m_ServiceStatus);
	m_gate.Open();

	while (m_ServiceStatus.dwCurrentState != SERVICE_STOPPED)
	{
		// Sleep until a control code comes in or a client connects
		inputOutputCompletionPort.GetStatus((ULONG_PTR *)&ck, &dwControl, &po);;
		switch(ck)
		{
		case Mt::Service::Control:
			switch(dwControl)
			{
				case SERVICE_CONTROL_CONTINUE:
					OnContinue();
					m_ServiceStatus.dwCurrentState = SERVICE_RUNNING;
					m_ServiceStatus.dwWin32ExitCode = NO_ERROR;
					m_ServiceStatus.dwServiceSpecificExitCode = 0;
					m_ServiceStatus.dwCheckPoint = 0; 
					m_ServiceStatus.dwWaitHint = 0;
					if (m_bDebug==false) ::SetServiceStatus(m_hss, &m_ServiceStatus);
					m_gate.Open();
					break;
				case SERVICE_CONTROL_PAUSE:
					OnPause();
					m_ServiceStatus.dwCurrentState = SERVICE_PAUSED;
					m_ServiceStatus.dwWin32ExitCode = NO_ERROR;
					m_ServiceStatus.dwServiceSpecificExitCode = 0;
					m_ServiceStatus.dwCheckPoint = 0; 
					m_ServiceStatus.dwWaitHint = 0;
					if (m_bDebug==false) ::SetServiceStatus(m_hss, &m_ServiceStatus);
					m_gate.Open();
					break;
				case SERVICE_CONTROL_STOP:
					OnStop();
					m_ServiceStatus.dwCurrentState = SERVICE_STOPPED;
					m_ServiceStatus.dwWin32ExitCode = NO_ERROR;
					m_ServiceStatus.dwServiceSpecificExitCode = 0;
					m_ServiceStatus.dwCheckPoint = 0; 
					m_ServiceStatus.dwWaitHint = 0;
					if (m_bDebug==false) ::SetServiceStatus(m_hss, &m_ServiceStatus);
					m_gate.Open();
					break;
			}
			break;
		case Mt::Service::Server:
			if (m_ServiceStatus.dwCurrentState != SERVICE_PAUSED)
			{
				OnRequestProcessing();
			}
			break;
		}
	}
}

void Service::OnStart(DWORD dwArgc, PTSTR* pszArgv)
{
	// Initialization of the servide
}

void Service::OnStop()
{
	// Cleaning up
}

void Service::OnPause()
{
}

void Service::OnContinue()
{
}

void Service::OnRequestProcessing()
{
	// This is where the actual work is done
}

void Service::Run(const wchar_t* pszUserName, const wchar_t* pszPassword, wchar_t* lpCmdLine, LPSERVICE_MAIN_FUNCTION pServiceFunction)
{
	if (lpCmdLine != NULL)
	{
		if (lstrlen(lpCmdLine)>0)
		{
			if (_tcsstr(L"-install", lpCmdLine)!=NULL || _tcsstr(L"-INSTALL", lpCmdLine)!=NULL) 
			{
				this->Install(pszUserName, pszPassword);
			}
			if (_tcsstr(L"-remove", lpCmdLine)!=NULL || _tcsstr(L"-REMOVE", lpCmdLine)!=NULL)
			{
				this->Remove();
			}
			if (_tcsstr(L"-debug", lpCmdLine)!=NULL || _tcsstr(L"-DEBUG", lpCmdLine)!=NULL)
			{
				m_bDebug = true;
			}
			if (_tcsstr(L"-list", lpCmdLine)!=NULL || _tcsstr(L"-LIST", lpCmdLine)!=NULL) 
			{
				MessageBox(NULL, GetDescription(), GetName(), MB_OK);
			}
		}
		else
		{
			if (m_bFirstService)
			{
				m_bFirstService = false;
				wchar_t szBuffer[512];
				wchar_t szModulePathname[512];
				wchar_t *sz =  L"[-install] [-remove] [-debug] [-list]  \
[-service]\r\n\
	-install   Installs the service in the SCM's database.\r\n\
	-remove   Removes the service from the SCM's database.\r\n\
	-debug  Runs the service as a normal process for debugging.\r\n\
	-list  List all services.\r\n\
	-service   Runs the process as a service (should only be set in the SCM's database).";

				GetModuleFileName(NULL, szModulePathname, 512);

	_snwprintf_s(szBuffer, 512, _TRUNCATE, L"Usage: \r\n%s\r\n%s", szModulePathname, sz);

				
				::MessageBox(NULL, szBuffer, L"Service Setup", MB_OK);
			}
		}
	}
}
//____________________________________________________________ IThread

//____________________________________________________________ ThreadObject
ThreadObject::ThreadObject(void)
{
	hThread = NULL;
	threadId = 0;
	ithread = NULL;
}

ThreadObject::~ThreadObject(void)
{
	if (hThread) this->WaitForExit();
}

bool ThreadObject::StartThread(IThread& ithread)
{
	this->ithread = &ithread;
	running.Set(true);
	progress.Set(0.0);
	stopwatch.Start();
	resetTime.Set(false);
	hThread=(HANDLE)_beginthreadex(NULL, 0, PrivateThreadFunc, (LPVOID)this, 0, &threadId);
	return (hThread!=NULL);
}

void ThreadObject::WaitForExit()
{
	::WaitForSingleObject(hThread, INFINITE);
	CloseHandle(hThread);
	hThread = NULL;
	running.Set(false);
	ithread = NULL;
}

unsigned WINAPI ThreadObject::PrivateThreadFunc(LPVOID param)
{
	ThreadObject* pto = (ThreadObject*)param;
	if (pto->ithread == NULL) return 0;
	return pto->ithread->ThreadFunc(pto->running, pto->progress, pto->resetTime);
}

wchar_t* ThreadObject::GetTimeLeftText()
{
	bool reset_time;
	if (resetTime.GetTry(reset_time))
	{
		if (reset_time) 
		{
			stopwatch.Start();
			resetTime.Set(false);
		}
	}
	double dprogress = 0.0;
	if (this->progress.GetTry(dprogress) == false) return L"Running ...";
	if (dprogress==0.0) return L"Initializing ...";
	
	const double seconds = stopwatch.GetSeconds();
	if (seconds == 0) return L"Running ...";
	const unsigned int remainingSeconds = (int)(seconds*(100.0-dprogress)/dprogress);
	//const unsigned int remainingSeconds = (int)(100.0*seconds/dprogress-seconds);
	const int remainingSec = remainingSeconds%3600;
	const int minOut = remainingSec/60;
	const int secOut = remainingSec%60; 
	const int hrOut = remainingSeconds/3600;
	const int dayOut = hrOut/24;
	const int hrLeft = hrOut%24;
	if (remainingSeconds==0)
	{
		text[0]='\0';
		//_snwprintf_s(text, 64, _TRUNCATE, L"%s", L"Almost done!");
	}
	else if (remainingSeconds<60)
	{
		_snwprintf_s(text, 64, _TRUNCATE, L"Time left: %d seconds", secOut);
	}
	else if (remainingSeconds<3600)
	{
		if (minOut==1 && secOut > 30)
			_snwprintf_s(text, 64, _TRUNCATE, L"Time left:  %d minutes", 2);
		else if (minOut==1)
			_snwprintf_s(text, 64, _TRUNCATE, L"Time left:  %d minute", 1);
		else
			_snwprintf_s(text, 64, _TRUNCATE, L"Time left:  %d minutes", minOut);
	}
	else if (remainingSeconds<86400)
	{
		if (hrOut==1 && minOut==1)
			_snwprintf_s(text, 64, _TRUNCATE, L"Time left:  %d hr+%d min", hrOut, minOut);
		else if (hrOut==1 && minOut!=1)
			_snwprintf_s(text, 64, _TRUNCATE, L"Time left:  %d hr+%d mins", hrOut, minOut);
		else if (hrOut!=1 && minOut==1)
			_snwprintf_s(text, 64, _TRUNCATE, L"Time left:  %d hrs+%d min", hrOut, minOut);
		else
			_snwprintf_s(text, 64, _TRUNCATE, L"Time left:  %d hrs+%d mins", hrOut, minOut);
	}
	else
	{
		if (dayOut==1 && hrLeft==1)
			_snwprintf_s(text, 64, _TRUNCATE, L"Time left:  %d day+%d hr", dayOut, hrLeft);
		else if (dayOut==1 && hrLeft!=1)
			_snwprintf_s(text, 64, _TRUNCATE, L"Time left:  %d day+%d hrs", dayOut, hrLeft);
		else if (dayOut!=1 && hrLeft==1)
			_snwprintf_s(text, 64, _TRUNCATE, L"Time left:  %d days+%d hr", dayOut, hrLeft);
		else
			_snwprintf_s(text, 64, _TRUNCATE, L"Time left:  %d days+%d hrs", dayOut, hrLeft);
	}
	return text;
}

//____________________________________________________________OverlappedE


#ifdef WIN_SOCKETS_SUPPORT
//____________________________________________________________________ Smtp
Smtp::Smtp()
{
	errorDescr[0] = '\0';
}

Smtp::~Smtp()
{
}

DWORD Smtp::ThreadFunc(Mt::BoolTs& running, Mt::DoubleTs& progress, Mt::BoolTs& resetTime)
{
	running.SetTry(true);
	progress.SetTry(0.0);
	errorDescr[0] = '\0';
	if (emailList.size() == 0)
	{
		running.Set(false);
		progress.Set(100.0);
		return 0;
	}

	Sys::Socket skt;
	const int count = emailList.size();
	if (count == 0) return 0;
	int trials=0;
	state = WIN_SOCKET_INITIAL;
	wchar_t * error = NULL;
	bool brunning = false;
	const int total = (WIN_SOCKET_PASSWORD - WIN_SOCKET_INITIAL+1) // Conexion
		+ count * (WIN_SOCKET_ATTACH_END - WIN_SOCKET_PASSWORD +1);

	while(trials < 16)
	{
		switch(state)
		{
		case WIN_SOCKET_INITIAL: 
			{
				wstring server_name;
				Sys::Convert::StringToWstring(serverName, server_name);
				error = skt.Connect(server_name.c_str(), 25);
				if (error == NULL)
				{
					state = WIN_SOCKET_CONNECTED;
					continue;
				}
				_snwprintf_s(errorDescr, 256, _TRUNCATE, L"%s", error);
				running.Set(false);
				progress.Set(false);
				break;
			}
			break;
		case WIN_SOCKET_CONNECTED:
			if (skt.ReceiveCode() == 220) state = WIN_SOCKET_WELCOME;
			break;
		case WIN_SOCKET_WELCOME:
			if (SendHELO(skt) == true)
			{
				if (skt.ReceiveCode() == 250) state = WIN_SOCKET_HELO;
			}
			break;
		case WIN_SOCKET_HELO:
			if (username.length() == 0)
			{
				state = WIN_SOCKET_PASSWORD;
				trials = 1000; // Exit now
				break;
			}
			if (SendAUTH(skt) == true)
			{
				if (skt.ReceiveCode() == 334) state = WIN_SOCKET_AUTH;
			}
			break;
		case WIN_SOCKET_AUTH:
			if (SendUsername(skt) == true)
			{
				if (skt.ReceiveCode() == 334) state = WIN_SOCKET_USERNAME;
			}
			break;
		case WIN_SOCKET_USERNAME:
			if (SendPassword(skt) == true)
			{
				if (skt.ReceiveCode() == 235)
				{
					trials = 1000;//Exit now
					state = WIN_SOCKET_PASSWORD;
				}
			}
			break;
		}

		trials++;
	}
	if (running.GetTry(brunning))
	{
		if (brunning == false) return 0;
	}
	if (state != WIN_SOCKET_PASSWORD) return 0;
	int index = 0;
	trials = 0;
	while(trials < 40)
	{
		switch (state)
		{
		case WIN_SOCKET_PASSWORD:
			if (SendMAILFrom(skt, emailList[index]) == true)
			{
				if (skt.ReceiveCode() == 250) state = WIN_SOCKET_MAILFROM;
			}
			break;
		case WIN_SOCKET_MAILFROM:
			if (SendRCPTTo(skt, emailList[index]) == true)
			{
				if (skt.ReceiveCode() == 250) state = WIN_SOCKET_RCPTTO;
			}
			break;
		case WIN_SOCKET_RCPTTO:
			if (SendDATA(skt) == true) state = WIN_SOCKET_DATA;
			break;
		case WIN_SOCKET_DATA:
			if (SendTimeHeader(skt) == true)
			{
				if (skt.ReceiveCode() == 354) state = WIN_SOCKET_TIMEHEADER;
			}
			break;
		case WIN_SOCKET_TIMEHEADER:
			if (SendFrom(skt, emailList[index]) == true) state = WIN_SOCKET_FROM;
			break;
		case WIN_SOCKET_FROM:
			if (SendSender(skt, emailList[index]) == true) state = WIN_SOCKET_SENDER;
			break;
		case WIN_SOCKET_SENDER:
			if (SendReplyTo(skt, emailList[index]) == true) state = WIN_SOCKET_REPLYTO;
			break;
		case WIN_SOCKET_REPLYTO:
			if (SendSubject(skt, emailList[index]) == true) state = WIN_SOCKET_SUBJECT;
			break;
		case WIN_SOCKET_SUBJECT:
			if (SendTo(skt, emailList[index]) == true) state = WIN_SOCKET_TO;
			break;
		case WIN_SOCKET_TO:
			if (SendMime(skt, emailList[index]) == true) state = WIN_SOCKET_MIME;
			break;
		case WIN_SOCKET_MIME:
			if (SendMultipartMixed(skt, emailList[index]) == true) state = WIN_SOCKET_MULTIPART_MIXED;
			break;
			//_________________________________________________ BODY
		case WIN_SOCKET_MULTIPART_MIXED:
			if (SendBodyFrontier(skt, emailList[index]) == true) state = WIN_SOCKET_BODY_FRONTIER;
			break;
		case WIN_SOCKET_BODY_FRONTIER:
			if (SendBodyContentType(skt, emailList[index]) == true) state = WIN_SOCKET_BODY_CONTENT_TYPE;
			break;
		case WIN_SOCKET_BODY_CONTENT_TYPE:
			if (SendBlankLine(skt) == true) state = WIN_SOCKET_BODY_BLANK1;
			break;
		case WIN_SOCKET_BODY_BLANK1:
			if (SendBody(skt, emailList[index]) == true) state = WIN_SOCKET_BODY;
			break;
		case WIN_SOCKET_BODY:
			if (SendBlankLine(skt) == true) state = WIN_SOCKET_BODY_BLANK2;
			break;
		//___________________________________________________ ATTACHMENT
		case WIN_SOCKET_BODY_BLANK2:
			if (SendAttachmentFrontier(skt, emailList[index]) == true) state = WIN_SOCKET_ATTACH_FRONTIER;
			break;
		case WIN_SOCKET_ATTACH_FRONTIER:
			if (SendAttachmentContentType(skt, emailList[index]) == true) state = WIN_SOCKET_ATTACH_CONTENT_TYPE;
			break;
		case WIN_SOCKET_ATTACH_CONTENT_TYPE:
			if (SendAttachmentTransferEncoding(skt, emailList[index]) == true) state = WIN_SOCKET_ATTACH_TRANSFER_ENCODING;
			break;
		case WIN_SOCKET_ATTACH_TRANSFER_ENCODING:
			if (SendAttachmentContentDisposition(skt, emailList[index]) == true) state = WIN_SOCKET_ATTACH_CONTENT_DISPOSITION;
			break;
		case WIN_SOCKET_ATTACH_CONTENT_DISPOSITION:
			if (SendBlankLine(skt) == true) state = WIN_SOCKET_ATTACH_BLANK1;
			break;
		case WIN_SOCKET_ATTACH_BLANK1:
			if (SendAttachment(skt, emailList[index]) == true) state = WIN_SOCKET_ATTACH;
			break;
		case WIN_SOCKET_ATTACH:
			if (SendBlankLine(skt) == true) state = WIN_SOCKET_ATTACH_BLANK2;
			break;
		case WIN_SOCKET_ATTACH_BLANK2:
			if (SendAttachmentEnd(skt, emailList[index]) == true) state = WIN_SOCKET_ATTACH_END;
			break;
		case WIN_SOCKET_ATTACH_END:
			if (SendDATAEnd(skt) == true)
			{	
				if (skt.ReceiveCode() == 250) state = WIN_SOCKET_DATA_END;
			}
			break;
		//____________________________________________________
		case WIN_SOCKET_DATA_END:
			state = WIN_SOCKET_PASSWORD; // Return for next message
			trials = 0;
			index ++;
			progress.SetTry(index/(double)count);
			if (index >= count)
			{
				trials = 1000; //Exit now
				state = WIN_SOCKET_DONE;
			}
			break;
		}
		trials++;
		if (running.GetTry(brunning))
		{
			if (brunning == false) return 0;
		}
	}
	if (SendQuit(skt) == true)
	{
		if (skt.ReceiveCode() == 221) state = WIN_SOCKET_DONE;
	}
	skt.Disconnect();
	running.Set(false);
	return 0;
}

wchar_t* Smtp::TestConnection(const wchar_t* smtpServerName)
{
	Sys::Socket skt;
	wchar_t * error = skt.Connect(smtpServerName, 25);
	if (error) return error;
	if (skt.ReceiveCode() != 220) return L"Incorrect response from the server";
	SendQuit(skt);
	skt.Disconnect();
	return NULL;
}

void Smtp::Setup(const vector<Sys::EMail>& emailList, const wchar_t* smtpServerName, const wchar_t* username, const wchar_t* password)
{
	Sys::Convert::WstringToString(smtpServerName, this->serverName);
	Sys::Convert::WstringToString(username, this->username);
	Sys::Convert::WstringToString(password, this->password);
	this->emailList = emailList;
}

wchar_t* Smtp::GetErrorDescr()
{
	const int len = wcslen(errorDescr);
	if (len > 7 ) return errorDescr;
	switch(abs(state))
	{
	case WIN_SOCKET_INITIAL: return L"Unable to get IP address";
	case WIN_SOCKET_HOSTNAME: return L"Unable to connect to smtp server";
	case WIN_SOCKET_DISCONNECTED: return L"Unable to connect to smtp server";
	case WIN_SOCKET_CONNECTED: return L"Bad response from the server";
	case WIN_SOCKET_WELCOME: return L"Unable to send HELO";
	case WIN_SOCKET_HELO: return L"Unable to send AUTH LOGIN";
	case WIN_SOCKET_AUTH: return L"Unable to send USERNAME";
	case WIN_SOCKET_USERNAME: return L"Unable to send PASSWORD";
	case WIN_SOCKET_PASSWORD: return L"Unable to send MAILFROM";
	case WIN_SOCKET_MAILFROM: return L"Unable to send RCPTTO";
	case WIN_SOCKET_RCPTTO: return L"Unable to send TIMEHEADER";
	case WIN_SOCKET_DATA: return L"Unable to send DATA";
	case WIN_SOCKET_TIMEHEADER: return L"Unable to send FROM";
	case WIN_SOCKET_FROM: return L"Unable to send SENDER";
	case WIN_SOCKET_SENDER: return L"Unable to send REPLYTO";
	case WIN_SOCKET_REPLYTO: return L"Unable to send SUBJECT";
	case WIN_SOCKET_SUBJECT: return L"Unable to send TO";
	case WIN_SOCKET_TO: return L"Unable to send MIME";
	case WIN_SOCKET_MIME: return L"Unable to send MULTIPART MIXED";
	case WIN_SOCKET_MULTIPART_MIXED: return L"Unable to send BODY FRONTIER";
	//_____________________________________________________________________ BODY
	case WIN_SOCKET_BODY_FRONTIER: return L"Unable to send BODY CONTENT TYPE";
	case WIN_SOCKET_BODY_CONTENT_TYPE: return L"Unable to send BODY BLANK 1";
	case WIN_SOCKET_BODY_BLANK1: return L"Unable to send BODY";
	case WIN_SOCKET_BODY: return L"Unable to send BODY BLANK 2";
	case WIN_SOCKET_BODY_BLANK2: return L"Unable to send ATTACH_FRONTIER";
//____________________________________________ ATTACHMENT
	case WIN_SOCKET_ATTACH_FRONTIER: return L"Unable to send ATTACHMENT CONTENT TYPE";
	case WIN_SOCKET_ATTACH_CONTENT_TYPE: return L"Unable to send CONTENT DISPOSITION";
	case WIN_SOCKET_ATTACH_CONTENT_DISPOSITION: return L"Unable to send TRANSFER ENCONDING";
	case WIN_SOCKET_ATTACH_TRANSFER_ENCODING: return L"Unable to send ATTACH_BLANK1";
	case WIN_SOCKET_ATTACH_BLANK1: return L"Unable to send ATTACH";
	case WIN_SOCKET_ATTACH: return L"Unable to send ATTACH_BLANK2";
	case WIN_SOCKET_ATTACH_BLANK2: return L"Unable to send ATTACH_END";
	case WIN_SOCKET_ATTACH_END: return L"Unable to send QUIT";
	//_________________________________________
	case WIN_SOCKET_QUIT: return L"OK";
	case WIN_SOCKET_DONE: return NULL;
	}
	return NULL;
}

bool Smtp::SendHELO(Sys::Socket& skt)
{
	//string server_name;
	//Sys::Convert::WstringToString(smtpServerName, server_name);
	char buffer[256];
	_snprintf_s(buffer, 256, _TRUNCATE, "HELO %s\r\n", serverName.c_str());
	if (skt.Send(buffer) <= 0) return false;
	return true;
}

bool Smtp::SendAUTH(Sys::Socket& skt)
{
	if (skt.Send("AUTH LOGIN\r\n") <= 0) return false;
	return true;
}

bool Smtp::SendUsername(Sys::Socket& skt)
{
	string request;
	//string ausername;
	//Sys::Convert::WstringToString(username, ausername);
	Sys::Convert::Base64BitEncode(username.c_str(), username.length(), request);
	request += "\r\n";
	if (skt.Send(request.c_str()) <= 0) return false;
	return true;
}

bool Smtp::SendPassword(Sys::Socket& skt)
{
	string request;
	//string apassword;
	//Sys::Convert::WstringToString(password, apassword);
	Sys::Convert::Base64BitEncode(password.c_str(), password.length(), request);
	request += "\r\n";
	if (skt.Send(request.c_str()) <= 0) return false;
	return true;
}

bool Smtp::SendMAILFrom(Sys::Socket& skt, const Sys::EMail& email)
{
	char buffer[256];
	string from;
	Sys::Convert::WstringToString(email.fromEmail, from);
	_snprintf_s(buffer, 256, _TRUNCATE, "MAIL FROM: <%s>\r\n", from.c_str());
	if (skt.Send(buffer) <= 0) return false;
	return true;
}

bool Smtp::SendRCPTTo(Sys::Socket& skt, const Sys::EMail& email)
{
	char buffer[256];
	string to;
	Sys::Convert::WstringToString(email.toEmail, to);
	_snprintf_s(buffer, 256, _TRUNCATE, "RCPT TO: <%s>\r\n", to.c_str());
	if (skt.Send(buffer) <= 0) return false;
	return true;
}

bool Smtp::SendTimeHeader(Sys::Socket& skt)
{
	char buffer[256];
	Web::HttpConnector::GetTimeHeader(buffer, 256);
	if (skt.Send(buffer) <= 0) return false;
	return true;
}

bool Smtp::SendFrom(Sys::Socket& skt, const Sys::EMail& email)
{
	char buffer[256];
	string name;
	string address;
	Sys::Convert::WstringToString(email.fromName, name);
	Sys::Convert::WstringToString(email.fromEmail, address);
	_snprintf_s(buffer, 256, _TRUNCATE, "From: \"%s\" <%s>\r\n", name.c_str(), address.c_str());
	if (skt.Send(buffer) <= 0) return false;
	return true;
}

bool Smtp::SendSender(Sys::Socket& skt, const Sys::EMail& email)
{
	char buffer[256];
	string address;
	Sys::Convert::WstringToString(email.fromEmail, address);
	_snprintf_s(buffer, 256, _TRUNCATE, "Sender: %s\r\n", address.c_str());
	if (skt.Send(buffer) <= 0) return false;
	return true;
}

bool Smtp::SendReplyTo(Sys::Socket& skt, const Sys::EMail& email)
{
	char buffer[256];
	string name;
	string address;
	Sys::Convert::WstringToString(email.fromName, name);
	Sys::Convert::WstringToString(email.fromEmail, address);
	_snprintf_s(buffer, 256, _TRUNCATE, "Reply-to: \"%s\" <%s>\r\n", name.c_str(), address.c_str());
	if (skt.Send(buffer) <= 0) return false;
	return true;
}

bool Smtp::SendSubject(Sys::Socket& skt, const Sys::EMail& email)
{
	char buffer[256];
	string subject;
	Sys::Convert::WstringToString(email.subject, subject);
	_snprintf_s(buffer, 256, _TRUNCATE, "Subject: %s\r\n", subject.c_str());
	if (skt.Send(buffer) <= 0) return false;
	return true;
}

bool Smtp::SendTo(Sys::Socket& skt, const Sys::EMail& email)
{
	char buffer[256];
	string name;
	string address;
	Sys::Convert::WstringToString(email.toName, name);
	Sys::Convert::WstringToString(email.toEmail, address);
	_snprintf_s(buffer, 256, _TRUNCATE, "To: \"%s\" <%s>\r\n", name.c_str(), address.c_str());
	if (skt.Send(buffer) <= 0) return false;
	return true;
}

bool Smtp::SendMime(Sys::Socket& skt, const Sys::EMail& email)
{
	if (skt.Send("MIME-Version: 1.0\r\n") <= 0) return false;
	return true;
}

bool Smtp::SendMultipartMixed(Sys::Socket& skt, const Sys::EMail& email)
{
	if (email.attachmentFileName.length() <= 0) return true;
	//if (skt.Send("Content-Type: multipart/mixed;\r\n") <= 0) return false;
	char buffer[256];
	_snprintf_s(buffer, 256, _TRUNCATE, "Content-Type: multipart/mixed; boundary=\"%s\"\r\n",  WIN_SMTP_BOUNDARY);
	if (skt.Send(buffer) <= 0) return false;
	return true;
}

bool Smtp::SendBodyFrontier(Sys::Socket& skt, const Sys::EMail& email)
{
	if (email.attachmentFileName.length() <= 0) return true;
	char buffer[256];
	_snprintf_s(buffer, 256, _TRUNCATE, "--%s\r\n",  WIN_SMTP_BOUNDARY);
	if (skt.Send(buffer) <= 0) return false;
	return true;
}

bool Smtp::SendBodyContentType(Sys::Socket& skt, const Sys::EMail& email)
{
	if (email.isHtmlFormat == true)
	{
		if (skt.Send("Content-type: text/html; charset=ISO-8859-1\r\n") <= 0) return false;
	}
	else
	{
		if (skt.Send("Content-type: text/plain\r\n") <= 0) return false;
	}
	return true;
}

bool Smtp::SendAttachmentFrontier(Sys::Socket& skt, const Sys::EMail& email)
{
	if (email.attachmentFileName.length() <= 0) return true;
	char buffer[256];
	_snprintf_s(buffer, 256, _TRUNCATE, "--%s\r\n",  WIN_SMTP_BOUNDARY);
	if (skt.Send(buffer) <= 0) return false;
	return true;
}

bool Smtp::SendAttachmentContentType(Sys::Socket& skt, const Sys::EMail& email)
{
	if (email.attachmentFileName.length() <= 0) return true;
	string filename;
	Sys::Convert::WstringToString(email.attachmentFileName, filename);
	size_t pos = filename.find_last_of(".");
	if (pos == std::string::npos) return false;
	string ext;
	ext.assign(filename.begin()+pos+1, filename.end());
	char * contentType = Web::HttpConnector::GetMimeContentType(ext.c_str());
	char buffer[256];
	_snprintf_s(buffer, 256, _TRUNCATE, "Content-type: %s\r\n", contentType);
	if (skt.Send(buffer) <= 0) return false;
	return true;
}

bool Smtp::SendAttachmentContentDisposition(Sys::Socket& skt, const Sys::EMail& email)
{
	if (email.attachmentFileName.length() <= 0) return true;
	string filename;
	string name;
	Sys::Convert::WstringToString(email.attachmentFileName, filename);
	size_t pos = filename.find_last_of('\\');
	if (pos != std::wstring::npos)
	{
		name.assign(filename.begin()+pos+1, filename.end());
	}
	char buffer[256];
	_snprintf_s(buffer, 256, _TRUNCATE, "Content-Disposition: attachment; filename=\"%s\";\r\n", name.c_str());
	if (skt.Send(buffer) <= 0) return false;
	return true;
}

bool Smtp::SendAttachmentTransferEncoding(Sys::Socket& skt, const Sys::EMail& email)
{
	if (email.attachmentFileName.length() <= 0) return true;
	if (skt.Send("Content-Transfer-Encoding: base64\r\n") <= 0) return false;
	return true;
}

bool Smtp::SendAttachment(Sys::Socket& skt, const Sys::EMail& email)
{
	if (email.attachmentFileName.length() <= 0) return true;
	//_______________________________________________ Load the File
	string fileContent;
	string encodedContent;
	if (Sys::FileAssistant::TextLoad(email.attachmentFileName, fileContent) == false) return false;
	const int len = fileContent.length();
	if (len <= 0) return false;
	//_______________________________________________ Encode the file content
	Sys::Convert::Base64BitEncode(fileContent.c_str(), fileContent.length(), encodedContent);
	//_______________________________________________ empty line
	//if (skt.Send("\r\n") <= 0) return false;
	//_______________________________________________ Send line by line
	char buffer[256];
	char* start = NULL;
	int bytesRead = 0;
	const int newlen = encodedContent.length();
	for(int i=0; i<newlen; i+=250)
	{
		start = (char*)encodedContent.c_str();
		start += i;
		strncpy_s(buffer, 256, start, 250);
		buffer[250]='\0';
		strcat_s(buffer, 256, "\r\n");
		if (skt.Send(buffer) <= 0) return false;
	}
	//_______________________________________________ empty line
	//if (skt.Send("\r\n") <= 0) return false;
	return true;
}

bool Smtp::SendAttachmentEnd(Sys::Socket& skt, const Sys::EMail& email)
{
	if (email.attachmentFileName.length() <= 0) return true;
	char buffer[256];
	_snprintf_s(buffer, 256, _TRUNCATE, "--%s--\r\n",  WIN_SMTP_BOUNDARY);
	if (skt.Send(buffer) <= 0) return false;
	return true;
}

bool Smtp::SendBlankLine(Sys::Socket& skt)
{
	if (skt.Send("\r\n") <= 0) return false;
	return true;
}

bool Smtp::SendDATA(Sys::Socket& skt)
{
	if (skt.Send("DATA\r\n") <= 0) return false;
	return true;
}

bool Smtp::SendBody(Sys::Socket& skt, const Sys::EMail& email)
{
	char buffer[256];
	string body;
	Sys::Convert::WstringToString(email.body, body);
	const int len = body.length();
	char* start = NULL;
	for(int i=0; i<len; i+=250)
	{
		start = (char*)body.c_str();
		start += i;
		strncpy_s(buffer, 256, start, 250);
		buffer[250]='\0';
		Sys::Socket::RemoveReturn(buffer);
		strcat_s(buffer, 256, "\r\n");
		if (skt.Send(buffer) <= 0) return false;
	}
	//if (skt.Send("\r\n") <= 0) return false;
	return true;
}

bool Smtp::SendQuit(Sys::Socket& skt)
{
	if (skt.Send("QUIT\r\n") <= 0) return false;
	return true;
}

bool Smtp::SendDATAEnd(Sys::Socket& skt)
{
	if (skt.Send("\r\n.\r\n") <= 0) return false;
	return true;
}

/*
int get_smtp_line( void )
{
  TCHAR ch = '.';
  TCHAR in_data [MAXOUTLINE];
  TCHAR * index;
  int retval = 0;

  index = in_data;

  while (ch != '\n')
  {
   if( (retval = (*pgensock_getTCHAR) (SMTPSock, 0, &ch) ) )
   {
      gensock_error ("gensock_getTCHAR", retval);
      return -1;
    }
    else
    {
      *index = ch;
      index++;
    }
  }

  /* this is to support multi-line responses, common with */
  /* servers that speak ESMTP *

  /* I know, I know, it's a hack 8^) *
  if( in_data[3] == '-' ) return( get_smtp_line() );
  else return atoi(in_data);
}


int transform_and_send_edit_data( socktag sock, TCHAR * editptr )
{
  TCHAR *index;
  TCHAR *header_end;
  TCHAR previous_TCHAR = 'x';
  unsigned int send_len;
  int retval;
  BOOL done = 0;

  send_len = llstrlen(editptr);
  index = editptr;

  header_end = _tcsstr (editptr, "\r\n\r\n");

  while (!done)
  {
    // room for extra TCHAR for double dot on end case
    while ((unsigned int) (index - editptr) < send_len)
    {
      switch (*index)
      {
       case '.':
	             if (previous_TCHAR == '\n')
	              /* send _two_ dots... *
	              if ((retval = (*pgensock_put_data_buffered) (sock, index, 1))) return (retval);
	  	         if ((retval = (*pgensock_put_data_buffered) (sock, index, 1))) return (retval);
	             break;
       case '\r':
	             // watch for soft-breaks in the header, and ignore them
                 if (index < header_end && (strncmp (index, "\r\r\n", 3) == 0))
	               index += 2;
	             else
	              if (previous_TCHAR != '\r')
	               if ((retval = (*pgensock_put_data_buffered) (sock, index, 1)))
	                return (retval);
	              // soft line-break (see EM_FMTLINES), skip extra CR *
				 break;
	   default:
	           if ((retval = (*pgensock_put_data_buffered) (sock, index, 1)))
	            return (retval);
      }
      previous_TCHAR = *index;
      index++;
    }
    if( (unsigned int) (index - editptr) == send_len) done = 1;
  }

  // this handles the case where the user doesn't end the last
  // line with a <return>

  if (editptr[send_len-1] != '\n')
  {
    if ((retval = (*pgensock_put_data_buffered) (sock, "\r\n.\r\n", 5)))
      return (retval);
  }
  else
    if ((retval = (*pgensock_put_data_buffered) (sock, ".\r\n", 3)))
      return (retval);

  /* now make sure it's all sent... *
  if ((retval = (*pgensock_put_data_flush)(sock))) return (retval);
  return (TRUE);
}

Agregar -> Content-Transfer-Encoding: quoted-printable
// MIME Quoted-Printable Content-Transfer-Encoding
#define MimeHexTCHAR "0123456789ABCDEF"; 
void ConvertToQuotedPrintable(TCHAR ThisTCHAR, int * CurrPos, TCHAR * buffer) {
int ThisValue;
div_t result;
// TCHAR buffer[8];
TCHAR HexTable[17] = MimeHexTCHAR;
	
	ThisValue = (256 + (unsigned int) ThisTCHAR) % 256; 

	if	(ThisValue == 13) {
		sprintf( buffer, "%s", "\0" );
		return;
	}
	else if	(ThisValue == 10) {
		sprintf( buffer, "%s", "\r\n" );
		(*CurrPos) = 0;
		return;
	}
	else if ((ThisValue < 33) | 
			(ThisValue == 61) | 
			(ThisValue > 126)) {
		result = div(ThisValue,16); 
		buffer[0] = '=';
		(*CurrPos)++;
		buffer[1] = HexTable[result.quot];
		(*CurrPos)++;
		buffer[2] = HexTable[result.rem];
 		(*CurrPos)++;
		buffer[3] = '\0';
	}
	else {
		buffer[0] = ThisTCHAR;
		(*CurrPos)++;
		buffer[1] = '\0';
	} 

   	if (*CurrPos > 71) {
		lstrcat(buffer, "=\r\n");     /* Add soft line break *
		(*CurrPos) = 0;
	}
} */

//_____________________________________________________________________ SmtpAsync
//SmtpAsync::SmtpAsync()
//{
//	hWnd = NULL;
//	state = WIN_SOCKET_INITIAL;
//	buffer[0] = '\0';
//	errorDescr[0] = '\0';
//}
//
//SmtpAsync::~SmtpAsync()
//{
//}
//
//wchar_t* SmtpAsync::TestConnection(HWND hWnd, const wchar_t* smtpServerName)
//{
//	return NULL;
//}
//
//bool SmtpAsync::SendEmail(HWND hWnd, const vector<Sys::EMail>& emailList, const wchar_t* smtpServerName, const wchar_t* username, const wchar_t* password)
//{
//	this->hWnd = hWnd;
//	state = WIN_SOCKET_INITIAL;
//	errorDescr[0] = '\0';
//	messageIndex = 0;
//	Sys::Convert::WstringToString(smtpServerName, serverName);
//	Sys::Convert::WstringToString(username, this->username);
//	Sys::Convert::WstringToString(password, this->password);
//	this->emailList = emailList;
//	return (0 != ::WSAAsyncGetHostByName(hWnd, WM_SOCKETHOSTNAME, serverName.c_str(), buffer, MAXGETHOSTSTRUCT));
//}
//
//// Call this on Window_SocketNotify(Win::Event& e)
//int SmtpAsync::OnSocketNotify(LPARAM lParam)
//{
//	WORD socketEvent = WSAGETSELECTEVENT(lParam);
//	WORD socketError = WSAGETSELECTERROR(lParam);
//
//	//e.returnValue = TRUE;
//	if (socketError)
//	{
//		_snwprintf_s(errorDescr, 256, _TRUNCATE, L"%s", sock.GetErrorDescr(socketError));
//		return -1;
//	}
//
//	switch(socketEvent)
//	{
//	case FD_CONNECT:
//		OnFdConnect();
//		break; 
//	case FD_READ: 
//		OnFdRead(-1);
//		break;
//	case FD_WRITE: 
//		OnFdWrite(true);
//		break;
//	case FD_CLOSE:
//		break;
//	}
//	return 0;
//}
//
//// Call this on Window_SocketHostname
//bool SmtpAsync::OnSocketHostname()
//{
//	if (strlen(buffer)<=0) 
//	{
//		_snwprintf_s(errorDescr, 256, _TRUNCATE, L"Server hostname is empty");
//		return false;
//	}
//	//______________________________ IP address was found
//	HOSTENT * pHost = NULL;
//	pHost = (hostent*)buffer;	
//	char* ipAddress =inet_ntoa(  *(LPIN_ADDR)*(pHost->h_addr_list) );
//	if (ipAddress == NULL)
//	{
//		_snwprintf_s(errorDescr, 256, _TRUNCATE, L"Server IP Address is empty");
//		return false;
//	}
//	state = WIN_SOCKET_HOSTNAME;
//
//
//	//_________________________________ Connect Request
//	wstring ip_address;
//	Sys::Convert::StringToWstring(ipAddress, ip_address);
//	const wchar_t* error = sock.ConnectAsync(hWnd, 25, ip_address.c_str());
//
//	if (error)
//	{
//		_snwprintf_s(errorDescr, 256, _TRUNCATE, L"%s", error);
//		return false;
//	}
//	return true;
//}
//
//bool SmtpAsync::OnFdConnect()
//{
//	state = WIN_SOCKET_CONNECTED;
//	const int code = sock.ReceiveCodeAsync();
//	if (code < 0) return OnFdRead(code);
//	return true;
//}
//
//bool SmtpAsync::OnFdRead(int code)
//{
//	if (code < 0) code = sock.ReceiveCode();
//
//	switch(state)
//	{
//	case WIN_SOCKET_CONNECTED:
//		if (code == 220)
//		{
//			state = WIN_SOCKET_WELCOME;
//			if (SendHELO(sock) == true) return OnFdWrite(false);
//		}
//		break;
//	case WIN_SOCKET_WELCOME:
//		if (code == 250)
//		{
//			state = WIN_SOCKET_HELO;
//			if (SendAUTH(sock) == true) return OnFdWrite(false);
//		}
//		break;
//	case WIN_SOCKET_HELO:
//		if (code == 334)
//		{
//			state = WIN_SOCKET_AUTH;
//			if (SendUsername(sock) == true) return OnFdWrite(false);
//		}
//		break;
//	case WIN_SOCKET_AUTH:
//		if (code == 334)
//		{
//			state = WIN_SOCKET_USERNAME;
//			if (SendUsername(sock) == true) return OnFdWrite(false);
//		}
//		break;
//	case WIN_SOCKET_USERNAME:
//		if (code == 334)
//		{
//			state = WIN_SOCKET_PASSWORD;
//			if (SendUsername(sock) == true) return OnFdWrite(false);
//		}
//		break;
//	case WIN_SOCKET_PASSWORD:
//		if (code == 334)
//		{
//			state = WIN_SOCKET_MAILFROM;
//			if (SendUsername(sock) == true) return OnFdWrite(false);
//		}
//		break;
//	case WIN_SOCKET_MAILFROM:
//		if (code == 334)
//		{
//			state = WIN_SOCKET_RCPTTO;
//			if (SendUsername(sock) == true) return OnFdWrite(false);
//		}
//		break;
//	case WIN_SOCKET_RCPTTO:
//		if (code == 334)
//		{
//			state = WIN_SOCKET_DATA;
//			if (SendUsername(sock) == true) return OnFdWrite(false);
//		}
//		break;
//////_____________________________________________ DATA
////#define WIN_SOCKET_DATA 11
////#define WIN_SOCKET_TIMEHEADER 12
////#define WIN_SOCKET_FROM 13
////#define WIN_SOCKET_SENDER 14
////#define WIN_SOCKET_REPLYTO 15
////#define WIN_SOCKET_SUBJECT 16
////#define WIN_SOCKET_TO 17
////#define WIN_SOCKET_MIME 18
////#define WIN_SOCKET_MULTIPART_MIXED 19
//////____________________________________________ BODY
////#define WIN_SOCKET_BODY_FRONTIER 20
////#define WIN_SOCKET_BODY_CONTENT_TYPE 21
////#define WIN_SOCKET_BODY_BLANK1 22
////#define WIN_SOCKET_BODY 23
////#define WIN_SOCKET_BODY_BLANK2 24
//////____________________________________________ ATTACHMENT
////#define WIN_SOCKET_ATTACH_FRONTIER 25
////#define WIN_SOCKET_ATTACH_CONTENT_TYPE 26
////#define WIN_SOCKET_ATTACH_CONTENT_DISPOSITION 27
////#define WIN_SOCKET_ATTACH_TRANSFER_ENCODING 28
////#define WIN_SOCKET_ATTACH_BLANK1 29
////#define WIN_SOCKET_ATTACH 30
////#define WIN_SOCKET_ATTACH_BLANK2 31
////#define WIN_SOCKET_ATTACH_END 32
//////
////#define WIN_SOCKET_DATA_END 33
////#define WIN_SOCKET_QUIT 34
////#define WIN_SOCKET_DONE 35
//	}
//	return true;
//}
//
//bool SmtpAsync::OnFdWrite(bool write)
//{
//	int code;
//	switch(state)
//	{
//	case WIN_SOCKET_WELCOME:
//		if (write == false || SendHELO(sock) == true)
//		{
//			code = sock.ReceiveCodeAsync();
//			if (code < 0) return OnFdRead(code);
//		}
//		return false;
//	case WIN_SOCKET_HELO:
//		if (write == false || SendAUTH(sock) == true)
//		{
//			code = sock.ReceiveCodeAsync();
//			if (code < 0) return OnFdRead(code);
//		}
//		return false;
//	case WIN_SOCKET_AUTH:
//		if (write == false || SendUsername(sock) == true)
//		{
//			code = sock.ReceiveCodeAsync();
//			if (code < 0) return OnFdRead(code);
//		}
//		return false;
//	case WIN_SOCKET_USERNAME:
//		if (write == false || SendPassword(sock) == true)
//		{
//			code = sock.ReceiveCodeAsync();
//			if (code < 0) return OnFdRead(code);
//		}
//		return false;
//	case WIN_SOCKET_PASSWORD:
//		if (write == false || SendMAILFrom(sock, emailList[messageIndex]) == true)
//		{
//			code = sock.ReceiveCodeAsync();
//			if (code < 0) return OnFdRead(code);
//		}
//		return false;
//	case WIN_SOCKET_MAILFROM:
//		if (write == false || SendRCPTTo(sock, emailList[messageIndex]) == true)
//		{
//			code = sock.ReceiveCodeAsync();
//			if (code < 0) return OnFdRead(code);
//		}
//		return false;
//	case WIN_SOCKET_RCPTTO:
//		if (write == false || SendUsername(sock) == true)
//		{
//			code = sock.ReceiveCodeAsync();
//			if (code < 0) return OnFdRead(code);
//		}
//		return false;
//	}
//////_____________________________________________ DATA
////#define WIN_SOCKET_DATA 11
////#define WIN_SOCKET_TIMEHEADER 12
////#define WIN_SOCKET_FROM 13
////#define WIN_SOCKET_SENDER 14
////#define WIN_SOCKET_REPLYTO 15
////#define WIN_SOCKET_SUBJECT 16
////#define WIN_SOCKET_TO 17
////#define WIN_SOCKET_MIME 18
////#define WIN_SOCKET_MULTIPART_MIXED 19
//////____________________________________________ BODY
////#define WIN_SOCKET_BODY_FRONTIER 20
////#define WIN_SOCKET_BODY_CONTENT_TYPE 21
////#define WIN_SOCKET_BODY_BLANK1 22
////#define WIN_SOCKET_BODY 23
////#define WIN_SOCKET_BODY_BLANK2 24
//////____________________________________________ ATTACHMENT
////#define WIN_SOCKET_ATTACH_FRONTIER 25
////#define WIN_SOCKET_ATTACH_CONTENT_TYPE 26
////#define WIN_SOCKET_ATTACH_CONTENT_DISPOSITION 27
////#define WIN_SOCKET_ATTACH_TRANSFER_ENCODING 28
////#define WIN_SOCKET_ATTACH_BLANK1 29
////#define WIN_SOCKET_ATTACH 30
////#define WIN_SOCKET_ATTACH_BLANK2 31
////#define WIN_SOCKET_ATTACH_END 32
//////
////#define WIN_SOCKET_DATA_END 33
////#define WIN_SOCKET_QUIT 34
////#define WIN_SOCKET_DONE 35
//	return true;
//}


#endif


} //____________________________________________________ namespace Mt::End

namespace Math //________________________________________ namespace Math::Ini
{
//____________________________________________________________ ISimAnneal

//_____________________________________________________________________ Oper
Oper::Oper()
{
}

Oper::~Oper()
{
}

bool Oper::IsPrime(int x)
{
	if (x<=1) return false;
	if (x%2==0) return false;
	const int root = (int)(sqrt((double)x)+0.5);
	for(int i = 3; i<= root; i+=2)
	{
		if (x%i==0) return false;
	}
	return true;
}

double Oper::Round(double value, int decimalCount)
{
	const double base = pow(10.0, decimalCount);
	int intValue = (int)(base*value+0.5);
	return (double)intValue/base;
}

double Oper::DotProduct(const valarray<double>& input_a, const valarray<double>& input_b)
{
	const int length = input_a.size();
	if (length != input_b.size()) throw L"Statistics::DotProduct input vectors need to be of the same size";
	double sum = 0.0;

	for(int i=0; i< length; i++)
	{
		sum += ( input_a[i] * input_b[i]);
	}

	return sum;
}

double Oper::ComputeMse(const MATRIX& input_a, const MATRIX& input_b)
{
	double mse = 0.0;
	const unsigned int rows = input_a.size();
	if (rows==0) return -1.0e100;
	//
	const unsigned int cols = input_a[0].size();
	if (rows!= input_b.size()) return -1.0e100;
	if (cols!= input_b[0].size()) return -1.0e100;
	unsigned int i, j;
	double div=0.0;
	for(i=0; i<rows; i++)
	{
		for(j=0; j<cols; j++)
		{
			div = input_a[i][j]-input_b[i][j];
			mse+= (div*div);
		}
	}
	return mse/(rows*cols);
}

wchar_t* Oper::ConfusionMatrix(const MATRIX& output, const MATRIX& target, MATRIX& confusionMatrix)
{
	double mse = 0.0;
	const int rows = output.size();
	if (rows==0) return L"Matrix is empty";
	//
	const int cols = output[0].size();
	if (rows!= target.size()) return L"Both matrices must be the same size";
	if (cols!= target[0].size()) return L"Both matrices must be the same size";
	int i, j;
	
	int count;
	//____________________________ Check the target (0 0 1 0 0 ...)
	for(i=0; i<rows; i++)
	{
		count = 0;
		for(j=0; j<cols; j++)
		{
			if (target[i][j] != 0.0) count++;
		}
		if (count == 0) continue; // 0, 0, 0, 0, ... 0
		if (count != 1) return L"The target matrix must have zero or only one \"1\" per row";
	}
	//____________________________ Prepare confusionMatrix
	const int classCount = cols +1;
	try
	{
		if (confusionMatrix.size() != classCount) confusionMatrix.resize(classCount);
		for(i = 0; i<classCount; i++)
		{
			if (confusionMatrix[i].size() != classCount) confusionMatrix[i].resize(classCount);
			for(j = 0; j<classCount; j++)
			{
				confusionMatrix[i][j] = 0.0;
			}
		}
	}
	catch(const std::bad_alloc& )
	{
		return L"No enough memory";
	}

	//____________________________ Compute confusionMatrix
	int output_index = -1;
	int target_index = -1;
	for(i=0; i<rows; i++)
	{
		output_index = Math::Oper::GetClass(output[i]);
		target_index = Math::Oper::GetClass(target[i]);
		confusionMatrix[target_index][output_index] ++;
	}
	return NULL;
}

int Oper::GetClass(const valarray<double>& inputRow)
{
	const int len = inputRow.size();
	if (len == 0) return 0;
	int i = 0;
	double maximum = inputRow[0];
	int class_index = 0;
	for(int i = 1; i<len; i++)
	{
		if (inputRow[i] > maximum)
		{
			maximum = inputRow[i];
			class_index = i;
		}
	}
	if (maximum > 0.0) return class_index;
	return len;
}

wchar_t* Oper::GetClass(const MATRIX input, valarray<int>& classes)
{
	const int rows = input.size();
	if (rows == 0)
	{
		classes.free();
		return L"Matrix is empty";
	}
	if (classes.size() != rows)
	{
		try
		{
			classes.resize(rows);
		}
		catch(const std::bad_alloc& )
		{
			return L"No enough memory";
		}
		for(int i = 0; i<rows; i++)
		{
			classes[i] = Math::Oper::GetClass(input[i]);
		}
	}
	return NULL;
}

wchar_t* Oper::GetClass(const MATRIX input, valarray<double>& classes)
{
	const int rows = input.size();
	if (rows == 0)
	{
		classes.free();
		return L"Matrix is empty";
	}
	if (classes.size() != rows)
	{
		try
		{
			classes.resize(rows);
		}
		catch(const std::bad_alloc& )
		{
			return L"No enough memory";
		}
		for(int i = 0; i<rows; i++)
		{
			classes[i] = Math::Oper::GetClass(input[i]);
		}
	}
	return NULL;
}

double Oper::GetMinimum(const MATRIX& input)
{
	const unsigned int rows = input.size();
	if (rows==0) return -1.0e100;
	//
	const unsigned int cols = input[0].size();
	if (cols==0) return -1.0e100;
	unsigned int i, j;
	double minimum = input[0][0];
	for(i=0; i<rows; i++)
	{
		for(j=0; j<cols; j++)
		{
			if (minimum>input[i][j]) minimum = input[i][j];
		}
	}
	return minimum;
}

double Oper::GetMaximum(const MATRIX& input)
{
	const unsigned int rows = input.size();
	if (rows==0) return -1.0e100;
	//
	const unsigned int cols = input[0].size();
	if (cols==0) return -1.0e100;
	unsigned int i, j;
	double maximum = input[0][0];
	for(i=0; i<rows; i++)
	{
		for(j=0; j<cols; j++)
		{
			if (maximum<input[i][j]) maximum = input[i][j];
		}
	}
	return maximum;
}

void Oper::AddValue(MATRIX& in_out, double value)
{
	const unsigned int rows = in_out.size();
	if (rows==0) return;
	//
	const unsigned int cols = in_out[0].size();
	if (cols==0) return;
	
	unsigned int i, j;
	for(i=0; i<rows; i++)
	{
		for(j=0; j<cols; j++)
		{
			in_out[i][j]+=value;
		}
	}
}

void Oper::MultiplyBy(MATRIX& in_out, double value)
{
	const unsigned int rows = in_out.size();
	if (rows==0) return;
	//
	const unsigned int cols = in_out[0].size();
	if (cols==0) return;
	
	unsigned int i, j;
	for(i=0; i<rows; i++)
	{
		for(j=0; j<cols; j++)
		{
			in_out[i][j]*=value;
		}
	}
}

void Oper::DivideBy(MATRIX& in_out, double value)
{
	const unsigned int rows = in_out.size();
	if (rows==0) return;
	//
	const unsigned int cols = in_out[0].size();
	if (cols==0) return;
	
	unsigned int i, j;
	for(i=0; i<rows; i++)
	{
		for(j=0; j<cols; j++)
		{
			in_out[i][j]/=value;
		}
	}
}

bool Oper::CopyToClipboard(HWND hWnd, const MATRIX& input)
{
	const unsigned int rows = input.size();
	if (rows==0) return true;
	//
	const unsigned int cols = input[0].size();
	if (cols==0) return true;
	
	unsigned int i, j;

	const int length = rows*cols*MATH_MATRIX_TEXTDOUBLE+2*rows;
	HGLOBAL hGlobal;
	wchar_t* pGlobal;
	bool bOk = false;
	wchar_t texto[MATH_MATRIX_TEXTDOUBLE];

	hGlobal = GlobalAlloc(GHND | GMEM_SHARE, (length+1)*sizeof(wchar_t));
	if (hGlobal)
	{
		pGlobal = (wchar_t*)GlobalLock(hGlobal);
		pGlobal[0]='\0';
		for(i=0; i<rows; i++)
		{
			for(j=0; j<cols; j++)
			{
				if (j<cols-1)
				{
					_snwprintf_s(texto, MATH_MATRIX_TEXTDOUBLE, _TRUNCATE, L"%g\t", input[i][j]);	
				}
				else
				{
					_snwprintf_s(texto, MATH_MATRIX_TEXTDOUBLE, _TRUNCATE, L"%g\r\n", input[i][j]);
				}
				lstrcat(pGlobal, texto);	
			}
		}

		GlobalUnlock(hGlobal);
		if (OpenClipboard(hWnd))
		{
			if (EmptyClipboard())
			{
				bOk = (SetClipboardData(CF_UNICODETEXT, hGlobal) != NULL);
			}
			CloseClipboard();
		}
	}
	return bOk;
}

bool Oper::CopyRowToClipboard(HWND hWnd, const MATRIX& input, int row_index)
{
	const unsigned int rows = input.size();
	if (rows==0) return true;
	//
	const unsigned int cols = input[0].size();
	if (cols==0) return true;
	
	unsigned int j;

	if (row_index<0 || (unsigned int)row_index>= rows) return false;
	const int length = cols*MATH_MATRIX_TEXTDOUBLE;
	HGLOBAL hGlobal;
	wchar_t* pGlobal;
	bool bOk = false;
	wchar_t texto[MATH_MATRIX_TEXTDOUBLE];

	hGlobal = GlobalAlloc(GHND | GMEM_SHARE, (length+1)*sizeof(wchar_t));
	if (hGlobal)
	{
		pGlobal = (wchar_t*)GlobalLock(hGlobal);
		pGlobal[0]='\0';

		for(j=0; j<cols; j++)
		{
			if (j<cols-1)
			{
				_snwprintf_s(texto, MATH_MATRIX_TEXTDOUBLE, _TRUNCATE, L"%g\t", input[row_index][j]);	
			}
			else
			{
				_snwprintf_s(texto, MATH_MATRIX_TEXTDOUBLE, _TRUNCATE, L"%g", input[row_index][j]);
			}
			lstrcat(pGlobal, texto);	
		}

		GlobalUnlock(hGlobal);
		if (OpenClipboard(hWnd))
		{
			if (EmptyClipboard())
			{
				bOk = (SetClipboardData(CF_UNICODETEXT, hGlobal) != NULL);
			}
			CloseClipboard();
		}
	}
	return bOk;
}

bool Oper::CopyColToClipboard(HWND hWnd, const MATRIX& input, int col_index)
{
	const unsigned int rows = input.size();
	if (rows==0) return true;
	//
	const unsigned int cols = input[0].size();
	if (cols==0) return true;
	
	unsigned int i;
	if (col_index<0 || (unsigned int)col_index>= cols) return false;
	const int length = rows*MATH_MATRIX_TEXTDOUBLE+2*rows;
	HGLOBAL hGlobal;
	wchar_t* pGlobal;
	bool bOk = false;
	wchar_t texto[MATH_MATRIX_TEXTDOUBLE];

	hGlobal = GlobalAlloc(GHND | GMEM_SHARE, (length+1)*sizeof(wchar_t));
	if (hGlobal)
	{
		pGlobal = (wchar_t*)GlobalLock(hGlobal);
		pGlobal[0]='\0';
		for(i=0; i<rows; i++)
		{
			if (i<rows-1)
			{
				_snwprintf_s(texto, MATH_MATRIX_TEXTDOUBLE, _TRUNCATE, L"%g\r\n", input[i][col_index]);	
			}
			else
			{
				_snwprintf_s(texto, MATH_MATRIX_TEXTDOUBLE, _TRUNCATE, L"%g", input[i][col_index]);
			}
			lstrcat(pGlobal, texto);	
		}

		GlobalUnlock(hGlobal);
		if (OpenClipboard(hWnd))
		{
			if (EmptyClipboard())
			{
				bOk = (SetClipboardData(CF_UNICODETEXT, hGlobal) != NULL);
			}
			CloseClipboard();
		}
	}
	return bOk;
}

bool Oper::InsertRow(MATRIX& in_out, int rowIndex)
{
	const int rows = in_out.size();
	const int cols = in_out.size() == 0 ? 0: in_out[0].size();
	if (rowIndex <0 || rowIndex>= rows) return false;

	valarray<double> newRow(cols);
	MATRIX::iterator p = in_out.begin();
	p+= rowIndex;
	if (p == in_out.end()) return false;
	in_out.insert(p, newRow);
	return true;
}

bool Oper::InsertRow(MATRIXC& in_out, int rowIndex)
{
	const int rows = in_out.size();
	const int cols = in_out.size() == 0 ? 0: in_out[0].size();
	if (rowIndex <0 || rowIndex>= rows) return false;

	valarray<complex<double> > newRow(cols);
	MATRIXC::iterator p = in_out.begin();
	p+= rowIndex;
	if (p == in_out.end()) return false;
	in_out.insert(p, newRow);
	return true;
}

bool Oper::InsertCell(valarray<double>& in_out, int index)
{
	const int rows = in_out.size();
	if (index <0 || index> rows) return false;

	valarray<double> tmp(in_out);
	in_out.resize(rows+1);
	int i = 0, j = 0;
	for(i = 0; i<rows+1; i++)
	{
		if (i<index)
		{
			in_out[i] = tmp[j++];
		}
		else if (i==index)
		{
			in_out[i] = 0.0;
		}
		else
		{
			in_out[i] = tmp[j++];
		}
	}
	return true;
}

bool Oper::InsertCell(valarray<complex<double> >& in_out, int index)
{
	const int rows = in_out.size();
	if (index <0 || index> rows) return false;

	valarray<complex<double> > tmp(in_out);
	in_out.resize(rows+1);
	int i = 0, j = 0;
	for(i = 0; i<rows+1; i++)
	{
		if (i<index)
		{
			in_out[i] = tmp[j++];
		}
		else if (i==index)
		{
			in_out[i] = 0.0;
		}
		else
		{
			in_out[i] = tmp[j++];
		}
	}
	return true;
}

bool Oper::DeleteCell(valarray<double>& in_out, int index)
{
	const int rows = in_out.size();
	if (index <0 || index>= rows) return false;

	valarray<double> tmp(in_out);
	in_out.resize(rows-1);
	int i = 0, j = 0;
	for(j = 0; j<rows; j++)
	{
		if (j != index)
		{
			in_out[i++] = tmp[j];
		}
	}
	return true;
}

bool Oper::DeleteCell(valarray<complex<double> >& in_out, int index)
{
	const int rows = in_out.size();
	if (index <0 || index>= rows) return false;

	valarray<complex<double> >tmp(in_out);
	in_out.resize(rows-1);
	int i = 0, j = 0;
	for(j = 0; j<rows; j++)
	{
		if (j != index)
		{
			in_out[i++] = tmp[j];
		}
	}
	return true;
}

bool Oper::InsertCol(MATRIX& in_out, int colIndex)
{
	const int rows = in_out.size();
	const int cols = in_out.size() == 0 ? 0: in_out[0].size();
	if (colIndex <0 || colIndex>= cols) return false;
	int i = 0, j = 0, k = 0;
	valarray<double> tmp(cols+1);

	for(i=0; i<rows; i++)
	{
		//if (tmp==NULL) return false;
		for(j=0, k=0; j<cols; j++)
		{
			if (j<colIndex)
			{
				tmp[k++] = in_out[i][j];
			}
			else if (j==colIndex)
			{
				tmp[k++] = 0.0;
				tmp[k++] = in_out[i][j];
			}
			else //j>colIndex
			{
				tmp[k++] = in_out[i][j];
			}
		}
		in_out[i] = tmp;
	}
	return true;
}

bool Oper::InsertCol(MATRIXC& in_out, int colIndex)
{
	const int rows = in_out.size();
	const int cols = in_out.size() == 0 ? 0: in_out[0].size();
	if (colIndex <0 || colIndex>= cols) return false;
	int i = 0, j = 0, k = 0;
	valarray<complex <double> >tmp(cols+1);

	for(i=0; i<rows; i++)
	{
		//if (tmp==NULL) return false;
		for(j=0, k=0; j<cols; j++)
		{
			if (j<colIndex)
			{
				tmp[k++] = in_out[i][j];
			}
			else if (j==colIndex)
			{
				tmp[k++] = 0.0;
				tmp[k++] = in_out[i][j];
			}
			else //j>colIndex
			{
				tmp[k++] = in_out[i][j];
			}
		}
		in_out[i] = tmp;
	}
	return true;
}

bool Oper::DeleteRow(MATRIX& in_out, int rowIndex)
{
	const int rows = in_out.size();
	const int cols = in_out.size() == 0 ? 0: in_out[0].size();
	if (rowIndex <0 || rowIndex>= rows) return false;

	MATRIX::iterator p = in_out.begin();
	p+= rowIndex;
	if (p == in_out.end()) return false;
	in_out.erase(p);
	return true;
}

bool Oper::DeleteRow(MATRIXC& in_out, int rowIndex)
{
	const int rows = in_out.size();
	const int cols = in_out.size() == 0 ? 0: in_out[0].size();
	if (rowIndex <0 || rowIndex>= rows) return false;

	MATRIXC::iterator p = in_out.begin();
	p+= rowIndex;
	if (p == in_out.end()) return false;
	in_out.erase(p);
	return true;
}

bool Oper::DeleteCol(MATRIX& in_out, int colIndex)
{
	const int rows = in_out.size();
	const int cols = in_out.size() == 0 ? 0 : in_out[0].size();
	if (colIndex <0 || colIndex>= cols) return false;

	if (cols==1) 
	{
		in_out.clear();
		return true;
	}

	int i, j, k=0;
	valarray<double> tmp(cols-1);

	for(i=0; i<rows; i++)
	{
		k = 0;
		for(j=0; j<cols; j++)
		{
			if (j != colIndex) tmp[k++] = in_out[i][j];
		}
		in_out[i] = tmp;
	}
	return true;
}

bool Oper::DeleteCol(MATRIXC& in_out, int colIndex)
{
	const int rows = in_out.size();
	const int cols = in_out.size() == 0 ? 0 : in_out[0].size();
	if (colIndex <0 || colIndex>= cols) return false;

	if (cols==1) 
	{
		in_out.clear();
		return true;
	}

	int i, j, k=0;
	valarray<complex<double> >tmp(cols-1);

	for(i=0; i<rows; i++)
	{
		k = 0;
		for(j=0; j<cols; j++)
		{
			if (j != colIndex) tmp[k++] = in_out[i][j];
		}
		in_out[i] = tmp;
	}
	return true;
}

bool Oper::AppendDown(MATRIX& in_out, const MATRIX& in_B)
{
	const int rows = in_out.size();
	const int cols = in_out.size() == 0 ? 0: in_out[0].size();
	const int rowsB = in_B.size();
	const int colsB = in_B.size() == 0 ? 0: in_B[0].size();

	//___________________________ If matrix is empty, just copy the new data
	if (rows == 0 && cols == 0)
	{
		in_out = in_B;
		return true;
	}


	if (cols != colsB && rows != 0 && cols != 0) return false;
	try
	{
		in_out.resize(rows + rowsB);
	}
	catch(const std::bad_alloc& )
	{
		return false;
	}

	for(int i=0; i<rowsB; i++)
	{
		in_out[i+rows] = in_B[i];
	}
	return true;
}

bool Oper::AppendDown(MATRIXC& in_out, const MATRIXC& in_B)
{
	const int rows = in_out.size();
	const int cols = in_out.size() == 0 ? 0: in_out[0].size();
	const int rowsB = in_B.size();
	const int colsB = in_B.size() == 0 ? 0: in_B[0].size();

	//___________________________ If matrix is empty, just copy the new data
	if (rows == 0 && cols == 0)
	{
		in_out = in_B;
		return true;
	}

	if (cols != colsB && rows != 0 && cols != 0) return false;
	try
	{
		in_out.resize(rows + rowsB);
	}
	catch(const std::bad_alloc& )
	{
		return false;
	}

	for(int i=0; i<rowsB; i++)
	{
		in_out[i+rows] = in_B[i];
	}
	return true;
}

bool Oper::AppendRight(MATRIX& in_out, const MATRIX& in_B)
{
	const int rows = in_out.size();
	const int cols = in_out.size() == 0 ? 0: in_out[0].size();
	const int rowsB = in_B.size();
	const int colsB = in_B.size() == 0 ? 0: in_B[0].size();

	//___________________________ If matrix is empty, just copy the new data
	if (rows == 0 && cols == 0)
	{
		in_out = in_B;
		return true;
	}

	if (rows != rowsB && rows != 0 && cols != 0) return false;

	try
	{
		const int newColCount = cols+colsB;
		valarray<double> tmp(newColCount);

		int i, j;
		for(i=0; i<rows; i++)
		{
			for(j=0; j<cols; j++)
			{
				tmp[j] = in_out[i][j];
			}
			for(j=0; j<colsB; j++)
			{
				tmp[j+cols] = in_B[i][j];
			}
			in_out[i] = tmp;
		}
	}
	catch (const std::bad_alloc& )
	{
		return false;
	}
	return true;
}

bool Oper::AppendRight(MATRIXC& in_out, const MATRIXC& in_B)
{
	const int rows = in_out.size();
	const int cols = in_out.size() == 0 ? 0: in_out[0].size();
	const int rowsB = in_B.size();
	const int colsB = in_B.size() == 0 ? 0: in_B[0].size();

	//___________________________ If matrix is empty, just copy the new data
	if (rows == 0 && cols == 0)
	{
		in_out = in_B;
		return true;
	}

	if (rows != rowsB && rows != 0 && cols != 0) return false;

	try
	{
		const int newColCount = cols+colsB;
		valarray<complex<double> > tmp(newColCount);

		int i, j;
		for(i=0; i<rows; i++)
		{
			for(j=0; j<cols; j++)
			{
				tmp[j] = in_out[i][j];
			}
			for(j=0; j<colsB; j++)
			{
				tmp[j+cols] = in_B[i][j];
			}
			in_out[i] = tmp;
		}
	}
	catch(const std::bad_alloc& )
	{
		return false;
	}
	return true;
}

void Oper::NormalizeRows(MATRIX& in_out)
{
	const int rows = in_out.size();
	if (rows == 0) return;
	const int cols = in_out[0].size();
	if (cols == 0) return;
	int i, j;
	double value;

	double maximum;
	for(i = 0; i<rows; i++)
	{
		//_____________________________ Find minimum and maximum
		maximum = fabs(in_out[i][0]);
		for(j = 1; j<cols; j++)
		{
			value = fabs(in_out[i][j]);
			if (value > maximum) maximum = value;
		}
		if (maximum == 0.0) maximum = 1.0e-100;
		//_____________________________ Normalize
		for(j = 0; j<cols; j++)
		{
			in_out[i][j] /= maximum;
		}
	}
}

void Oper::NormalizeCols(MATRIX& in_out)
{
	const int rows = in_out.size();
	if (rows == 0) return;
	const int cols = in_out[0].size();
	if (cols == 0) return;
	int i, j;
	double value;

	double maximum;
	for(j = 0; j<cols; j++)
	{
		//_____________________________ Find minimum and maximum
		maximum = fabs(in_out[0][j]);
		for(i = 1; i<rows; i++)
		{
			value = fabs(in_out[i][j]);
			if (value > maximum) maximum = value;
		}
		if (maximum == 0.0) maximum = 1.0e-100;
		//_____________________________ Normalize
		for(i = 0; i<rows; i++)
		{
			in_out[i][j] /= maximum;
		}
	}
}

bool Oper::GetRows(const MATRIX& input, MATRIX& output, const valarray<int> indexes)
{
	const int len = indexes.size();
	if (len == 0) return true;
	const int rows = input.size();
	if (rows == 0) return true;
	set<int> setint;
	int i, j;
	//___________________________ be sure indexes are unique and valid
	for(i = 0; i<len; i++)
	{
		if (indexes[i] < 0) continue;
		if (indexes[i] >= rows) continue;
		setint.insert(indexes[i]);
	}
	const int newlen = setint.size();
	output.resize(newlen);
	
	for(i = 0, j = 0; i<rows; i++)
	{
		if (setint.find(i) == setint.end()) continue;
		output[j] = input[i];
		j++;
	}
	return true;
}

bool Oper::GetCols(const MATRIX& input, MATRIX& output, const valarray<int> indexes)
{
	MATRIX tmp;
	if (Math::Oper::Transpose(input, output) == false) return false;
	if (Math::Oper::GetRows(output, tmp, indexes) == false) return false;
	if (Math::Oper::Transpose(tmp, output) == false) return false;
	return true;
}

bool Oper::DeleteRows(MATRIX& input, const valarray<int> indexes)
{
	const int len = indexes.size();
	if (len == 0) return true;
	const int rows = input.size();
	if (rows == 0) return true;
	set<int> setint;
	int i, j;
	//_____________________________ be sure indexes are unique and valid
	for(i = 0; i<len; i++)
	{
		if (indexes[i]<0) continue;
		if (indexes[i]>=rows) continue;
		setint.insert(indexes[i]);
	}
	const int newlen = rows - setint.size();
	try
	{
		MATRIX tmp(input);
		input.resize(newlen);
		for(i = 0, j = 0; i<rows; i++)
		{
			if (setint.find(i) != setint.end()) continue;
			input[j] = tmp[i]; 
			j++;
		}
	}
	catch(const std::bad_alloc& )
	{
		return false;
	}
	return true;
}

bool Oper::DeleteCols(MATRIX& input, const valarray<int> indexes)
{
	MATRIX tmp;
	if (Math::Oper::Transpose(input, tmp) == false) return false;
	if (Math::Oper::DeleteRows(tmp, indexes) == false) return false;
	if (Math::Oper::Transpose(tmp, input) == false) return false;
	return true;
}

bool Oper::DeleteRows(const MATRIX& input, MATRIX& output, const valarray<int> indexes)
{
	const int len = indexes.size();
	if (len == 0)
	{
		output.clear();
		return true;
	}
	const int rows = input.size();
	if (rows == 0)
	{
		output.clear();
		return true;
	}
	set<int> setint;
	int i, j;
	//_____________________________ be sure indexes are unique and valid
	for(i = 0; i<len; i++)
	{
		if (indexes[i]<0) continue;
		if (indexes[i]>=rows) continue;
		setint.insert(indexes[i]);
	}
	const int newlen = rows - setint.size();
	try
	{
		output.resize(newlen);
		for(i = 0, j = 0; i<rows; i++)
		{
			if (setint.find(i) != setint.end()) continue;
			output[j] = input[i]; 
			j++;
		}
	}
	catch(const std::bad_alloc& )
	{
		return false;
	}
	return true;
}

bool Oper::DeleteCols(const MATRIX& input, MATRIX& output, const valarray<int> indexes)
{
	MATRIX tmp;
	if (Math::Oper::Transpose(input, tmp) == false) return false;
	if (Math::Oper::DeleteRows(tmp, indexes) == false) return false;
	if (Math::Oper::Transpose(tmp, output) == false) return false;
	return true;
}

bool Oper::GetRows(const MATRIXC& input, MATRIXC& output, const valarray<int> indexes)
{
	const int len = indexes.size();
	if (len == 0) return true;
	const int rows = input.size();
	if (rows == 0) return true;
	set<int> setint;
	int i, j;
	//___________________________ be sure indexes are unique and valid
	for(i = 0; i<len; i++)
	{
		if (indexes[i] < 0) continue;
		if (indexes[i] >= rows) continue;
		setint.insert(indexes[i]);
	}
	const int newlen = setint.size();
	output.resize(newlen);
	
	for(i = 0, j = 0; i<rows; i++)
	{
		if (setint.find(i) == setint.end()) continue;
		output[j] = input[i];
		j++;
	}
	return true;
}

bool Oper::GetCols(const MATRIXC& input, MATRIXC& output, const valarray<int> indexes)
{
	MATRIXC tmp;
	if (Math::Oper::Transpose(input, output) == false) return false;
	if (Math::Oper::GetRows(output, tmp, indexes) == false) return false;
	if (Math::Oper::Transpose(tmp, output) == false) return false;
	return true;
}

bool Oper::DeleteRows(MATRIXC& input, const valarray<int> indexes)
{
	const int len = indexes.size();
	if (len == 0) return true;
	const int rows = input.size();
	if (rows == 0) return true;
	set<int> setint;
	int i, j;
	//_____________________________ be sure indexes are unique and valid
	for(i = 0; i<len; i++)
	{
		if (indexes[i]<0) continue;
		if (indexes[i]>=rows) continue;
		setint.insert(indexes[i]);
	}
	const int newlen = setint.size();
	try
	{
		MATRIXC tmp(input);
		input.resize(newlen);
		for(i = 0, j = 0; i<rows; i++)
		{
			if (setint.find(i) != setint.end()) continue;
			input[j] = tmp[i]; 
			j++;
		}
	}
	catch(const std::bad_alloc& )
	{
		return false;
	}
	return true;
}

bool Oper::DeleteCols(MATRIXC& input, const valarray<int> indexes)
{
	MATRIXC tmp;
	if (Math::Oper::Transpose(input, tmp) == false) return false;
	if (Math::Oper::DeleteRows(tmp, indexes) == false) return false;
	if (Math::Oper::Transpose(tmp, input) == false) return false;
	return true;
}

bool Oper::DeleteRows(const MATRIXC& input, MATRIXC& output, const valarray<int> indexes)
{
	const int len = indexes.size();
	if (len == 0) return true;
	const int rows = input.size();
	if (rows == 0) return true;
	set<int> setint;
	int i, j;
	//_____________________________ be sure indexes are unique and valid
	for(i = 0; i<len; i++)
	{
		if (indexes[i]<0) continue;
		if (indexes[i]>=rows) continue;
		setint.insert(indexes[i]);
	}
	const int newlen = setint.size();
	try
	{
		output.resize(newlen);
		for(i = 0, j = 0; i<rows; i++)
		{
			if (setint.find(i) != setint.end()) continue;
			output[j] = input[i]; 
			j++;
		}
	}
	catch(const std::bad_alloc& )
	{
		return false;
	}
	return true;
}

bool Oper::DeleteCols(const MATRIXC& input, MATRIXC& output, const valarray<int> indexes)
{
	MATRIXC tmp;
	if (Math::Oper::Transpose(input, tmp) == false) return false;
	if (Math::Oper::DeleteRows(tmp, indexes) == false) return false;
	if (Math::Oper::Transpose(tmp, output) == false) return false;
	return true;
}

bool Oper::GetRow(const MATRIX& input, valarray<double>& output, int index)
{
	const int rows = input.size();
	if (rows == 0) return false;
	const int cols = input[0].size();
	if (cols == 0) return false;
	if (index < 0 || index >=rows) return false;
	try
	{
		output.resize(cols);
		for(int i = 0; i < cols; i++)
		{
			output[i] = input[index][i];
		}
	}
	catch(const std::bad_alloc& )
	{
		return false;
	}
	return true;
}

bool Oper::GetCol(const MATRIX& input, valarray<double>& output, int index)
{
	const int rows = input.size();
	if (rows == 0) return false;
	const int cols = input[0].size();
	if (cols == 0) return false;
	if (index < 0 || index >= cols) return false;
	try
	{
		output.resize(rows);
		for(int i = 0; i < rows; i++)
		{
			output[i] = input[i][index];
		}
	}
	catch(const std::bad_alloc& )
	{
		return false;
	}
	return true;
}

bool Oper::GetRow(const MATRIXC& input, valarray<complex<double> >& output, int index)
{
	const int rows = input.size();
	if (rows == 0) return false;
	const int cols = input[0].size();
	if (cols == 0) return false;
	if (index < 0 || index >=rows) return false;
	try
	{
		output.resize(cols);
		for(int i = 0; i < cols; i++)
		{
			output[i] = input[index][i];
		}
	}
	catch(const std::bad_alloc& )
	{
		return false;
	}
	return true;
}

bool Oper::GetCol(const MATRIXC& input, valarray<complex<double> >& output, int index)
{
	const int rows = input.size();
	if (rows == 0) return false;
	const int cols = input[0].size();
	if (cols == 0) return false;
	if (index < 0 || index >= cols) return false;
	try
	{
		output.resize(rows);
		for(int i = 0; i < rows; i++)
		{
			output[i] = input[i][index];
		}
	}
	catch(const std::bad_alloc& )
	{
		return false;
	}
	return true;
}

wchar_t* Oper::Product(const valarray<double>& input_a, const MATRIX& input_b, int rowb_index, MATRIX& output)
{
	const int rows_a = input_a.size();
	const int rows_b = input_b.size();
	const int cols_b = rows_b == 0 ? 0 : input_b[0].size();
	if (rowb_index<0) return L"The row index for the input matrix must be bigger than or equal to zero";
	if (rowb_index>=rows_b) return L"The row index for the input matrix is bigger than or equal to the number of rows of the matrix";
	output.resize(rows_a);
	int i, j;
	for(i = 0; i<rows_a; i++)
	{
		output[i].resize(cols_b);
		for(j = 0; j<cols_b; j++)
		{
			output[i][j] = input_a[i] * input_b[rowb_index][j];
		}
	}
	return NULL;
}

wchar_t* Oper::Product(const valarray<complex<double> >& input_a, const MATRIXC& input_b, int rowb_index, MATRIXC& output)
{
	const int rows_a = input_a.size();
	const int rows_b = input_b.size();
	const int cols_b = rows_b == 0 ? 0 : input_b[0].size();
	if (rowb_index<0) return L"The row index for the input matrix must be bigger than or equal to zero";
	if (rowb_index>=rows_b) return L"The row index for the input matrix is bigger than or equal to the number of rows of the matrix";
	output.resize(rows_a);
	int i, j;
	for(i = 0; i<rows_a; i++)
	{
		output[i].resize(cols_b);
		for(j = 0; j<cols_b; j++)
		{
			output[i][j] = input_a[i] * input_b[rowb_index][j];
		}
	}
	return NULL;
}

wchar_t* Oper::Product(const MATRIX& input_a, const valarray<double>& input_b, valarray<double>& output)
{
	const unsigned int m = input_a.size();
	if (m==0) 
	{
		output.resize(0);
		return NULL;
	}

	const unsigned int n = input_a[0].size();
	if (n==0)
	{
		output.resize(0);
		return NULL;
	}

	const unsigned int p = input_b.size();

	if (n != p) return L"The number of columns in the Matrix is different from the vector size";

	output.resize(m);

	unsigned int i, k;
	double d;
	for(i= 0; i<m; i++)
	{
		d=0;
		for(k=0; k<n; k++)
		{
			d+=(input_a[i][k]*input_b[k]);
		}
		output[i]=d;
	}
	return NULL;
}

wchar_t* Oper::Product(const MATRIXC& input_a, const valarray<complex <double> >& input_b, valarray<complex <double> >& output)
{
	const unsigned int m = input_a.size();
	if (m==0) 
	{
		output.resize(0);
		return NULL;
	}

	const unsigned int n = input_a[0].size();
	if (n==0)
	{
		output.resize(0);
		return NULL;
	}

	const unsigned int p = input_b.size();

	if (n != p) return L"The number of columns in the Matrix is different from the vector size";

	output.resize(m);

	unsigned int i, k;
	complex<double> d;
	for(i= 0; i<m; i++)
	{
		d=0;
		for(k=0; k<n; k++)
		{
			d+=(input_a[i][k]*input_b[k]);
		}
		output[i]=d;
	}
	return NULL;
}

wchar_t* Oper::Product(const MATRIX& input_a, const valarray<double>& input_b, MATRIX& output)
{
	const unsigned int m = input_a.size();
	if (m==0) 
	{
		output.resize(0);
		return NULL;
	}

	const unsigned int n = input_a[0].size();
	if (n==0)
	{
		output.resize(0);
		return NULL;
	}

	const unsigned int p = input_b.size();

	if (n != p) return L"The number of columns in the Matrix is different from the vector size";

	output.resize(m);
	unsigned int i, k;
	for(i=0; i<m; i++) output[i].resize(1);
	double d;

	for(i= 0; i<m; i++)
	{
		d=0;
		for(k=0; k<n; k++)
		{
			d+=(input_a[i][k]*input_b[k]);
		}
		output[i][0]=d;
	}
	return NULL;
}

wchar_t* Oper::Product(const MATRIX& input_a, const MATRIX& input_b, MATRIX& output)
{

	const unsigned int m = input_a.size();
	if (m==0) 
	{
		output.resize(0);
		return NULL;
	}

	const unsigned int n = input_a[0].size();
	if (n==0)
	{
		output.resize(0);
		return NULL;
	}

	const unsigned int p = input_b.size();
	if (p==0)
	{
		output.resize(0);
		return NULL;
	}

	const unsigned int q = input_b[0].size();
	if (q==0)
	{
		output.resize(0);
		return NULL;
	}

	if (n != p) return L"The number of columns in the first matrix is different from the number of rows in the second matrix";
	unsigned int i, j, k;

	output.resize(m);
	for(i=0; i<m; i++) output[i].resize(q);

	double d;
	for(i= 0; i<m; i++)
	{
		for (j=0; j<q; j++)
		{
			d=0;
			for(k=0; k<n; k++)
			{
				d+=(input_a[i][k]*input_b[k][j]);
			}
			output[i][j] = d;
		}
	}
	return NULL;
}

wchar_t* Oper::Product(const MATRIXC& input_a, const MATRIXC& input_b, MATRIXC& output)
{

	const unsigned int m = input_a.size();
	if (m==0) 
	{
		output.resize(0);
		return NULL;
	}

	const unsigned int n = input_a[0].size();
	if (n==0)
	{
		output.resize(0);
		return NULL;
	}

	const unsigned int p = input_b.size();
	if (p==0)
	{
		output.resize(0);
		return NULL;
	}

	const unsigned int q = input_b[0].size();
	if (q==0)
	{
		output.resize(0);
		return NULL;
	}

	if (n != p) return L"The number of columns in the first matrix is different from the number of rows in the second matrix";
	unsigned int i, j, k;

	output.resize(m);
	for(i=0; i<m; i++) output[i].resize(q);

	complex<double> d;
	for(i= 0; i<m; i++)
	{
		for (j=0; j<q; j++)
		{
			d=0;
			for(k=0; k<n; k++)
			{
				d+=(input_a[i][k]*input_b[k][j]);
			}
			output[i][j] = d;
		}
	}
	return NULL;
}

bool Oper::Transpose(const MATRIX& input, MATRIX& output)
{
	const unsigned int rows = input.size();
	if (rows==0)
	{
		output.resize(0);
		return true;
	}

	const unsigned int cols = input[0].size();
	if (cols==0)
	{
		output.resize(0);
		return true;
	}
	
	unsigned int i, j;
	try
	{
		output.resize(cols);
		for(j=0; j<cols; j++) output[j].resize(rows);
	}
	catch(const std::bad_alloc& )
	{
		return false;
	}

	for(i=0; i<rows; i++)
	{
		for(j=0; j<cols; j++)
		{
			output[j][i]=input[i][j];
		}
	}
	return true;
}

bool Oper::Transpose(const MATRIXC& input, MATRIXC& output)
{
	const unsigned int rows = input.size();
	if (rows==0)
	{
		output.resize(0);
		return true;
	}

	const unsigned int cols = input[0].size();
	if (cols==0)
	{
		output.resize(0);
		return true;
	}
	
	unsigned int i, j;
	try
	{
		output.resize(cols);
		for(j=0; j<cols; j++) output[j].resize(rows);
	}
	catch(const std::bad_alloc& )
	{
		return false;
	}

	for(i=0; i<rows; i++)
	{
		for(j=0; j<cols; j++)
		{
			output[j][i]=input[i][j];
		}
	}
	return true;
}


bool Oper::CreateMatrix(MATRIX& in_out, int rowCount, int colCount)
{
	try
	{
		in_out.resize(rowCount);
		for(int i = 0; i<rowCount; i++)
			in_out[i].resize(colCount);
	}
	catch (const std::bad_alloc& )
	{
		return false;
	}
	return true;
}

bool Oper::CreateRandom(MATRIX& in_out, int rowCount, int colCount, double minValue, double maxValue)
{
	if (Math::Oper::CreateMatrix(in_out, rowCount, colCount) == false) return false;
	std::tr1::uniform_real<double> ur (minValue, maxValue);
	int i, j;
	for(i = 0; i < rowCount; i++)
	{
		for(j = 0; j < colCount; j++)
		{
			in_out[i][j] = ur(Math::Statistics::random_generator);
		}
	}
	return true;
}

bool Oper::CreateRandom(valarray<double>& in_out, int length, double minValue, double maxValue)
{
	try
	{
		in_out.resize(length);
	}
	catch(const std::bad_alloc& )
	{
		return false;
	}
	std::tr1::uniform_real<double> ur (minValue, maxValue);
	for(int i = 0; i < length; i++)
	{
		in_out[i] = ur(Math::Statistics::random_generator);
	}
	return true;
}

bool Oper::WrapVector(const valarray<double>& input, int colCount, MATRIX& output)
{
	const int len = input.size();
	if (len<=0)
	{
		//____________________ nothing to do
		output.clear();
		return true;
	}
	const int rows = len-colCount+1;
	if (rows<=0)
	{
		//____________________ nothing to do
		output.clear();
		return true;
	}
	int i = 0, j = 0;
	try
	{
		output.resize(rows);
		for(i = 0; i<rows; i++)
		{
			output[i].resize(colCount);
			for(j = 0; j<colCount; j++)
			{
				output[i][j] = input[i+j];
			}
		}
	}
	catch(const std::bad_alloc& )
	{
		return false;
	}
	return true;
}

bool Oper::WrapVector(const valarray<complex<double> >& input, int colCount, MATRIXC& output)
{
	const int len = input.size();
	if (len<=0)
	{
		//____________________ nothing to do
		output.clear();
		return true;
	}
	const int rows = len-colCount+1;
	if (rows<=0)
	{
		//____________________ nothing to do
		output.clear();
		return true;
	}
	int i = 0, j = 0;
	try
	{
		output.resize(rows);
		for(i = 0; i<rows; i++)
		{
			output[i].resize(colCount);
			for(j = 0; j<colCount; j++)
			{
				output[i][j] = input[i+j];
			}
		}
	}
	catch(const std::bad_alloc& )
	{
		return false;
	}
	return true;
}

bool Oper::CreateMatrix(MATRIXC& in_out, int rowCount, int colCount)
{
	try
	{
		in_out.resize(rowCount);
		for(int i = 0; i<rowCount; i++)
			in_out[i].resize(colCount);
	}
	catch (const std::bad_alloc& )
	{
		return false;
	}
	return true;
}

bool Oper::CreateRandomSet(valarray<double>& in_out, int length, int maxValue)
{
	if (length>=maxValue) return false;
	try
	{
		in_out.resize(length);
		std::tr1::uniform_int<int> ur (0, maxValue);
		int count = 0;
		set<int> mySet;
		int value = -1;
		while(count<length)
		{
			value = ur(Math::Statistics::random_generator);
			mySet.insert(value);
			count = mySet.size();
		}
		set<int>::iterator p = mySet.begin();
		for(int i = 0; i<length; i++, p++)
		{
			in_out[i] = *p;
		}
	}
	catch(const std::bad_alloc& )
	{
		return false;
	}
	return true;
}

double Oper::Sign(const double &a, const double &b)
{
	if (b < 0)
	{
		if (a < 0) return a;
		return -a;
	}
	if (a < 0) return -a; 
	return a;
}

// Given a set of points (x, y) it returns the value of m and b so that y = mx+b
// The function returns the mean squared error
double Oper::LineFitting(const valarray<double>& in_x, const valarray<double>& in_y, double &out_m, double &out_b)
{
	out_m = 0.0;
	out_b = 0.0;
	double mse = 9.99e300;
	const int len = in_x.size();
	if (len != in_y.size()) return mse;
	double sum_x = in_x.sum();
	double sum_y = in_y.sum();
	const double mean_x = sum_x/len;
	double diff = 0.0;
	double nvariance_x = 0.0;

	int i;
	for (i=0; i<len; i++) 
	{
		diff = in_x[i] - mean_x;
		nvariance_x += diff*diff;
		out_m += diff * in_y[i];
	}
	out_m /= nvariance_x; 
	out_b = (sum_y - sum_x*out_m)/(double)len;
	//__________________________________ compute the mse
	mse = 0.0;
	for (i=0; i<len; i++)
	{
		diff = in_y[i] - (out_m * in_x[i] + out_b);
		mse += diff*diff;
	}
	return mse/len;
}

//____________________________________________________________ SimulatedAnnealing
SimulatedAnnealing::SimulatedAnnealing(void)
{
	numTemps=100;
	numIterations=100;
	initialTemp=100.0;
	finalTemp=0.1;
	isCoolingScheduleLinear=false;
	cycles = 4;
	goal = 0.001;
	solution = NULL;
	work1 = NULL; 
	work2 = NULL;
	error = NULL;
	stopWhenDone = true; 
}

SimulatedAnnealing::~SimulatedAnnealing(void)
{
}

void SimulatedAnnealing::SetStopWhenDone(bool stop)
{
	stopWhenDone = stop;
}

DWORD SimulatedAnnealing::ThreadFunc(Mt::BoolTs& running, Mt::DoubleTs& progress, Mt::BoolTs& resetTime)
{
	if (error == NULL) return 0;
	running.Set(true);
	double errorWork1 = SIMANNEAL_INITIAL_ERROR;

	//__________________________________ work2 will be used to test if the solution has be initialized
	work2->SimAnnealInitialize();
	double errorWork2 = fabs(work2->SimAnnealGetError());
	//
	double errorSolution = fabs(solution->SimAnnealGetError());
	if (errorSolution > errorWork2)
	{
		solution->SimAnnealInitialize();
		errorSolution = fabs(solution->SimAnnealGetError());
		if (errorWork2 < errorSolution)
		{
			//______________________ Copy Work 2 to current solution
			solution->SimAnnealCopy(*work2);
			errorSolution = errorWork2;
		}
	}

	int index_cycles, index_temp, index_iter;
	const int eval_compK = 200;

	progress.Set(0.0);
	error->Set(errorSolution);
	//___________________________________________________ Estimate K and prepare for annealing
	double k = EstimateK(eval_compK, running);
	//int no_eval = eval_compK;
	const int total_eval = eval_compK + cycles*numTemps*numIterations;
	progress.Set(100.0*eval_compK/(double)total_eval);
	double temperature, deltaError;
	int retries;
	bool brunning = false;
	//___________________________________________________ Annealing
	for(index_cycles=0; index_cycles<cycles; index_cycles++)
	{
		work2->SimAnnealCopy(*solution);
		errorWork2 = errorSolution;
		//
		for (index_temp=0; index_temp<numTemps; index_temp++) 
		{  
			temperature = GetTemperature(index_temp);
			retries = 0;
			//_____________________________ Iterate at this temperature
			for (index_iter=0; index_iter<numIterations; index_iter++)
			{ 
				//no_eval++;
				progress.Set(100.0*(index_cycles*numTemps*numIterations+index_temp*numIterations+index_iter+eval_compK)/(double)total_eval);
				//
				work1->SimAnnealPerturb(*work2, temperature, initialTemp);
				errorWork1 = fabs(work1->SimAnnealGetError());
				//
				deltaError =  errorWork1 - errorSolution;
				if (IsAcceptedByMetropolis(temperature, deltaError, k))
				{       
					if (retries<5)
					{
						index_iter = 0;
						retries++;
					}
					//______________________ Copy Work1 to Work 2
					work2->SimAnnealCopy(*work1);
					errorWork2 = errorWork1;

					//______________________ Is Work1 better than current solution ?
					if (errorWork1 < errorSolution) 
					{
						//______________________ Copy Work 1 to current solution
						solution->SimAnnealCopy(*work1);
						errorSolution = errorWork1;
						//______________________ Report to main thread
						if (error) error->Set(errorSolution);
					}
				}   
				if (running.GetTry(brunning))
				{
					if (brunning == false) // user has cancelled
					{
						error->Set(errorSolution);
						progress.Set(100.0);
						return 0;
					}
				}
			}
			if (errorSolution<=goal) break;
		} 
	}
	error->Set(errorSolution);
	progress.Set(100.0);
	if (stopWhenDone == true)
	{
		running.Set(false);
	}
	return 0;
}

void SimulatedAnnealing::Setup(Mt::DoubleTs& error, ISimAnneal& solution, ISimAnneal& work1, ISimAnneal& work2)
{
	this->error = &error;
	this->solution = &solution;
	this->work1 = &work1;
	this->work2 = &work2;
}

double SimulatedAnnealing::EstimateK(int N, Mt::BoolTs& running)
{
	double E = 1.0;
	double sum = 0.0;
	double sums = 0.0;

	for(int i = 0; i<N; i++)
	{
		work2->SimAnnealPerturb(*solution, initialTemp, initialTemp);
		E = fabs(work2->SimAnnealGetError());
		sum+=E;
		sums+=(E*E);
		if (running.Get()==false) return 1.0e100;
	}
	double variance  = sums/(N-1) - (sum*sum)/(N*(N-1));
	return -log(0.8)*initialTemp/sqrt(variance);
}

// Solution is used only to get access to the random number generator
bool SimulatedAnnealing::IsAcceptedByMetropolis(double temperature, double deltaError, double k)
{
	if (deltaError<=0) return true;
	std::tr1::uniform_real<double> dist(0.0, 1.0);
	return dist(Math::Statistics::random_generator) < exp(-k*deltaError/temperature);
}

double SimulatedAnnealing::GetTemperature(int index)
{
	if (isCoolingScheduleLinear)
	{
		return initialTemp+index*(finalTemp-initialTemp) / (numTemps-1);
	}
	else
	{
		return initialTemp*exp(index * log(finalTemp/initialTemp) / (numTemps-1));
	}
}

//____________________________________________________________ GeneticParam

//____________________________________________________________ GeneticIndividual
GeneticIndividual::GeneticIndividual()
{
	error = 1.0e100;
	fitness = 0.0;
}

GeneticIndividual::~GeneticIndividual()
{
}

GeneticIndividual::GeneticIndividual(const GeneticIndividual& init)
{
	error = 1.0e100;
	fitness = 0.0;
	Copy(init);
}

GeneticIndividual& GeneticIndividual::operator=(const GeneticIndividual& init)
{
	Copy(init);
	return *this;
}

void GeneticIndividual::Copy(const GeneticIndividual &init)
{
	this->bits = init.bits;
	this->error = init.error;
	this->fitness = init.fitness;
}

bool GeneticIndividual::operator<(const GeneticIndividual& input) const
{
	if (this->error < input.error) return true;
	return false;
}

//____________________________________________________________ GeneticAlgorithm
GeneticAlgorithm::GeneticAlgorithm()
{
	initPopulationSize = 100;
	numGenerations = 50;
	overPopulation = 1.5;
	mutationProbability = 0.0001;
	crossoverProbability = 0.85;
	goal = 0.0001;
	//
	igenetic = NULL;
	stopWhenDone = true;
	error = NULL;
}

GeneticAlgorithm::~GeneticAlgorithm()
{
}

void GeneticAlgorithm::Delete()
{
	igenetic = NULL;
	poolA.clear();
	poolB.clear();
	poolOverPop.clear();
	bestIndividual.bits.Delete();
	bestIndividual.error = 1.0e100;
	bestIndividual.fitness = 0.0;
	error = NULL;
}

bool GeneticAlgorithm::Setup(Mt::DoubleTs& error, int individualSize, Math::IGenetic& igenetic)
{
	Delete();
	const int numIndividuals = initPopulationSize;
	if (bestIndividual.bits.Create(individualSize)==false) return false;

	//________________________________________________________ Over population
	if (overPopulation < 1.0) overPopulation = 1.5;
	//if (overPopulation > 2.0) overPopulation = 2.0;
	const int numOverIndividuals = (int)(numIndividuals*overPopulation+0.5);

	try
	{
		poolA.resize(numIndividuals);
		poolB.resize(numIndividuals);
		selection.resize(numIndividuals);
		poolOverPop.resize(numOverIndividuals);
	}
	catch(const std::bad_alloc& )
	{
		return false;
	}
	
	int i;
	//____________________________________ Create population
	for(i=0; i<numIndividuals; i++)
	{
		if (poolA[i].bits.Create(individualSize)==false) return false;
		if (poolB[i].bits.Create(individualSize)==false) return false;
	}
	
	for(list<Math::GeneticIndividual>::iterator p = poolOverPop.begin(); p != poolOverPop.end(); p++)
	{
		if (p->bits.Create(individualSize)==false) return false;
	}
	this->error = &error;
	this->igenetic = &igenetic;
	return true;
}

DWORD GeneticAlgorithm::ThreadFunc(Mt::BoolTs& running, Mt::DoubleTs& progress, Mt::BoolTs& resetTime)
{
	if (igenetic == NULL || error == NULL)
	{
		if (stopWhenDone == true)
		{
			running.Set(false);
			return 0;
		}
	}
	progress.SetTry(0.0);
	const int numIndividuals = poolA.size();

	//_________________________________________________________ Best Individual
	bestIndividual.error = fabs(igenetic->GeneticGetError(bestIndividual.bits));
	error->SetTry(bestIndividual.error);

	//_________________________________________________________ Create Population
	const int overPopulationSize = poolOverPop.size();
	const double total = overPopulationSize + numIndividuals*numGenerations;
	bool brunning = false;

	for(list<Math::GeneticIndividual>::iterator p = poolOverPop.begin(); p != poolOverPop.end(); p++)
	{
		igenetic->GeneticInitialize(p->bits);
		p->error = fabs(igenetic->GeneticGetError(p->bits));
		if (running.GetTry(brunning))
		{
			if (brunning == false) return 0; // user has cancelled
		}
	}
	poolOverPop.sort();
	//______________________________________________________ Copy best individuals to poolA
	int i = 0;
	for(list<Math::GeneticIndividual>::iterator p = poolOverPop.begin(); p != poolOverPop.end()&& i<numIndividuals; p++, i++)
	{
		poolA[i] = *p;
	}
	progress.SetTry(100.0*numIndividuals*overPopulation/total);
	if (poolA[0].error < bestIndividual.error) // Best individual is the first in the pool 
	{
		bestIndividual.bits = poolA[0].bits;
		bestIndividual.error = poolA[0].error;
	}
	error->SetTry(bestIndividual.error); 
	bool firstTime = true;

	//________________________________________________________ Begin first generation
	bool usePoolA = true;
	int generation, individual;
	for(generation = 0; generation<numGenerations; generation++)
	{
		for(individual = 0; individual<numIndividuals; individual++)
		{
			progress.SetTry(100.0*(numIndividuals*overPopulation + generation*numIndividuals + individual)/total);
			if (usePoolA)
			{
				if (firstTime == false) // Skip computing poolA errors the first time as they have been already computed
				{
					poolA[individual].error = fabs(igenetic->GeneticGetError(poolA[individual].bits));
					if (poolA[individual].error < bestIndividual.error)
					{
						bestIndividual = poolA[individual]; 
						error->SetTry(bestIndividual.error);
					}
				}
				if (running.GetTry(brunning))
				{
					if (brunning == false) break;
				}
			}
			else
			{
				poolB[individual].error = fabs(igenetic->GeneticGetError(poolB[individual].bits));
				if (poolB[individual].error < bestIndividual.error)
				{
					bestIndividual = poolB[individual]; 
					error->SetTry(bestIndividual.error);
				}
				if (running.GetTry(brunning))
				{
					if (brunning == false) break;
				}
			}
		}
		//___________________________________________ End of Current Generation
		firstTime = false;
		if (usePoolA)
		{
			CreateNewGeneration(poolA, poolB);
			usePoolA = false;
		}
		else
		{
			CreateNewGeneration(poolB, poolA);
			usePoolA = true;
		}
	}

	//____________________________________________ End of Evolution
	error->SetTry(bestIndividual.error);
	igenetic->GeneticReportBestIndividual(bestIndividual.bits);
	if (stopWhenDone == true)
	{
		running.Set(false);
		return 0;
	}
	return 0;
}

void GeneticAlgorithm::CreateNewGeneration(vector<Math::GeneticIndividual>& parents, vector<Math::GeneticIndividual>& children)
{
	ComputeFitness(parents);
	ComputeChoices(parents); //It updates selection vector
	//_______________________________________________Generate the children
	const int numIndividuals = parents.size();
	int numCrossover = (int)(crossoverProbability * numIndividuals+0.5); 
	bool bFirstChild = true; 
	int motherIndex = -1;
	int fatherIndex = -1;
	int count = numIndividuals;
	int i, j;

	for (i=0; i<numIndividuals; i++, numCrossover--) 
	{
		if (bFirstChild) SelectParents(count, motherIndex, fatherIndex); // Returns the mother index and the father index

		if (numCrossover > 0)
		{
			//__________________________ Crossovers
			Reproduce(parents[motherIndex], parents[fatherIndex], children[i], bFirstChild);	
		}
		else if (bFirstChild)
		{
			children[i] = parents[motherIndex];
		}
		else
		{
			children[i] = parents[fatherIndex];
		}

		bFirstChild = ! bFirstChild;
	}

	//________________________________________________________ Mutation
	std::tr1::uniform_real<double> probability(0.0, 1.0);
	const int individualSize = poolA[0].bits.GetCount();
	for(i=0; i<numIndividuals; i++)
	{
		for(j=0; j<individualSize; j++)
		{
			if (probability(Math::Statistics::random_generator) < mutationProbability)
			{
				children[i].bits.FlipBit(j);
			}
		}
	}
}

void GeneticAlgorithm::ComputeFitness(vector<Math::GeneticIndividual>& pool)
{
	const int numIndividuals = poolA.size();
	int i;
	double avgFitness = 0.0;
	double maxFitness = -1.e30;
	double minFitness = 1.e30;
	double fitness;

	//_______________________________ Computer maximum, minimum and average (fitness)
	for (i=0; i<numIndividuals; i++) 
	{
		fitness = exp(-20.0 * pool[i].error);
		pool[i].fitness = fitness;
		avgFitness += fitness;
		if (fitness > maxFitness) maxFitness = fitness;
		if (fitness < minFitness) minFitness = fitness;
	}
	avgFitness /= (double) numIndividuals;

	//_______________________________ linear transformation y = m x + b
	double deltaFitness = maxFitness - avgFitness;
	double m = 1.0;
	double b = 0.0;
	const double favor_best = 3.1;
	if (deltaFitness > 1.e-20) 
	{ 
		m = (favor_best - 1.0) * avgFitness / deltaFitness;
		b = avgFitness * (maxFitness - favor_best * avgFitness) / deltaFitness;
	}

	//_______________________________ force positive fitness values
	if (m * minFitness + b < 0.0)
	{ 
		deltaFitness = avgFitness - minFitness;
		if (deltaFitness > 1.e-20) 
		{
			m = avgFitness / deltaFitness;
			b = -minFitness * avgFitness / deltaFitness;
		}
		else 
		{
			m = 1.0;
			b = 0.0;
		}
	}

	//____________________________________________ scale
	avgFitness = 0.0;
	for (i=0; i<numIndividuals; i++) 
	{
		fitness = m * pool[i].fitness + b;
		if (fitness < 0.0) fitness = 0.0;
		pool[i].fitness = fitness;
		avgFitness += fitness;
	}
	avgFitness /= (double) numIndividuals;

	//Normalize: fitness is the expected number of times the individual may be chosen
	for (i=0; i<numIndividuals; i++)
	{
		pool[i].fitness =  pool[i].fitness / avgFitness;
	}
}

void GeneticAlgorithm::ComputeChoices (vector<Math::GeneticIndividual>& pool)
{
	const int numIndividuals = poolA.size();	
	int i = 0, k = 0, expected = 0;
	std::tr1::uniform_int<int> distInd(0, numIndividuals-1);
	std::tr1::uniform_real<double> probability(0.0, 1.0);

	//________________________ assigns parents according to the integer part of their expected frequencies.
	for (i=0, k=0; i<numIndividuals; i++) 
	{
		expected = (int) pool[i].fitness; 
		pool[i].fitness = pool[i].fitness - expected; 
		while (expected--) selection[k++] = i;
	}

	//________________________ assigns parents according to the remaining part of their expected frequencies.
	while (k < numIndividuals) 
	{  
		i = distInd(Math::Statistics::random_generator);
		if (pool[i].fitness> 0.0) // Individuals still having a chance to be selected
		{   
			if (pool[i].fitness >= probability(Math::Statistics::random_generator)) 
			{ 
				selection[k++] = i; 
				pool[i].fitness = pool[i].fitness - 1.0; // reduce probabily of being selected
			}
		}
	}
}

void GeneticAlgorithm::Reproduce(const Math::GeneticIndividual& mother, const Math::GeneticIndividual& father, Math::GeneticIndividual& out_child, bool isFirstChild)
{
	static int combinationPoint1 = 0;
	static int combinationPoint2 = 0;
	const int individualSize = mother.bits.GetCount();

	if (isFirstChild) 
	{
		tr1::uniform_int<int> dist(0, individualSize-1);
		const int a = dist(Math::Statistics::random_generator);
		const int b = dist(Math::Statistics::random_generator);
		if (a<b)
		{
			combinationPoint1 = a;
			combinationPoint2 = b;
		}
		else
		{
			combinationPoint1 = b;
			combinationPoint2 = a;
		}
		//_____________________________________________________ Create the first child
		out_child.bits = mother.bits;
		out_child.bits.CopyBits(father.bits, combinationPoint1, combinationPoint2);
	}
	else
	{
		//_____________________________________________________ Create the second child
		out_child.bits = father.bits;
		out_child.bits.CopyBits(mother.bits, combinationPoint1, combinationPoint2);
	}
}

void GeneticAlgorithm::SelectParents(int &count,  int &out_mother, int &out_father)
{

	//________________________________________ select mother
	std::tr1::uniform_int<int> disMother(0, count-1);
	int motherIndex = disMother(Math::Statistics::random_generator);
	out_mother = selection[motherIndex];   
	selection[motherIndex] = selection[--count]; 
	//________________________________________ select father
	std::tr1::uniform_int<int> disFather(0, count-1);
	int fatherIndex = disFather(Math::Statistics::random_generator);
	out_father = selection[fatherIndex];
	selection[fatherIndex] = selection[--count];
}

void GeneticAlgorithm::SetStopWhenDone(bool stopWhenDone)
{
	this->stopWhenDone = stopWhenDone;
}

void GeneticAlgorithm::ListIndividuals(HWND hWnd)
{
	wchar_t texto[256];
	wstring info;
	const int numIndividuals = poolA.size();

	int i;
	//__________________________________________________ pool A
	for(i=0; i<numIndividuals; i++)
	{
		_snwprintf_s(texto, 256, _TRUNCATE, L"ind[%d]\t\terror = %.10f\r\n", i, poolA[i].error);
		info += texto;
		::MessageBox(hWnd, info.c_str(), L"Pool A", MB_OK);
	}
	info = L"";
	//__________________________________________________ pool B
	for(i=0; i<numIndividuals; i++)
	{
		_snwprintf_s(texto, 256, _TRUNCATE, L"ind[%d]\t\terror = %.10f\r\n", i, poolB[i].error);
		info += texto;
		::MessageBox(hWnd, info.c_str(), L"Pool B", MB_OK);
	}
}

//_____________________________________________________________________FindMinimum
FindMinimum::FindMinimum(void)
{
}

FindMinimum::~FindMinimum(void)
{
}

// Given a function y = f(x), and two distinct initial values of x: a and b 
// Bracketing searches the downhill direction to return:
//     - three values of x:  a, b, c that bracket a minimum of the function
//     - three values of y: ya = f(a), yb = f(b), and yc = f(c).
void FindMinimum::Bracketing(Math::IFunction& func, Math::Point& a, Math::Point& b, Math::Point& c)
{
	const double golden_ration = 1.6180339887498948482045868343656;
	a.y = func.EvaluateFunc(a.x);
	b.y = func.EvaluateFunc(b.x);

	if (b.y > a.y) //_______________________________ Swap to go to the righ direction
	{ 
		Math::Point tmp = a;
		a = b; 
		b = tmp;
	}

	//________________________________________ Guess c
	c.x = b.x + golden_ration * (b.x - a.x); 
	c.y = func.EvaluateFunc(c.x);

	double m1 = 0.0; 
	double m2 = 0.0; 
	double delta_m = 0.0;
	Math::Point u;
	double edge = 0.0;
	double frac = 0.0;
	while (b.y > c.y) 
	{ 
		m1 = (b.x - a.x) * (b.y - c.y); 
		m2 = (b.x - c.x) * (b.y - a.y);
		delta_m = m2 - m1;
		frac = (fabs(delta_m) > 1.0e-20) ? fabs(delta_m) : 1.0e-20;
		frac = 2.0 * Math::Oper::Sign(frac, delta_m);
		u.x = b.x - ((b.x - c.x) * m2 - (b.x - a.x)* m1) / frac;
		edge = b.x + 100.0 * (c.x - b.x);

		if ((b.x - u.x)*(u.x - c.x) > 0.0) //_____________________________________ Case 1
		{ 
			u.y = func.EvaluateFunc(u.x);
			if (u.y < c.y) //Minimum between b and c
			{ 				
				a = b;
				b = u;
				return;
			} 
			else if (u.y > b.y) //Minimum between a and u
			{ 
				c = u;
				return;
			}
			else
			{
				u.x = c.x + golden_ration * (c.x - b.x); //Default
				u.y=func.EvaluateFunc(u.x);
			}
		} 
		else if ((c.x - u.x)*(u.x - edge) > 0.0)  //_________________________________ Case 2
		{ 
			u.y = func.EvaluateFunc(u.x);
			if (u.y < c.y) 
			{
				b = c;
				c = u;
				u.x += ( golden_ration * (u.x - c.x) );
				u.y = func.EvaluateFunc(u.x);
			}
		} 
		else if ((u.x - edge)*(edge - c.x) >= 0.0)  //______________________________ Case 3
		{ 
			u.x = edge;
			u.y = func.EvaluateFunc(u.x);
		} 
		else  //______________________________________________________ Case 4
		{ 
			u.x = c.x + golden_ration * (c.x - b.x);
			u.y = func.EvaluateFunc(u.x);
		}
		a = b;
		b = c;
		c = u;
	}
}

// It computes the value of x that minimizes y = f(x)
// given the values of a, b and c returned by the funcion Bracketing()
// The function returns the y = f(x) and min_out_x where min_out_x is value of x that produces the minimum value of y 
double FindMinimum::BrentWithDerivative(Math::IFunctionD& func, const double a, const double b, const double c, const double tol, double &out_min_x)
{
	double x1 = (a < c) ? a : c;
	double x2 = (a > c ) ? a : c;
	Math::DPoint p;
	p.x = b;
	p.y = func.EvaluateFunc(p.x);
	p.dy = func.EvaluateDeri(p.x);
	Math::DPoint w = p;
	Math::DPoint v = p;
	Math::DPoint u;
	double xm = 0.0;
	double tol1 = 0.0;
	double tol2 = 0.0;
	double d = 0.0;
	double d1 = 0.0;
	double d2 = 0.0;
	double u1 = 0.0;
	double u2 = 0.0;
	bool ok1 = false;
	bool ok2 = false;
	double olderror = 0.0;
	double error = 0.0;
	const double epsilon = numeric_limits<double>::epsilon()*1.0e-3;

	for (int i = 0; i < 110; i++) 
	{
		xm = 0.5 * (x1 + x2);
		tol1 = tol * fabs(p.x) + epsilon;
		tol2 = 2.0*tol1;
		if (fabs(p.x - xm) <= (tol2-0.5*(x2 - x1))) 
		{
			out_min_x = p.x;
			return p.y;
		}

		if (fabs(error) > tol1) 
		{
			d1 = 2.0 * (x2 - x1); 
			d2 = d1; 
			if (w.dy != p.dy)
			{
				d1 = (w.x - p.x)*p.dy/(p.dy - w.dy); 
			}
			if (v.dy != p.dy) 
			{
				d2 = (v.x - p.x) * p.dy / (p.dy - v.dy); 
			}
			//
			u1 = p.x + d1;
			u2 = p.x + d2;
			ok1 = (x1 - u1)*(u1 - x2) > 0.0 && p.dy*d1 <= 0.0;
			ok2 = (x1 - u2)*(u2 - x2) > 0.0 && p.dy*d2 <= 0.0;
			olderror = error; 
			error = d;
			if (ok1 == true || ok2 == true) 
			{ 
				if (ok1 == true && ok2 == true)
				{
					d = (fabs(d1) < fabs(d2)) ? d1 : d2;
				}
				else if (ok1 == true)
				{
					d = d1;
				}
				else
				{
					d = d2;
				}

				if (fabs(d) <= fabs(0.5*olderror)) 
				{
					u.x = p.x + d;
					if (u.x - x1 < tol2 || x2 - u.x < tol2)
					{
						d = Math::Oper::Sign(tol1, xm - p.x);
					}
				} 
				else 
				{ 
					error = (p.dy >= 0.0) ? (x1 - p.x) : (x2 - p.x);
					d = 0.5 * error;
				}
			} 
			else 
			{
				error = (p.dy >= 0.0) ? (x1 - p.x) : (x2 - p.x);
				d = 0.5 * error;
			}
		} 
		else 
		{
			error = (p.dy >= 0.0) ? (x1 - p.x) : (x2 - p.x);
			d = 0.5 * error;
		}
		if (fabs(d) >= tol1) 
		{
			u.x = p.x + d;
			u.y = func.EvaluateFunc(u.x);
		} 
		else 
		{
			u.x = p.x + Math::Oper::Sign(tol1, d);
			u.y = func.EvaluateFunc(u.x);
			if (u.y > p.y) 
			{ 
				out_min_x = p.x;
				return p.y;
			}
		}

		u.dy = func.EvaluateDeri(u.x); 
		if (u.y <= p.y) 
		{
			if (u.x >= p.x)
			{
				x1 = p.x; 
			}
			else 
			{
				x2 = p.x;
			}
			v = w;
			w = p;
			p = u;
		} 
		else 
		{
			if (u.x< p.x)
			{
				x1 = u.x; 
			}
			else
			{
				x2 = u.x;
			}
			if (u.y <= w.y || w.x == p.x) 
			{
				v = w;
				w = u;
			} 
			else if (u.y < v.y || v.x == p.x || v.x == w.x) 
			{
				v = u;
			}
		}
	}
	return 9.99e300;
}


//_____________________________________________________________________ FindMinimumMV
FindMinimumMV::FindMinimumMV()
{
	ifunc = NULL;
	stopWhenDone = true;
	error = NULL;
	numIterations = 220;
	goal = 1.0e-8;
	method = WT_MATH_CONJGRAD;
}

FindMinimumMV::~FindMinimumMV()
{
}

bool FindMinimumMV::Setup(Mt::DoubleTs& error, Math::IMultiVarFuncD& ifunc, const valarray<double>& startingPoint, int numIterations, double goal, int method)
{
	if (method != WT_MATH_CONJGRAD && method != WT_MATH_VARMETRIC) return false;
	this->method = method;
	this->error = &error;
	this->ifunc = &ifunc;
	const int size = startingPoint.size();
	if (size == 0) return false;

	try
	{
		solution = startingPoint;
		derivative.resize(size);
		derg.resize(size);
		derh.resize(size);
		//
		xtmp.resize(size);
		dertmp.resize(size);
		//
		if (method == WT_MATH_VARMETRIC)
		{
			g.resize(size);
			hessian.resize(size);
			for(int i = 0; i<size; i++) hessian[i].resize(size);
		}
	}
	catch (const std::bad_alloc& )
	{
		return false;
	}
	this->numIterations = numIterations;
	this->goal = goal;
	return true;
}


DWORD FindMinimumMV::ThreadFunc(Mt::BoolTs& running, Mt::DoubleTs& progress, Mt::BoolTs& resetTime)
{
	if (ifunc == NULL) return 0;
	if (error == NULL) return 0;
	progress.SetTry(0.0);
	double derror = 9.99e300;

	if (method == WT_MATH_CONJGRAD)
	{
		derror = ConjugateGradient(running, progress);
	}
	else if (method == WT_MATH_VARMETRIC)
	{
		derror = VariableMetric(running, progress);
	}
	error->Set(derror);
	if (stopWhenDone) running.Set(false);
	return 0;
}

double FindMinimumMV::ConjugateGradient(Mt::BoolTs& running, Mt::DoubleTs& progress)
{
	const int len= solution.size();
	if (len == 0) return 9.99e300;
	bool brunning = false;
	double derror = 9.99e300;
	double gradient, gam, dgg;
	const double ftol = 1.0e-7;

	//________________________________ Compute the function and its derivative at the starting solution
	double fx = ifunc->EvaluateFunc(solution); 
	ifunc->EvaluateGrad(solution, derivative); 
	
	derivative = -derivative;
	derh = derivative;
	derg = derivative;
	int i = 0, j = 0;

	for(i = 1; i<= numIterations; i++) 
	{ 
		progress.SetTry(100.0*i/(double)numIterations);
		if (running.GetTry(brunning))
		{
			if (brunning == false) return derror;
		}
		derror = MoveAlongDirection(); 
		if (running.GetTry(brunning))
		{
			if (brunning == false) return derror;
		}
		error->SetTry(derror);
		//____________________________________ Stop when goal has been reached
		if (derror <= goal) return derror;
		//____________________________________ Stop when there is no improvement
		if (2.0*fabs(derror-fx) <= ftol*(fabs(derror)+fabs(fx)+1.0e-8)) 
		{
			return derror; // done
		}
		fx = derror;
		ifunc->EvaluateGrad(solution, derivative); 
		dgg = gradient = 0.0;
		for (j=0; j<len; j++) 
		{
			gradient += derg[j]*derg[j];
			dgg += (derivative[j]+derg[j])*derivative[j]; 
		}
		if (gradient == 0.0) //____________________ Stop when gradient is zero
		{
			return derror;
		}
		gam=dgg/gradient;
		for (j=0; j<len; j++) 
		{
			derg[j] = -derivative[j];
			derivative[j] = derh[j]= derg[j] + gam * derh[j];
		}
	}
	return derror;
}

double FindMinimumMV::VariableMetric(Mt::BoolTs& running, Mt::DoubleTs& progress)
{
	const int len= solution.size();
	if (len == 0) return 9.99e300;
	bool brunning = false;
	double derror = 9.99e300;
	const double ftol = 1.0e-7;

	//________________________________ Compute the function and its derivative at the starting solution
	double fx = ifunc->EvaluateFunc(solution);
	ifunc->EvaluateGrad(solution, g);

	int i = 0, j = 0;
	double sum = 0.0;

	for (i=0; i<len; i++) 
	{
		for (j=0; j<len; j++)
		{
			hessian[i][j]=0.0;
		}
		hessian[i][i]=1.0;
		sum += solution[i]*solution[i];
	}
	derivative = -g;
	double c = 0.0;
	double d = 0.0;
	double e = 0.0;

	for (int iteration = 0; iteration < numIterations; iteration++) 
	{
		progress.SetTry(100.0*i/(double)numIterations);
		if (running.GetTry(brunning))
		{
			if (brunning == false) return derror;
		}
		derror = this->MoveAlongDirection();
		if (running.GetTry(brunning))
		{
			if (brunning == false) return derror;
		}
		error->SetTry(derror);
		//____________________________________ Stop when goal has been reached
		if (derror <= goal) return derror;
		//_____________________________________________  Stop when there is no improvement
		if (2.0*fabs(derror - fx) <= ftol*(fabs(derror)+fabs(fx)+1.0e-10)) 
		{
			return derror;
		}
		fx = derror;
		derg = g; 
		derror = ifunc->EvaluateFunc(solution);
		ifunc->EvaluateGrad(solution, g);
		 derg = g - derg; 
		 derh = 0.0;
		for (i=0; i<len; i++) 
		{
			for (j=0; j<len; j++)
			{
				derh[i] += hessian[i][j]*derg[j];
			}
		}
		c = 0.0;
		e = 0.0;
		for (i=0; i<len; i++) 
		{
			c += derg[i]*derivative[i];
			e += derg[i]*derh[i];
		}

		c=1.0/c;
		d=1.0/e;
		derg = c* derivative - d * derh;
		for (i = 0; i < len; i++) 
		{
			for (j = i; j < len; j++) 
			{
				hessian[i][j] += c * derivative[i] * derivative[j] - d * derh[i] * derh[j] + e * derg[i] * derg[j];
				hessian[j][i]=hessian[i][j];
			}
		}
		derivative = 0.0;
		for (i=0; i<len; i++) 
		{
			for (j=0; j<len; j++) derivative[i] -= hessian[i][j] * g[j];
		}
	}
	return derror;
}

void FindMinimumMV::SetStopWhenDone(bool stopWhenDone)
{
	this->stopWhenDone = stopWhenDone;
}

double FindMinimumMV::MoveAlongDirection()
{
	Math::Point a, x, b;
	a.x = 0.0;
	x.x = 1.0;
	double min_x = 0.0;
	Math::FindMinimum::Bracketing(*this, a, x, b);
	const double error = Math::FindMinimum::BrentWithDerivative(*this, a.x, x.x, b.x, 3.0e-08, min_x);
	derivative *= min_x;
	solution += derivative;
	return error;
}

double FindMinimumMV::EvaluateFunc(const double x)
{
	xtmp = solution + x * derivative;
	return ifunc->EvaluateFunc(xtmp);
}

double FindMinimumMV::EvaluateDeri(const double x)
{
	xtmp = solution + x * derivative;
	ifunc->EvaluateGrad(xtmp, dertmp);
	const int len = solution.size();
	double sum = 0.0;
	for(int j = 0; j<len; j++) sum += dertmp[j]*derivative[j];
	return sum;
}

//_____________________________________________________________________ SingularValueDecomposition
SingValDecompos::SingValDecompos(void)
{
}

SingValDecompos::~SingValDecompos(void)
{
}

wchar_t* SingValDecompos::Decompose(const MATRIX& in_a, MATRIX& out_u, valarray<double>& out_s, MATRIX& out_v)
{
	try
	{
		out_u = in_a;
	}
	catch(const std::bad_alloc& )
	{
		return L"No enough memory";
	}
	return Decompose(out_u, out_s, out_v);
}

// A = (U)(S)(VT)
//MATRIX a(3, 3);
//a[0][0]=1;
//a[0][1]=2;
//a[0][2]=3;
//a[1][0]=4;
//a[1][1]=5;
//a[1][2]=6;
//a[2][0]=7;
//a[2][1]=8;
//a[2][2]=9;
//MATRIX v;
//valarray<double> s;
//Math::SingValDecompos::Decompose(a, s, v);
//
//MATRIX S(3, 3);
//S[0][0] = s[0];
//S[1][1] = s[1];
//S[2][2] = s[2];
//MATRIX result;
//Math::Oper::Product(a, S, result);
//MATRIX vt;
//MATRIX A;
//Math::Oper::Transpose(v, vt);
//Math::Oper::Product(result, vt, A);
//______________________________________
// Matrix U is returned in A
// Matrix S is returned in vector s
// Matrix V is not transposed
wchar_t* SingValDecompos::Decompose(MATRIX& a, valarray<double>& s, MATRIX& v)
{
	const int rows = a.size();
	const int cols = (rows == 0) ? 0 : a[0].size();

	if (rows<cols) return L"The number or rows must be greater than or equal to the number of columns";

	int i = 0;
	valarray<double> in;
	try 
	{
		//__________________ v
		v.resize(cols);
		for(i = 0; i < cols; i++)
		{
			v[i].resize(cols);
		}
		//__________________ s
		s.resize(cols);
		//__________________ in
		in.resize(cols);
	}
	catch (std::bad_alloc const&) 
	{
		return L"No enough memory to perform Singular Value Decomposition";
	}

	int j, jj, k, nm;
	double anorm, c, f, g, h, sep, scale, x, y, z;
	bool isSplitting = false;
	int iteracionCount = 0;
	double max1, max2; 
	int index = 0;

	g=scale=anorm=0.0; //Householder reduction to bidiagonal form.
	for (i=0; i<cols; i++) 
	{
		index = i+1;
		in[i]=scale*g;
		g=sep=scale=0.0;
		if (i < rows) 
		{
			for (k = i; k<rows; k++)
			{
				scale += fabs(a[k][i]);
			}
			if (scale>0.0) 
			{
				for (k = i; k < rows; k++) 
				{
					a[k][i] /= scale; 
					sep += a[k][i]*a[k][i];
				}
				f=a[i][i];
				g=-Sign(sqrt(sep), f);
				h=f*g-sep;
				a[i][i]=f-g; 
				for (j = index; j<cols; j++) 
				{
					for (sep = 0.0, k=i; k < rows; k++)
					{
						sep += a[k][i]*a[k][j];
					}
					f=sep/h;
					for (k=i; k<rows; k++)
					{
						a[k][j] += f*a[k][i];
					}
				}
				for (k = i; k<rows; k++) 
				{
					a[k][i] *= scale;
				}
			}
		}
		s[i] = scale *g;
		g=sep=scale=0.0;
		if (i < rows && i != cols-1)
		{
			for (k = index; k<cols; k++)
			{
				scale += fabs(a[i][k]);
			}
			if (scale>0.0)
			{
				for (k = index; k<cols; k++) 
				{
					a[i][k] /= scale;
					sep += a[i][k]*a[i][k];
				}
				f=a[i][index];
				g = -Sign(sqrt(sep),f);
				h=f*g-sep;
				a[i][index] = f-g;
				for (k=index; k<cols; k++)
				{
					in[k]=a[i][k]/h;
				}
				for (j = index; j < rows; j++) 
				{
					for (sep=0.0, k = index; k<cols; k++)
					{
						sep += a[j][k]*a[i][k];
					}
					for (k = index; k<cols; k++)
					{
						a[j][k] += sep*in[k];
					}
				}
				for (k = index; k < cols; k++)
				{
					a[i][k] *= scale;
				}
			}
		}

		max1 = anorm; 
		max2 =fabs(s[i])+fabs(in[i]);
		anorm = (max1 > max2) ? max1 : max2;
	}
	for (i = cols-1; i >= 0; i--)
	{ 
		if (i < cols-1) 
		{
			if (g!=0.0) 
			{
				for (j = index; j<cols; j++)
				{
					v[j][i]=(a[i][j]/a[i][index])/g;
				}
				for (j = index; j<cols; j++) 
				{
					for (sep=0.0, k=index; k<cols; k++)
					{
						sep += a[i][k]*v[k][j];
					}
					for (k = index; k<cols; k++) 
					{
						v[k][j] += sep*v[k][i];
					}
				}
			}
			for (j = index; j < cols; j++)
			{
				v[i][j] = 0.0;
				v[j][i] = 0.0;
			}
		}
		v[i][i] = 1.0;
		g = in[i];
		index = i;
	}

	const int init = ( (rows-1) < (cols-1)) ? (rows-1) : (cols-1);
	for (i= init; i>=0; i--)
	{ 
		index = i+1;
		g = s[i];
		for (j = index; j<cols; j++)
		{
			a[i][j]=0.0;
		}
		if (g!=0.0) 
		{
			g=1.0/g;
			for (j = index; j<cols; j++) 
			{
				for (sep = 0.0, k = index; k<rows; k++)
				{
					sep += a[k][i]*a[k][j];
				}
				f=(sep/a[i][i])*g;
				for (k=i; k<rows; k++)
				{
					a[k][j] += f*a[k][i];
				}
			}
			for (j=i; j<rows; j++)
			{
				a[j][i] *= g;
			}
		} 
		else 
		{
			for (j=i; j<rows; j++) 
			{
				a[j][i]=0.0;
			}
		}
		++a[i][i];
	}

	for (k = cols-1; k >= 0; k--) 
	{ 
		for (iteracionCount = 0; iteracionCount < 100; iteracionCount++) 
		{
			isSplitting =  true;
			for (index = k; index >= 0; index--) 
			{ 
				nm = index-1; 
				if ((double)(fabs(in[index])+anorm) == anorm) 
				{
					isSplitting = false;
					break;
				}
				if ((double)(fabs(s[nm])+anorm) == anorm) break;
			}
			if (isSplitting == true) 
			{
				c = 0.0;
				sep=1.0;
				for (i = index; i<=k; i++) 
				{
					f = sep*in[i];
					in[i] = c*in[i];
					if ((double)(fabs(f)+anorm) == anorm) break;
					g = s[i];
					h = Module(f, g);
					s[i]=h;
					h=1.0/h;
					c=g*h;
					sep = -f*h;
					for (j = 0; j < rows; j++) 
					{
						y = a[j][nm];
						z = a[j][i];
						a[j][nm] = y*c + z*sep;
						a[j][i] = z*c - y*sep;
					}
				}
			}
			z = s[k];

			if (index == k) //Convergence.
			{ 
				if (z < 0.0) //Singular value is made nonnegative.
				{ 
					s[k] = -z;
					for (j=0; j<cols; j++) 
					{
						v[j][k] = -v[j][k];
					}
				}
				break;
			}

			if (iteracionCount == 100) return L"Singular Value Decomposition no convergence in 100 iterations";
			x = s[index]; 
			nm = k-1;
			y = s[nm];
			g = in[nm];
			h = in[k];
			f = ((y-z)*(y+z)+(g-h)*(g+h))/(2.0*h*y);
			g = Module(f, 1.0);
			f = ((x-z)*(x+z)+h*((y/(f+Sign(g,f)))-h))/x;
			c = sep = 1.0; //Next QR transformation:
			for (j = index; j <= nm; j++) 
			{
				i = j+1;
				g = in[i];
				y = s[i];
				h = sep*g;
				g = c*g;
				z = Module(f, h);
				in[j] = z;
				c = f/z;
				sep = h/z;
				f = x*c + g*sep;
				g = g*c - x*sep;
				h = y*sep;
				y *= c;
				for (jj=0; jj<cols; jj++) 
				{
					x = v[jj][j];
					z = v[jj][i];
					v[jj][j] = x*c + z*sep;
					v[jj][i] = z*c - x*sep;
				}
				z = Module(f,h);
				s[j] = z;
				if (z > 0) 
				{
					z = 1.0/z;
					c = f*z;
					sep = h*z;
				}
				f = c*g + sep*y;
				x = c*y - sep*g;
				for (jj = 0; jj < rows; jj++) 
				{
					y = a[jj][j];
					z = a[jj][i];
					a[jj][j] = y*c + z*sep;
					a[jj][i] = z*c - y*sep;
				}
			}
			in[index] = 0.0;
			in[k] = f;
			s[k] = x;
		}
	}
	return NULL;
}

double SingValDecompos::Sign(double a, double b)
{
	if (b > 0.0) return fabs(a);
	return - fabs(a);
}

//pow(a*a + b*b, 0.5) 
double SingValDecompos::Module(double a, double b)
{
	a = fabs(a);
	b = fabs(b);

	if (a == 0.0 && b == 0.0) return 0.0;
	if (a == 0.0) return b;
	if (b == 0.0) return a;
	double tmp;

	if (a > b) 
	{
		tmp = b/a;
		return a*sqrt(1.0+ tmp * tmp);
	}
	tmp = a/b;
	return b*sqrt(1.0+ tmp * tmp);
}

//Solves A·x = b for a vector X
//where A is specified by U S V from a singular value descomposition U[m n], s[n], V[n n]
// b[m], x[n]
//1.  Call Decompose to produce S, U, V.  Matrix U is return in variable a 
//2.  Call BackSubstitution providing S, U, V as returned by Decompose
//Returns false if not enough memory
bool SingValDecompos::BackSubstitution(const MATRIX& u, const valarray<double>& s, const MATRIX& v, const valarray<double>& b, valarray<double>& x)
{
	int rows = u.size(); 
	int cols = (rows==0) ? 0 : u[0].size();
	int jj,j,i;
	double sep;
	
	valarray<double> tmp;

	try
	{
		tmp.resize(cols);
		x.resize(cols);
	}
	catch(std::bad_alloc const&)
	{
		return false;
	}

	for (j=0; j<cols; j++)
	{ 
		sep = 0.0;
		if (s[j] != 0.0)
		{ 
			for (i=0; i<rows; i++)
			{
				sep += u[i][j]*b[i];
			}
			sep /= s[j]; 
		}
		tmp[j] = sep;
	}
	 //________________________________ Multiply by V
	for (j=0; j<cols; j++)
	{ 
		sep = 0.0;
		for (jj=0; jj< cols; jj++)
		{
			sep += v[j][jj]*tmp[jj];
		}
		x[j] = sep;
	}
	return true;
}

//_____________________________________________________________________ Remez
Remez::~Remez()
{
}

Remez::Remez()
{
}

bool Remez::IsExtrema(double w, int index, int numPoints)
{
	if (w == 0.0) return false;
	if (w == M_PI) return false;
	if (index == 0) return true;
	if (index == numPoints-1) return true;
	return false;
}

double Remez::ComputeImpulseResponse(const vector<Math::Remez::Band>& in_band, int length, valarray<double>& out_impulseResponse)
{
	return ImpulseResponse(in_band, length, REMEZ_BANDPASS, out_impulseResponse);
}

double Remez::ComputeHilbertImpulseResponse(int length, valarray<double>& out_impulseResponse)
{
	vector<Math::Remez::Band> band(1);
	band[0].gain = 1.0;
	band[0].priory = 1.0;
	band[0].w1 = 0.0;
	band[0].w2 = M_PI;
	return ImpulseResponse(band, length, REMEZ_HILBERT, out_impulseResponse);
}

double Remez::ComputeDifferentiatorImpulseResponse(int length, valarray<double>& out_impulseResponse)
{
	vector<Math::Remez::Band> band(1);
	band[0].gain = 1.0;
	band[0].priory = 1.0;
	band[0].w1 = 0.0;
	band[0].w2 = M_PI;
	return ImpulseResponse(band, length, REMEZ_DIFFERENTIATOR, out_impulseResponse);
}

int Remez::ComputeType(int M, int remezType)
{
	if (M % 2 == 0) //_________________ M is even
	{
		if (remezType == REMEZ_BANDPASS) return REMEZ_TYPE_I;
		 return REMEZ_TYPE_III;
	}
	//___________________________ M is odd
	if (remezType == REMEZ_BANDPASS) return REMEZ_TYPE_II;
	return REMEZ_TYPE_IV;
}

//Oppenheim & Schafer: problem 7.35
int Remez::ComputeL(int M, int type)
{                                                                                                                                                                                                                                                                                                                                                                                                                                            
	switch(type)
	{
	case REMEZ_TYPE_I: return M/2; //Oppenheim & Schafer: between equation 7.105 and 7.106
	case REMEZ_TYPE_II: return (M-1)/2; //Oppenheim & Schafer: problem 7.35 (b)
	case REMEZ_TYPE_III: return (M-2)/2; //Oppenheim & Schafer: problem 7.35 (d)
	case REMEZ_TYPE_IV: return (M-1)/2; //Oppenheim & Schafer: problem 7.35 (d)
	}
	return 0;
}

void Remez::CreatePerformanceData(const vector<Math::Remez::Band> in_band, int type, int L, vector<BandPoint>& out_perfomanceData)
{
	const double deltaFreq = M_PI / (L * REMEZ_DENSITY);
	const int numBands = in_band.size();
	Math::Remez::BandPoint bandPoint;
	vector<BandPoint>::iterator p;
	int i= 0, j = 0;
	int numPoints = 0;
	for(i = 0; i < numBands; i++)
	{
		bandPoint.w = in_band[i].w1;
		bandPoint.gain = in_band[i].gain;
		bandPoint.priority = in_band[i].priory;
		bandPoint.error = 1.0e100;
		//___________________________________ Adjust first point for Differentiator and Hilbert
		if (i == 0 && (type == REMEZ_TYPE_III || type == REMEZ_TYPE_IV))
		{
			if (bandPoint.w < deltaFreq) bandPoint.w = deltaFreq;
		}
		//
		numPoints = (int)( ((in_band[i].w2 - bandPoint.w)/deltaFreq) + 1.5);
		for(j = 0; j < numPoints; j++)
		{
			bandPoint.isExtrema = IsExtrema(bandPoint.w, j, numPoints);
			bandPoint.x = cos(bandPoint.w);
			out_perfomanceData.push_back(bandPoint);
			//
			bandPoint.w += deltaFreq;
		}
		//____________________________ adjust last point in each band to w2
		p = out_perfomanceData.end()-1;
		p->w = in_band[i].w2;
		p->x = cos(p->w);
		if (p->w == M_PI) p->isExtrema = false;
	}

	//_________________________________ Adjust last point for Differentiator and Hilbert
	if (type == REMEZ_TYPE_IV) // type == REMEZ_TYPE_III
	{
		p = out_perfomanceData.end()-1;
		if (p->w > (M_PI - deltaFreq))
		{
			p->w = M_PI - deltaFreq;
		}
	}

}

void Remez::CreateInitialExtremaIndex(vector<BandPoint>& in_performanceData, int L, set<int>& out_extremaIndex)
{
	const int len = in_performanceData.size();
	int i = 0;
	//________________________First, we insert all cut frequencies and all stop frequencies
	//for(i = 0; i<len ; i++)
	//{
	//	if (in_performanceData[i].isExtrema == false) continue;
	//	if (in_performanceData[i].w == 0.0) continue;
	//	if (in_performanceData[i].w == M_PI) continue;
	//	out_extremaIndex.insert(i);
	//}
	//______________________ Second, we insert uniform distributed frequencies
	for(i = 0; i<L+1; i++)
	{
		out_extremaIndex.insert(i*(len-1)/L);
	}
	//if ((int)out_extremaIndex.size() < L+2)
	//{
	//	// we add extra values, to reach a length of L+2
	//	set<int>::iterator q;
	//	std::tr1::minstd_rand gen;// linear congruential generator
	//	std::tr1::uniform_int<int> dist(0, len-1);// uniform integer distribution
	//	gen.seed((unsigned int)::GetTickCount());// initialize the generator
	//	int index = 0;
	//	while((int)out_extremaIndex.size() < L+2)
	//	{
	//		index = dist(gen);
	//		q = out_extremaIndex.find(index);
	//		if (q != out_extremaIndex.end()) continue;
	//		out_extremaIndex.insert(index);
	//	}
	//}
	//else if ((int)out_extremaIndex.size() > L+2)
	//{
	//	// we remove extra values, to reach a length of L+2
	//	set<int>::iterator q;
	//	std::tr1::minstd_rand gen;// linear congruential generator
	//	std::tr1::uniform_int<int> dist(0, len-1);// uniform integer distribution
	//	gen.seed((unsigned int)::GetTickCount());// initialize the generator
	//	int index = 0;
	//	while((int)out_extremaIndex.size() > L+2)
	//	{
	//		index = dist(gen);
	//		q = out_extremaIndex.find(index);
	//		if (q == out_extremaIndex.end()) continue;
	//		if (in_performanceData[*q].isExtrema == false)
	//		{
	//			out_extremaIndex.erase(q);
	//		}
	//	}
	//}
}

double Remez::ImpulseResponse(const vector<Math::Remez::Band>& in_band, int length, int remezType, 
	valarray<double>& out_impulseResponse, valarray<double>& error, valarray<double>& freq)
{
	if (length%2 == 0) length++;
	const int M = length -1;
	const int type = ComputeType(M, remezType);
	const int L = ComputeL(M, type);
	int i = 0;

	//____________________________________ Create Performance Data
	vector<BandPoint> performanceData;
	CreatePerformanceData(in_band, type, L, performanceData);
	const int perfDataLen = performanceData.size();
	if (remezType == REMEZ_DIFFERENTIATOR)
	{
		for(i = 0; i < perfDataLen; i++)
		{
			if (performanceData[i].gain > 0.0001) 
			{
				performanceData[i].priority = 2.0*M_PI *performanceData[i].priority / performanceData[i].w;
			}
		}
	}
	AdjustPerformanceData(performanceData, type);

	//____________________________________ Create extrema index
	set<int> extremaIndex;
	set<int> newExtremaIndex;
	CreateInitialExtremaIndex(performanceData, L, extremaIndex);

	//___________________________________ Variable declaration
	valarray<double> b(L+2);//Oppenheim & Schafer: equation (7.132)
	valarray<double> C(L+1);//Oppenheim & Schafer: equation (7.133b)
	valarray<double> d(L+1);//Oppenheim & Schafer: equation (7.133c)
	double delta = 0.0;//Oppenheim & Schafer: equation (7.131)

	//___________________________________ Iterate
	for(i = 0; i<100; i++)
	{
		ComputeB(performanceData, extremaIndex, b);
		delta = ComputeDelta(performanceData, extremaIndex, b);
		ComputeD(performanceData, extremaIndex, b, d);
		ComputeC(performanceData, extremaIndex, delta, C);
		ComputeErrors(performanceData, extremaIndex, C, d);
		UpdateExtremaIndex(performanceData, L, newExtremaIndex);	
		if (extremaIndex == newExtremaIndex) break;
		extremaIndex = newExtremaIndex;
	}

	//_______________________________________ Compute A
	//double factor = 0.0;
	//valarray<double> A(length);
	//for(i = 0; i <= L; i++)
	//{
	//	switch(type)
	//	{
	//	case REMEZ_TYPE_I:
	//		factor = 1.0;
	//		break;
	//	case REMEZ_TYPE_II:
	//		factor = cos(M_PI*(double)i/L);
	//		break;
	//	case REMEZ_TYPE_III:
	//		factor = sin(2.0*M_PI*(double)i/L);
	//		break;
	//	case REMEZ_TYPE_IV:
	//		factor = sin(M_PI*(double)i/L);
	//		break;
	//	}
	//	A[i] = factor*ComputeA(performanceData, extremaIndex, performanceData[i].w, C, d);
	//}

	//FreqToTime(length, A, out_impulseResponse, type);

	//______________________________________________________ Copy data for debuging purposes
	out_impulseResponse.resize(perfDataLen);
	ComputeA(performanceData, extremaIndex, C, d, out_impulseResponse);
	error.resize(perfDataLen);
	freq.resize(perfDataLen);
	for(i = 0 ; i < perfDataLen; i++)
	{
		freq[i] = performanceData[i].w;
		error[i] = performanceData[i].error;
	}
	return ComputeMaxError(performanceData);
}

double Remez::ImpulseResponse(const vector<Math::Remez::Band>& in_band, int length, int remezType, 
	valarray<double>& out_impulseResponse)
{
	if (length%2 == 0) length++;
	const int M = length -1;
	const int type = ComputeType(M, remezType);
	const int L = ComputeL(M, type);
	int i = 0;

	//____________________________________ Create Performance Data
	vector<BandPoint> performanceData;
	CreatePerformanceData(in_band, type, L, performanceData);
	const int perfDataLen = performanceData.size();
	if (remezType == REMEZ_DIFFERENTIATOR)
	{
		for(i = 0; i < perfDataLen; i++)
		{
			if (performanceData[i].gain > 0.0001) 
			{
				performanceData[i].priority = 2.0*M_PI *performanceData[i].priority / performanceData[i].w;
			}
		}
	}
	AdjustPerformanceData(performanceData, type);

	//____________________________________ Create extrema index
	set<int> extremaIndex;
	set<int> newExtremaIndex;
	CreateInitialExtremaIndex(performanceData, L, extremaIndex);

	//___________________________________ Variable declaration
	valarray<double> b(L+2);//Oppenheim & Schafer: equation (7.132)
	valarray<double> C(L+1);//Oppenheim & Schafer: equation (7.133b)
	valarray<double> d(L+1);//Oppenheim & Schafer: equation (7.133c)
	double delta = 0.0;//Oppenheim & Schafer: equation (7.131)

	//___________________________________ Iterate
	for(i = 0; i<100; i++)
	{
		ComputeB(performanceData, extremaIndex, b);
		delta = ComputeDelta(performanceData, extremaIndex, b);
		ComputeD(performanceData, extremaIndex, b, d);
		ComputeC(performanceData, extremaIndex, delta, C);
		ComputeErrors(performanceData, extremaIndex, C, d);
		UpdateExtremaIndex(performanceData, L, newExtremaIndex);	
		if (extremaIndex == newExtremaIndex) break;
		extremaIndex = newExtremaIndex;
	}

	//_______________________________________ Compute A
	double factor = 0.0;
	valarray<double> A(length);
	for(i = 0; i <= L; i++)
	{
		switch(type)
		{
		case REMEZ_TYPE_I:
			factor = 1.0;
			break;
		case REMEZ_TYPE_II:
			factor = cos(M_PI*(double)i/L);
			break;
		case REMEZ_TYPE_III:
			factor = sin(2.0*M_PI*(double)i/L);
			break;
		case REMEZ_TYPE_IV:
			factor = sin(M_PI*(double)i/L);
			break;
		}
		A[i] = factor*ComputeA(performanceData, extremaIndex, performanceData[i].w, C, d);
	}

	FreqToTime(length, A, out_impulseResponse, type);

	//______________________________________________________ Copy data for debuging purposes
	//out_impulseResponse.resize(perfDataLen);
	//ComputeA(performanceData, extremaIndex, C, d, out_impulseResponse);
	//error.resize(perfDataLen);
	//freq.resize(perfDataLen);
	//for(i = 0 ; i < perfDataLen; i++)
	//{
	//	freq[i] = performanceData[i].w;
	//	error[i] = performanceData[i].error;
	//}
	return ComputeMaxError(performanceData);
}

void Remez::FreqToTime(int length, valarray<double>& in_A_freq, valarray<double>& out_A_time, int type)
{
	int n, k;
	const double M = (length-1.0)/2.0;
	double value, x;
	out_A_time.resize(length);

	//const unsigned int N = input.size();
	//output.resize(N);
	//const double f = (2*M_PI)/(double)N;
	//unsigned int i, j;
	//complex<double> tmp;
	//double sum; 
	//complex<double> real;

	//for(i=0; i<N; i++) //Direct calculation
	//{
	//	sum= 0.0;
	//	for (j=0; j<N; j++)
	//	{
	//		tmp._Val[_RE] = cos(f*i*j);
	//		tmp._Val[_IM] = sin(f*i*j);
	//		real = input[j]*tmp;
	//		sum+= real.real();
	//	}
	//	output[i] = sum;
	//}
	//output /= N;

	switch(type)
	{
	case REMEZ_TYPE_I:
		for(n = 0; n < length; n++)
		{
			value = in_A_freq[0];
			x = 2.0*M_PI*(n-M)/length;
			for(k = 1; k <= M; k++)
			{
				value += 2.0*in_A_freq[k]*cos(x*k);
			}
			out_A_time[n] = value/length;
		}
		break;
	case REMEZ_TYPE_II:
		for(n = 0; n < length; n++)
		{
			value = in_A_freq[0];
			x = 2.0*M_PI*(n-M)/length;
			for(k = 1; k <= (length/2-1); k++)
			{
				value += 2.0*in_A_freq[k]*cos(x*k);
			}
			out_A_time[n] = value/length;
		}
		break;
	case REMEZ_TYPE_III:
		for(n = 0; n < length; n++)
		{
			value = 0;
			x = 2.0*M_PI*(n-M)/length;
			for(k = 1; k <= M; k++)
			{
				value += 2.0*in_A_freq[k]*sin(x*k);
			}
			out_A_time[n] = value/length;
		}
		break;
	case REMEZ_TYPE_IV:
		for(n = 0; n < length; n++)
		{
			value = in_A_freq[length/2] * sin(M_PI*(n-M));
			x = 2.0*M_PI*(n-M)/length;
			for(k = 1; k <= (length/2-1); k++)
			{
				value += 2.0*in_A_freq[k]*sin(x*k);
			}
			out_A_time[n] = value/length;
		}
		break;
	}
}

void Remez::ComputeErrors(vector<BandPoint>& in_performanceData,  set<int>& in_extremaIndex, valarray<double>& in_C, valarray<double>& in_d)
{
	const int len = in_performanceData.size();
	double A = 0.0;
	for(int i = 0; i < len; i++)
	{
		A= ComputeA(in_performanceData, in_extremaIndex, in_performanceData[i].w, in_C, in_d);
		in_performanceData[i].error = in_performanceData[i].priority*(in_performanceData[i].gain - A);
	}
}

double Remez::ComputeMaxError(vector<BandPoint>& in_performanceData)
{
	const int len = in_performanceData.size();
	if (len == 0) return 1.0e+100;
	double maxval = fabs(in_performanceData[0].error);
	const vector<BandPoint>::iterator bandPointEnd = in_performanceData.end();
	vector<BandPoint>::iterator p;
	for(p = in_performanceData.begin(); p != bandPointEnd; p++)
	{
		if (fabs(p->error) > maxval) maxval =  fabs(p->error);
	}
	return maxval;
}

void Remez::AdjustPerformanceData(vector<BandPoint>& in_performanceData, int type)
{
	const int len = in_performanceData.size();
	int k = 0;
	double tmp = 0.0;
	switch(type)
	{
	case REMEZ_TYPE_I: 
		// Nothing to do
		break; 
	case REMEZ_TYPE_II: 
		for(k = 0; k< len; k++)
		{
			tmp = cos(in_performanceData[k].w/2);
			//Oppenheim & Schafer: equation (7.127)
			in_performanceData[k].gain /= tmp; //Hd
			//Oppenheim & Schafer: equation (7.128)
			in_performanceData[k].priority *= tmp;//W
		}
		break;
	case REMEZ_TYPE_III:
		//Oppenheim & Schafer: problem 7.35 (d)
		for(k = 0; k< len; k++)
		{
			tmp = sin(in_performanceData[k].w);
			in_performanceData[k].gain /= tmp; //Hd
			in_performanceData[k].priority *= tmp; //W
		}
		break;
	case REMEZ_TYPE_IV:
		//Oppenheim & Schafer: problem 7.35 (d)
		for(k = 0; k< len; k++)
		{
			tmp = sin(in_performanceData[k].w/2);
			in_performanceData[k].gain /= tmp; //Hd
			in_performanceData[k].priority *= tmp;//W
		}
		break;
	}
}

//Oppenheim & Schafer: equation (7.131)
double Remez::ComputeDelta(vector<BandPoint>& in_performanceData, set<int>& in_extremaIndex, valarray<double>& in_b)
{
	double numerator = 0.0;
	double denominator = 0.0;
	double sign = 1.0;
	int k = 0;
	const set<int>::iterator extremaIndexEnd = in_extremaIndex.end();
	set<int>::iterator pk;
	for(pk = in_extremaIndex.begin(); pk != extremaIndexEnd; pk++, k++)
	{
		numerator += (in_b[k] *in_performanceData[*pk].gain);
		denominator += (sign * in_b[k] /in_performanceData[*pk].priority);
		sign = -sign;
	}
	if (fabs(denominator) < 1.0e-100) denominator = 1.0e-100;
	return numerator/denominator;
}

//Oppenheim & Schafer: equation (7.132)
void Remez::ComputeB(vector<BandPoint>& in_performanceData, set<int>& in_extremaIndex, valarray<double>& out_b)
{
	if (out_b.size() != in_extremaIndex.size())
	{
		out_b.resize(in_extremaIndex.size()); // never get here
	}
	double xk;
	int k = 0;
	set<int>::iterator pk, pi;
	const set<int>::iterator extremaIndexEnd = in_extremaIndex.end();
	double denominator = 1.0;
	for(pk = in_extremaIndex.begin(); pk != extremaIndexEnd; pk++, k++)
	{
		xk = in_performanceData[*pk].x;
		denominator = 1.0;
		for(pi = in_extremaIndex.begin(); pi != extremaIndexEnd; pi++)
		{
			if (pi == pk) continue;
			denominator *= (xk - in_performanceData[*pi].x);
		}
		if (fabs(denominator) < 1.0e-100) denominator = 1.0e-100;
		out_b[k] = 1.0 / denominator;
	}
}

//Oppenheim & Schafer: equation (7.133a)
double Remez::ComputeA(vector<BandPoint>& in_performanceData, set<int>& in_extremaIndex, double w, valarray<double>& in_C, valarray<double>& in_d)
{
	double numerator = 0.0;
	double denominator = 0.0;
	const double x = cos(w);
	const int len = in_C.size();
	double tmp = 0.0;
	double dx = 0.0;
	set<int>::iterator pk = in_extremaIndex.begin();

	for(int k = 0; k<len; k++, pk++)
	{
		dx = x - in_performanceData[*pk].x;
		if (fabs(dx) <1.0e-10) return in_C[k];
		tmp = in_d[k]/dx;
		numerator += tmp*in_C[k];
		denominator += tmp;
	}
	return numerator/denominator;
}

void Remez::ComputeA(vector<BandPoint>& in_performanceData, set<int>& in_extremaIndex, valarray<double>& in_C, valarray<double>& in_d, valarray<double>& out_A)
{
	const int len = out_A.size();
	for(int i = 0; i<len; i++)
	{
		out_A[i] = ComputeA(in_performanceData, in_extremaIndex, in_performanceData[i].w, in_C, in_d);
	}
}

//Oppenheim & Schafer: equation (7.133b)
void Remez::ComputeC(vector<BandPoint>& in_performanceData, set<int>& in_extremaIndex, double delta, valarray<double>& out_C)
{
	const int len = out_C.size();
	double sign = 1.0;
	set<int>::iterator pk = in_extremaIndex.begin();
	for(int k = 0; k < len; k++, pk++)
	{
		out_C[k] = in_performanceData[*pk].gain - sign * delta / in_performanceData[*pk].priority; // C = Hd - (-1) Delta / W
		sign = -sign;
	}
}

//Oppenheim & Schafer: equation (7.133c)
void Remez::ComputeD(vector<BandPoint>& in_performanceData, set<int>& in_extremaIndex, valarray<double>& in_b, valarray<double>& out_d)
{
	const int len = out_d.size();
	const int pflen = in_performanceData.size(); // This is the last element of the vector
	const double xLplusTwo = in_performanceData[pflen-1].x;
	set<int>::iterator pk = in_extremaIndex.begin();
	for(int k = 0; k < len; k++, pk++)
	{
		out_d[k] = in_b[k]*(in_performanceData[*pk].x - xLplusTwo);
	}
}

void Remez::UpdateExtremaIndex(vector<BandPoint>& in_performanceData, int L, set<int>& out_newExtremaIndex)
{
	out_newExtremaIndex.clear();
	const int len = in_performanceData.size();
	if (len == 0) return;
	if (len == 1) return;
	int i = 0;
	//_____________________________ Add all cut frequencies and all stop band frequencies
	for(i = 0; i < len; i++)
	{
		if (in_performanceData[i].isExtrema == true)
		{
			out_newExtremaIndex.insert(i);
		}
	}

	//____________________________ Find all extrema
	Math::Remez::Extrema extrema;
	list<Math::Remez::Extrema> extremaList;
	double current = 0.0;
	double next = 0.0;
	double previous = 0.0;

	//____________________________ Check if w = 0 is extrema
	current = in_performanceData[0].error;
	next = in_performanceData[1].error;
	extrema.index = 0;
	extrema.error = current;
	if (current > 0)
	{
		if (current > next) extremaList.push_back(extrema);
	}
	else
	{
		if (current < next) extremaList.push_back(extrema);
	}

	//____________________________ Check if w = pi is extrema
	current = in_performanceData[len-1].error;
	previous = in_performanceData[len-2].error;
	extrema.index = len-1;
	extrema.error = current;
	if (current > 0)
	{
		if (current > previous) extremaList.push_back(extrema);
	}
	else
	{
		if (current < previous) extremaList.push_back(extrema);
	}

	//____________________________________ Look for extrema in between
	for(i = 1; i < len-1; i++)
	{
		if (in_performanceData[i].isExtrema == true) continue;
		previous = in_performanceData[i-1].error;
		current = in_performanceData[i].error;
		next = in_performanceData[i+1].error;
		if (current >= 0)
		{
			if (previous < current && current > next)
			{
				extrema.index = i;
				extrema.error = in_performanceData[i].error;
				extremaList.push_back(extrema);
			}
		}
		else
		{
			if (previous > current && current < next)
			{
				extrema.index = i;
				extrema.error = in_performanceData[i].error;
				extremaList.push_back(extrema);
			}
		}
	}
	extremaList.sort(); // Sort extrema so that we can use the biggest
	list<Math::Remez::Extrema>::reverse_iterator p = extremaList.rbegin();
	const list<Math::Remez::Extrema>::reverse_iterator pend = extremaList.rend();
	while((int)out_newExtremaIndex.size() < L+2)
	{
		if (p == pend) break;
		out_newExtremaIndex.insert(p->index);
		p++;
	}
}

//_____________________________________________________________________ Dsp
Dsp::~Dsp()
{
}

Dsp::Dsp()
{
}

bool Dsp::Convolution(const valarray<double>& input_x, const valarray<double>& input_y, valarray<double>& result)
{
	const int nX =input_x.size();
	const int nY = input_y.size();
	const int n = nX+nY-1;
	int i=0, j=0, index=0;
	double sum;

	try
	{
		result.resize(n);
	}
	catch(const std::bad_alloc& )
	{
		return false;
	}
	if (n<=0) return false;
	
	for(i=0; i<n; i++)
	{
		sum = 0.0;
		for(j=0; j<i+1; j++)
		{
			index = i-j;
			if (0<=j && j<nX && 0<=index && index<nY) 
				sum += (input_x[j]*input_y[index]);
		}
		result[i]= sum;
	}
	return true;
}

bool Dsp::ShortConvolution(const valarray<double>& input_x, const valarray<double>& input_h, valarray<double>& result)
{
	const int length_h = input_h.size();
	const int M = length_h-1;
	const int alpha = M/2;
	const int length = input_x.size();
	try
	{
		result.resize(length);
	}
	catch(const std::bad_alloc& )
	{
		return false;
	}
	valarray<double> output;
	if (Math::Dsp::Convolution(input_x, input_h, output)==false) return false;
	for(int n=0; n<length; n++) result[n] = output[n+alpha];
	return true;	
}
	
bool Dsp::IsPowerOfTwo(int input)
{
	double d = log10((double)input)/log10(2.0);
	return (d-(int)(d)==0);
}

int Dsp::FindNextPowerOfTwo(int input)
{
	int new_n = (int)(log10((double)input)/log10(2.0))+1;
	return (int)pow(2.0, new_n);
	//int new_n = (int)(log10((double)n)/log10(2.0))-1;
	//int result = 0;
	//for(int i = new_n; i< 4294967290; i++)
	//{
	//	if (pow(2, i)<n && n<=pow(2, i+1))
	//	{
	//		result = (int)pow(2, i+1);
	//		break;
	//	}
	//}
	//return result;
}

int Dsp::FindPreviousPowerOfTwo(int input)
{
	int new_n = (int)(log10((double)input)/log10(2.0));
	return (int)pow(2.0, new_n);
}

void Dsp::FourierTransform(const valarray<complex<double> >& input, valarray<complex<double> >& output, bool inverse)
{
	const unsigned int N = input.size();
	//Math::Matrix mreal, mimag;
	//double sumr = 0.0, sumi = 0.0;
	output.resize(N);
	//int i, j, k;
	const double f = inverse ? (2*M_PI)/(double)N : (-2*M_PI)/(double)N;

	//bool optimize = mreal.Create(N, N);
	//if (optimize) optimize = mimag.Create(N, N);

	//if (optimize==false)
	//{
	//	mreal.Delete();
	//	mimag.Delete();
	//}

	//if (optimize)
	//{
	//	for(i=0; i<N; i++) 
	//	{		
	//		mreal[0][i] = 1;//*************** first row is e^0=1+0j
	//		mimag[0][i]=0;
	//		//
	//		mreal[i][0] = 1;//************************** first col is e^0=1+0j
	//		mimag[i][0]=0;
	//	}

	//	for(i=1; i<N; i++)
	//	{
	//		for (j=i; j<N; j++)
	//		{
	//			mreal[i][j] = cos(f*i*j);
	//			mimag[i][j] = sin(f*i*j);
	//			//	
	//			mreal[j][i] = mreal[i][j];//**************** Fill simmetric part
	//			mimag[j][i] = mimag[i][j];
	//		}
	//	}

	//	for(i=0; i<N; i++)
	//	{
	//		sumr = 0.0;
	//		sumi = 0.0;
	//		for (j=0; j<N; j++)
	//		{
	//			sumr+=(input[j]*mreal[i][j]);
	//			sumi+=(input[j]*mimag[i][j]);
	//		}
	//		k = 2*i;
	//		output[k] = sumr;
	//		output[k+1] = sumi;
	//	}
	//}
	//else
	//{
		unsigned int i, j;
		complex<double> tmp;
		complex<double> sum; 

		for(i=0; i<N; i++) //If there is no memory, perform direct calcularion
		{
			sum= 0.0;
			for (j=0; j<N; j++)
			{
				tmp._Val[_RE] = cos(f*i*j);
				tmp._Val[_IM] = sin(f*i*j);
				sum += input[j]*tmp;
			}
			output[i] =sum;
		}
		if (inverse) output /= N;
	//}
}

void Dsp::FourierTransformRe(const valarray<double>& input, valarray<complex<double> >& output)
{
	const unsigned int N = input.size();
	output.resize(N);
	const double f = (-2*M_PI)/(double)N;
	unsigned int i, j;
	complex<double> tmp;
	complex<double> sum; 

	for(i=0; i<N; i++) // Direct calculation
	{
		sum= 0.0;
		for (j=0; j<N; j++)
		{
			tmp._Val[_RE] = input[j]*cos(f*i*j);
			tmp._Val[_IM] = input[j]*sin(f*i*j);
			sum += tmp;
		}
		output[i] =sum;
	}
}

void Dsp::InverseFourierTransformRe(const valarray<complex<double> >& input, valarray<double>& output)
{
	const unsigned int N = input.size();
	output.resize(N);
	const double f = (2*M_PI)/(double)N;
	unsigned int i, j;
	complex<double> tmp;
	double sum; 
	complex<double> real;

	for(i=0; i<N; i++) //Direct calculation
	{
		sum= 0.0;
		for (j=0; j<N; j++)
		{
			tmp._Val[_RE] = cos(f*i*j);
			tmp._Val[_IM] = sin(f*i*j);
			real = input[j]*tmp;
			sum+= real.real();
		}
		output[i] = sum;
	}
	output /= N;
}

wchar_t* Dsp::Fft(valarray<complex<double> >& in_out,bool inverse)
{
	const unsigned int size = in_out.size();
	
	if (Math::Dsp::IsPowerOfTwo(size) == false) return L"The input lenght must be a power of two";
	unsigned int i, j = 0, k;
	unsigned int px;
	complex <double> tx, t1, u, c;
	const unsigned int m = (int)(log((double)size)/log((double)2));

	//unsigned int n = 1;
	//for(i = 0; i < m; i++) n <<= 1;   

	const unsigned int i2 = size >> 1;
	for (i = 0; i < size-1 ; i++)
	{
		if (i < j) swap(in_out[i], in_out[j]);
		k = i2;
		while (k <= j) 
		{
			j -= k;
			k >>= 1;
		}
		j += k;
	}
	c.real(-1.0);
	c.imag(0.0);
	int nx = 1, ca;
	for (unsigned int mx = 0; mx < m; mx++) 
	{
		px = nx;
		nx <<= 1;
		u.real(1.0);
		u.imag(0.0);

		for (j = 0; j <px; j++) 
		{
			for (i = j; i < size; i += nx) 
			{
				ca = i + px;
				t1 = u * in_out[ca];
				in_out[ca] = in_out[i] - t1; 
				in_out[i] += t1;
			}
			u = u * c;
		}
		c.imag(sqrt((1.0 - c.real()) / 2.0));
		if (inverse==false) c.imag(-c.imag());
		c.real(sqrt((1.0 + c.real()) / 2.0));
	}

	if (inverse == true) in_out /= size;      
	//{
	//	for (i = 0; i < size; i++)
	//	{
	//		if (i == size-1) break;
	//		{
	//			in_out[i] = 0.0;
	//			break;
	//		}
	//		in_out[i] = in_out[i] / (double)size;
	//	}
	//}
	return NULL;
}

wchar_t* Dsp::Fft(const valarray<double>& input, valarray<complex<double> >& output, bool inverse)
{
	const int in_size = input.size();
	const int out_size = output.size();
	try
	{
		if (in_size != out_size) output.resize(in_size);
		for(int i = 0; i<in_size; i++) output[i] = input[i];
	}
	catch(const std::bad_alloc& )
	{
		return L"No enough memory";
	}
	return Math::Dsp::Fft(output, inverse);
}

wchar_t* Dsp::RealFft(valarray<double>& in_out, bool inverse)
{
	const int size = in_out.size();
	if (size == 0) return NULL;
	valarray<complex<double> > tmp;
	int i = 0;
	try
	{
		tmp.resize(size);
		for(i = 0; i<size; i++)
		{
			tmp[i] = in_out[i];
		}
	}
	catch(const std::bad_alloc& )
	{
		return L"No enough memory";
	}
	wchar_t * error = Fft(tmp, inverse);
	if (error != NULL) return error;
	for(i = 0; i<size; i++)
	{
		if (i%2 == 0)
		{
			in_out[i] = tmp[i].real();
		}
		else
		{
			in_out[i] = tmp[i].imag();
		}
	}
	return NULL;
}

wchar_t* Dsp::RealFft(const valarray<double>& input, valarray<double>& output, bool inverse)
{
	const int size = input.size();
	if (size == 0) return NULL;
	if (size <=1) return NULL;
	valarray<complex<double> > tmp;
	int i = 0;
	try
	{
		tmp.resize(size);
		output.resize(size);
		if (inverse == true)
		{	
			//________________________ Complete symmetric conjugate spectrum
			const int mid = size/2;
			//____________ offset
			tmp[0] = input[0];
			//____________ first part
			for(i = 1; i<mid; i++)
			{
				tmp[i]._Val[0] = input[2*i-1];
				tmp[i]._Val[1] = input[2*i];
			}
			//____________ middle
			tmp[mid] = input[size-1];
			//____________ symm conj
			for(i = 1; i<mid; i++)
			{
				tmp[mid+i]._Val[0] = input[2*mid-2*i-1];
				tmp[mid+i]._Val[1] = -input[2*mid-2*i];
			}
		}
		else
		{
			//________________________ Just copy real part
			for(i = 0; i<size; i++)
			{
				tmp[i] = input[i];
			}
		}
	}
	catch(const std::bad_alloc& )
	{
		return L"No enough memory";
	}
	wchar_t * error = Fft(tmp, inverse);
	if (error != NULL) return error;
	if (inverse == true)
	{
		//________________________ Just copy real part
		for(i = 0; i<size; i++)
		{
			output[i] = tmp[i].real();
		}
	}
	else
	{
		//________________________ Remove symmetric conjugate spectrum
		for(i = 0; i<size; i++)
		{
			if (i == 0)
			{
				output[0] = tmp[0].real();
			}
			else if (i > 0)
			{
				output[2*i-1] = tmp[i].real();
				if (2*i == size) break;
				output[2*i] = tmp[i].imag();
			}
		}
	}
	return NULL;
}

wchar_t* Dsp::RealFft(MATRIX& in_out, bool inverse)
{
	const int rows = in_out.size();
	if (rows == 0) return NULL;
	wchar_t* error = NULL;
	for(int i = 0; i<rows; i++)
	{
		error = RealFft(in_out[i], inverse);
		if (error) return error;
	}
	return NULL;
}

wchar_t* Dsp::RealFft(const MATRIX& input, MATRIX& output, bool inverse)
{
	const int rows = input.size();
	if (rows == 0) return NULL;
	try
	{
		output.resize(rows);
	}
	catch(const std::bad_alloc& )
	{
		return L"No enough memory";
	}
	wchar_t* error = NULL;
	for(int i = 0; i<rows; i++)
	{
		error = RealFft(input[i], output[i], inverse);
		if (error) return error;
	}
	return NULL;
}

wchar_t* Dsp::Periodogram(const valarray<complex<double> >& input, valarray<double>& output)
{
	valarray<complex<double> > tmp(input);
	wchar_t* error = Math::Dsp::Fft(tmp, false);
	if (error) return error;
	Math::Dsp::GetModulus(tmp, output);
	//if (bScale) output[i] = output[i] / (2*M_PI*n);
	return NULL;
}

void Dsp::GetModulus(const valarray<complex<double> >& input, valarray<double>& output)
{
	const unsigned int len = input.size();
	output.resize(len);
	for(unsigned int i=0; i<len; i++)
	{
		output[i] = input[i].real()*input[i].real() + input[i].imag()*input[i].imag();
	}
}

wchar_t* Dsp::Fft(MATRIXC& in_out, bool inverse)
{
	const int rows = in_out.size();
	if (rows == 0) return NULL;
	const int cols = in_out[0].size();
	if (cols == 0) return NULL;
	if (Math::Dsp::IsPowerOfTwo(cols) == false) return L"The number of columns must be a power of 2";
	for(int i = 0; i<rows; i++)
	{
		Math::Dsp::Fft(in_out[i], inverse);
	}
	return NULL;
}

wchar_t* Dsp::Fft(const valarray<complex<double> >& input, valarray<complex<double> >& output, bool inverse)
{
	output = input;
	return Math::Dsp::Fft(output, inverse);
}

wchar_t* Dsp::Fft(const MATRIX& input, MATRIXC& output, bool inverse)
{
	const int rows = input.size();
	if (rows == 0) return NULL;
	const int cols = input[0].size();
	if (cols == 0) return NULL;
	if (Math::Dsp::IsPowerOfTwo(cols) == false) return L"The number of columns must be a power of 2";
	try
	{
		if (output.size() != rows) output.resize(rows);
		for(int i = 0; i<rows; i++)
		{
			if (output[i].size() != cols) output[i].resize(cols);
			Math::Dsp::Fft(input[i], output[i], inverse);
		}
	}
	catch(const std::bad_alloc& )
	{
		return L"No enough memory";
	}
	return NULL;
}

wchar_t* Dsp::Fft(const MATRIXC& input, MATRIXC& output, bool inverse)
{
	const int rows = input.size();
	if (rows == 0) return NULL;
	const int cols = input[0].size();
	if (cols == 0) return NULL;
	if (Math::Dsp::IsPowerOfTwo(cols) == false) return L"The number of columns must be a power of 2";
	try
	{
		if (output.size() != rows) output.resize(rows);
		for(int i = 0; i<rows; i++)
		{
			if (output[i].size() != cols) output[i].resize(cols);
			Math::Dsp::Fft(input[i], output[i], inverse);
		}
	}
	catch(const std::bad_alloc& )
	{
		return L"No enough memory";
	}
	return NULL;
}

void Dsp::SpectrumUnfold(valarray<complex<double> >& in_out)
{
	const int len = in_out.size();
	if (len <= 1) return;
	complex <double> tmp;
	int i = 0;
	const int half = len/2;
	if (len%2 == 0)
	{	
		for(i = 0; i < half; i++)
		{
			tmp = in_out[i];
			in_out[i] = in_out[i+half];
			in_out[i+half] = tmp;
		}
	}
	else
	{
		complex <double> first = in_out[0];
		for(i = 1; i <= half; i++) // invert
		{
			tmp = in_out[i];
			in_out[i] = in_out[i+half];
			in_out[i+half] = tmp;
		}
		for(i = 0; i < half; i++) // shift first half
		{
			in_out[i] = in_out[i+1];
		}
		in_out[half] = first;
	}
}

void Dsp::SpectrumUnfold(valarray<double>& in_out)
{
	const int len = in_out.size();
	if (len <= 1) return;
	double tmp;
	int i = 0;
	const int half = len/2;
	if (len%2 == 0)
	{	
		for(i = 0; i < half; i++)
		{
			tmp = in_out[i];
			in_out[i] = in_out[i+half];
			in_out[i+half] = tmp;
		}
	}
	else
	{
		double first = in_out[0];
		for(i = 1; i <= half; i++) // invert
		{
			tmp = in_out[i];
			in_out[i] = in_out[i+half];
			in_out[i+half] = tmp;
		}
		for(i = 0; i < half; i++) // shift first half
		{
			in_out[i] = in_out[i+1];
		}
		in_out[half] = first;
	}
}

wchar_t* Dsp::Spectrum(const valarray<double>& input, valarray<double>& output)
{
	valarray<complex<double> > y;
	wchar_t* error = Math::Dsp::Fft(input, y, false);
	if (error) return error;
	const int len = input.size()/2;
	try
	{
		if (output.size() != len) output.resize(len);
		for(int i = 0; i<len; i++)
		{
			output[i] = abs(y[i]);
		}
	}
	catch(const std::bad_alloc& )
	{
		return L"No enough memory";
	}
	return NULL;
}

wchar_t* Dsp::Spectrum(const valarray<complex<double>>& input, valarray<double>& output)
{
	valarray<complex<double> > y;
	wchar_t* error = Math::Dsp::Fft(input, y, false);
	if (error) return error;
	const int len = input.size()/2;
	try
	{
		if (output.size() != len) output.resize(len);
		for(int i = 0; i<len; i++)
		{
			output[i] = abs(y[i]);
		}
	}
	catch(const std::bad_alloc& )
	{
		return L"No enough memory";
	}
	return NULL;
}

wchar_t* Dsp::Spectrum(const MATRIX& input, MATRIX& output)
{
	const int rows = input.size();
	if (rows == 0)
	{
		output.clear();
		return NULL;
	}
	const int cols = input[0].size();
	{
		output.clear();
		return NULL;
	}
	if (Math::Dsp::IsPowerOfTwo(cols) == false) return L"The number of columns must be a power of 2";
	try
	{
		if (output.size() != rows) output.resize(rows);
		for(int i = 0; i<rows; i++)
		{
			Math::Dsp::Spectrum(input[i], output[i]);
		}
	}
	catch(const std::bad_alloc& )
	{
		return L"No enough memory";
	}
	return NULL;
}

wchar_t* Dsp::Spectrum(const MATRIXC& input, MATRIX& output)
{
	const int rows = input.size();
	if (rows == 0)
	{
		output.clear();
		return NULL;
	}
	const int cols = input[0].size();
	{
		output.clear();
		return NULL;
	}
	if (Math::Dsp::IsPowerOfTwo(cols) == false) return L"The number of columns must be a power of 2";
	try
	{
		if (output.size() != rows) output.resize(rows);
		for(int i = 0; i<rows; i++)
		{
			Math::Dsp::Spectrum(input[i], output[i]);
		}
	}
	catch(const std::bad_alloc& )
	{
		return L"No enough memory";
	}
	return NULL;
}

double Dsp::Impulse(int n, int delay) // n is the discrete time d[n-delay]
{
	return (n==delay) ? 1 : 0;
}

double Dsp::Step(int n, int delay) // n is the discrete time u[n-delay]
{
	return (n-delay)>=0 ? 1 : 0;
}

double Dsp::Sin(int n, double k, int delay) // n is the discrete time Sin(kn-delay)
{
	return sin(n*k-delay);
}

double Dsp::Sinc(int n, double k, int delay) // n is the discrete time Sin(kn-delay)
{
	double t = n*k-delay;
	if (t==0) return 1;
	return sin(M_PI*t)/(M_PI*t);
}

double Dsp::Sinc(double x)
{
	if (x==0) return 1.0;
	return sin(M_PI*x)/(M_PI*x);
}

double Dsp::Sawtooth(double x, double period)
{
	const double half = period/2.0;
	if (x==0) return 0.0;
	if (x>0)
		while(x>half) x-=period;
	else
		while(x<half) x+=period;
	return x/half;
}

double Dsp::Triangular(double x, double period)
{
	const double half = period/2.0;
	if (x==0) return 1.0;
	if (x>0)
		while(x>half) x-=period;
	else
		while(x<half) x+=period;
	if (x>0)
		return -4.0*x/period+1.0;
	else
		return 4.0*x/period+1.0;
	return 0.0;
}

double Dsp::Rectangular(double x, double period)
{
	const double half = period/2.0;
	if (x==0) return 0.0;
	if (x>0)
		while(x>half) x-=period;
	else
		while(x<half) x+=period;
	if (x>0)
		return 1.0;
	else
		return -1.0;
	return 0.0;
}

double Dsp::Pi(int n, int delay, int duration) // PI(n-delay)
{
	if (n-delay<-duration/2.0) return 0;
	if (duration/2.0<n-delay) return 0;
	return 1;
}

/*
This subroutine calculates the first kind modified Bessel function
of integer order N, for any REAL X. We use here the classical
recursion formula, when X > N. For X < N, the Miller's algorithm
is used to avoid overflows. 
REFERENCE:
C.W.CLENSHAW, CHEBYSHEV SERIES FOR MATHEMATICAL FUNCTIONS,
MATHEMATICAL TABLES, VOL.5, 1962.
*/
double Dsp::bessi(int n, double x) 
{
	int IACC = 40; 
	double BIGNO = 1e10, BIGNI = 1e-10;
	double TOX, BIM, BI, BIP, BSI;
	int J, M;

	if (n==0)  return (bessi0(x));
	if (n==1)  return (bessi1(x));
	if (x==0.0) return 0.0;

	TOX = 2.0/x;
	BIP = 0.0;
	BI  = 1.0;
	BSI = 0.0;
	M = (int) (2*((n+floor(sqrt((double)IACC*n)))));
	for (J = M; J>0; J--) 
	{
		BIM = BIP+J*TOX*BI;
		BIP = BI;
		BI  = BIM;
		if (fabs(BI) > BIGNO) 
		{
			BI  = BI*BIGNI;
			BIP = BIP*BIGNI;
			BSI = BSI*BIGNI;
		}
		if (J==n)  BSI = BIP;
	}
	return (BSI*bessi0(x)/BI);
}

double Dsp::bessi0(double x) 
{
	double Y;
	
	if (fabs(x) < 3.75) 
	{
		const double P1=1.0; 
		const double P2=3.5156229; 
		const double P3=3.0899424; 
		const double P4=1.2067429;
		const double P5=0.2659732; 
		const double P6=0.360768e-1; 
		const double P7=0.45813e-2;
		Y=(x/3.75)*(x/3.75);
		return (P1+Y*(P2+Y*(P3+Y*(P4+Y*(P5+Y*(P6+Y*P7))))));
	}
	else 
	{
		const double Q1=0.39894228; 
		const double Q2=0.1328592e-1; 
		const double Q3=0.225319e-2;
		const double Q4=-0.157565e-2; 
		const double Q5=0.916281e-2; 
		const double Q6=-0.2057706e-1;
		const double Q7=0.2635537e-1; 
		const double Q8=-0.1647633e-1; 
		const double Q9=0.392377e-2;
		double AX=fabs(x);
		Y=3.75/AX;
		const double BX=exp(AX)/sqrt(AX);
		AX=Q1+Y*(Q2+Y*(Q3+Y*(Q4+Y*(Q5+Y*(Q6+Y*(Q7+Y*(Q8+Y*Q9)))))));
		return (AX*BX);
	}
}

double Dsp::bessi1(double x) 
{
	double Y;

	if (fabs(x) < 3.75) 
	{
		const double P1=0.5; 
		const double P2=0.87890594; 
		const double P3=0.51498869; 
		const double P4=0.15084934;
		const double P5=0.2658733e-1; 
		const double P6=0.301532e-2; 
		const double P7=0.32411e-3;
		Y=(x/3.75)*(x/3.75);
		return(x*(P1+Y*(P2+Y*(P3+Y*(P4+Y*(P5+Y*(P6+Y*P7)))))));
	}
	else 
	{
		const double Q1=0.39894228; 
		const double Q2=-0.3988024e-1; 
		const double Q3=-0.362018e-2;
		const double Q4=0.163801e-2; 
		const double Q5=-0.1031555e-1; 
		const double Q6=0.2282967e-1;
		const double Q7=-0.2895312e-1; 
		const double Q8=0.1787654e-1; 
		const double Q9=-0.420059e-2;
		double AX=fabs(x);
		Y=3.75/AX;
		const double BX=exp(AX)/sqrt(AX);
		AX=Q1+Y*(Q2+Y*(Q3+Y*(Q4+Y*(Q5+Y*(Q6+Y*(Q7+Y*(Q8+Y*Q9)))))));
		return (AX*BX);
	}
}

void Dsp::KaiserWindow(double beta, int length, valarray<double>& out_window)
{
	const int M = length-1;
	out_window.resize(length);
	const double alpha = M/2.0;
	double z;
	//_j0, _j1, _jn
	for(int n=0; n<=M; n++)
	{
		z = (n-alpha)/(double)alpha;
		out_window[n] = Math::Dsp::bessi(0, beta*sqrt(1.0-z*z))/Math::Dsp::bessi(0, beta); 
	}
}

void Dsp::WelchWindow(int length, valarray<double>& out_window)
{
	const double n = (length-1.0)/2.0;
	const double m = (length+1.0)*(length+1.0)/4.0;

	out_window.resize(length);
	double w;
	for(int i=0; i<length; i++)
	{
		w = (i-n);
		out_window[i] = 1.0 - w*w/m;
	}
}

void Dsp::ImpulRespLowPass(double beta, int length, double cutFreqRad, valarray<double>& out_h)
{
	valarray<double> kaiser;
	Dsp::KaiserWindow(beta, length, kaiser);

	const int M = length-1;
	const double alpha = M/2.0;
	out_h.resize(length);

	for(int n=0; n<length; n++)
	{
		if (n-alpha == 0.0)
		{
			out_h[n]=cutFreqRad/M_PI;
		}
		else
		{
			out_h[n]=sin(cutFreqRad*(n-alpha))/(M_PI*(n-alpha));
		}
		out_h[n] = kaiser[n]*out_h[n];
	}
}

void  Dsp::ImpulRespHighPass(double beta, int length, double cutFreqRad, valarray<double>& out_h)
{
	valarray<double> kaiser;
	Dsp::KaiserWindow(beta, length, kaiser);
	const int M = length-1;
	const double alpha = M/2.0;
	out_h.resize(length);

	for(int n=0; n<length; n++)
	{
		if (n-alpha == 0.0)
		{
			out_h[n]=Math::Dsp::Sinc(n-alpha) - cutFreqRad/M_PI;
		}
		else
		{
			out_h[n]=Math::Dsp::Sinc(n-alpha) - sin(cutFreqRad*(n-alpha))/(M_PI*(n-alpha));
		}
		out_h[n] = kaiser[n]*out_h[n];
	}
}

double Dsp::ComputeBeta(double stopBandGaindB)
{
	const double A = fabs(stopBandGaindB);

	if (A>50)
	{
		return 0.1102*(A-8.7);
	}
	else if (A<21)
	{
		return 0.0;
	}
	else
	{
		return 0.5842*pow((A-21), 0.4) + 0.07886*(A-21);
	}
	return 0.0;
}

int Dsp::ComputeM(double stopBandGaindB, double transitionWidthRad)
{
	const double A = fabs(stopBandGaindB);
	return (int)((A-8)/(2.285*transitionWidthRad)+0.5);
}

void Dsp::ImpulRespLowPass(double sampFreqHz, double cutFreqHz, double stopBandGaindB, double transitionWidthHz, valarray<double>& out_h)
{
	const double cutFreqRad = 2.0 * M_PI * cutFreqHz / sampFreqHz;
	const double transitionWidthRad = 2.0 * M_PI * transitionWidthHz / sampFreqHz;
	const double beta = ComputeBeta(stopBandGaindB);
	const int length = ComputeM(stopBandGaindB, transitionWidthRad)+1;
	ImpulRespLowPass(beta, length, cutFreqRad, out_h);
}

void Dsp::ImpulRespHighPass(double sampFreqHz, double cutFreqHz, double stopBandGaindB, double transitionWidthHz, valarray<double>& out_h)
{
	const double cutFreqRad = 2.0 * M_PI * cutFreqHz / sampFreqHz;
	const double transitionWidthRad = 2.0 * M_PI * transitionWidthHz / sampFreqHz;
	const double beta = ComputeBeta(stopBandGaindB);
	const int length = ComputeM(stopBandGaindB, transitionWidthRad)+1;
	ImpulRespHighPass(beta, length, cutFreqRad, out_h);
}

void Dsp::FreqRespLowPass(double beta, int length, double cutFreqRad, valarray<double>& out_H)
{
	Math::Dsp::ImpulRespLowPass(beta, length, cutFreqRad, out_H);
	int i;
	valarray<complex<double> > freq(length);
	Math::Dsp::FourierTransformRe(out_H, freq);

	for(i=0; i<length; i++) //Compute Modulus
	{
		out_H[i] = abs(freq[i]);
	}
}

void Dsp::FreqRespHighPass(double beta, int length, double cutFreqRad, valarray<double>& out_H)
{
	Math::Dsp::ImpulRespHighPass(beta, length, cutFreqRad, out_H);
	int i;
	valarray<complex<double> > freq(length);
	Math::Dsp::FourierTransformRe(out_H, freq);

	for(i=0; i<length; i++) //Compute Modulus
	{
		out_H[i] = abs(freq[i]);
	}
	out_H[0] = 0.0; //Eliminate DC
}

bool Dsp::LowPass(const valarray<double>& input, valarray<double>& output, double cutFreqRad)
{
	const double beta = 6.0;
	const int M = 128;
	const int alpha = M/2;
	const int length = input.size();
	valarray<double> h, result;
	Math::Dsp::ImpulRespLowPass(beta, M+1, cutFreqRad, h);
	try
	{
		output.resize(length);
	}
	catch(const std::bad_alloc& )
	{
		return false;
	}
	if (Math::Dsp::Convolution(input, h, result)==false) return false;
	for(int n=0; n<length; n++) output[n] = result[n+alpha];
	return true;
}

bool Dsp::HighPass(const valarray<double>& input, valarray<double>& output, double cutFreqRad)
{
	const double beta = 6.0;
	const int M = 128;
	const int alpha = M/2;
	const int length = input.size();
	valarray<double> h, result;
	Math::Dsp::ImpulRespHighPass(beta, M+1, cutFreqRad, h);
	try
	{
		output.resize(length);
	}
	catch(const std::bad_alloc& )
	{
		return false;
	}
	if (Math::Dsp::Convolution(input, h, result)==false) return false;
	for(int n=0; n<length; n++) output[n] = result[n+alpha];
	return true;
}

void Dsp::ImpulRespHilbertTransform(double beta, int length, valarray<double>& out_h)
{
	const int M = length -1;
	out_h.resize(length);
	const double alpha = M/2.0;
	double z;
	double kaiser;
	double sinz;
	double delay;
	for(int n=0; n<length; n++)
	{
		if (n == alpha) 
		{
			out_h[n] = 0.0;
			continue;
		}
		delay = n-alpha;
		z = delay/(double)alpha;
		kaiser = Math::Dsp::bessi(0, beta*sqrt(1.0-z*z))/Math::Dsp::bessi(0, beta); 
		//
		sinz = sin(M_PI*delay/2.0);
		out_h[n] = kaiser*2.0*sinz*sinz/(M_PI*delay);
	}
}

void Dsp::FreqRespHilbertTransform(double beta, int length, valarray<double>& out_H)
{
	Math::Dsp::ImpulRespHilbertTransform(beta, length, out_H);
	const unsigned int size = out_H.size();
	unsigned int i;
	valarray<complex<double> > freq(size);
	Math::Dsp::FourierTransformRe(out_H, freq);

	const unsigned int freq_length = freq.size();
	out_H.resize(freq_length);
	for(i=0; i<freq_length; i++) //Compute Modulus
	{
		out_H[i] = abs(freq[i]);
	}
}

// rippleErrordB = -40.0 dB
void Dsp::ImpulRespHilbertTransform(double sampFreqHz, double rippleErrordB, double transitionWidthHz, valarray<double>& out_h)
{
	const double transitionWidthRad = 2.0 * M_PI * transitionWidthHz / sampFreqHz;
	const double beta = ComputeBeta(rippleErrordB);
	const int length = ComputeM(rippleErrordB, transitionWidthRad)+1;
	ImpulRespHilbertTransform(beta, length, out_h);
}

// rippleErrordB = -40.0 dB
void Dsp::FreqRespHilbertTransform(double sampFreqHz, double rippleErrordB, double transitionWidthHz, valarray<double>& out_H)
{
	const double transitionWidthRad = 2.0 * M_PI * transitionWidthHz / sampFreqHz;
	const double beta = ComputeBeta(rippleErrordB);
	const int length = ComputeM(rippleErrordB, transitionWidthRad)+1;
	FreqRespHilbertTransform(beta, length, out_H);
}

//_____________________________________________________________________ PidController
PidController::PidController(void)
{
	kp= 0.0;
	ki= 0.0;
	kd= 0.0;
	error= 0.0;
	prev_error= 0.0;
	target= 0.0;
	minControlValue= 0.0;
	maxControlValue= 0.0;
	controlValue= 0.0;
}

PidController::~PidController(void)
{
}

//returns the initial controlValue
double PidController::Create(double kp, double ki, double kd, double target, double minControlValue, double maxControlValue)
{
	this->kp= kp;
	this->ki=ki;
	this->kd=kd;
	this->target=target;
	this->minControlValue=minControlValue;
	this->maxControlValue=maxControlValue;
	this->controlValue = (maxControlValue+minControlValue)/2.0;
	return this->controlValue;
}

double PidController::GetControlValue(double currentOutput)
{
	prev_error = error;
	error = target-currentOutput;
	double derivative = error - prev_error;
	double integral = (error+prev_error)/2.0;
	controlValue += (kp*error +ki*integral+kd*derivative);
	if (controlValue>maxControlValue) return maxControlValue;
	if (controlValue<minControlValue) return minControlValue;
	return controlValue;
}

double PidController::GetControlValue(double currentOutput, double amortiguamiento)
{
	prev_error = error;
	error = target-currentOutput;
	double derivative = error - prev_error;
	double integral = (error+prev_error)/2.0;
	if (error>0)
	{
		controlValue += (kp*error +ki*integral+kd*derivative)/amortiguamiento;
	}
	else
	{
		controlValue += (kp*error +ki*integral+kd*derivative);
	}
	if (controlValue>maxControlValue) return maxControlValue;
	if (controlValue<minControlValue) return minControlValue;
	return controlValue;
}

//_____________________________________________________________________ IIRFilter
IIRFilter::IIRFilter(void)
{
	currentIndex = 0;
	order = 0;
}

IIRFilter::~IIRFilter(void)
{
}

// Both vectors must be same size
bool IIRFilter::Create(valarray<double>& numerator, valarray<double>& denominator)
{
	const int nNumerator = numerator.size();
	const int nDenominator = denominator.size();
	if (nNumerator!=nDenominator) return false;
	if (nNumerator<=1) return false;
	this->numerator = numerator;
	this->denominator = denominator;
	this->order = nNumerator-1;
	this->currentIndex = 0;
	this->vectDelay.resize(nNumerator);
	if (this->denominator[0]!=1)
	{
		double a= this->denominator[0];
		for(int i=0; i<nNumerator; i++)
		{
			this->numerator[i]=this->numerator[i]/a;
			this->denominator[i]=this->denominator[i]/a;
		}
	}
	return true;
}

double IIRFilter::GenerateOutput(double input)
{
	int index = 0, i;
	double y = input;

	// Apply denominator
	index = GoNext(currentIndex);
	for(i=0; i<order; i++)
	{
		if (denominator[i+1] != 0.0) y-=(vectDelay[index]*denominator[i+1]);
		index=GoNext(index);
	}
	vectDelay[currentIndex]=y;
	//m_vectDelay.Display_(NULL);

	// Apply numerator
	y=0;
	index = currentIndex;
	for(i=0; i<=order; i++)
	{
		if (numerator[i] != 0.0) y+=(numerator[i]*vectDelay[index]);
		index = GoNext(index);
	}
	currentIndex = GoPrevious(currentIndex);

	return y;
}

int IIRFilter::GoNext(int n)
{
	n++;
	return (n>order) ? 0 : n;
}

int IIRFilter::GoPrevious(int n)
{
	n--;
	return (n<0) ? order: n;
}

//_____________________________________________________________________ FIRFilter
FIRFilter::FIRFilter(void)
{
	currentIndex = 0;
	order = 0;
}

FIRFilter::~FIRFilter(void)
{
}

bool FIRFilter::Create(valarray<double>& numerator)
{
	const int nNumerator = numerator.size();
	if (nNumerator<=1) return false;
	this->numerator = numerator;
	this->order = nNumerator-1;
	this->currentIndex = 0;
	this->vectDelay.resize(nNumerator);
	for(int i = 0; i<nNumerator; i++) vectDelay[i] = 0.0;
	return true;
}

void FIRFilter::ClearTaps()
{
	this->currentIndex = 0;
	const int len = vectDelay.size();
	for(int i = 0; i<len; i++) vectDelay[i] = 0.0;
}

double FIRFilter::GenerateOutput(double input)
{
	vectDelay[currentIndex] = input;
	double y = 0.0;
	int index = currentIndex;
	for(int i=0; i<=order; i++)
	{
		if (numerator[i] != 0.0) y+=(numerator[i]*vectDelay[index]);
		index = GoNext(index);
	}
	currentIndex = GoPrevious(currentIndex);
	return y;
}

int FIRFilter::GoNext(int n)
{
	n++;
	return (n>order) ? 0 : n;
}

int FIRFilter::GoPrevious(int n)
{
	n--;
	return (n<0) ? order: n;
}

//_____________________________________________________________________Function

//_____________________________________________________________________ NumericDerivative
NumericDerivative::NumericDerivative(void)
{
}

 NumericDerivative::~NumericDerivative(void)
 {
 }

void  NumericDerivative::FirstDerivative(double deltaX, const valarray<double>& in_y, valarray<double>& out_dy)
{
	const int len = in_y.size();
	if (len == 0)//____________________________________ 0
	{
		out_dy.free();
		return;
	}
	out_dy.resize(len);
	if (len == 1) //____________________________________ 1
	{
		out_dy[0] = 0.0;
		return;
	}
	if (len == 2)//____________________________________ 2
	{
		out_dy[0] = (-in_y[0] +in_y[1])/deltaX;
		out_dy[1] = out_dy[0];
		return;
	}
	if (len == 3)//____________________________________ 3
	{
		const double denominator = 2.0*deltaX;
		out_dy[0] = (-3.0*in_y[0] + 4.0*in_y[1] - in_y[2])/denominator;
		out_dy[1] = (-1.0*in_y[0] + in_y[2])/denominator;
		out_dy[2] = (in_y[0] - 4.0*in_y[1]+3.0*in_y[2])/denominator;
		return;
	}
	//______________________________________________ 4 or longer
	const double denominator = 6.0*deltaX;
	for(int i = 0; i < len; i++)
	{
		if (i == 0)
		{
			out_dy[i] = -11.0*in_y[0] +18.0*in_y[1]-9.0*in_y[2]+2.0*in_y[3];
		}
		else if (i == len-2)
		{
			out_dy[i] = in_y[len-4] -6.0*in_y[len-3]+3.0*in_y[len-2]+2.0*in_y[len-1];
		}
		else if (i == len-1)
		{
			out_dy[i] = -2.0*in_y[len-4] +9.0*in_y[len-3]-18.0*in_y[len-2]+11.0*in_y[len-1];
		}
		else
		{
			out_dy[i] = -2.0*in_y[i-1] -3.0*in_y[i]+6.0*in_y[i+1]-1.0*in_y[i+2];
		}
		out_dy[i] /= denominator;
	}
}

void NumericDerivative::SecondDerivative(double deltaX, const valarray<double>& in_y, valarray<double>& out_dy)
{
	const int len = in_y.size();
	const double denominator = deltaX*deltaX;
	if (len == 0)
	{
		out_dy.free();
		return;
	}
	out_dy.resize(len);
	if (len == 1)//______________________________________________ 1
	{
		out_dy[0] = 0.0;
		return;
	}
	if (len == 2)//______________________________________________ 2
	{
		out_dy[0] = 0.0;
		out_dy[1] = 0.0;
		return;
	}
	if (len == 3)//______________________________________________ 3
	{
		out_dy[0] = 0.0;
		out_dy[1] = (in_y[0] -2.0*in_y[1]+in_y[2])/denominator;
		out_dy[2] = 0.0;
		return;
	}
	//______________________________________________ 4 or longer
	for(int i = 0; i < len; i++)
	{
		if (i == 0)
		{
			out_dy[i] = 2.0*in_y[0] -5.0*in_y[1]+4.0*in_y[2]-1.0*in_y[3];
		}
		else if (i == len-2)
		{
			out_dy[i] = /*0* in_y[len-4] + */in_y[len-3]-2.0*in_y[len-2]+in_y[len-1];
		}
		else if (i == len-1)
		{
			out_dy[i] = -1.0*in_y[len-4] +4.0*in_y[len-3]-5.0*in_y[len-2]+2.0*in_y[len-1];
		}
		else
		{
			out_dy[i] = in_y[i-1] -2.0*in_y[i]+in_y[i+1];//-1.0*in_y[i+2];
		}
		out_dy[i] /= denominator;
	}
}

void NumericDerivative::ThirdDerivative(double deltaX, const valarray<double>& in_y, valarray<double>& out_dy)
{
	const int len = in_y.size()-2;
	const double denominator = deltaX*deltaX*deltaX;
	if (len <= 0)
	{
		out_dy.free();
		return;
	}
	out_dy.resize(len);
	for(int i = 0; i < len; i++)
	{
		if (i == len-1)
		{
			out_dy[i] = -1.0*in_y[len-2] +3.0*in_y[len-1]-3.0*in_y[len]+in_y[len+1];
		}
		else
		{
			out_dy[i] = -1.0* in_y[i] + 3.0*in_y[i+1]-3.0*in_y[i+2]+in_y[i+3];
		}
		out_dy[i] /= denominator;
	}
}

//_____________________________________________________________________ NumericIntegration
NumericIntegration::NumericIntegration(void)
{
}

NumericIntegration::~NumericIntegration(void)
{
}

// steps will be approximated to next multiple of 4
double NumericIntegration::Simpson(Math::IFunction* func, double a, double b, int steps, double& resultingError)
{
	int i =0, j = 0;
	double delta = 0;
	double sum_half = 0.0;
	double sum = 0.0;
	double x = 0, y = 0;
	resultingError = 1.0e100;

	if (b<a || steps<=0) return 0.0; 

	//______________ be sure steps is a multiple of 4
	if (steps<4) steps = 4;

	if (steps%4==1)
	{
		steps+=3;
	}
	else if (steps%4==2)
	{
		steps+=2;
	}
	else if (steps%4==3)
	{
		steps++;
	}
	delta=(b-a)/steps;

	for(i=0, x=a; i<=steps; i++, x+=delta)
	{
		y=func->EvaluateFunc(x);
		j = i/2;
		if (i==0 || i==steps)
		{
			sum+=y;
			sum_half+=y;
		}
		else if (i%2==0)
		{
			sum+=(2.0*y);
			//_______________ Compute the integral using half the steps 
			if (j%2==0)
			{
				sum_half+=(2.0*y);
			}
			else
			{
				sum_half+=(4.0*y);
			}
		}
		else
		{
			sum+=(4.0*y);
		}
	}
	sum_half = sum_half*(2.0*delta)/3.0;
	sum = sum*delta/3.0;

	resultingError = fabs(sum_half-sum)/16.0; // 2^4
	return sum;
}

// steps will be approximated to next multiple of 4
complex<double> NumericIntegration::Simpson(Math::IFunctionC* func, double a, double b, int steps, double& resultingError)
{
	int i =0, j = 0;
	double delta = 0;
	complex<double> sum_half = 0.0;
	complex<double> sum = 0.0;
	double x = 0;
	complex<double> y = 0;
	resultingError = 1.0e100;

	if (b<a || steps<=0) return 0.0; 

	//______________ be sure steps is a multiple of 4
	if (steps<4) steps = 4;

	if (steps%4==1)
	{
		steps+=3;
	}
	else if (steps%4==2)
	{
		steps+=2;
	}
	else if (steps%4==3)
	{
		steps++;
	}
	delta=(b-a)/steps;

	for(i=0, x=a; i<=steps; i++, x+=delta)
	{
		y=func->EvaluateFunc(x);
		j = i/2;
		if (i==0 || i==steps)
		{
			sum+=y;
			sum_half+=y;
		}
		else if (i%2==0)
		{
			sum+=(2.0*y);
			//_______________ Compute the integral using half the steps 
			if (j%2==0)
			{
				sum_half+=(2.0*y);
			}
			else
			{
				sum_half+=(4.0*y);
			}
		}
		else
		{
			sum+=(4.0*y);
		}
	}
	sum_half = sum_half*(2.0*delta)/3.0;
	sum = sum*delta/3.0;
	resultingError = abs(sum_half-sum)/16.0; // 2^4
	return sum;
}

double NumericIntegration::helper(Math::IFunction* func, double a, double b, int nx)
{
	static double value;
	if (nx == 0) 
	{
		value=0.5*(b-a)*(func->EvaluateFunc(a)+func->EvaluateFunc(b));
		return value;
	}

	double sum = 0.0;
	int ivalue = 1;
	int j;

	for (j=0; j<nx-1; j++) 
	{
		ivalue <<= 1;
	}

	double delta=(b-a)/(double)ivalue;
	double x = a + 0.5*delta;
	for (j=1; j<=ivalue; j++) 
	{
		sum += func->EvaluateFunc(x);
		x += delta;
	}
	value=0.5*(value+(b-a)*sum/(double)ivalue);
	return value;
}

complex<double> NumericIntegration::helper(Math::IFunctionC* func, double a, double b, int nx)
{
	static complex<double> value;
	if (nx == 0) 
	{
		value=0.5*(b-a)*(func->EvaluateFunc(a)+func->EvaluateFunc(b));
		return value;
	}
	
	complex<double> sum = 0.0;
	int ivalue = 1;
	int j;

	for (j=0; j<nx-1; j++) 
	{
		ivalue <<= 1;
	}

	double delta=(b-a)/(double)ivalue;
	double x = a + 0.5*delta;
	for (j=1; j<=ivalue; j++) 
	{
		sum += func->EvaluateFunc(x);
		x += delta;
	}
	value=0.5*(value+(b-a)*sum/(double)ivalue);
	return value;
}

double NumericIntegration::Simpson(Math::IFunction* func, double a, double b, double& resultingError)
{
	resultingError = 1.0e100;
	double result = 0.0;
	double sresult = 0.0, xresult=0.0, presult = 0.0;
	for (int ix=0; ix<=11; ix++) 
	{
		sresult = helper(func, a, b, ix);
		result=(4.0*sresult - xresult)/3.0;
		resultingError = fabs(result-presult);
		if (ix > 4)
		{
			if (resultingError < 1.0e-6*fabs(presult))
			{
				resultingError/=15.5;
				return result;
			}
			if (result == 0.0 && presult == 0.0) 
			{
				resultingError/=15.5;
				return result;
			}
		}
		presult = result;
		xresult = sresult;
	}
	resultingError/=15.5;
	return result;
}

complex<double> NumericIntegration::Simpson(Math::IFunctionC* func, double a, double b, double& resultingError)
{
	resultingError = 1.0e100;
	complex<double> sresult = 0.0,  xresult = 0.0, presult = 0.0;
	complex<double> result = 0.0;
	double err = 0.0;
	for (int ix=0; ix<=11; ix++) 
	{
		sresult = helper(func, a, b, ix);
		result=(4.0*sresult-xresult)/3.0; 
		resultingError = abs(result-presult);
		if (ix>4)
		{
			if (resultingError < 1.0e-4*abs(presult)) 
			{
				resultingError/=15.5;
				return result;
			}
			if (result == 0.0 && presult == 0.0) 
			{
				resultingError/=15.5;
				return 0.0;
			}
		}
		presult = result;
		xresult = sresult;
	}
	resultingError/=15.5;
	return result;
}

//_____________________________________________________________________ TimePredictor
TimePredictor::TimePredictor(void)
{
	whenLast = ::GetTickCount();
	valueLast = 0.0;
	for(int i = 0; i<TIME_PREDICTOR_LENGTH; i++) data[i]=0.0;
	index = 0;
}

TimePredictor::~TimePredictor(void)
{
}

void TimePredictor::AddValue(double value)
{
	const DWORD now = ::GetTickCount();
	const DWORD deltaTime = now - whenLast;
	whenLast = now;
	//
	if (value==valueLast)
	{
		data[index++] = 0.0;
	}
	else
	{
		data[index++] = deltaTime/(value-valueLast);
	}
	valueLast = value;
	if (index==TIME_PREDICTOR_LENGTH) index=0;
}

int TimePredictor::GetPredictionInSeconds(double targetValue)
{
	double average = 0.0;
	for(int i=0; i<TIME_PREDICTOR_LENGTH; i++) average+=data[i];
	return (int)((targetValue-valueLast)*average/(TIME_PREDICTOR_LENGTH*1000.0)+0.5);
}

void TimePredictor::Reset(void)
{
	whenLast = ::GetTickCount();
	valueLast = 0.0;
	for(int i = 0; i<TIME_PREDICTOR_LENGTH; i++) data[i]=0.0;
	index = 0;
}

//_____________________________________________________________________ BinaryConverter
BinaryConverter::BinaryConverter(void)
{
	this->bitCount = 0;
	data = NULL;
}

int BinaryConverter::Convert(int value)
{
	if (data) delete [] data;
	data = NULL;
	bitCount = 0;
	//
	if (value <= 0)
	{
		return 0;
	}

	bitCount = (int)(log((double)value)/log(2.0)+1.0);
	if (bitCount==0) return 0;
	data = new bool[bitCount];
	if (data==NULL)
	{
		bitCount = 0;
		return 0;
	}
	for(int i = 0; i<bitCount; i++)
	{
		if (value%2==0)
			data[i]=false;
		else
			data[i]=true;
		value /= 2;
	}
	return bitCount;
}

// Call this function after calling BinaryConverter::Convert
bool BinaryConverter::GetBit(int bitIndex)
{
	if (bitIndex<0 || bitIndex>=bitCount) return false;
	return data[bitIndex];
}

int BinaryConverter::Convert(const int value, const int bitCount, valarray<int>& output)
{
	if (value <= 0)
	{
		try
		{
			output.resize(bitCount);
		}
		catch(const std::bad_alloc& )
		{
			return 0;
		}
		for(int i = 0; i<bitCount; i++) output[i] = 0;
		return bitCount;
	}
	BinaryConverter bc;
	const int _bitCount = bc.Convert(value);
	if (_bitCount <= 0)
	{
		output.free();
		return 0;
	}
	try
	{
		output.resize(bitCount);
	}
	catch(const std::bad_alloc& )
	{
		return 0;
	}
	for(int i = 0; i<bitCount; i++)
	{
		if (bc.GetBit(i) == true)
		{
			output[bitCount-i-1] = 1;
		}
		else
		{
			output[bitCount-i-1] = 0;
		}
	}
	return _bitCount;
}

int BinaryConverter::Convert(const int value, const int bitCount, valarray<double>& output)
{
	if (value <= 0)
	{
		try
		{
			output.resize(bitCount);
		}
		catch(const std::bad_alloc& )
		{
			return 0;
		}
		for(int i = 0; i<bitCount; i++) output[i] = 0.0;
		return bitCount;
	}
	BinaryConverter bc;
	const int _bitCount = bc.Convert(value);
	if (_bitCount <= 0)
	{
		output.free();
		return 0;
	}
	try
	{
		output.resize(bitCount);
	}
	catch(const std::bad_alloc& )
	{
		return 0;
	}
	for(int i = 0; i<bitCount; i++)
	{
		if (bc.GetBit(i) == true)
		{
			output[bitCount-i-1] = 1.0;
		}
		else
		{
			output[bitCount-i-1] = 0.0;
		}
	}
	return _bitCount;
}

BinaryConverter::~BinaryConverter(void)
{
	if (data) delete [] data;
}

//_____________________________________________________________________Statistics
std::tr1::mt19937 Statistics::random_generator;

Statistics::Statistics(void)
{
}

Statistics::~Statistics(void)
{
}

//Theil's U inequality index (Theil 1961) is a measure of the degree to which one time series () 
//differs from another ().  The score returned by the THEIL this test is  for consistency;  
//varies from 0 to 1 with 1 meaning maximum disagreement. Like DBK, it performs a 
//point-by-point matching of the two time series; if the lengths of reference and actual data 
//do not match, a warning is issued, and only the number of pairs corresponding to the length of the shortest one is used.
double Statistics::TheilUInequalityIndex(valarray<double>& input_x, valarray<double>& input_y)
{
	int size = input_x.size();
	if ((int) input_y.size()<size) size = input_y.size();
	double sumx=0, sumy=0, sumxy=0, tmp;
	int i;
	for(i=0; i<size; i++) 
	{
		tmp = input_x[i];
		sumx += tmp*tmp;
	}
	for(i=0; i<size; i++) 
	{
		tmp = input_y[i];
		sumy += tmp*tmp;
	}
	for(i=0; i<size; i++) 
	{
		tmp = input_x[i]-input_y[i];
		sumxy += tmp*tmp;
	}
	return (sqrt(sumxy/size))/(  sqrt(sumx)/size + sqrt(sumy)/size   );
}

double Statistics::TheilIndex(valarray<double>& input)
{
	double mean = 0.0;
	int size = input.size();
	int i;
	for(i=0; i<size; i++) mean+=input[i];
	//
	double theil = 0.0, tmp;
	for(i=0; i<size; i++)
	{
		tmp = input[i]/mean;
		theil += (tmp*log(tmp));
	}
	return theil/size;
}

double Statistics::GetMin(valarray<double>& input)
{
	const int size = input.size();
	if (size<=0) throw L"Math::Statistics::GetMin empty input vector";
	double minimum = input[0];
	for(int i=0; i<size; i++)
	{
		if (input[i]<minimum) minimum=input[i];
	}
	return minimum;
}

complex<double> Statistics::GetMin(valarray<complex<double> >& input)
{
	const int size = input.size();
	if (size<=0) throw L"Math::Statistics::GetMin empty input vector";
	complex<double> minimum = input[0];
	for(int i=0; i<size; i++)
	{
		if (abs(input[i])<abs(minimum)) minimum=input[i];
	}
	return minimum;
}

double Statistics::GetMin(MATRIX& input)
{
	const int rows = input.size();
	const int cols = rows == 0 ? 0: input[0].size();
	if (rows*cols == 0) throw L"Math::Statistics::GetMin empty input matrix";
	int i, j;
	double minimum = input[0][0];

	for(i=0; i<rows; i++)
	{
		for(j=0; j<cols; j++)
		{
			if (input[i][j]<minimum) minimum=input[i][j];
		}
	}
	return minimum;
}

complex<double> Statistics::GetMin(MATRIXC& input)
{
	const int rows = input.size();
	const int cols = rows == 0 ? 0: input[0].size();
	if (rows*cols == 0) throw L"Math::Statistics::GetMin empty input matrix";
	int i, j;
	complex<double> minimum = input[0][0];

	for(i=0; i<rows; i++)
	{
		for(j=0; j<cols; j++)
		{
			if (abs(input[i][j])<abs(minimum)) minimum=input[i][j];
		}
	}
	return minimum;
}

double Statistics::GetMax(valarray<double>& input)
{
	const  int size = input.size();
	if (size<=0) throw L"Statistics::GetMax empty input vector";
	double maximum = input[0];
	for(int i=0; i<size; i++)
	{
		if (input[i]>maximum) maximum=input[i];
	}
	return maximum;
}

complex<double> Statistics::GetMax(valarray<complex<double> >& input)
{
	const  int size = input.size();
	if (size<=0) throw L"Statistics::GetMax empty input vector";
	complex<double> maximum = input[0];
	for(int i=0; i<size; i++)
	{
		if (abs(input[i])>abs(maximum)) maximum=input[i];
	}
	return maximum;
}

double Statistics::GetMax(MATRIX& input)
{
	const int rows = input.size();
	const int cols = rows == 0 ? 0: input[0].size();
	if (rows*cols == 0) throw L"Math::Statistics::GetMax empty input matrix";
	int i, j;
	double maximum = input[0][0];

	for(i=0; i<rows; i++)
	{
		for(j=0; j<cols; j++)
		{
			if (input[i][j]>maximum) maximum=input[i][j];
		}
	}
	return maximum;
}

complex<double> Statistics::GetMax(MATRIXC& input)
{
	const int rows = input.size();
	const int cols = rows == 0 ? 0: input[0].size();
	if (rows*cols == 0) throw L"Math::Statistics::GetMax empty input matrix";
	int i, j;
	complex<double> maximum = input[0][0];

	for(i=0; i<rows; i++)
	{
		for(j=0; j<cols; j++)
		{
			if (abs(input[i][j])>abs(maximum)) maximum=input[i][j];
		}
	}
	return maximum;
}

double Statistics::GetSum(valarray<double>& input)
{
	const int size = input.size();
	double sum = 0.0;
	for(int i=0; i<size; i++)
	{
		sum += input[i];
	}
	return sum;
}

complex<double> Statistics::GetSum(valarray<complex<double> >& input)
{
	const int size = input.size();
	complex<double> sum = 0.0;
	for(int i=0; i<size; i++)
	{
		sum += input[i];
	}
	return sum;
}

double Statistics::GetSum(MATRIX& input)
{
	const int rows = input.size();
	const int cols = rows == 0 ? 0: input[0].size();
	double sum = 0.0;
	int i, j;

	for(i=0; i<rows; i++)
	{
		for(j=0; j<cols; j++)
		{
			sum += input[i][j];
		}
	}
	return sum;
}

complex<double> Statistics::GetSum(MATRIXC& input)
{
	const int rows = input.size();
	const int cols = rows == 0 ? 0: input[0].size();
	int i, j;
	complex<double> sum = 0.0;

	for(i=0; i<rows; i++)
	{
		for(j=0; j<cols; j++)
		{
			sum += input[i][j];
		}
	}
	return sum;
}

double Statistics::GetDiagonalSum(MATRIX& input)
{
	const int rows = input.size();
	const int cols = rows == 0 ? 0: input[0].size();
	double sum = 0.0;
	const int len = rows<cols ? rows : cols;

	for(int i=0; i<len; i++)
	{
		sum += input[i][i];
	}
	return sum;
}

complex<double> Statistics::GetDiagonalSum(MATRIXC& input)
{
	const int rows = input.size();
	const int cols = rows == 0 ? 0: input[0].size();
	complex<double> sum = 0.0;
	const int len = rows<cols ? rows : cols;

	for(int i=0; i<len; i++)
	{
		sum += input[i][i];
	}
	return sum;
}

double Statistics::GetSumOfSquares(valarray<double>& input)
{
	const int size = input.size();
	double sum = 0.0;
	for(int i=0; i<size; i++)
	{
		sum += (input[i]*input[i]);
	}
	return sum;
}

double Statistics::GetSumOfSquares(valarray<complex<double> >& input)
{
	const int size = input.size();
	double sum = 0.0;
	for(int i=0; i<size; i++)
	{
		sum += abs(input[i]);
	}
	return sum;
}

double Statistics::GetSumOfSquares(MATRIX& input)
{
	const int rows = input.size();
	const int cols = rows == 0 ? 0: input[0].size();
	double sum = 0.0;
	int i, j;

	for(i=0; i<rows; i++)
	{
		for(j=0; j<cols; j++)
		{
			sum += (input[i][j]*input[i][j]);
		}
	}
	return sum;
}

double Statistics::GetSumOfSquares(MATRIXC& input)
{
	const int rows = input.size();
	const int cols = rows == 0 ? 0: input[0].size();
	int i, j;
	double sum = 0.0;

	for(i=0; i<rows; i++)
	{
		for(j=0; j<cols; j++)
		{
			sum += abs(input[i][j]);
		}
	}
	return sum;
}

double Statistics::AbsoluteRelativeError(valarray<double>& exact, valarray<double>& approx)
{
	if (exact.size() != approx.size())
		throw L"Statistics::AbsoluteRelativeError input vectors need to be of the same size";
	double error = 0;
	const int length = exact.size();

	for(int i=0; i< length; i++)
	{
		error += fabs(approx[i] - exact[i]);
	}
	return error/length;
}

void Statistics::AbsoluteRelativeError(valarray<double>& exact, valarray<double>& approx,
											valarray<double>& outRelativeError)
{
	if (exact.size() != approx.size())
		throw L"Statistics::AbsoluteRelativeError input vectors need to be of the same size";
	const int length = exact.size();
	outRelativeError.resize(length);

	for(int i=0; i< length; i++)
	{
		outRelativeError[i] = ( approx[i] - exact[i]) / exact[i];
	}
}

double Statistics::MeanAbsoluteError(valarray<double>& exact, valarray<double>& approx)
{
	if (exact.size() != approx.size())
		throw L"Statistics::MeanAbsoluteError input vectors need to be of the same size";
	double error = 0.0;
	const int length = exact.size();

	for(int i=0; i< length; i++)
	{
		error += fabs(approx[i] - exact[i]);
	}
	return error/length;
}

double Statistics::MeanSquaredError(valarray<double>& exact, valarray<double>& approx)
{
	if (exact.size() != approx.size())
		throw L"Statistics::MeanSquaredError input vectors need to be of the same size";
	double error = 0.0;
	double tmp = 0.0;
	const int length = exact.size();

	for(int i=0; i< length; i++)
	{
		tmp = approx[i] - exact[i];
		error += (tmp*tmp);
	}
	return error/length;
}

double Statistics::RootMeanSquaredError(valarray<double>& exact, valarray<double>& approx)
{
	return sqrt(Math::Statistics::MeanSquaredError(exact, approx));
}

double Statistics::RelativeRootMeanSquareError(valarray<double>& exact, valarray<double>& approx)
{
	if (exact.size() != approx.size())
		throw L"Statistics::RelativeRootMeanSquareError input vectors need to be of the same size";
	double error = 0;
	double tmp = 0;
	const int length = exact.size();

	for(int i=0; i< length; i++)
	{
		tmp = (approx[i] - exact[i]) / exact[i];
		error += (tmp*tmp);
	}
	return sqrt(error/length);
}

double Statistics::MeanValue(valarray<double>& input)
{
	double sum = 0.0;
	const int length = input.size(); 
	if (length==0) return 0.0;
	for(int i = 0; i<length; i++)
	{
		sum += input[i]; 
	}
	return sum/length;
}

complex<double> Statistics::MeanValue(valarray<complex<double> >& input)
{
	complex<double> sum = 0.0;
	const int length = input.size(); 
	if (length==0) return 0.0;
	for(int i = 0; i<length; i++)
	{
		sum += input[i]; 
	}
	return sum/(double)length;
}

double Statistics::MeanValue(MATRIX& input)
{
	double sum = 0.0;
	const int rows = input.size(); 
	const int cols = rows == 0 ? 0 : input[0].size();
	const int length = rows*cols;
	if (length==0) return 0.0;
	int i, j;
	for(i = 0; i<rows; i++)
	{
		for(j=0; j<cols; j++)
		{
			sum += input[i][j]; 
		}
	}
	return sum/length;
}

complex<double> Statistics::MeanValue(MATRIXC& input)
{
	complex<double> sum = 0.0;
	const int rows = input.size(); 
	const int cols = rows == 0 ? 0 : input[0].size();
	const int length = rows*cols;
	if (length==0) return 0.0;
	int i, j;
	for(i = 0; i<rows; i++)
	{
		for(j=0; j<cols; j++)
		{
			sum += input[i][j]; 
		}
	}
	return sum/(double)length;
}

double Statistics::Bias(valarray<double>& exact, valarray<double>& approx)
{
	double bias = 0.0;
	const unsigned int length = exact.size(); 
	if (length==0) return 0.0;
	if (length!=approx.size()) return -999999.999;
	for(unsigned int i = 0; i<length; i++)
	{
		bias += (exact[i]-approx[i]); 
	}
	return bias/length;
}

double Statistics::Bias(valarray<double>& approx, double exact)
{
	double bias = 0.0;
	const int length = approx.size(); 
	if (length==0) return 0.0;

	for(int i = 0; i<length; i++)
	{
		bias += (exact-approx[i]); 
	}
	return bias/length;
}

double Statistics::StandardDeviation(valarray<double>& input)
{
	return sqrt(Variance(input));
}

double Statistics::Variance(valarray<double>& input)
{
	const int size = input.size();
	double sum = 0.0;
	double sums = 0.0;

	if (size==0) return 0.0;
	for(int i = 0; i<size; i++)
	{
		sum+=input[i];
		sums+=(input[i]*input[i]);
	}
	return sums/(size-1) - (sum*sum)/(size*(size-1));
}

complex<double> Statistics::Variance(valarray<complex<double> >& input)
{
	const int size = input.size();
	complex<double> sum = 0.0;
	complex<double> sums = 0.0;

	if (size==0) return 0.0;
	for(int i = 0; i<size; i++)
	{
		sum+=input[i];
		sums+=(input[i]*input[i]);
	}
	return sums/(size-1.0) - (sum*sum)/(size*(size-1.0));
}

double Statistics::Variance(MATRIX& input)
{
	const int rows = input.size();
	const int cols = rows == 0 ? 0: input[0].size();
	const int size = rows*cols;
	if (size==0) return 0.0;
	double sum = 0.0;
	double sums = 0.0;
	double value;

	int i, j;
	for(i = 0; i<rows; i++)
	{
		for(j = 0; j<cols; j++)
		{
			value = input[i][j];
			sum+=value;
			sums+=(value*value);
		}
	}
	return sums/(size-1.0) - (sum*sum)/(size*(size-1.0));
}

complex<double> Statistics::Variance(MATRIXC& input)
{
	const int rows = input.size();
	const int cols = rows == 0 ? 0: input[0].size();
	const int size = rows*cols;
	if (size==0) return 0.0;
	complex<double> sum = 0.0;
	complex<double> sums = 0.0;
	complex<double> value;

	int i, j;
	for(i = 0; i<rows; i++)
	{
		for(j = 0; j<cols; j++)
		{
			value = input[i][j];
			sum+=value;
			sums+=(value*value);
		}
	}
	return sums/(size-1.0) - (sum*sum)/(size*(size-1.0));
}

void Statistics::ColumnVariance(const MATRIX& input, valarray<double>& output)
{
	const int rows = input.size();
	if (rows == 0)
	{
		output.free();
		return;
	}
	const int cols = input[0].size();
	if (cols == 0)
	{
		output.free();
		return;
	}
	output.resize(cols);

	double sum = 0.0;
	double sums = 0.0;
	double value;

	int i, j;
	for(j = 0; j<cols; j++)
	{
		sum = 0.0;
		sums = 0.0;
		for(i = 0; i<rows; i++)
		{
			value = input[i][j];
			sum+=value;
			sums+=(value*value);
		}
		output[j] = sums/(rows-1.0) - (sum*sum)/(rows*(rows-1.0));
	}
}

void Statistics::RowVariance(const MATRIX& input, valarray<double>& output)
{
	const int rows = input.size();
	if (rows == 0)
	{
		output.free();
		return;
	}
	const int cols = input[0].size();
	if (cols == 0)
	{
		output.free();
		return;
	}
	output.resize(rows);

	double sum = 0.0;
	double sums = 0.0;
	double value;

	int i, j;
	for(i = 0; i<rows; i++)
	{
		sum = 0.0;
		sums = 0.0;
		for(j = 0; j<cols; j++)
		{
			value = input[i][j];
			sum+=value;
			sums+=(value*value);
		}
		output[i] = sums/(cols-1.0) - (sum*sum)/(cols*(cols-1.0));
	}
}

double Statistics::Covariance(valarray<double>& input_x, valarray<double>& input_y, bool bNormalDistr)
{
	unsigned int size = input_x.size();
	if (size != input_y.size() || size == 0) throw L"Statistics::Covariance input vectors need to be of the same size";
	double meanX = 0.0;
	double meanY = 0.0;
	double cov = 0.0;
	unsigned int i;

	for(i=0; i<size; i++)
	{
		meanX += input_x[i];
		meanY += input_y[i];
	}
	meanX /= size;
	meanY /= size;

	for(i=0; i< size; i++) cov += (input_x[i]*input_y[i]);
	if (bNormalDistr) size--;
	return cov /size - meanX * meanY;
}

double Statistics::Correlation(valarray<double>& input_x, valarray<double>& input_y)
{
	unsigned int size = input_x.size();
	if (size != input_y.size() || size == 0) throw L"Statistics::Correlation input vectors need to be of the same size";
	double corr = 0.0;

	for(unsigned int i=0; i< size; i++) corr += (input_x[i]*input_y[i]);
	return corr /size;
}

double Statistics::CorrelationCoeff(valarray<double>& input_x, valarray<double>& input_y)
{
	double stdX = sqrt(Statistics::Variance(input_x));
	double stdY = sqrt(Statistics::Variance(input_y));
	return Statistics::Correlation(input_x, input_y)/(stdX*stdY);
}

//_____________________________________________________________________Normalization
Normalization::Normalization()
{
	mean = 0.0;
	std = 0.0;
}

Normalization::~Normalization()
{
}

void Normalization::prestd(valarray<double>& values)
{
	const unsigned int size = values.size();
	if (size<=0) return;
	mean = Math::Statistics::MeanValue(values);
	std = Math::Statistics::StandardDeviation(values);
	for(unsigned int i = 0; i<size; i++)
	{
		values[i]=(values[i]-mean)/std;
	}
}

void Normalization::poststd(valarray<double>& values)
{
	const unsigned int size = values.size();
	if (size<=0) return;
	for(unsigned int i = 0; i<size; i++)
	{
		values[i]=values[i]*std+mean;
	}
}


//_____________________________________________________________________ Trender
Trender::Trender()
{
	m = 0.0;
	b = 0.0;
}

Trender::~Trender()
{
}

void Trender::CalculateMB(bool leastSquares, valarray<double>& source)
{
	const unsigned int count = source.size();
	if (count<2) return;
	unsigned int i;
	double x, y;
	m = 0.0;
	b = 0.0;
	if (leastSquares)
	{
		double xmean = (count-1.0)/2.0;
		//
		double ymean = 0.0;
		for(i=0; i<count; i++) ymean +=source[i];
		ymean /= (double)count;
		//
		double xvar =0.0, xy = 0.0;
		for(i=0; i<count; i++)
		{
			x = (double)i-xmean;
			y = source[i]-ymean;
			xvar+=x*x;
			xy+=x*y;
		}
		//*********************** Calculate m and b
		m = xy/xvar;
		b = ymean-m*xmean;
	}
	else
	{
		m = (source[count-1]-source[0])/(double)(count-1);
		b = source[0];
	}
}

void Trender::pretrending(bool leastSquares, valarray<double>& source, valarray<double>& destination)
{
	double y;
	this->CalculateMB(leastSquares, source);
	//*********************** Pretrending
	const unsigned int count = source.size();
	for(unsigned int i=0; i<count; i++)
	{ 
		y = m*(double)i+b;
		destination[i]=source[i]-y;
	}
}


void Trender::posttrending(valarray<double>& source, valarray<double>& destination)
{
	const unsigned int count = source.size();
	destination.resize(count);
	for(unsigned int i=0; i<count; i++)
	{
		destination[i] = source[i]+m*(double)i+b;
	}
}

//_____________________________________________________________________SyntheticDiv
SyntheticDiv::SyntheticDiv(void)
{
}

SyntheticDiv::~SyntheticDiv(void)
{
}

// Returns F(inX)
double SyntheticDiv::Run(const valarray<double>& inputCoeff, valarray<double>& outputCoeff, double x)
{
	const unsigned int size = inputCoeff.size();
	outputCoeff.resize(size);

	outputCoeff[0]=inputCoeff[0];

	for(unsigned int i=1; i<size; i++)
	{
		outputCoeff[i]=inputCoeff[i]+outputCoeff[i-1]*x;
	}
	return outputCoeff[size-1];
}

// Returns F(x)
// and F'(x) in out_dx
double SyntheticDiv::Run(const valarray<double>& inputCoeff, valarray<double>& outputCoeff, double x, double&out_dx)
{
	const unsigned int size = inputCoeff.size();
	unsigned int i = 0;
	//_______________________________________ F(x)
	outputCoeff.resize(size);
	outputCoeff[0]=inputCoeff[0];

	for(i=1; i<size; i++)
	{
		outputCoeff[i]=inputCoeff[i]+outputCoeff[i-1]*x;
	}
	//______________________________________ F'(x)
	out_dx = outputCoeff[0];
	for(i=1; i<size-1; i++)
	{
		out_dx = outputCoeff[i]+out_dx*x;
	}
	return outputCoeff[size-1];
}


// Input: the equation coefficiente and a initial guess for x
// Output: the output coeff and the value of x
// Returns the error,
// Xn = Xn-1  -  F(X) / F'(X)
double SyntheticDiv::Newton(const valarray<double>& inputCoeff, valarray<double>& outputCoeff, double& int_out_x)
{
	double prevx = 1.0;
	double fx = 1.0;
	double dx = 0.0;
	double error = 1.0e100;
	for(int i = 0; i <1000; i++)
	{
		fx = Math::SyntheticDiv::Run(inputCoeff, outputCoeff, int_out_x, dx);
		prevx =int_out_x;
		int_out_x -= (fx/dx);
		error = fabs((int_out_x-prevx)/prevx);
		if (error < 1.0e-9) break;
	}
	return error;
}

// Returns F(inX)
complex<double> SyntheticDiv::Run(const valarray<complex<double> >& inputCoeff, valarray<complex<double> >& outputCoeff, complex<double> x)
{
	const unsigned int size = inputCoeff.size();
	outputCoeff.resize(size);

	outputCoeff[0]=inputCoeff[0];

	for(unsigned int i=1; i<size; i++)
	{
		outputCoeff[i]=inputCoeff[i]+outputCoeff[i-1]*x;
	}
	return outputCoeff[size-1];
}

// Returns F(x)
// and F'(x) in out_dx
complex<double> SyntheticDiv::Run(const valarray<complex<double> >& inputCoeff, valarray<complex<double> >& outputCoeff, complex<double> x, complex<double>&out_dx)
{
	const unsigned int size = inputCoeff.size();
	unsigned int i = 0;
	//_______________________________________ F(x)
	outputCoeff.resize(size);
	outputCoeff[0]=inputCoeff[0];

	for(i=1; i<size; i++)
	{
		outputCoeff[i]=inputCoeff[i]+outputCoeff[i-1]*x;
	}
	//______________________________________ F'(x)
	out_dx = outputCoeff[0];
	for(i=1; i<size-1; i++)
	{
		out_dx = outputCoeff[i]+out_dx*x;
	}
	return outputCoeff[size-1];
}


// Input: the equation coefficiente and a initial guess for x
// Output: the output coeff and the value of x
// Returns the error,
// Xn = Xn-1  -  F(X) / F'(X)
double SyntheticDiv::Newton(const valarray<complex<double> >& inputCoeff, valarray<complex<double> >& outputCoeff, complex<double>& int_out_x)
{
	complex<double> prevx = 1.0;
	complex<double> fx = 1.0;
	complex<double> dx = 0.0;
	double error = 1.0e100;
	for(int i = 0; i <1000; i++)
	{
		fx = Math::SyntheticDiv::Run(inputCoeff, outputCoeff, int_out_x, dx);
		prevx =int_out_x;
		int_out_x -= (fx/dx);
		error = abs(int_out_x-prevx)/abs(prevx);
		if (error < 1.0e-9) break;
	}
	return error;
}

} //____________________________________________________ namespace Math::End

namespace Nn //________________________________________ namespace Nn::Ini
{

//_____________________________________________________________________ Scaler
Scaler::Scaler()
{
	Constructor();
}

Scaler::~Scaler()
{
}

Scaler::Scaler(const Scaler& init)
{
	Constructor();
	Copy(init);
}

Scaler& Scaler::operator=(const Scaler& init)
{
	Delete();
	Copy(init);
	return *this;
}

void Scaler::Copy(const Scaler &init)
{
	if (init.size<=0) return;
	if (init.data)
	{
		this->data = new Nn::ScalingInfo[init.size];
		if (this->data==NULL) return;
		::memcpy(data, init.data, init.size*sizeof(Nn::ScalingInfo));
		this->size = init.size;
	}
}

void Scaler::Constructor()
{
	//errorDescr[0] = '\0';
	size = 0;
	data = NULL;
}

void Scaler::Delete()
{
	size = 0;
	if (data) delete [] data;
	data = NULL;
}

void Scaler::GetDescription(wchar_t* description, int length)
{
	_snwprintf_s(description, length, _TRUNCATE, L"%d", size);
}

bool Scaler::Create(int count)
{
	Delete();
	this->data = new Nn::ScalingInfo[count];
	if (this->data==NULL) return false;
	size = count;
	for(int i = 0; i<count; i++)
	{
		data[i].minimum = 0.0;
		data[i].maximum = 0.0;
		//data[i].processingIndex = 1.0;
	}
	return true;
}

bool Scaler::AutoSet(MATRIX& input)
{
	const int rows = input.size();
	const int cols = input.size() == 0 ? 0 : input[0].size();
	if (rows<=0) return false;
	if (cols<=0) return false;
	if (Create(cols)==false) return false;

	double minimum = 0.0, maximum = 0.0;
	int i, j;
	for(j=0; j<cols; j++)
	{
		minimum = input[0][j];
		maximum = minimum;
		for(i=1; i<rows; i++)
		{
			if (input[i][j]>maximum) maximum = input[i][j];
			if (input[i][j]<minimum) minimum = input[i][j];
		}
		data[j].minimum = minimum;
		data[j].maximum = maximum;
		//data[j].processingIndex = 1.0;
	}
	return true;
}

bool Scaler::Save(const wchar_t* filename)
{
	Sys::File file;
	if (file.CreateForWritting(filename)==false) return false;
	return this->Save(file);
}

bool Scaler::Save(Sys::File& file)
{
	if (file.Write(&size, sizeof(int)) != sizeof(int)) return false;
	const int bytes = size*sizeof(Nn::ScalingInfo);
	return (file.Write(data, bytes) == bytes);
}

bool Scaler::Load(const wchar_t* filename)
{
	Sys::File file;
	if (file.CreateForReading(filename)==false) return false;
	return Load(file);
}

bool Scaler::Load(Sys::File& file)
{
	Delete();
	int new_size = 0;
	//_____________________________________________ read size
	if (file.Read(&new_size, sizeof(int)) != sizeof(int)) return false;
	if (new_size==0) return true;
	//
	if (this->Create(new_size)==false) return false;
	const int bytes = new_size*sizeof(Nn::ScalingInfo);
	return (file.Read(data, bytes) == bytes);
}

bool Scaler::Set(int index, double minimum, double maximum)
{
	ScalingInfo si;
	si.minimum = minimum;
	si.maximum = maximum;
	//si.processingIndex = processingIndex;
	return Set(index, si);
}

bool Scaler::Set(int index, ScalingInfo& si)
{
	if (index<0 || index>=size) return false;
	//if (si.processingIndex != 1.0) // Be sure minimum and maximum are simmetric
	//{
	//	const double max_tmp = MAXIMUM(fabs(si.minimum), fabs(si.maximum));
	//	si.minimum = -max_tmp;
	//	si.maximum = max_tmp;
	//}
	data[index] = si;
	return true;
}

bool Scaler::GetScalingInfo(int index, ScalingInfo& si)
{
	if (index<0 || index>=size) return false;
	si = data[index];
	return true;
}

bool Scaler::Get(int index, double& minimum, double& maximum)
{
	if (index<0 || index>=size) return false;
	minimum = data[index].minimum;
	maximum = data[index].maximum;
	//processingIndex = data[index].processingIndex;
	return true;
}

bool Scaler::operator==(const Scaler& init) const
{
	if (size != init.size) return false;
	for(int i = 0; i<size; i++)
	{
		if (this->data[i].minimum != init.data[i].minimum) return false;
		if (this->data[i].maximum != init.data[i].maximum) return false;
		//if (this->data[i].processingIndex != init.data[i].processingIndex) return false;
	}
	return true;
}

bool Scaler::operator!=(const Scaler& init) const
{
	if (size != init.size) return true;
	for(int i = 0; i<size; i++)
	{
		if (this->data[i].minimum != init.data[i].minimum) return true;
		if (this->data[i].maximum != init.data[i].maximum) return true;
		//if (this->data[i].processingIndex != init.data[i].processingIndex) return true;
	}
	return false;
}

wchar_t* Scaler::ScaleToStandardRange(const valarray<double>& input, valarray<double>& output)
{
	if (data == NULL || size == 0) return L"The scaler has not been created";
	const int cols = input.size();
	if (cols != size) return L"The number of columns in the data set does not match the size of the scaler";
	int j;
	double range = 1.0;
	double minOut = 0.0;

	if (output.size() != cols)
	{
		output.resize(cols);
	}
	for(j=0; j<cols; j++)
	{
		if (data[j].maximum == 0.0 && data[j].minimum == 0.0) //__________________No scaling
		{
			output[j] = input[j];
			//if (input[j] < NN_LAYERNET_OFF-0.01 || input[j] > NN_LAYERNET_ON+0.01)
			//{
			//	_snwprintf_s(errorDescr, 256, _TRUNCATE, L"The scaling produced a value out of range: index %d", j);
			//	return errorDescr;
			//	//return L"The scaling produced a value out of range";
			//}
			//if (data[j].processingIndex == 1.0)// No processing
			//{	
			//	output[j] = input[j];
			//}
			//else//_______________________ Processing
			//{
			//	output[j] = input[j]/0.9; //  -1.0 to 1.0
			//	if (input[j] > 0)
			//	{
			//		output[j] = pow(input[j], data[j].processingIndex);
			//	}
			//	else if (input[j] < 0)
			//	{
			//		output[j] = -pow(-input[j], data[j].processingIndex);
			//	}
			//	output[j]  = output[j] * 0.9; // -0.9 to 0.9
			//}
		}
		else //___________________________________________________________ Scaling
		{
			range = data[j].maximum-data[j].minimum;
			if (range == 0.0) range = 1.0;
			//if (data[j].processingIndex == 1.0)// No processing
			//{
				output[j] = (1.8*(input[j]-data[j].minimum)/range)-0.9;  // -0.9 to 0.9
				//if (output[j] < NN_LAYERNET_OFF-0.01 || output[j] > NN_LAYERNET_ON+0.01)
				//{
				//	_snwprintf_s(errorDescr, 256, _TRUNCATE, L"The scaling produced a value out of range: index %d", j);
				//	return errorDescr;
				//	//return L"The scaling produced a value out of range";
				//}
			//}
			//else//_______________________ Processing
			//{
			//	output[j] = (2.0*(input[j]-data[j].minimum)/range)-1.0;//  -1.0 to 1.0
			//	if (output[j] < -1.0 || output[j] > 1.0)
			//	{
			//		_snwprintf_s(errorDescr, 256, _TRUNCATE, L"The scaling produced a value out of range: index %d", j);
			//		return errorDescr;
			//		//return L"The scaling produced a value out of range";
			//	}
			//	if (input[j] > 0)
			//	{
			//		output[j] = pow(output[j], data[j].processingIndex);
			//	}
			//	else if (input[j] < 0)
			//	{
			//		output[j] = -pow(-output[j], data[j].processingIndex);
			//	}
			//	output[j] = output[j]*0.9; //  -0.9 to 0.9
			//}
		}
	}
	return NULL;
}

wchar_t*  Scaler::ScaleToStandardRange(const MATRIX& input, MATRIX& output)
{
	if (data == NULL || size == 0) return L"The scaler has not been created";
	const int rows = input.size();
	if (rows == 0)
	{
		output.clear();
		return NULL;
	}
	const int cols = input[0].size();
	if (cols != size) return L"The number of columns in the data set does not match the size of the scaler";
	if (Math::Oper::CreateMatrix(output, rows, cols) == false) return L"No enough memory to scale the data set";
	wchar_t * error = NULL;
	for(int i=0; i<rows; i++)
	{
		error = ScaleToStandardRange(input[i], output[i]);
		if (error) return error;
	}
	return NULL;
}

wchar_t* Scaler::ScaleFromStandardRange(const valarray<double>& input, valarray<double>& output)
{
	if (data == NULL || size == 0) return L"The scaler has not been created";
	const int cols = input.size();
	if (cols != size) return L"The number of columns in the data set does not match the size of the scaler";
	int j;
	double range = 1.0;
	double minOut = 0.0;

	if (output.size() != cols)
	{
		output.resize(cols);
	}
	for(j=0; j<cols; j++)
	{
		//if (data[j].processingIndex == 1.0)//_______________________________ No processing
		//{
			if (data[j].maximum == 0.0 && data[j].minimum == 0.0)//______ No Processing + No scaling
			{
				output[j] = input[j];
			}
			else//______________________________________________No Processing + Scaling
			{
				range = data[j].maximum-data[j].minimum;
				output[j] = (range*(input[j]+0.9)/1.8)+data[j].minimum;
			}
		//}
		//else //____________________________________________________ Processing
		//{
		//	output[j] = input[j];
		//	//___________________________ clip to: -0.9 to 0.9
		//	if (output[j] > 0.9) output[j] = 0.9;
		//	if (output[j] < -0.9) output[j] = -0.9;
		//	output[j] = (output[j]/0.9);//________________Scale to: -1 to 1
		//	if (output[j] > 0)
		//	{
		//		output[j] = pow(output[j], 1.0/(data[j].processingIndex));
		//	}
		//	else if (output[j] < 0)
		//	{
		//		output[j] = -pow(-output[j], 1.0/(data[j].processingIndex));
		//	}
		//	if (data[j].maximum == 0.0 && data[j].minimum == 0.0)//______ Processing + No scaling
		//	{
		//	}
		//	else//______________________________________________ Processing + Scaling
		//	{
		//		range = data[j].maximum-data[j].minimum;
		//		output[j] = (range*(output[j]+1.0)/2.0)+data[j].minimum;
		//	}
		//}
	}
	return NULL;
}

wchar_t*  Scaler::ScaleFromStandardRange(const MATRIX& input, MATRIX& output)
{
	if (data == NULL || size == 0) return L"The scaler has not been created";
	const int rows = input.size();
	if (rows == 0)
	{
		output.clear();
		return NULL;
	}
	const int cols = input[0].size();
	if (cols!=size) return L"The number of columns in the data set does not match the size of the scaler";
	if (Math::Oper::CreateMatrix(output, rows, cols) == false) return L"No enough memory to scale the data set";
	wchar_t * error = NULL;
	for(int i=0; i<rows; i++)
	{
		error = ScaleFromStandardRange(input[i], output[i]);
		if (error) return error;
	}
	return NULL;
}

void Scaler::GetText(int index, wchar_t* buffer, int buffer_length)
{
	if (index<0 || index>=size) 	
	{
		_snwprintf_s(buffer, buffer_length, _TRUNCATE, L"Invalid scaler index");
		return;
	}
	if (data == NULL)
	{
		_snwprintf_s(buffer, buffer_length, _TRUNCATE, L"The scaler has not been created");
		return;
	}

	//_snwprintf_s(buffer, buffer_length, _TRUNCATE, L"[%g   %g] pi=%.1f",
	//	data[index].minimum, data[index].maximum, data[index].processingIndex);
	_snwprintf_s(buffer, buffer_length, _TRUNCATE, L"[%g   %g]", data[index].minimum, data[index].maximum);
}

int Scaler::GetSize()
{
	return size;
}

//__________________________________________________________________ Tanh
double Nn::Tanh::scale = 0.0;
double Nn::Tanh::funcTable[NN_AF_TABLE_LENGTH];
double Nn::Tanh::deriTable[NN_AF_TABLE_LENGTH];

Tanh::Tanh(void)
{
	if (scale == 0.0)
	{
		scale = (double)(NN_AF_TABLE_LENGTH-1)/(double)NN_AF_TANHLIM;
		for(int i=0; i<NN_AF_TABLE_LENGTH; i++)
		{
			funcTable[i]=tanh(1.5*(double)i/scale);
			if (i != 0) 
			{
				deriTable[i-1]= funcTable[i]-funcTable[i-1];
			}
		}
	}
}

Tanh::~Tanh(void)
{
}

double Tanh::Func(double x)
{
	if (x>NN_AF_TANHLIM) return 1.0;
	if (x<-NN_AF_TANHLIM) return -1.0;
	double xd = fabs(x*scale);
	int i = (int)xd;
	double y = funcTable[i]+deriTable[i]*(xd-i); 
	return (x>=0.0) ? y : -y;
}

double Tanh::Derivative(double y)
{
	return 1.5 * (1.0 - y * y) ;
}

double Tanh::InverseFunc(double y)
{
	//if (y<0) return -20.0;
	//if (y>0) return 20.0;
	if (y < -NN_AF_LIM) y = -NN_AF_LIM;
	if (y > NN_AF_LIM) y = NN_AF_LIM;
	return 0.333333333333333 * log ( (1.0 + y) / (1.0 - y) ) ;
}

double Tanh::GetNeuronOn(void)
{
	return 0.9;
}

double Tanh::GetNeuronOff(void)
{
	return -0.9;
}

double Tanh::GetClassificationThreshold(void)
{
	return 0.0;
}

void Tanh::ShowError(HWND hWnd)
{
	const double x1 = -20.0;
	const double x2 = 20.0;
	const int length = 32000;
	const double delta = (x2-x1)/length;
	double x = 0.0;
	double y = 0.0;
	double mse = 0.0;
	//Win::Clipboard cb;

	// Reading or writing file
	//DWORD dwWritten, dwWrite = 0;
	wchar_t texto[256];

	//HANDLE hFile = CreateFile(_T("C:\\hola.csv"), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);

	//if (hFile == INVALID_HANDLE_VALUE) return;

	for(int i=0; i<length; i++)
	{
		x = x1+i*delta;
		y = GetExactValue(x) - Func(x);
		mse += (y*y);
		//dwWrite = _sntprintf(texto, 256, _T("%.14f, %.14f, %.14f\r\n"), x, getExactValue(x), func(x));
		//::WriteFile(hFile, texto, dwWrite, &dwWritten, NULL);
	}
	_snwprintf_s(texto, 256, _TRUNCATE, L"%d\t%g", NN_AF_TANHLIM, mse/length);
	::MessageBox(hWnd, texto, L"mse", MB_OK);
	//Win::Clipboard::CopyTextToClipboard(hWnd, texto);

	//if (hFile!=INVALID_HANDLE_VALUE) ::CloseHandle(hFile);
}

double Tanh::GetExactValue(double x)
{
	return tanh(1.5*x);
}

//__________________________________________________________ Layer
Layer::Layer(void)
{

}

Layer::~Layer(void)
{
}

Layer::Layer(const Layer& init)
{
	//Constructor();
	Copy(init);
}

Layer& Layer::operator=(const Layer& init)
{
	Delete();
	Copy(init);
	return *this;
}

void Layer::Copy(const Layer &init)
{
	weight = init.weight;
	output = init.output;
}

double Layer::OutputDerivative(const int index)
{
	const double value  = output[0][index];
	return 1.5 * (1.0 - value * value) ;
}

void Layer::ComputeOutput(const MATRIX& input, int rowInputIndex)
{
	const int numOut = (output.size() == 0) ? 0 : output[0].size();
	const int numWeights = (weight.size() == 0) ? 0: weight[0].size();
	if (numWeights == 0) return;
	double sum = 0.0;
	int i, j;
	for(i=0; i<numOut; i++)
	{
		sum = 0.0;
		for(j=0; j<numWeights-1; j++)
		{
			sum+= (input[rowInputIndex][j]*weight[i][j]);
		}
		sum +=weight[i][numWeights-1]; //bias
		output[0][i] = activation.Func(sum);
	}
}

void Layer::Delete()
{
	this->weight.clear();
	this->output.clear();
}

void Layer::Agitate(double perturbRatio, Nn::Layer& source)
{
	const int rows = weight.size();
	if (rows <= 0) return;
	const int cols = (rows == 0) ? 0 : weight[0].size();
	if (cols <= 0) return;
	//
#ifdef _DEBUG
	const int rowsSource = source.weight.size();
	const int colsSource = (rowsSource == 0) ? 0 : source.weight[0].size();
	if (rows != rowsSource) throw L"Nn::Layer::Agitate size error in the number of rows";
	if (cols != colsSource) throw L"Nn::Layer::Agitate size error in the number of columns";
#endif
	std::tr1::uniform_real<double> dist(-NN_LAYERNET_WEIGHTMAX, NN_LAYERNET_WEIGHTMAX);
	const double originalRatio = 1.0 - perturbRatio;
	int i, j;
	for(i = 0; i<rows; i++)
	{
		for(j=0; j<cols; j++)
		{
			weight[i][j] = originalRatio * source.weight[i][j] + perturbRatio * dist(Math::Statistics::random_generator);
		}
	}
}

void Layer::Initialize()
{
	const int rows = weight.size();
	if (rows<=0) return;
	const int cols = (weight.size()==0) ? 0 : weight[0].size();
	if (cols<=0) return;
	std::tr1::uniform_real<double> dist(-NN_LAYERNET_WEIGHTMAX, NN_LAYERNET_WEIGHTMAX);

	int i, j;
	for(i = 0; i<rows; i++)
	{
		for(j=0; j<cols; j++)
		{
			weight[i][j] = dist(Math::Statistics::random_generator);
		}
	}
}

//_____________________________________________________________________ LayerNet
MATRIX LayerNet::trainSetScaledIn;
MATRIX LayerNet::trainSetScaledTarget;
MATRIX LayerNet::svd_a;
MATRIX LayerNet::svd_u;
MATRIX LayerNet::svd_v;
MATRIX LayerNet::svd_y;
valarray<double> LayerNet::deltaOutput;
valarray<double> LayerNet::deltaHidden2;

LayerNet::LayerNet()
{
	Constructor();
}

LayerNet::~LayerNet()
{
}

LayerNet::LayerNet(const LayerNet& init)
{
	Constructor();
	Copy(init);
}

LayerNet& LayerNet::operator=(const LayerNet& init)
{
	Delete();
	Copy(init);
	return *this;
}

int LayerNet::GetMinNumTrainCases()
{
	const int layerCount = GetLayerCount();
	int rows = 0;
	int numWeights = 0;

	if (layerCount == 2)
	{       
		rows = layerOut.weight.size();
		if (rows == 0) return 0;
		numWeights = layerOut.weight[0].size() * rows;
	}
   else if (layerCount == 3)
   {          
		rows = layerHid1.weight.size();
		if (rows == 0) return 0;
		numWeights = layerHid1.weight[0].size() * rows;
		//_________ ignore output layer
	}
	else if (layerCount == 4)
	{                    
		rows = layerHid1.weight.size();
		if (rows > 0) numWeights += (layerHid1.weight[0].size() * rows);
		//
		rows = layerHid2.weight.size();
		if (rows > 0) numWeights += (layerHid2.weight[0].size() * rows);
		//_________ ignore output layer
	}
	return (int)(2.2*numWeights+0.99999999);
}

void LayerNet::CopyThisToPoint(valarray<double>& point) const
{
	const int layerCount = GetLayerCount();
	int r, c, j=0;

	if (layerCount >= 2)
	{
		//_______________________________________ Copy Output Layer
		const int rows = layerOut.weight.size();
		const int cols = (rows == 0) ? 0 : layerOut.weight[0].size();
		for(r=0; r<rows; r++) 
		{
			for(c=0; c<cols; c++) point[j++] = layerOut.weight[r][c];
		}
	}
	if (layerCount >= 4)
	{
		//_______________________________________ Copy Hidden 2 Layer
		const int rows = layerHid2.weight.size();
		const int cols = (rows == 0) ? 0 : layerHid2.weight[0].size();
		for(r=0; r<rows; r++) 
		{
			for(c=0; c<cols; c++) point[j++] = layerHid2.weight[r][c];
		}
	}
	if (layerCount >= 3)
	{
		//_______________________________________ Copy Hidden1 Layer
		const int rows = layerHid1.weight.size();
		const int cols = (rows == 0) ? 0 : layerHid1.weight[0].size();
		for(r=0; r<rows; r++) 
		{
			for(c=0; c<cols; c++) point[j++] = layerHid1.weight[r][c];
		}
	}
}

void LayerNet::CopyPointToThis(const valarray<double>& point)
{
	const int layerCount = GetLayerCount();
	int r, c, j=0;

	if (layerCount >= 2)
	{
		//_______________________________________ Copy Output Layer
		const int rows = layerOut.weight.size();
		const int cols = (rows == 0) ? 0 : layerOut.weight[0].size();
		for(r=0; r<rows; r++) 
		{
			for(c=0; c<cols; c++) layerOut.weight[r][c] = point[j++];
		}
	}
	if (layerCount >= 4)
	{
		//_______________________________________ Copy Hidden 2 Layer
		const int rows = layerHid2.weight.size();
		const int cols = (rows == 0) ? 0 : layerHid2.weight[0].size();
		for(r=0; r<rows; r++) 
		{
			for(c=0; c<cols; c++) layerHid2.weight[r][c] = point[j++];
		}
	}
	if (layerCount >= 3)
	{
		//_______________________________________ Copy Hidden 1 Layer
		const int rows = layerHid1.weight.size();
		const int cols = (rows == 0) ? 0 : layerHid1.weight[0].size();
		for(r=0; r<rows; r++) 
		{
			for(c=0; c<cols; c++) layerHid1.weight[r][c] = point[j++];
		}
	}
}

void LayerNet::Copy(const LayerNet &init)
{
	this->layerHid1 = init.layerHid1;
	this->layerHid2 = init.layerHid2;
	this->layerOut = init.layerOut;
	this->scalerInput = init.scalerInput;
	this->scalerOutput = init.scalerOutput;
	this->hasTrainSet = false;
	this->trainSetScaledIn.clear();
	this->trainSetScaledTarget.clear();
}

double LayerNet::EvaluateFunc(const valarray<double>& x)
{
	this->CopyPointToThis(x);
	int i, j;
	const int rows = trainSetScaledIn.size();
	double divergence;
	const int numIn = GetInputCount();
	const int numOut = GetOutputCount();
	const int layerCount = GetLayerCount();
	double gradError = 0.0;

	if (layerCount == 2)
	{
		for(i=0; i<rows; i++)
		{
			layerOut.ComputeOutput(trainSetScaledIn, i);//it updates layerOut.output	
			for(j=0; j<numOut; j++)
			{
				divergence = layerOut.output[0][j] -trainSetScaledTarget[i][j];
				gradError += (divergence*divergence);
			}
		}
	}
	else if (layerCount == 3)
	{
		const int numHid1 = GetHidden1NeuronCount();
		for(i=0; i<rows; i++)
		{
			layerHid1.ComputeOutput(trainSetScaledIn, i);
			layerOut.ComputeOutput(layerHid1.output, 0);
			for(j=0; j<numOut; j++)
			{
				divergence = layerOut.output[0][j] -trainSetScaledTarget[i][j];
				gradError += (divergence*divergence);
			}
		}
	}
	else if (layerCount == 4)
	{
		const int numHid1 = GetHidden1NeuronCount();
		const int numHid2 = GetHidden2NeuronCount();
		for(i=0; i<rows; i++)
		{
			layerHid1.ComputeOutput(trainSetScaledIn, i);
			layerHid2.ComputeOutput(layerHid1.output, 0);
			layerOut.ComputeOutput(layerHid2.output, 0);
			for(j=0; j<numOut; j++)
			{
				divergence = layerOut.output[0][j] - trainSetScaledTarget[i][j];
				gradError += (divergence*divergence);
			}
		}
	}
	return gradError/(rows*numOut);
}

void LayerNet::EvaluateGrad(const valarray<double>& x, valarray<double>& outGrad)
{
	this->CopyPointToThis(x);
	const int gradSize = outGrad.size();
	int i, j, m, index=0;

	
	//________________________________________________ Set the gradient to zero
	for(i = 0; i < gradSize; i++) outGrad[i] = 0.0;
	//
	const int rows = trainSetScaledIn.size();
	double divergence;
	const int numIn = GetInputCount();
	const int numOut = GetOutputCount();
	double delta = 0.0;
	const int layerCount = GetLayerCount();
	//gradError = 0.0;

	if (layerCount == 2)
	{
		for(i=0; i<rows; i++)
		{
			index = 0;
			layerOut.ComputeOutput(trainSetScaledIn, i);//it updates layerOut.output	
			for(j=0; j<numOut; j++)
			{
				divergence = layerOut.output[0][j] -trainSetScaledTarget[i][j];
				//gradError += (divergence*divergence);
				delta = 2.0*divergence * layerOut.OutputDerivative(j);
				for(m=0; m<numIn; m++) outGrad[index++] += (delta * this->trainSetScaledIn[i][m]);
				outGrad[index++] += delta;
			}
		}
	}
	else if (layerCount == 3)
	{
		const int numHid1 = GetHidden1NeuronCount();
		for(i=0; i<rows; i++)
		{
			index = 0;
			layerHid1.ComputeOutput(trainSetScaledIn, i);
			layerOut.ComputeOutput(layerHid1.output, 0);
			//____________________________________________________________ Output layer gradient
			for(j=0; j<numOut; j++)
			{
				divergence = layerOut.output[0][j] -trainSetScaledTarget[i][j];
				//gradError += (divergence*divergence);
				delta = 2.0*divergence * layerOut.OutputDerivative(j);
				deltaOutput[j]= delta;
				for(m=0; m<numHid1; m++)
				{
					outGrad[index++] += (delta * layerHid1.output[0][m]);
				}
				outGrad[index++] += delta;
			}
			//____________________________________________________________ Hid1 layer gradient
			for(m=0; m<numHid1; m++)
			{
				delta = 0.0;
				for(j=0; j<numOut; j++)
				{
					delta += deltaOutput[j]*layerOut.weight[j][m];
				}
				delta *= layerHid1.OutputDerivative(m);
				for(j=0; j<numIn; j++) 
				{
					outGrad[index++] += (delta*trainSetScaledIn[i][j]);
				}
				outGrad[index++] += delta;
			}
		}
	}
	else if (layerCount == 4)
	{
		const int numHid1 = GetHidden1NeuronCount();
		const int numHid2 = GetHidden2NeuronCount();
		for(i=0; i<rows; i++)
		{
			index = 0;
			layerHid1.ComputeOutput(trainSetScaledIn, i);
			layerHid2.ComputeOutput(layerHid1.output, 0);
			layerOut.ComputeOutput(layerHid2.output, 0);
			//____________________________________________________________ Output layer gradient
			for(j=0; j<numOut; j++)
			{
				divergence = layerOut.output[0][j] - trainSetScaledTarget[i][j];
				//gradError += (divergence*divergence);
				delta = 2.0*divergence * layerOut.OutputDerivative(j);
				deltaOutput[j]= delta;
				for(m=0; m<numHid2; m++)
				{
					outGrad[index++] += (delta * layerHid2.output[0][m]);
				}
				outGrad[index++] += delta;
			}
			//____________________________________________________________ Hid2 layer gradient
			for(m=0; m<numHid2; m++)
			{
				delta = 0.0;
				for(j=0; j<numOut; j++) delta += deltaOutput[j]*layerOut.weight[j][m];
				delta *= layerHid2.OutputDerivative(m);
				deltaHidden2[m]=delta;
				for(j=0; j<numHid1; j++)
				{
					outGrad[index++] += (delta*layerHid1.output[0][j]);
				}
				outGrad[index++] += delta;
			}
			//____________________________________________________________ Hid1 layer gradient
			for(m=0; m<numHid1; m++)
			{
				delta = 0.0;
				for(j=0; j<numHid2; j++)
				{
					delta += (deltaHidden2[j]*layerHid2.weight[j][m]);
				}
				delta *= layerHid1.OutputDerivative(m);
				for(j=0; j<numIn; j++)
				{
					outGrad[index++] += (delta*trainSetScaledIn[i][j]);
				}
				outGrad[index++] += delta;
			}
		}
	}
	outGrad /= rows;
	//gradError = gradError/(rows*numOut);
}

//double LayerNet::EvaluateFuncAndGrad(const valarray<double>& x, valarray<double>& outGrad)
//{
//	this->CopyPointToThis(x);
//	const int gradSize = outGrad.size();
//	int i, j, m, index=0;
//
//	//________________________________________________ Set the gradient to zero
//	for(i = 0 ; i < gradSize; i++) outGrad[i] = 0.0;
//	//
//	const int rows = trainSetScaledIn.size();
//	double divergence;
//	const int numIn = GetInputCount();
//	const int numOut = GetOutputCount();
//	double delta = 0.0;
//	const int layerCount = GetLayerCount();
//	double gradError = 0.0;
//
//	if (layerCount == 2)
//	{
//		for(i=0; i<rows; i++)
//		{
//			index = 0;
//			layerOut.ComputeOutput(trainSetScaledIn, i);//it updates layerOut.output	
//			for(j=0; j<numOut; j++)
//			{
//				divergence = layerOut.output[0][j] -trainSetScaledTarget[i][j];
//				gradError += (divergence*divergence);
//				delta = 2.0*divergence * layerOut.OutputDerivative(j);
//				for(m=0; m<numIn; m++) outGrad[index++] += delta * trainSetScaledTarget[i][m];
//				outGrad[index++] += delta;
//			}
//		}
//	}
//	else if (layerCount == 3)
//	{
//		const int numHid1 = GetHidden1NeuronCount();
//		for(i=0; i<rows; i++)
//		{
//			index = 0;
//			layerHid1.ComputeOutput(trainSetScaledIn, i);
//			layerOut.ComputeOutput(layerHid1.output, 0);
//			//____________________________________________________________ Output layer gradient
//			for(j=0; j<numOut; j++)
//			{
//				divergence = layerOut.output[0][j] -trainSetScaledTarget[i][j];
//				gradError += (divergence*divergence);
//				delta = 2.0*divergence * layerOut.OutputDerivative(j);
//				deltaOutput[j]= delta;
//				for(m=0; m<numHid1; m++)
//				{
//					outGrad[index++] += delta * layerHid1.output[0][m];
//				}
//				outGrad[index++] += delta;
//			}
//			//____________________________________________________________ Hid1 layer gradient
//			for(m=0; m<numHid1; m++)
//			{
//				delta = 0.0;
//				for(j=0; j<numOut; j++)
//				{
//					delta += deltaOutput[j]*layerOut.weight[j][m];
//				}
//				delta *= layerHid1.OutputDerivative(m);
//				for(j=0; j<numIn; j++) 
//				{
//					outGrad[index++] += delta*trainSetScaledIn[i][j];
//				}
//				outGrad[index++] += delta;
//			}
//		}
//	}
//	else if (layerCount == 4)
//	{
//		const int numHid1 = GetHidden1NeuronCount();
//		const int numHid2 = GetHidden2NeuronCount();
//		for(i=0; i<rows; i++)
//		{
//			index = 0;
//			layerHid1.ComputeOutput(trainSetScaledIn, i);
//			layerHid2.ComputeOutput(layerHid1.output, 0);
//			layerOut.ComputeOutput(layerHid2.output, 0);
//			//____________________________________________________________ Output layer gradient
//			for(j=0; j<numOut; j++)
//			{
//				divergence = layerOut.output[0][j] - trainSetScaledTarget[i][j];
//				gradError += (divergence*divergence);
//				delta = 2.0*divergence * layerOut.OutputDerivative(j);
//				deltaOutput[j]= delta;
//				for(m=0; m<numHid2; m++)
//				{
//					outGrad[index++] += delta * layerHid2.output[0][m];
//				}
//				outGrad[index++] += delta;
//			}
//			//____________________________________________________________ Hid2 layer gradient
//			for(m=0; m<numHid2; m++)
//			{
//				delta = 0.0;
//				for(j=0; j<numOut; j++) delta += deltaOutput[j]*layerOut.weight[j][m];
//				delta *= layerHid2.OutputDerivative(m);
//				deltaHidden2[m]=delta;
//				for(j=0; j<numHid1; j++)
//				{
//					outGrad[index++] += delta*layerHid1.output[0][j];
//				}
//				outGrad[index++] += delta;
//			}
//			//____________________________________________________________ Hid1 layer gradient
//			for(m=0; m<numHid1; m++)
//			{
//				delta = 0.0;
//				for(j=0; j<numHid2; j++)
//				{
//					delta += deltaHidden2[j]*layerHid2.weight[j][m];
//				}
//				delta *= layerHid1.OutputDerivative(m);
//				for(j=0; j<numIn; j++)
//				{
//					outGrad[index++] += delta*trainSetScaledIn[i][j];
//				}
//				outGrad[index++] += delta;
//			}
//		}
//	}
//	outGrad /= rows;
//	return gradError/(rows*numOut);
//}

void LayerNet::Constructor()
{
	hasTrainSet = false;
}

void LayerNet::Delete()
{
	layerHid1.Delete();
	layerHid2.Delete();
	layerOut.Delete();
	scalerInput.Delete();
	scalerOutput.Delete();
	hasTrainSet = false;
	//trainSetScaledIn.clear();
	//trainSetScaledTarget.clear();
	//SvdDelete();
}

bool LayerNet::SvdCreate()
{
	// This for regression in Simulated Annealing and Genetic Algorithm for (for one and two hidden layers)
	const int layerCount = GetLayerCount();
	if (layerCount != 3 && layerCount != 4) return false;
	const int numTrainCases = trainSetScaledIn.size();
	const int numOutputs = GetOutputCount();
	const int numInputs = GetInputCount();

	int i, j;
	if (Math::Oper::CreateMatrix(svd_y, numOutputs, numTrainCases) == false) return false;
	//__________________________________________________________  Expected y'
	for(i = 0; i<numOutputs; i++)
	{
		for(j = 0; j<numTrainCases; j++)
		{
			svd_y[i][j] = Nn::Tanh::InverseFunc(trainSetScaledTarget[j][i]); // y = transposed(inv_tanh(trainSetScaledTarget))
		}
	}

	if (layerCount == 3)
	{	
		if (Math::Oper::CreateMatrix(svd_a, numTrainCases, GetHidden1NeuronCount()+1) == false) return false;
		if (Math::Oper::CreateMatrix(svd_u, numTrainCases, GetHidden1NeuronCount()+1) == false) return false;
	}
	else if (layerCount == 4)
	{
		if (Math::Oper::CreateMatrix(svd_a, numTrainCases, GetHidden2NeuronCount()+1) == false) return false;
		if (Math::Oper::CreateMatrix(svd_u, numTrainCases, GetHidden2NeuronCount()+1) == false) return false;
	}
	return true;
}

void LayerNet::SvdDelete()
{
	svd_a.clear();
	svd_u.clear();
	svd_v.clear();
	svd_y.clear();
	svd_s.free();
	
}

bool LayerNet::DeltaCreate()
{
	const int layerCount = GetLayerCount();
	try
	{
		if (layerCount == 2)
		{
			//deltaOutput.resize(GetOutputCount());
			return true;
		}
		else if (layerCount == 3)
		{
			deltaOutput.resize(GetOutputCount());
			return true;
		}
		else if (layerCount == 4)
		{
			deltaOutput.resize(GetOutputCount());
			deltaHidden2.resize(GetHidden2NeuronCount());
			return true;
		}
	}
	catch (const std::bad_alloc& )
	{
		return false;
	}
	return false;
}

void LayerNet::DeltaDelete()
{
	deltaOutput.free();
	deltaHidden2.free();
}

void LayerNet::GetDescription(wchar_t* description, int length)
{
	const int layerCount = GetLayerCount();
	int rows = 0;
	int inputCount = 0;
	switch(layerCount)
	{
	case 2:
		_snwprintf_s(description, length, _TRUNCATE, L"%d, %d", GetInputCount(), GetOutputCount());
		break;
	case 3:
		_snwprintf_s(description, length, _TRUNCATE, L"%d, %d, %d", GetInputCount(), GetHidden1NeuronCount(), GetOutputCount());
	case 4:
		_snwprintf_s(description, length, _TRUNCATE, L"%d, %d, %d, %d", GetInputCount(), GetHidden1NeuronCount(), GetHidden2NeuronCount(), GetOutputCount());
	}	
}

int LayerNet::GetLayerCount() const
{
	const int hidden1Count = GetHidden1NeuronCount();
	const int hidden2Count = GetHidden2NeuronCount();
	int layerCount = 0;
	if (hidden1Count ==0 && hidden2Count == 0)
	{
		layerCount = 2; // Input and Output Layer
	}
	else if (hidden1Count != 0 && hidden2Count == 0)
	{
		layerCount = 3; // Input, Hidden1 and Output Layer
	}
	else
	{
		layerCount = 4; // Input, Hidden1, Hidden2 and Output Layer
	}
	return layerCount;
}

bool LayerNet::Create(int inputCount, int hidden1Count, int hidden2Count, int outputCount)
{
	Delete();
	//___________________________________________ check and correct input values
	if (inputCount<=0) inputCount = 1;
	if (outputCount<=0) outputCount = 1;
	if (hidden1Count<0) hidden1Count = 0;
	if (hidden2Count<0) hidden2Count = 0;
	if (hidden1Count == 0) hidden2Count = 0;
	if (hidden2Count != 0 && hidden1Count == 0) hidden1Count = 1;
	//___________________________________________ computer layer count
	int layerCount = 0;
	if (hidden1Count ==0 && hidden2Count == 0)
	{
		layerCount = 2; // Input and Output Layer
	}
	else if (hidden1Count != 0 && hidden2Count == 0)
	{
		layerCount = 3; // Input, Hidden1 and Output Layer
	}
	else
	{
		layerCount = 4; // Input, Hidden1, Hidden2 and Output Layer
	}
	//__________________________________________ allocate layers
	bool ok = false;
	switch(layerCount)
	{
	case 2:
		ok = Math::Oper::CreateMatrix(layerOut.weight, outputCount, inputCount+1);
		ok = ok && Math::Oper::CreateMatrix(layerOut.output, 1, outputCount);
		break;
	case 3:
		ok = Math::Oper::CreateMatrix(layerHid1.weight, hidden1Count, inputCount+1);
		ok = ok && Math::Oper::CreateMatrix(layerHid1.output, 1, hidden1Count);
		ok = ok && Math::Oper::CreateMatrix(layerOut.weight, outputCount, hidden1Count+1);
		ok = ok && Math::Oper::CreateMatrix(layerOut.output, 1, outputCount);
		break;
	case 4:
		ok = Math::Oper::CreateMatrix(layerHid1.weight, hidden1Count, inputCount+1);
		ok = ok && Math::Oper::CreateMatrix(layerHid1.output, 1, hidden1Count);
		ok = ok && Math::Oper::CreateMatrix(layerHid2.weight, hidden2Count, hidden1Count+1);
		ok = ok && Math::Oper::CreateMatrix(layerHid2.output, 1, hidden2Count);
		ok = ok && Math::Oper::CreateMatrix(layerOut.weight, outputCount, hidden2Count+1);
		ok = ok && Math::Oper::CreateMatrix(layerOut.output, 1, outputCount);
		break;
	}
	if (ok==false)
	{
		this->Delete();
		return false;
	}
	if (scalerInput.Create(inputCount) == false)
	{
		Delete();
		return false;
	}
	if (scalerOutput.Create(outputCount) == false)
	{
		Delete();
		return false;
	}
	return true;
}

wchar_t* LayerNet::Load(const wchar_t* filename)
{
	this->Delete();
	Sys::File file;
	//Nn::LayerNetHead head;
	//wchar_t * error = NULL;

	if (file.CreateForReading(filename)== false) return L"The file couldn't be read";
	//
	int version = NN_NEURAL_LAB_VERSION;
	if (file.Read(&version, sizeof(int))==false) return L"Unable to read version";
	//
	int subversion = NN_NEURAL_LAB_SUBVERSION;
	if (file.Read(&subversion, sizeof(int))==false) return L"Unable to read sub version";
	//
	if (version != NN_NEURAL_LAB_VERSION || subversion != NN_NEURAL_LAB_SUBVERSION)
	{
		_snwprintf_s(text, NN_LAYERNET_TEXTMAX, _TRUNCATE, L"Neural Lab %s.%s does not open files of version %d.%d",
			NN_NEURAL_LAB_VERSION, NN_NEURAL_LAB_SUBVERSION, version, subversion);
		return text;
	}
	//
	if (Sys::SerialAssistant::Load(file, layerHid1.weight) == false) {this->Delete(); return L"Unable to read hidden layer 1";}
	if (layerHid1.weight.size() > 0)
	{
		if (Math::Oper::CreateMatrix(layerHid1.output, 1, layerHid1.weight.size()) == false) {this->Delete(); return L"No enough memory for layer hidden 1";}
	}
	//
	if (Sys::SerialAssistant::Load(file, layerHid2.weight) == false) {this->Delete(); return L"Unable to read hidden layer 2";}
	if (layerHid2.weight.size() > 0)
	{
		if (Math::Oper::CreateMatrix(layerHid2.output, 1, layerHid2.weight.size()) == false) {this->Delete(); return L"No enough memory for layer hidden 2";}
	}
	//
	if (Sys::SerialAssistant::Load(file, layerOut.weight) == false) {this->Delete(); return L"Unable to read output layer";}
	if (layerOut.weight.size() > 0)
	{
		if (Math::Oper::CreateMatrix(layerOut.output, 1, layerOut.weight.size()) == false) {this->Delete(); return L"No enough memory for output layer";}
	}
	//
	if (this->scalerInput.Load(file)==false) {this->Delete(); return L"Unable to read network input scaler";}
	if (this->scalerOutput.Load(file)==false) {this->Delete(); return L"Unable to read network output scaler";}
	return NULL;
}

wchar_t* LayerNet::Save(const wchar_t* filename)
{
	Sys::File file;
	wchar_t * error = NULL;

	if (file.CreateForWritting(filename)==false) return L"Unable to write file";
	//
	int version = NN_NEURAL_LAB_VERSION;
	if (file.Write(&version, sizeof(int))==false) return L"Unable to write version";
	//
	int subversion = NN_NEURAL_LAB_SUBVERSION;
	if (file.Write(&subversion, sizeof(int))==false) return L"Unable to write sub version";
	//
	if (Sys::SerialAssistant::Save(file, layerHid1.weight) == false) return L"Unable to save weights from hidden layer 1";
	if (Sys::SerialAssistant::Save(file, layerHid2.weight) == false) return L"Unable to save weights from hidden layer 2";
	if (Sys::SerialAssistant::Save(file, layerOut.weight) == false) return L"Unable to save weights from output layer";
	//
	//
	if (this->scalerInput.Save(file)==false) return L"Unable to save network input scaler";
	if (this->scalerOutput.Save(file)==false) return L"Unable to save network output scaler";
	return NULL;
}

bool LayerNet::SetWeights(int layerIndex, const MATRIX& weights)
{
	const int layerCount = GetLayerCount();
	switch(layerCount)
	{
	case 2:
		if (layerIndex == 3) break;
		return false;
	case 3:
		if (layerIndex == 1) break;
		if (layerIndex == 3) break;
		return false;
	case 4:
		if (layerIndex == 1) break;
		if (layerIndex == 2) break;
		if (layerIndex == 3) break;
		return false;
	}
	if (layerIndex == 1)
	{
		if (AreMatrixSameSize(layerHid1.weight, weights) == false) return false;
		layerHid1.weight = weights;
		Math::Oper::CreateMatrix(layerHid1.output, 1, weights.size());
		return true;
	}
	else if (layerIndex == 2)
	{
		if (AreMatrixSameSize(layerHid2.weight, weights) == false) return false;
		layerHid2.weight = weights;
		Math::Oper::CreateMatrix(layerHid2.output, 1, weights.size());
		return true;
	}
	else if (layerIndex == 3)
	{
		if (AreMatrixSameSize(layerOut.weight, weights) == false) return false;
		layerOut.weight = weights;
		Math::Oper::CreateMatrix(layerOut.output, 1, weights.size());
		return true;
	}
	return false;
}

bool LayerNet::AreMatrixSameSize(const MATRIX& a, const MATRIX& b)
{
	if (a.size() != b.size()) return false;
	if (a.size() == 0) return true;
	if (a[0].size() != b[0].size()) return false;
	return true;
}

bool LayerNet::GetActivation(int layerIndex, valarray<double>& activation)
{
	const int layerCount = GetLayerCount();
	if (layerIndex == 1)
	{
		if (layerCount == 2) return false;
		activation = layerHid1.output[0];
		return true;
	}
	else if (layerIndex == 2)
	{
		if (layerCount == 2 || layerCount == 3) return false;
		activation = layerHid2.output[0];
		return true;
	}
	else if (layerIndex == 3)
	{
		activation = layerOut.output[0];
		return true;
	}
	return false;
}

bool LayerNet::GetWeights(int layerIndex, MATRIX& weights)
{
	if (layerIndex == 1)
	{
		weights = layerHid1.weight;
		return true;
	}
	else if (layerIndex == 2)
	{
		weights = layerHid2.weight;
		return true;
	}
	else if (layerIndex == 3)
	{
		weights = layerOut.weight;
		return true;
	}
	return false;
}

int LayerNet::GetInputCount() const
{
	const int layerCount = GetLayerCount();
	int rows = 0;
	int inputCount = 0;
	switch(layerCount)
	{
	case 2:
		rows = layerOut.weight.size();
		inputCount = (rows == 0) ? 0 : layerOut.weight[0].size()-1;
		break;
	case 3:
	case 4:
		rows = layerHid1.weight.size();
		inputCount = (rows == 0) ? 0 : layerHid1.weight[0].size()-1;
		break;
	}
	return inputCount;
}

int LayerNet::GetOutputCount() const
{
	return layerOut.weight.size();
}

int LayerNet::GetHidden1NeuronCount() const
{
	return layerHid1.weight.size();
}

int LayerNet::GetHidden2NeuronCount() const
{
	return layerHid2.weight.size();
}

void LayerNet::Unlearn()
{
	this->SimAnnealInitialize();
}

bool LayerNet::AutoSetInputScaler(MATRIX& input)
{
	return scalerInput.AutoSet(input);
}

bool LayerNet::AutoSetOutputScaler(MATRIX& output)
{
	return scalerOutput.AutoSet(output);
}

bool LayerNet::SetInputScaler(int index, double minimum, double maximum)
{
	return scalerInput.Set(index, minimum, maximum);
}

bool LayerNet::SetOutputScaler(int index, double minimum, double maximum)
{
	return scalerOutput.Set(index, minimum, maximum);
}

bool LayerNet::GetInputScaler(int index, double& minimum, double& maximum)
{
	Nn::ScalingInfo si;
	if (scalerInput.GetScalingInfo(index, si) == false) return false;
	minimum = si.minimum;
	maximum = si.maximum;
	//processingIndex = si.processingIndex;
	return true;
}

bool LayerNet::GetOutputScaler(int index, double& minimum, double& maximum)
{
	Nn::ScalingInfo si;
	if (scalerOutput.GetScalingInfo(index, si) == false) return false;
	minimum = si.minimum;
	maximum = si.maximum;
	//processingIndex = si.processingIndex;
	return true;
}

wchar_t * LayerNet::ScaleInputDataSet(const MATRIX& input, MATRIX& scaledInput, bool ignoreWarnings)
{
	const int rows = input.size();
	if (rows == 0) return L"The input data set is empty";
	const int cols = (rows == 0) ? 0 : input[0].size();
	if (cols == 0) return L"The input data set is empty";
	if (cols != GetInputCount()) return L"The numb of cols in the input set and the numb of inputs in the network must be equal";
	wchar_t * error  = scalerInput.ScaleToStandardRange(input, scaledInput);
	if (error) return error;

	int i, j;
	double value;
	//______________________________________ Check range
	for(i = 0; i<rows; i++)
	{
		for(j = 0; j<cols; j++)
		{
			value = scaledInput[i][j];
			if (NN_LAYERNET_OFF-0.001 <= value && value <= NN_LAYERNET_ON+0.001) continue;
			_snwprintf_s(text, NN_LAYERNET_TEXTMAX, _TRUNCATE, L"The network scaling in input %d is invalid", j);
			return text;
		}
	}
	if (ignoreWarnings == false)
	{
		double sum, sums;
		double variance;
		//_____________________________________ Check the set
		for(j = 0; j<cols; j++)
		{
			sum = 0.0;
			sums = 0.0;
			for(i = 0; i<rows; i++)
			{
				value = input[i][j];
				sum += value;
				sums += (value*value);
			}
			variance = fabs(sums/(rows-1.0) - (sum*sum)/(rows*(rows-1.0)));
			if (variance < NN_MIN_VARIANCE)
			{
				_snwprintf_s(text, NN_LAYERNET_TEXTMAX, _TRUNCATE, L"The colum %i in the input data set has very little information", j);
				return text;
			}
		}
	}
	return NULL;
}

wchar_t* LayerNet::GetScaledOutput(MATRIX& scaledOutput)
{
	return scalerOutput.ScaleFromStandardRange(layerOut.output, scaledOutput);
}

wchar_t * LayerNet::ScaleOutputDataSet(const MATRIX& output, MATRIX& scaledOutput, bool ignoreWarnings)
{
	const int rows = output.size();
	if (rows == 0) return L"The output set is empty";
	const int cols = (rows == 0) ? 0 : output[0].size();
	if (cols == 0) return L"The output set is empty";
	if (cols != GetOutputCount()) return L"The numb of cols in the output set must be equal to the numb of outputs in the network";
	wchar_t * error  = scalerOutput.ScaleToStandardRange(output, scaledOutput);
	if (error) return error;

	int i, j;
	double value;
	//______________________________________ Check range
	for(i = 0; i<rows; i++)
	{
		for(j = 0; j<cols; j++)
		{
			value = scaledOutput[i][j];
			if (NN_LAYERNET_OFF-0.01 <= value && value <= NN_LAYERNET_ON+0.01) continue;
			_snwprintf_s(text, NN_LAYERNET_TEXTMAX, _TRUNCATE, L"Network scaling in output %i is invalid", j);
			return text;
		}
	}

	//_____________________________________ Check variance
	if (ignoreWarnings == false)
	{
		double sum, sums;
		double variance;
		//_____________________________________ Check the set
		for(j = 0; j<cols; j++)
		{
			sum = 0.0;
			sums = 0.0;
			for(i = 0; i<rows; i++)
			{
				value = scaledOutput[i][j];
				sum += value;
				sums += (value*value);
			}
			variance = fabs(sums/(rows-1.0) - (sum*sum)/(rows*(rows-1.0)));
			if (variance < NN_MIN_VARIANCE)
			{
				_snwprintf_s(text, NN_LAYERNET_TEXTMAX, _TRUNCATE, L"Column %i in the target set has little information", j);
				return text;
			}
		}
	}
	return NULL;
}

wchar_t* LayerNet::SetTrainingSet(const MATRIX& trainSetIn, const MATRIX& trainSetTarget, bool ignoreWarnings)
{
	//trainSetScaledIn.clear();
	//trainSetScaledTarget.clear();

	hasTrainSet = false;
	wchar_t * error = NULL;

	if (trainSetIn.size() != trainSetTarget.size()) return L"The number of rows in the input set and the target set must be equal";

	error = ScaleInputDataSet(trainSetIn, trainSetScaledIn, ignoreWarnings);
	if (error) return error;

	error = ScaleOutputDataSet(trainSetTarget, trainSetScaledTarget, ignoreWarnings);
	if (error) return error;

	if (ignoreWarnings == false)
	{
		const int minNumTrainCases = GetMinNumTrainCases();
		if (trainSetIn.size() < (size_t)minNumTrainCases)
		{
			_snwprintf_s(text, NN_LAYERNET_TEXTMAX, _TRUNCATE, L"The minimum number of training cases is %d", minNumTrainCases);
			return text;
		}
	}

	hasTrainSet = true;

	return NULL;
}

wchar_t* LayerNet::TrainGenetic(Mt::BoolTs& running, Mt::DoubleTs& progress, Mt::DoubleTs& mse, Math::GeneticParam& param)
{
	if (hasTrainSet == false) return L"The training set is missing.  Call net.SetTrainingSet()";
	const int layerCount = GetLayerCount();
	Mt::BoolTs resetTime;
	int individualSize = 0;
	int i, j, k;

	Math::GeneticAlgorithm ga;
	ga.initPopulationSize = param.initPopulationSize;
	ga.numGenerations = param.numGenerations;
	ga.overPopulation = param.overPopulation;
	ga.mutationProbability = param.mutationProbability;
	ga.crossoverProbability = param.crossoverProbability;
	ga.goal = param.goal;
	//
	ga.SetStopWhenDone(false);
	//
	const int rows = this->layerOut.weight.size();
	const int cols = (rows == 0) ? 0 : layerOut.weight[0].size();
	const int rowsHid1 = layerHid1.weight.size();
	const int colsHid1 = (rowsHid1 == 0) ? 0 : layerHid1.weight[0].size();
	const int rowsHid2 = layerHid2.weight.size();
	const int colsHid2 = (rowsHid2 == 0) ? 0 : layerHid2.weight[0].size();

	if (layerCount == 2)
	{
		
		individualSize = rows*cols*NN_BITS_PER_WEIGHT;
		ga.Setup(mse, individualSize, *this);
		//_____________________________Copy Best individual
		k = 0;
		for(i = 0; i<rows; i++)
		{
			for(j = 0; j < cols; j++)
			{
				ga.bestIndividual.bits.SetInt16(k++, (int)(NN_WEIGHT_RES*layerOut.weight[i][j]/NN_LAYERNET_WEIGHTMAX));
			}
		}
		//____________________________ 
		ga.ThreadFunc(running, progress, resetTime);
		mse.Set(ComputeCurrentTrueMse());
	}
	else if (layerCount == 3)
	{
		SvdCreate();
		individualSize = rowsHid1*colsHid1*NN_BITS_PER_WEIGHT;
		ga.Setup(mse, individualSize, *this);
		//_____________________________Copy Best individual
		k = 0;
		for(i = 0; i<rowsHid1; i++)
		{
			for(j = 0; j < colsHid1; j++)
			{
				ga.bestIndividual.bits.SetInt16(k++, (int)(NN_WEIGHT_RES*layerHid1.weight[i][j]/NN_LAYERNET_WEIGHTMAX));
			}
		}
		//____________________________ 
		ga.ThreadFunc(running, progress, resetTime);
		mse.Set(ComputeCurrentTrueMse());
		SvdDelete();
	}
	else if (layerCount == 4)
	{
		SvdCreate();
		individualSize = rowsHid1*colsHid1*NN_BITS_PER_WEIGHT + rowsHid2*colsHid2*NN_BITS_PER_WEIGHT;
		ga.Setup(mse, individualSize, *this);
		//_____________________________Copy Best individual
		k = 0;
		for(i = 0; i<rowsHid1; i++)
		{
			for(j = 0; j < colsHid1; j++)
			{
				ga.bestIndividual.bits.SetInt16(k++, (int)(NN_WEIGHT_RES*layerHid1.weight[i][j]/NN_LAYERNET_WEIGHTMAX));
			}
		}
		for(i = 0; i<rowsHid2; i++)
		{
			for(j = 0; j < colsHid2; j++)
			{
				ga.bestIndividual.bits.SetInt16(k++, (int)(NN_WEIGHT_RES*layerHid2.weight[i][j]/NN_LAYERNET_WEIGHTMAX));
			}
		}
		//____________________________ 
		ga.ThreadFunc(running, progress, resetTime);
		mse.Set(ComputeCurrentTrueMse());
		SvdDelete();
	}
	return 0;
}

wchar_t* LayerNet::TrainSimAnneal(Mt::BoolTs& running, Mt::DoubleTs& progress, Mt::DoubleTs& mse, Math::SimAnnealParam& param)
{
	if (hasTrainSet == false) return L"The training set is missing.  Call net.SetTrainingSet()";
	const int layerCount = GetLayerCount();
	Mt::BoolTs resetTime;

	Math::SimulatedAnnealing sa;
	sa.numTemps = param.numTemps;
	sa.numIterations = param.numIterations;
	sa.initialTemp = param.initialTemp;
	sa.finalTemp = param.finalTemp;
	sa.isCoolingScheduleLinear = param.isCoolingScheduleLinear;
	sa.cycles = param.cycles;
	sa.goal = param.goal;

	Nn::LayerNet work1, work2;
	if (work1.Create(this->GetInputCount(), this->GetHidden1NeuronCount(), this->GetHidden2NeuronCount(), this->GetOutputCount()) == false)
	{
		return L"No enough memory to train using Simulated Annealing";
	}
	if (work2.Create(this->GetInputCount(), this->GetHidden1NeuronCount(), this->GetHidden2NeuronCount(), this->GetOutputCount()) == false)
	{
		return L"No enough memory to train using Simulated Annealing";
	}
	sa.SetStopWhenDone(false);
	sa.Setup(mse, *this, work1, work2);

	if (layerCount == 2)
	{
		sa.ThreadFunc(running, progress, resetTime);
	}
	else if (layerCount == 3)
	{
		SvdCreate();
		sa.ThreadFunc(running, progress, resetTime);
		SvdDelete();
	}
	else if (layerCount == 4)
	{
		SvdCreate();
		sa.ThreadFunc(running, progress, resetTime);
		SvdDelete();
	}
	mse.Set(ComputeCurrentTrueMse());
	return NULL;
}

wchar_t* LayerNet::TrainConjugateGradient(Mt::BoolTs& running, Mt::DoubleTs& progress, Mt::DoubleTs& mse, int epochs, double goal)
{
	return TrainCGVM(running, progress, mse, epochs, goal, WT_MATH_CONJGRAD);
}

wchar_t* LayerNet::TrainVariableMetric(Mt::BoolTs& running, Mt::DoubleTs& progress, Mt::DoubleTs& mse, int epochs, double goal)
{
	return TrainCGVM(running, progress, mse, epochs, goal, WT_MATH_VARMETRIC);
}

wchar_t * LayerNet::TrainCGVM(Mt::BoolTs& running, Mt::DoubleTs& progress, Mt::DoubleTs& mse, int epochs, double goal, int method)
{
	if (hasTrainSet == false) return L"The training set is missing.  Call SetTrainingSet()";
	if (DeltaCreate() == false) return L"No enough memory";
	const int layerCount = GetLayerCount();
	Mt::BoolTs resetTime;
	const int weightCount = GetWeightCount();
	valarray<double> x(weightCount);
	this->CopyThisToPoint(x);

	Math::FindMinimumMV fmmv;
	fmmv.Setup(mse, *this, x, epochs, goal, method);
	fmmv.SetStopWhenDone(false);
	fmmv.ThreadFunc(running, progress, resetTime);
	mse.Set(ComputeCurrentTrueMse());

	DeltaDelete();
	return NULL;
}

wchar_t* LayerNet::TrainLevenbergMarquardt(Mt::BoolTs& running, Mt::DoubleTs& progress, Mt::DoubleTs& mse, int epochs, double goal, bool stopWhenDone)
{
	if (hasTrainSet == false) return L"The training set is missing.  Call SetTrainingSet()";
	const int numWeights = this->GetWeightCount();

	int i = 0;

	//_____________________________________________________ Allocate singular value decompostion
	MATRIX a, v; // For Singular Value Decomposition
	valarray<double> s;  // For Singular Value Decomposition
	MATRIX hessian;
	valarray<double> b;
	valarray<double> gradient, grad, correction, delta;
	valarray<double> deltaHiddenLayer2;
	const int layerCount = GetLayerCount();
	try
	{
		a.resize(numWeights);
		hessian.resize(numWeights);
		v.resize(numWeights);
		for(i = 0; i < numWeights; i++)
		{
			a[i].resize(numWeights);
			hessian[i].resize(numWeights);
			v[i].resize(numWeights);
		}
		b.resize(numWeights);
		s.resize(numWeights);
		if (layerCount == 4) deltaHiddenLayer2.resize(GetHidden2NeuronCount());
		gradient.resize(numWeights);
		grad.resize(numWeights);
		correction.resize(numWeights);
		delta.resize(numWeights);
	}
	catch (const std::bad_alloc& )
	{
		return L"No enough memory";
	}
	progress.SetTry(0.0);
	double derror = LevenMarComputeHessianAndGradient(deltaHiddenLayer2, gradient, hessian, grad, running);
 
	//______________________________________________________ Initialize lambda
	double lambda = 0.0 ;
	for (i=0 ; i<numWeights; i++) 
	{
		if (hessian[i][i] > lambda) lambda = hessian[i][i];
	}
	lambda += 1.0e-20;
	bool brunning = false;
	if (running.GetTry(brunning))
	{
		if (brunning == false) return NULL;
	}

	const double ftol = 1.0e-7;
	const double reltol = 1.0e-10;
	double improvement = 0.0;
	double maxgrad = 0.0;
	double previousError = derror;
	bool resetAlphaAndBeta = true;
	int numBadIterations = 0;
	int numTrivialImprovements = 0;

	for (int iteration = 1; iteration <= epochs; iteration++)
	{  
		progress.SetTry(100.0*iteration/(double)epochs);
		if (running.GetTry(brunning))
		{
			if (brunning == false) break;
		}
		if (resetAlphaAndBeta)
		{      
			a = hessian;
			b = grad;
		}

		for (i=0; i<numWeights; i++)
		{
			a[i][i] += lambda; 
		}
		//________________________________________________ Solve the system of equations using Singular Value Decomposition
		Math::SingValDecompos::Decompose(a, s, v);
		Math::SingValDecompos::BackSubstitution(a, s, v, b, delta);
		LevenMarMove(1.0, delta);
		derror = LevenMarComputeHessianAndGradient(deltaHiddenLayer2, gradient, a, b, running);
		improvement = (previousError - derror) / previousError;

		if (improvement > 0.0) 
		{
			if (derror <= goal) break; 
			if (2.0*fabs(derror-previousError) <= ftol*(fabs(derror)+fabs(previousError)+1.0e-8)) break;
			previousError = derror;
			mse.SetTry(derror);
			if (improvement < reltol) 
			{
				maxgrad = 0.0 ;
				for (i=0 ; i<numWeights ; i++) 
				{
					if (fabs (b[i])  >  maxgrad) maxgrad = fabs (b[i]);
				}
				if (derror > 1.0) maxgrad /= derror;
				if (maxgrad <= reltol) break;
				numTrivialImprovements++;
				if (numTrivialImprovements == 4) 
				{
					for (i=0; i<numWeights; i++) 
					{
						if (hessian[i][i] > lambda) lambda = hessian[i][i];
					}
				}
				else if (numTrivialImprovements == 10)  //Done
				{
					break;
				}
			}
			else
			{
				numTrivialImprovements = 0 ; // Good improvement
			}
			hessian = a;
			grad = b;
			resetAlphaAndBeta = false;
			numBadIterations = 0;
			lambda *= 0.5;
		}
		else 
		{
			this->LevenMarMove(-1.0, delta);   // Move back
			resetAlphaAndBeta = true;
			lambda *= 2.0; 
			numBadIterations++;
			if (numBadIterations == 4) 
			{ 
				for (i=0 ; i<numWeights ; i++) 
				{	
					if (hessian[i][i] > lambda) lambda = hessian[i][i] ;
				}
			}
			if (numBadIterations == 10)  break;    //Almost impossible to get here     
		}
		if (running.GetTry(brunning))
		{
			if (brunning == false) break;
		}
	}
	if (stopWhenDone) running.Set(false);
	mse.Set(ComputeCurrentTrueMse());

	return NULL;
}

void LayerNet::LevenMarMove(double step, valarray<double>& direction)
{
	const int rows = layerOut.weight.size();
	const int cols = (rows == 0) ? 0: layerOut.weight[0].size();
	const int rowsHid1 = layerHid1.weight.size();
	const int colsHid1 = (rowsHid1 == 0) ? 0: layerHid1.weight[0].size();
	const int rowsHid2 = layerHid2.weight.size();
	const int colsHid2 = (rowsHid2 == 0) ? 0: layerHid2.weight[0].size();
	int r, c, index=0;

	//_________________________________________________ Output Layer
	for(r = 0; r<rows; r++)
	{
		for(c=0; c<cols; c++)
		{
			layerOut.weight[r][c] += direction[index++]*step;
		}
	}
	//_________________________________________________ Hidden 2 Layer
	for(r = 0; r<rowsHid2; r++)
	{
		for(c=0; c<colsHid2; c++)
		{
			layerHid2.weight[r][c] += direction[index++]*step;
		}
	}
	//_________________________________________________ Hidden 1 Layer
	for(r = 0; r<rowsHid1; r++)
	{
		for(c=0; c<colsHid1; c++)
		{
			layerHid1.weight[r][c] += direction[index++]*step;
		}
	}
}

double LayerNet::LevenMarComputeHessianAndGradient(valarray<double>& hid2delta, valarray<double>& grad, MATRIX& hessian, valarray<double>& beta, Mt::BoolTs& running)
{
	const int weightCount = GetWeightCount();
	int i = 0, j = 0;
	beta = 0.0;
	for (i=0 ; i<weightCount ; i++)
	{   
		for (j=0 ; j<=i ; j++)  hessian[i][j] = 0.0 ;// Set to zero only half
	}
	const int rows = trainSetScaledIn.size();
	double error = 0.0, err;
	const int numIn = GetInputCount();
	const int numOut = GetOutputCount();
	const int layerCount = GetLayerCount();
	for (int tset=0; tset<rows; tset++) 
	{ 
		this->ComputeOutput(trainSetScaledIn, tset, layerCount);
		err = 0.0;
		for (i=0 ; i<numOut ; i++)
		{
				err += LevenMar(trainSetScaledIn, tset, i, trainSetScaledTarget[tset][i], hessian, beta, hid2delta, grad);
		}
		if (running.Get() == false) 
		{
			error=9.99e300; //Prevent from taking this solution
			break;
		}
		error += err;
	}

	for (i=1; i<weightCount; i++) //Fill in the uncomputed half of alpha via symmetry.
	{
		for (j=0; j<i; j++) hessian[j][i] = hessian[i][j];
	}
   return error / (double)(rows*numOut); 
}

double LayerNet::LevenMar(MATRIX & input, int inputRow, 
							  int idep, double target, 
							  MATRIX& alpha, valarray<double>& beta, 
							  valarray<double>& hid2delta, valarray<double>& grad)
{
	const int layerCount = GetLayerCount();
	const int numIn = GetInputCount();
	const int numOut = GetOutputCount();
	const int n = alpha.size();

	if (layerCount == 2)
	{	
		const double outdelta = layerOut.OutputDerivative(idep);
		int i, j, index = 0;
		double difference;
	
		for (i=0 ; i<numOut; i++) 
		{
			if (i == idep) 
			{
				for (j=0 ; j<numIn; j++)
				{
					grad[index++] = outdelta * input[inputRow][j];
				}
				grad[index++] = outdelta; 
			}
			else 
			{
				for (j=0; j<numIn; j++)
				{
					grad[index++] = 0.0;
				}
				grad[index++] = 0.0;
			}
		}
		difference = target - layerOut.output[0][idep]; 

		const int weightCount = this->GetWeightCount();
		for (i=0; i<weightCount; i++) 
		{
			beta[i] += difference * grad[i];
			for (j=0; j<=i; j++)
			{
				alpha[i][j] += grad[i] * grad[j];
			}
		}
		return difference*difference;
	}
	else if (layerCount == 3)
	{
		const int numHid1 = GetHidden1NeuronCount();
		int i, j, index = 0;
		double difference, delta;
		const double outdelta = layerOut.OutputDerivative(idep);

		for (i=0 ; i<numOut; i++) 
		{
			if (i == idep) 
			{
				for (j=0 ; j<numHid1; j++) 
				{
					grad[index++] = outdelta * layerHid1.output[0][j];
				}
				grad[index++] = outdelta;
			}
			else 
			{
				for (j=0; j<numHid1; j++)
				{
					grad[index++] = 0.0;
				}
				grad[index++] = 0.0;
			}
		}
	
		//________________________________________________ Hidden 1 Layer
		for (i=0; i<numHid1; i++) 
		{
			delta = outdelta * layerOut.weight[idep][i];
			delta *= layerHid1.OutputDerivative(i);
			for (j=0; j<numIn; j++)
			{
				grad[index++] = delta * input[inputRow][j];
			}
			grad[index++]= delta ;
		}
		difference = target - layerOut.output[0][idep]; 

		for (i=0; i<n; i++) 
		{
			beta[i] += difference * grad[i];
			for (j=0; j<=i; j++)
			{
				alpha[i][j] += grad[i] * grad[j];
			}
		}
		return difference*difference;
	}
	else if (layerCount == 4)
	{
		const int numHid1 = GetHidden1NeuronCount();
		const int numHid2 = GetHidden2NeuronCount();
		
		int i, j, index = 0;
		double difference, delta;
		const double outdelta = layerOut.OutputDerivative(idep);

		for (i=0 ; i<numOut; i++) 
		{
			if (i == idep) 
			{
				for (j=0 ; j<numHid2; j++)
				{
					grad[index++] = outdelta * layerHid2.output[0][j];
				}
				grad[index++] = outdelta; 
			}
			else 
			{
				for (j=0; j<numHid2; j++)
				{
					grad[index++] = 0.0;
				}
				grad[index++] = 0.0;
			}
		}

		//________________________________________________________ Hidden 2 Layer
		for (i=0 ; i<numHid2 ; i++) 
		{
			delta = outdelta * layerOut.weight[idep][i];
			delta *= layerHid2.OutputDerivative(i);
			hid2delta[i] = delta ;
			for (j=0 ; j<numHid1 ; j++)
			{
				grad[index++]  = delta * layerHid1.output[0][j];
			}
			grad[index++] = delta ; 
		}

		//________________________________________________________ Hidden 1 Layer
		for (i=0 ; i<numHid1; i++) 
		{
			delta = 0.0;
			for (j=0; j<numHid2; j++)
			{
				delta += hid2delta[j] * layerHid2.weight[j][i];
			}
			delta *= layerHid1.OutputDerivative(i);
			for (j=0; j<numIn; j++)
			{
				grad[index++] = delta * input[inputRow][j];
			}
			grad[index++] = delta ;
		}
		difference = target - layerOut.output[0][idep];

		for (i=0; i<n; i++) 
		{
			beta[i] += difference * grad[i];
			for (j=0; j<=i; j++) alpha[i][j] += grad[i] * grad[j];
		}
		return difference*difference;
	}
	return 9.99e300;
}

wchar_t* LayerNet::TrainRegression(Mt::BoolTs& running, Mt::DoubleTs& progress, Mt::DoubleTs& mse)
{
	if (hasTrainSet == false) return L"The training set is missing.  Call SetTrainingSet()";
	const int layerCount = GetLayerCount();
	if (layerCount != 2) return L"The number of hidden layers must be zero to use regression for training";
	const int numTrainCases = trainSetScaledIn.size();
	const int numOutputs = GetOutputCount();
	const int numInputs = GetInputCount();
	bool isRunning = false;
	int i, j;
	MATRIX a, v, y;
	valarray<double> s;

	if (Math::Oper::CreateMatrix(y, numOutputs, numTrainCases) == false) return L"No enough memory";
	if (Math::Oper::CreateMatrix(a, numTrainCases, numInputs+1) == false) return L"No enough memory";

	//__________________________________________________________  Expected y'
	for(i = 0; i<numOutputs; i++)
	{
		for(j = 0; j<numTrainCases; j++)
		{
			y[i][j] = Nn::Tanh::InverseFunc(trainSetScaledTarget[j][i]); // y = transposed(inv_tanh(trainSetScaledTarget))
		}
	}

	//______________________________________________ Is still running?
	if (running.GetTry(isRunning))
	{
		if (isRunning == false) return L"Stopped by the user";
	}

	//_________________________________________________________  A = [X 1]
	for(i = 0; i<numTrainCases; i++)
	{
		for(j = 0; j<numInputs+1; j++)
		{
			if (j == numInputs) // Last column
			{
				a[i][j] = 1.0;
			}
			else
			{
				a[i][j] = trainSetScaledIn[i][j];
			}
		}
	}

	//______________________________________________ Is still running?
	if (running.GetTry(isRunning))
	{
		if (isRunning == false) return L"Stopped by the user";
	}

	wchar_t* error = NULL;
	error = Math::SingValDecompos::Decompose(a, s, v);
	if (error ) return error;

	//______________________________________________ Is still running?
	if (running.GetTry(isRunning))
	{
		if (isRunning == false) return L"Stopped by the user";
	}

	for(i=0; i<numOutputs; i++)
	{
		Math::SingValDecompos::BackSubstitution(a, s, v, y[i], layerOut.weight[i]);
	}
	mse.Set(ComputeCurrentTrueMse());
	return NULL;
}

int LayerNet::GetWeightCount() const
{
	const int layerCount = GetLayerCount();
	int count = 0;
	int rows, cols;
	if (layerCount >= 2)
	{
		rows = layerOut.weight.size();
		cols = (rows == 0) ? 0 : layerOut.weight[0].size();
		count += (rows*cols);
	}
	if (layerCount >= 3)
	{
		rows = layerHid1.weight.size();
		cols = (rows == 0) ? 0 : layerHid1.weight[0].size();
		count += (rows*cols);
	}
	if (layerCount >= 4)
	{
		rows = layerHid2.weight.size();
		cols = (rows == 0) ? 0 : layerHid2.weight[0].size();
		count += (rows*cols);
	}

	return count;
}

bool LayerNet::Run(const MATRIX& input, MATRIX& output)
{
	const int rows = input.size();
	const int cols = (rows == 0) ? 0 : input[0].size();
	if (cols != GetInputCount()) return false;
	MATRIX scaledInput;
	scalerInput.ScaleToStandardRange(input, scaledInput);
	const int layerCount = GetLayerCount();
	const int outputCount = GetOutputCount();
	//______________________________ Create the output matrix
	try
	{
		output.resize(rows);
	
		for(int i = 0; i<rows; i++)
		{
			ComputeOutput(scaledInput, i, layerCount);  // it updates layerOut.output[0]
			output[i].resize(outputCount);
			scalerOutput.ScaleFromStandardRange(layerOut.output[0], output[i]);
		}
	}
	catch(const std::bad_alloc& )
	{
		return false;
	}
	return true;
}

void LayerNet::ComputeOutput(const MATRIX& input, int inputRowIndex, int layerCount)
{
	switch(layerCount)
	{
	case 2:
		layerOut.ComputeOutput(input, inputRowIndex); //it updates layerOut.output
		break;
	case 3:
		layerHid1.ComputeOutput(input, inputRowIndex);
		layerOut.ComputeOutput(layerHid1.output, 0); //it updates layerOut.output
		break;
	case 4:
		layerHid1.ComputeOutput(input, inputRowIndex);
		layerHid2.ComputeOutput(layerHid1.output, 0);
		layerOut.ComputeOutput(layerHid2.output, 0); //it updates layerOut.output
		break;
	}
}

void LayerNet::SimAnnealInitialize()
{
	layerHid1.Initialize();
	layerHid2.Initialize();
	layerOut.Initialize();
}

void LayerNet::SimAnnealPerturb(Math::ISimAnneal& original, double temperature, double initialTemperature)
{
	const double pertubRatio = temperature/initialTemperature;
	const int layerCount = GetLayerCount();
	if (layerCount == 2)
	{
		layerOut.Agitate(pertubRatio, ((Nn::LayerNet&)original).layerOut);
	}
	else if (layerCount == 3)
	{
		layerHid1.Agitate(pertubRatio, ((Nn::LayerNet&)original).layerHid1);
		//__________________ LayerOut is not perturbed as Regression is used at the output level
	}
	else if (layerCount == 4)
	{
		layerHid1.Agitate(pertubRatio, ((Nn::LayerNet&)original).layerHid1);
		layerHid2.Agitate(pertubRatio, ((Nn::LayerNet&)original).layerHid2);
		//__________________ LayerOut is not perturbed as Regression is used at the output level
	}	
}

double LayerNet::SimAnnealGetError()
{
	const int layerCount = GetLayerCount();
	const int rows = trainSetScaledIn.size();
	const int outputCount = GetOutputCount();
	const int numHid1 = GetHidden1NeuronCount();
	const int numHid2 = GetHidden2NeuronCount();
	int i, j;
	double mse = 0.0;
	double diff  = 0.0;

	if (layerCount == 2)
	{
		for(i = 0; i<rows; i++)
		{
			layerOut.ComputeOutput(trainSetScaledIn, i); //it updates layerOut.output
			for(j = 0; j < outputCount; j++)
			{
				diff = layerOut.output[0][j] - trainSetScaledTarget[i][j];
				mse += diff * diff;
			}
		}
		return mse/(rows*outputCount);
	}
	else if (layerCount == 3)
	{
		//______________________________________________________ A = [X 1]
		for(i = 0; i<rows; i++)
		{
			layerHid1.ComputeOutput(trainSetScaledIn, i);	
			for(j = 0; j<numHid1+1; j++)
			{
				if (j == numHid1) // Last column
				{
					svd_a[i][j] = 1.0;
				}
				else
				{
					svd_a[i][j] = layerHid1.output[0][j];
				}
			}
		}
		//______________________________________________________ Compute Ouput Weights using SVD
		Math::SingValDecompos::Decompose(svd_a, svd_u, svd_s, svd_v);
		for(i=0; i<outputCount; i++)
		{
			Math::SingValDecompos::BackSubstitution(svd_u, svd_s, svd_v, svd_y[i], layerOut.weight[i]);
		}
		//_____________________________________________________ Compute mse
		for(i = 0; i<rows; i++)
		{
			//layerHid1.ComputeOutput(trainSetScaledIn, i);	
			//layerOut.ComputeOutput(layerHid1.output, 0); //it updates layerOut.output
			layerOut.ComputeOutput(svd_a, i); // Instead of computing the activation again, we use svd_a
			for(j = 0; j < outputCount; j++)
			{
				diff = layerOut.output[0][j] - trainSetScaledTarget[i][j];
				mse += diff * diff;
			}
		}
		return mse/(rows*outputCount);
	}
	else if (layerCount == 4)
	{
		for(i = 0; i<rows; i++)
		{
			layerHid1.ComputeOutput(trainSetScaledIn, i);
			layerHid2.ComputeOutput(layerHid1.output, 0);
			//_____________________________________________________ A = [X 1]
			for(j = 0; j<numHid2+1; j++)
			{
				if (j == numHid2) // Last column
				{
					svd_a[i][j] = 1.0;
				}
				else
				{
					svd_a[i][j] = layerHid2.output[0][j];
				}
			}
		}
		//______________________________________________________ Compute Ouput Weights using SVD
		Math::SingValDecompos::Decompose(svd_a, svd_u, svd_s, svd_v);
		for(i=0; i<outputCount; i++)
		{
			Math::SingValDecompos::BackSubstitution(svd_u, svd_s, svd_v, svd_y[i], layerOut.weight[i]);
		}
		//_____________________________________________________ Compute mse
		for(i = 0; i<rows; i++)
		{
			//layerHid1.ComputeOutput(trainSetScaledIn, i);	
			//layerHid2.ComputeOutput(layerHid1.output, 0);	
			//layerOut.ComputeOutput(layerHid2.output, 0); //it updates layerOut.output
			layerOut.ComputeOutput(svd_a, i); // Instead of computing the activation again, we use svd_a
			for(j = 0; j < outputCount; j++)
			{
				diff = layerOut.output[0][j] - trainSetScaledTarget[i][j];
				mse += diff * diff;
			}
		}
		return mse/(rows*outputCount);
	}	
	return 9.99e300;
}

void LayerNet::SimAnnealCopy(const Math::ISimAnneal& source)
{
	Nn::LayerNet& net_source((Nn::LayerNet&)source);
	const int layerCount = GetLayerCount();

	if (layerCount == 2)
	{
		this->layerOut = net_source.layerOut;
	}
	else if (layerCount == 3)
	{
		this->layerHid1 = net_source.layerHid1;
		this->layerOut = net_source.layerOut;
	}
	else if (layerCount == 4)
	{
		this->layerHid1 = net_source.layerHid1;
		this->layerHid2 = net_source.layerHid2;
		this->layerOut = net_source.layerOut;
	}	
}

void LayerNet::GeneticInitialize(Sys::BoolArray& bits)
{
	const int bitCount = bits.GetCount();
	const int weightCount = bitCount / NN_BITS_PER_WEIGHT; 
	std::tr1::uniform_real<double> dis(-NN_LAYERNET_WEIGHTMAX, NN_LAYERNET_WEIGHTMAX);
	int i;
	__int16 value;
	double weight = 0.0;
	for(i = 0; i < weightCount; i++)
	{
		weight = dis(Math::Statistics::random_generator);
		value = (__int16)(NN_WEIGHT_RES*weight/NN_LAYERNET_WEIGHTMAX);
		bits.SetInt16(i, value);
	}
}

double LayerNet::GeneticGetError(const Sys::BoolArray& bits)
{
	GeneticCopyFromBits(bits);
	return SimAnnealGetError();
}

void LayerNet::GeneticReportBestIndividual(const Sys::BoolArray& bits)
{
	GeneticCopyFromBits(bits);
	SimAnnealGetError(); // To compute the output weights using SVD at the end of the algorithm
}

void LayerNet::GeneticCopyFromBits(const Sys::BoolArray& bits)
{
	const int layerCount = GetLayerCount();
	int i, j, k = 0;

	if (layerCount == 2)
	{
		const int rows = this->layerOut.weight.size();
		const int cols = (rows == 0) ? 0 : layerOut.weight[0].size();
		//__________________________________________________________ Output
		for(i = 0; i < rows; i++)
		{
			for(j = 0; j < cols; j++)
			{
				layerOut.weight[i][j] = NN_LAYERNET_WEIGHTMAX *bits.GetInt16(k++)/(double)NN_WEIGHT_RES;
			}
		}
	}
	else if (layerCount == 3)
	{
		const int rowsHid1 = layerHid1.weight.size();
		const int colsHid1 = (rowsHid1 == 0) ? 0 : layerHid1.weight[0].size();
		//_________________________________________________________ Hidden 1
		for(i = 0; i < rowsHid1; i++)
		{
			for(j = 0; j < colsHid1; j++)
			{
				layerHid1.weight[i][j] = NN_LAYERNET_WEIGHTMAX *bits.GetInt16(k++)/(double)NN_WEIGHT_RES;
			}
		}
	}
	else if (layerCount == 4)
	{
		const int rowsHid1 = layerHid1.weight.size();
		const int colsHid1 = (rowsHid1 == 0) ? 0 : layerHid1.weight[0].size();
		const int rowsHid2 = layerHid2.weight.size();
		const int colsHid2 = (rowsHid2 == 0) ? 0 : layerHid2.weight[0].size();
		//_________________________________________________________ Hidden 1
		for(i = 0; i < rowsHid1; i++)
		{
			for(j = 0; j < colsHid1; j++)
			{
				layerHid1.weight[i][j] = NN_LAYERNET_WEIGHTMAX *bits.GetInt16(k++)/(double)NN_WEIGHT_RES;
			}
		}
		//_________________________________________________________ Hidden 2
		for(i = 0; i < rowsHid2; i++)
		{
			for(j = 0; j < colsHid2; j++)
			{
				layerHid2.weight[i][j] = NN_LAYERNET_WEIGHTMAX *bits.GetInt16(k++)/(double)NN_WEIGHT_RES;
			}
		}
	}	
}

double LayerNet::ComputeCurrentTrueMse()
{
	MATRIX trainSet_target;

	wchar_t * error = NULL;

	//_____________________________________ De Scaled the training set output
	error = scalerOutput.ScaleFromStandardRange(trainSetScaledTarget, trainSet_target);
	if (error != NULL) return -1.0;
	//
	const int layerCount = GetLayerCount();
	const int rows = trainSetScaledIn.size();
	const int outputCount = GetOutputCount();
	valarray<double> output;
	try
	{
		output.resize(outputCount);
	}
	catch(std::bad_alloc& )
	{
		return -1.0;
	}

	int i, j;
	double mse = 0.0;
	double diff  = 0.0;

	if (layerCount == 2)
	{
		//__________________________________________ Compute and scale the network output
		for(i = 0; i<rows; i++)
		{
			layerOut.ComputeOutput(trainSetScaledIn, i); //it updates layerOut.output
			error = scalerOutput.ScaleFromStandardRange(layerOut.output[0], output);
			if (error != NULL) return -1.0;
			for(j = 0; j < outputCount; j++)
			{
				diff = trainSet_target[i][j] - output[j];
				mse += diff * diff;
			}
		}
	}
	else if (layerCount == 3)
	{
		for(i = 0; i<rows; i++)
		{
			layerHid1.ComputeOutput(trainSetScaledIn, i);
			layerOut.ComputeOutput(layerHid1.output, 0); //it updates layerOut.output
			error = scalerOutput.ScaleFromStandardRange(layerOut.output[0], output);
			if (error != NULL) return -1.0;
			for(j = 0; j < outputCount; j++)
			{
				diff = trainSet_target[i][j] - output[j];
				mse += diff * diff;
			}
		}
	}
	else if (layerCount == 4)
	{
		for(i = 0; i<rows; i++)
		{
			layerHid1.ComputeOutput(trainSetScaledIn, i);
			layerHid2.ComputeOutput(layerHid1.output, 0);
			layerOut.ComputeOutput(layerHid2.output, 0); //it updates layerOut.output
			error = scalerOutput.ScaleFromStandardRange(layerOut.output[0], output);
			if (error != NULL) return -1.0;
			for(j = 0; j < outputCount; j++)
			{
				diff = trainSet_target[i][j] - output[j];
				mse += diff * diff;
			}
		}
	}	
	else
	{
		return -1.0;
	}
	return mse/(rows*outputCount);
}

double LayerNet::ComputeTrueMse(const MATRIX& trainSet_in, const MATRIX& trainSet_target)
{
	wchar_t * error = NULL;

	//_____________________________________ Scaled the training set input
	error = scalerInput.ScaleToStandardRange(trainSet_in, trainSetScaledIn);
	if (error != NULL) return -1.0;

	const int layerCount = GetLayerCount();
	const int rows = trainSetScaledIn.size();
	const int outputCount = GetOutputCount();
	valarray<double> output;
	try
	{
		output.resize(outputCount);
	}
	catch(std::bad_alloc& )
	{
		return -1.0;
	}

	int i, j;
	double mse = 0.0;
	double diff  = 0.0;

	if (layerCount == 2)
	{
		//__________________________________________ Compute and scale the network output
		for(i = 0; i<rows; i++)
		{
			layerOut.ComputeOutput(trainSetScaledIn, i); //it updates layerOut.output
			error = scalerOutput.ScaleFromStandardRange(layerOut.output[0], output);
			if (error != NULL) return -1.0;
			for(j = 0; j < outputCount; j++)
			{
				diff = trainSet_target[i][j] - output[j];
				mse += diff * diff;
			}
		}
	}
	else if (layerCount == 3)
	{
		for(i = 0; i<rows; i++)
		{
			layerHid1.ComputeOutput(trainSetScaledIn, i);
			layerOut.ComputeOutput(layerHid1.output, 0); //it updates layerOut.output
			error = scalerOutput.ScaleFromStandardRange(layerOut.output[0], output);
			if (error != NULL) return -1.0;
			for(j = 0; j < outputCount; j++)
			{
				diff = trainSet_target[i][j] - output[j];
				mse += diff * diff;
			}
		}
	}
	else if (layerCount == 4)
	{
		for(i = 0; i<rows; i++)
		{
			layerHid1.ComputeOutput(trainSetScaledIn, i);
			layerHid2.ComputeOutput(layerHid1.output, 0);
			layerOut.ComputeOutput(layerHid2.output, 0); //it updates layerOut.output
			error = scalerOutput.ScaleFromStandardRange(layerOut.output[0], output);
			if (error != NULL) return -1.0;
			for(j = 0; j < outputCount; j++)
			{
				diff = trainSet_target[i][j] - output[j];
				mse += diff * diff;
			}
		}
	}	
	else
	{
		return -1.0;
	}
	return mse/(rows*outputCount);
}

//_____________________________________________________________________ KohoNet
KohoNet::KohoNet()
{
	Constructor();
}

KohoNet::~KohoNet()
{
}

KohoNet::KohoNet(const KohoNet& init)
{
	Constructor();
	Copy(init);
}

KohoNet& KohoNet::operator=(const KohoNet& init)
{
	Delete();
	Copy(init);
	return *this;
}

bool KohoNet::Create(int numInputs, int numOutputs)
{
	return true;
}

void KohoNet::Copy(const KohoNet &init)
{
	//if (init.m_pElements)
	//{
	//	this->SetSize(init.m_size);
	//	CopyMemory(m_pElements, init.m_pElements, m_size*sizeof(double));
	//}
}

void KohoNet::Constructor()
{
}

void KohoNet::Delete()
{
}

void KohoNet::GetDescription(wchar_t* description, int length)
{
	_snwprintf_s(description, length, _TRUNCATE, L"(%d)", 1);
}

//_____________________________________________________________________ ProbNet
ProbNet::ProbNet()
{
	Constructor();
}

ProbNet::~ProbNet()
{
}

ProbNet::ProbNet(const ProbNet& init)
{
	Constructor();
	Copy(init);
}

ProbNet& ProbNet::operator=(const ProbNet& init)
{
	Delete();
	Copy(init);
	return *this;
}

void ProbNet::Copy(const ProbNet &init)
{
	//if (init.m_pElements)
	//{
	//	this->SetSize(init.m_size);
	//	CopyMemory(m_pElements, init.m_pElements, m_size*sizeof(double));
	//}
}

void ProbNet::Constructor()
{
}

void ProbNet::Delete()
{
}

void ProbNet::GetDescription(wchar_t* description, int length)
{
	_snwprintf_s(description, length, _TRUNCATE, L"(%d)", 1);
}


}//________________________________________ namespace Nn::End

namespace Cpl //________________________________________ namespace Cpl::Ini
{
//_____________________________________________________________________ LexicalAnalyzer
LexicalAnalyzer::LexicalAnalyzer(void)
{
	inputString = NULL;
	index = 0;
	length = 0;
}

LexicalAnalyzer::~LexicalAnalyzer(void)
{
	Destroy();
}

void LexicalAnalyzer::Destroy()
{
	if (this->inputString) delete [] this->inputString;
	this->inputString = NULL;
	index = 0;
	length = 0;
	line_number = 1;
}

bool LexicalAnalyzer::Create(const wchar_t* inputString)
{
	Destroy();
	if (inputString==NULL) return true;
	this->length = wcslen(inputString)+1;
	this->inputString = new wchar_t[length];
	if (this->inputString==NULL) return false;
	_snwprintf_s(this->inputString, length, _TRUNCATE, L"%s", inputString);
	//___Replace \r with spaces to be sure to get \n only
	for(register int i = 0; i<(int)this->length; i++) 
	{
		if (this->inputString[i] == '\r') this->inputString[i] = ' ';
	}
	return true;
}

bool LexicalAnalyzer::Create(HWND hWnd)
{
	Destroy();
	this->length = ::GetWindowTextLength(hWnd) + 1;
	if (length <= 1) return false;
	this->inputString = new wchar_t[length];
	if (this->inputString==NULL) return false;
	::GetWindowText(hWnd, this->inputString, this->length);
	//___Replace \r with spaces to be sure to get \n only
	for(register int i = 0; i<(int)this->length; i++)
	{
		if (this->inputString[i] == '\r') this->inputString[i] = ' ';
	}
	return true;
}

bool LexicalAnalyzer::IsError(LexicalAnalyzer::Token& token)
{
	if (token.type == LEX_ERROR_UNRECOGNIZED_CHAR) return true;
	if (token.type == LEX_ERROR_STRING_TOO_LONG) return true;
	if (token.type == LEX_ERROR_MISSING_COMMENT_TERMINATOR) return true;
	if (token.type == LEX_ERROR_MISSING_STRING_TERMINATOR) return true;
	return false;
}

void LexicalAnalyzer::ExtractInt(wchar_t& c, int& index, int &i, Cpl::LexicalAnalyzer::Token& token)
{
	while(iswdigit(c))
	{
		token.string_value[i]=c;
		i++;
		if (i>=LEX_STRINGMAX)
		{
			token.type = LEX_ERROR_STRING_TOO_LONG ;
			token.line_number = line_number;
			token.string_value[i-1] = '\0';
			return;
		}
		c = inputString[index++];
	}
	index--;
}

void LexicalAnalyzer::GetNextText(wchar_t* buffer, int buffer_len)
{
	buffer[0] = '\0';
	const int new_len = length - index + 1;
	const int min_len = (new_len < buffer_len) ? new_len : buffer_len;
	for(int i = 0; i<min_len; i++)
	{
		buffer[i] = inputString[index+i];
		if (Sys::TextAssistant::IsSeparator(buffer[i]) == true)
		{
			buffer[i] = '\0';
			return;
		}
	}
}

bool LexicalAnalyzer::ProcessComments(wchar_t& c, wchar_t& prev, LexicalAnalyzer::Token& token, int& i)
{
	if (c != '/') return false;

	c = inputString[index++];
	if (c=='/')  //_______________________ single line comments
	{
		while(c!='\n' && c!='\0')
		{
			c = inputString[index++];
		}
	}
	else if (c=='*')//___________________ multi-line comments
	{
		do
		{
			c = inputString[index++];
			prev = c;
			if (c == '\0') break;
			if (c == '\n') line_number++; //update line number
			if (c == '*')
			{
				c = inputString[index++];
				if (c=='\0')
				{
					token.type = LEX_ERROR_MISSING_COMMENT_TERMINATOR ;
					token.line_number = line_number;
					token.string_value[i] = '\0';
					_snwprintf_s(token.string_value, LEX_STRINGMAX, _TRUNCATE, L"Missing comment terminator in line %d", line_number);
					index--;
					return true;
				}
				if (c=='\n') line_number++; //update line number			
			}
		}
		while(prev != '*' || c != '/'); // NOT (prev == '*' && c =='/')
		c = inputString[index++]; // Advance /
	}
	else
	{
		//_____________________________________ It is not a comment
		index-=2;
		c = inputString[index++];
	}
	return false;
}

void LexicalAnalyzer::GetNextToken(Cpl::LexicalAnalyzer::Token& token)
{
	int i=0;
	wchar_t* text = NULL;
	wchar_t prev;
	wchar_t c;
	bool isSequenceEscape = false;
	//___________________ clear token
	token.type = LEX_ERROR_UNRECOGNIZED_CHAR ;
	token.int_value = 0;
	token.double_value = 0.0;
	token.string_value[0]='\0';
	token.line_number = line_number;

	//_________________________ Have we reached the end of the file?
	if (index >= (int)length)
	{
		token.type = LEX_END_OF_FILE;
		token.line_number = line_number;
		token.string_value[i] = '\0';
		return;
	}
	//_________________________ find the token
	while(true)
	{
		c = inputString[index++];
		if (ProcessComments(c, prev, token, i) == true) return;

		if (c==' ' || c=='\t') //________________strip out white space
		{
			continue;
		}
		else if (c=='\n') //_________________ update line number
		{
			line_number++;
		}
		else if (c=='"') //_________________ const string
		{
			isSequenceEscape = false;
			i = 0;
			c = inputString[index++];
			if (c=='"') // empty string
			{
				token.type = LEX_CONST_VALUE_STRING;
				token.line_number = line_number;
				token.string_value[0] = '\0';
				c = inputString[index++]; // Closing "
				return;
			}
			if (c == '\\') 
			{
				c = inputString[index++];
				isSequenceEscape = true;
			}
			else
			{
				isSequenceEscape = false;
			}
			if (c == '\0')
			{
				token.type = LEX_END_OF_FILE;
				token.line_number = line_number;
				token.string_value[0] = '\0';
				return;
			}
			do
			{
				token.string_value[i]=c;
				i++;
				if (i>=LEX_STRINGMAX)
				{
					token.type = LEX_ERROR_STRING_TOO_LONG;
					token.line_number = line_number;
					token.string_value[i-1] = '\0';
					//_snwprintf_s(token.string_value, LEX_STRINGMAX, _TRUNCATE, L"String too long in line %d", line_number);
					//___________ discard rest of the string and return
					do
					{
						c = inputString[index++];
						if (c=='\n') line_number++; //update line number	
						if (c == '\\') 
						{
							c = inputString[index++];
							if (c=='\n') line_number++; //update line number	
							isSequenceEscape = true;
						}
						else
						{
							isSequenceEscape = false;
						}
					}
					while((c != '"' || isSequenceEscape == true) && c != '\0'); // NOT (c == '"' && isSequenceEscape==false) || c == '\0'
					return;
				}
				c = inputString[index++];
				if (c=='\n') line_number++; //update line number	
				if (c == '\\') 
				{
					c = inputString[index++];
					if (c=='\n') line_number++; //update line number	
					isSequenceEscape = true;
				}
				else
				{
					isSequenceEscape = false;
				}
			}
			while((c != '"' || isSequenceEscape == true) && c != '\0'); // NOT (c == '"' && isSequenceEscape==false) || c == '\0'
			token.type = LEX_CONST_VALUE_STRING;
			token.line_number = line_number;
			token.string_value[i] = '\0';
			if (c == '\0') index--;
			return;
		}
		else if (iswdigit(c)) //_________________  it is a digit
		{
			i = 0;
			while(iswdigit(c))
			{
				token.string_value[i]=c;
				i++;
				if (i>=LEX_STRINGMAX)
				{
					token.type = LEX_ERROR_STRING_TOO_LONG ;
					token.line_number = line_number;
					token.string_value[i-1] = '\0';
					//_snwprintf_s(token.string_value, LEX_STRINGMAX, _TRUNCATE, L"String too long in line %d", line_number);
					return;
				}
				c = inputString[index++];
			}
			if (c=='.') //_______________________ const double
			{
				token.string_value[i]=c;
				i++;
				c = inputString[index++];
				if (c == 'e' || c == 'E')
				{
					token.string_value[i]=c;
					i++;
					c = inputString[index++];
					if (c == '-')
					{
						token.string_value[i]=c;
						i++;
						c = inputString[index++];
					}
					ExtractInt(c, index, i, token);
					token.string_value[i]='\0';
					token.type = LEX_CONST_VALUE_DOUBLE;
					token.double_value = _wtof(token.string_value);
					token.int_value = (int)token.double_value;
					token.line_number = line_number;
					return;
				}
				else
				{
					//___________________________________________ a floating value without E
					ExtractInt(c, index, i, token);
					c = inputString[index++];
					if (c == 'e' || c == 'E')
					{
						token.string_value[i]=c;
						i++;
						c = inputString[index++];
						if (c == '-')
						{
							token.string_value[i]=c;
							i++;
							c = inputString[index++];
						}
						ExtractInt(c, index, i, token);
						token.string_value[i]='\0';
						token.type = LEX_CONST_VALUE_DOUBLE;
						token.double_value = _wtof(token.string_value);
						token.int_value = (int)token.double_value;
						token.line_number = line_number;
						return;
					}
					token.string_value[i]=c;
					i++;
					index--;
					token.string_value[i-1]='\0';
					token.type = LEX_CONST_VALUE_DOUBLE;
					token.double_value = _wtof(token.string_value);
					token.int_value = (int)token.double_value;
					token.line_number = line_number;
					return;
				}
			}
			else //___________________________ const integer
			{
				index--;
				token.string_value[i]='\0';
				token.type = LEX_CONST_VALUE_INTEGER;
				token.int_value = _wtoi(token.string_value);
				token.double_value = token.int_value;
				token.line_number = line_number;
				return;
			}
		}
		else if (iswalnum(c) || c == '_') //_________________ it is a letter
		{
			int b=0;
			i = 0;
			do
			{
				token.string_value[i]=c;
				i++;
				c = inputString[index++];
				b++;
				if (b>=LEX_STRINGMAX)
				{
					token.type = LEX_ERROR_STRING_TOO_LONG ;
					token.line_number = line_number;
					token.string_value[b]='\0';
					//_snwprintf_s(token.string_value, LEX_STRINGMAX, _TRUNCATE, L"String too long in line %d", line_number);
					return;
				}
			}
			while(iswalnum(c) || c == '0' || c == '1' || c == '2' || c == '3' || c == '4' || c == '5' || c == '6' || c == '7' || c == '8' || c == '9' || c == '_');
			token.string_value[i]='\0';
			index--;
			//if (c != '\0') index--; 

			if (ProcessKeywords(token) == true) return;

			//______________________________________ is bool value (true or false)?
			if (wcscmp(token.string_value, L"true") == 0)
			{
				token.type = LEX_CONST_VALUE_BOOL;
				token.int_value = 1;
				token.double_value = 1.0;
				token.line_number = line_number;
				return;
			}
			if (wcscmp(token.string_value, L"false") == 0)
			{
				token.type = LEX_CONST_VALUE_BOOL;
				token.int_value = 0;
				token.double_value = 0.0;
				token.line_number = line_number;
				return;
			}
			token.type = LEX_ID;
			token.line_number = line_number;
			return;
		}
		else if (CheckToken(token, c, '>', '=', LEX_IS_BIGGER_EQ)) return;
		else if (CheckToken(token, c, '<', '=', LEX_IS_LESS_EQ)) return;
		else if (CheckToken(token, c, '=', '=', LEX_IS_EQUAL)) return;
		else if (CheckToken(token, c, '!', '=', LEX_IS_DIFFERENT)) return;
		else if (CheckToken(token, c, '|', '|', LEX_OR)) return;
		else if (CheckToken(token, c, '&', '&', LEX_AND)) return;
		else if (CheckToken(token, c, '+', '+', LEX_PLUS_PLUS)) return;
		else if (CheckToken(token, c, '-', '-', LEX_MINUS_MINUS)) return;
		else if (CheckToken(token, c, '+', '=', LEX_PLUS_EQUAL)) return;
		else if (CheckToken(token, c, '-', '=', LEX_MINUS_EQUAL)) return;
		else if (CheckToken(token, c, '*', '=', LEX_PRODUCT_EQUAL)) return;
		else if (CheckToken(token, c, '/', '=', LEX_DIVISION_EQUAL)) return;
		else if (CheckToken(token, c, '-', '>', LEX_POINTER_ARROW)) return;
		else if (CheckToken(token, c, '|', LEX_BROKEN_BAR)) return;
		else if (CheckToken(token, c, '&', LEX_AMPERSAND)) return;
		else if (CheckToken(token, c, '(', LEX_LEFT_PARENTHESIS)) return;
		else if (CheckToken(token, c, ')', LEX_RIGHT_PARENTHESIS)) return;
		else if (CheckToken(token, c, '[', LEX_LEFT_BRACKET)) return;
		else if (CheckToken(token, c, ']', LEX_RIGHT_BRACKET)) return;
		else if (CheckToken(token, c, '{', LEX_LEFT_CURLY_BRACKET)) return;
		else if (CheckToken(token, c, '}', LEX_RIGHT_CURLY_BRACKET)) return;
		else if (CheckToken(token, c, ',', LEX_COMMA)) return;
		else if (CheckToken(token, c, '.', LEX_DOT)) return;
		else if (CheckToken(token, c, ';', LEX_SEMICOLON)) return;
		else if (CheckToken(token, c, ':', LEX_COLON)) return;
		else if (CheckToken(token, c, '+', LEX_PLUS)) return;
		else if (CheckToken(token, c, '-', LEX_MINUS)) return;
		else if (CheckToken(token, c, '*', LEX_ASTERISK)) return;
		else if (CheckToken(token, c, '/', LEX_DIVISION)) return;
		else if (CheckToken(token, c, '>', LEX_IS_BIGGER)) return;
		else if (CheckToken(token, c, '<', LEX_IS_LESS)) return;
		else if (CheckToken(token, c, '=', LEX_EQUAL)) return;
		else if (CheckToken(token, c, '%', LEX_PERCENT_SIGN)) return;
		else if (CheckToken(token, c, '#', LEX_NUMBER_SIGN)) return;
		else if (CheckToken(token, c, '\\', LEX_REVERSE_SOLIDUS)) return;
		else if (CheckToken(token, c, '~', LEX_TILDE)) return;
		else if (CheckToken(token, c, '?', LEX_QUESTION_MARK)) return;
		else if (CheckToken(token, c, '!', LEX_EXCLAMATION_MARK)) return;
		else if (CheckToken(token, c, '\'', LEX_APOSTROPHE)) return;
		else if (CheckToken(token, c, '@', LEX_AT)) return;
		else if (c == '\0')
		{
			token.type = LEX_END_OF_FILE;
			token.line_number = line_number;
			token.string_value[i] = '\0';
			return;
		}
		else
		{
			token.type = LEX_ERROR_UNRECOGNIZED_CHAR;
			_snwprintf_s(token.string_value, LEX_STRINGMAX, _TRUNCATE, L"Unrecognized character %c", c);
			token.line_number = line_number;
			return;
		}
	}
}

bool LexicalAnalyzer::ProcessKeywords(Cpl::LexicalAnalyzer::Token& token)
{
	if (CheckToken(token, LEX_DATATYPE_BOOL, LEX_DATATYPE_PROBNET)) return true; //Data type
	if (CheckToken(token, LEX_DATATYPE_CHAR, LEX_DATATYPE_LONG)) return true; //Data type (other C++)
	if (CheckToken(token, LEX_IF, LEX_BROKEN_BAR)) return true; //Data Control and General
	if (CheckToken(token, LEX_FUNC_SIN, LEX_FUNC_ISPRIME)) return true; //Function
	return false;
}

bool LexicalAnalyzer::GetTokens(const wchar_t* inputString, vector<Cpl::LexicalAnalyzer::Token>& output)
{
	Cpl::LexicalAnalyzer lex;
	Cpl::LexicalAnalyzer::Token token;
	if (lex.Create(inputString) == false) return false;
	do
	{
		lex.GetNextToken(token);
		output.push_back(token);
	}
	while (token.type != LEX_END_OF_FILE);// && token.type != LEX_ERROR);
	return true;
}

bool LexicalAnalyzer::GetTokens(HWND hWndInput, vector<Cpl::LexicalAnalyzer::Token>& output)
{
	Cpl::LexicalAnalyzer lex;
	Cpl::LexicalAnalyzer::Token token;
	if (lex.Create(hWndInput) == false) return false;
	do
	{
		lex.GetNextToken(token);
		output.push_back(token);
	}
	while (token.type != LEX_END_OF_FILE); //&& token.type != LEX_ERROR);
	return true;
}

bool LexicalAnalyzer::CheckToken(LexicalAnalyzer::Token& token, const int first, const int last)
{
	wchar_t * text = NULL;
	for(int type = first; type <= last; type++)
	{
		text = GetTokenText(type);
		if (text == NULL) return false;
		if (wcscmp(token.string_value, text) == 0)
		{
			token.type = type;
			token.line_number = line_number;
			return true;
		}
	}
	return false;
}

bool LexicalAnalyzer::CheckTokenNoCase(LexicalAnalyzer::Token& token, const int first, const int last)
{
	wchar_t * text = NULL;
	for(int type = first; type <= last; type++)
	{
		text = GetTokenText(type);
		if (text == NULL) return false;

		if (_wcsicmp(token.string_value, text) == 0)
		{
			token.type = type;
			token.line_number = line_number;
			return true;
		}
	}
	return false;
}

bool LexicalAnalyzer::CheckToken(LexicalAnalyzer::Token& token, const wchar_t c, const wchar_t match, int lex_type)
{
	if (c != match) return false;
	//index++;
	token.type = lex_type;
	token.string_value[0]=match;
	token.string_value[1]='\0';
	token.line_number = line_number;
	return true;
}

bool LexicalAnalyzer::CheckToken(LexicalAnalyzer::Token& token, const wchar_t c, const wchar_t match1, const wchar_t match2, int lex_type)
{
	if (c != match1) return false;
	if (inputString[index] != match2) return false;
	index++;
	token.type = lex_type;
	token.string_value[0]=match1;
	token.string_value[1]=match2;
	token.string_value[2]='\0';
	token.line_number = line_number;
	return true;
}

void LexicalAnalyzer::Debug(wstring& outputDebugString)
{
	outputDebugString = L"Line\tstring\t\tdouble\t\tbool\tint\r\n";
	Token token;
	wstring text;
	while(true)
	{
		GetNextToken(token);
		if (token.type == LEX_END_OF_FILE) break;

		if (token.type == LEX_ERROR_UNRECOGNIZED_CHAR)
		{
			Sys::Format(text, L"%d\tERROR(unrecognized character) %s\r\n", token.line_number, token.string_value);
		}
		else if (token.type == LEX_ERROR_STRING_TOO_LONG)
		{
			Sys::Format(text, L"%d\tERROR(string too long) %s\r\n", token.line_number, token.string_value);
		}
		else if (token.type == LEX_ERROR_MISSING_COMMENT_TERMINATOR)
		{
			Sys::Format(text, L"%d\tERROR(missing comment terminator)\r\n", token.line_number);
		}
		else if (token.type == LEX_ERROR_MISSING_STRING_TERMINATOR)
		{
			Sys::Format(text, L"%d\tERROR(missing quotes) %s\r\n", token.line_number, token.string_value);
		}
		else
		{
			Sys::Format(text, L"%d\t%s\t\t%g\t%d\r\n", 
				token.line_number, token.string_value, token.double_value, token.int_value);
		}
		outputDebugString += text;
	}
}

wchar_t * LexicalAnalyzer::GetTokenText(int type)
{
	switch(type)
	{
	case LEX_PLUS: return L"+";
	case LEX_MINUS: return L"-";
	case LEX_ASTERISK: return L"*";
	case LEX_DIVISION: return L"/";
	case LEX_EQUAL: return L"=";
	case LEX_PERCENT_SIGN: return L"%";
	//___________________________ Unary operators
	case LEX_MINUS_SIGN: return L"-";
	case LEX_PLUS_PLUS: return L"++";
	case LEX_MINUS_MINUS: return L"--";
	//___________________________ Binary expressions
	case LEX_PLUS_EQUAL: return L"+=";
	case LEX_MINUS_EQUAL: return L"-=";
	case LEX_PRODUCT_EQUAL: return L"*=";
	case LEX_DIVISION_EQUAL: return L"/=";
	//_____________________________ Separator
	case LEX_LEFT_PARENTHESIS: return L"(";
	case LEX_RIGHT_PARENTHESIS: return L")";
	case LEX_LEFT_BRACKET: return L"[";
	case LEX_RIGHT_BRACKET: return L"]";
	case LEX_LEFT_CURLY_BRACKET: return L"{";
	case LEX_RIGHT_CURLY_BRACKET: return L"}";
	case LEX_COMMA: return L",";
	case LEX_DOT: return L".";
	case LEX_SEMICOLON: return L";";
	//____________________________ Relation
	case LEX_IS_BIGGER: return L">";
	case LEX_IS_BIGGER_EQ: return L">=";
	case LEX_IS_LESS: return L"<";
	case LEX_IS_LESS_EQ: return L"<=";
	case LEX_IS_EQUAL: return L"==";
	case LEX_IS_DIFFERENT: return L"!="; 
	//____________________________ Boolean operators
	case LEX_OR: return L"||";
	case LEX_AND: return L"&&";
	//____________________________ Control
	case LEX_IF: return L"if";
	case LEX_ELSE: return L"else";
	case LEX_FOR: return L"for";
	case LEX_WHILE: return L"while";
	case LEX_DO: return L"do";
	case LEX_SWITCH: return L"switch";
	case LEX_CASE: return L"case";
	case LEX_BREAK: return L"break";
	case LEX_CONTINUE: return L"continue";
	case LEX_RETURN: return L"return";
	case LEX_STRUCT: return L"struct";
	case LEX_CLASS: return L"class";
	case LEX_PRIVATE: return L"private";
	case LEX_PROTECTED: return L"protected";
	case LEX_PUBLIC: return L"public";
	case LEX_STATIC: return L"static";
	case LEX_NAMESPACE: return L"namespace";
	case LEX_CONST: return L"const";
	case LEX_UNSIGNED: return L"unsigned";
	case LEX_NUMBER_SIGN: return L"#";
	case LEX_AMPERSAND: return L"&";
	case LEX_APOSTROPHE: return L"\'";
	case LEX_REVERSE_SOLIDUS: return L"\\";
	case LEX_TILDE: return L"~";
	case LEX_QUESTION_MARK: return L"?";
	case LEX_EXCLAMATION_MARK: return L"!";
	case LEX_POINTER_ARROW: return L"->";
	case LEX_DEFINE: return L"define";
	case LEX_INCLUDE: return L"include";
	case LEX_BROKEN_BAR: return L"|";
	//_____________________________ Datatype
	case LEX_DATATYPE_BOOL: return L"bool";
	case LEX_DATATYPE_DOUBLE: return L"double";
	case LEX_DATATYPE_INTEGER: return L"int";
	case LEX_DATATYPE_VOID: return L"void";
	case LEX_DATATYPE_MATRIX: return L"Matrix";
	case LEX_DATATYPE_VECTOR: return L"Vector";
	case LEX_DATATYPE_COMPLEX: return L"Complex";
	case LEX_DATATYPE_COMPLEX_VECTOR: return L"ComplexVector";
	case LEX_DATATYPE_COMPLEX_MATRIX: return L"ComplexMatrix";
	//case LEX_DATATYPE_SCALER: return L"Scaler";
	case LEX_DATATYPE_LAYERNET: return L"LayerNet";
	case LEX_DATATYPE_KOHONET: return L"KohoNet";
	case LEX_DATATYPE_PROBNET: return L"ProbNet";
	case LEX_DATATYPE_CONTROL: return L"Control"; // For special use only
	case LEX_DATATYPE_CHAR: return L"char"; 
	case LEX_DATATYPE_WCHAR_T: return L"wchar_t";
	case LEX_DATATYPE_LONG: return L"long"; 
	//______________________________ Value
	case LEX_CONST_VALUE_BOOL: return L"const bool";
	case LEX_CONST_VALUE_INTEGER: return L"const int";
	case LEX_CONST_VALUE_DOUBLE: return L"const double";
	case LEX_CONST_VALUE_STRING: return L"const text";
	//_____________________________________  FUNCTION SUBTYPE
	case LEX_FUNC_SIN: return L"sin";
	case LEX_FUNC_COS: return L"cos";
	case LEX_FUNC_TAN: return L"tan";
	case LEX_FUNC_ASIN: return L"asin";
	case LEX_FUNC_ACOS: return L"acos";
	case LEX_FUNC_ATAN: return L"atan";
	case LEX_FUNC_SINH: return L"sinh";
	case LEX_FUNC_COSH: return L"cosh";
	case LEX_FUNC_TANH: return L"tanh";
	case LEX_FUNC_SQRT: return L"sqrt";
	case LEX_FUNC_LOG10: return L"log10";
	case LEX_FUNC_LOG: return L"log";
	case LEX_FUNC_EXP: return L"exp";
	case LEX_FUNC_POW: return L"pow";
	case LEX_FUNC_ABS: return L"abs";
	case LEX_FUNC_SINC: return L"sinc";
	case LEX_FUNC_TRIANG: return L"triang";
	case LEX_FUNC_SAW: return L"saw";
	case LEX_FUNC_RECT: return L"rect";
	case LEX_FUNC_CEIL: return L"ceil";
	case LEX_FUNC_FLOOR: return L"floor";
	case LEX_FUNC_TOINT: return L"toint";
	case LEX_FUNC_FFT: return L"fft";
	case LEX_FUNC_IFFT: return L"ifft";
	case LEX_FUNC_REALFFT: return L"realfft";
	case LEX_FUNC_IREALFFT: return L"irealfft";
	case LEX_FUNC_SPECTRUM: return L"spectrum";
	case LEX_FUNC_CONVOLUTION: return L"Convolution";
	case LEX_FUNC_SHORT_CONVOLUTION: return L"ShortConvolution";
	case LEX_FUNC_COMPUTE_MSE: return L"ComputeMse";
	case LEX_FUNC_CONFUSION_MATRIX: return L"ConfusionMatrix";
	case LEX_FUNC_RAND: return L"rand";
	case LEX_FUNC_RANDI: return L"randi";
	case LEX_FUNC_ISPRIME: return L"isprime";
	//_____________________________ SQL DATATYPE
	case LEX_SQLTYPE_BIT: return L"BIT";
	//
	case LEX_SQLTYPE_INTEGER: return L"INTEGER";
	case LEX_SQLTYPE_SMALLINT: return L"SMALLINT";
	case LEX_SQLTYPE_BIGINT: return L"BIGINT";
	case LEX_SQLTYPE_TINYINT: return L"TINYINT";
	case LEX_SQLTYPE_INT: return L"INT";
	//
	case LEX_SQLTYPE_DOUBLE: return L"DOUBLE";
	case LEX_SQLTYPE_DECIMAL: return L"DECIMAL";
	case LEX_SQLTYPE_REAL: return L"REAL";
	case LEX_SQLTYPE_NUMERIC: return L"NUMERIC";
	case LEX_SQLTYPE_MONEY: return L"MONEY";
	case LEX_SQLTYPE_SMALLMONEY: return L"SMALLMONEY";
	//
	case LEX_SQLTYPE_VARCHAR2: return L"VARCHAR2";
	case LEX_SQLTYPE_VARCHAR: return L"VARCHAR";
	case LEX_SQLTYPE_CHAR: return L"CHAR";
	case LEX_SQLTYPE_TEXT: return L"TEXT";
	case LEX_SQLTYPE_NVARCHAR: return L"NVARCHAR";
	case LEX_SQLTYPE_NCHAR: return L"NCHAR";
	case LEX_SQLTYPE_NTEXT: return L"NTEXT";
	//
	case LEX_SQLTYPE_DATETIME: return L"DATETIME";
	case LEX_SQLTYPE_DATETIME2: return L"DATETIME2";
	case LEX_SQLTYPE_SMALLDATETIME: return L"SMALLDATETIME";
	case LEX_SQLTYPE_DATE: return L"DATE";
	case LEX_SQLTYPE_TIME: return L"TIME";
	case LEX_SQLTYPE_TIMESTAMP: return L"TIMESTAMP";
	//_____________________________ SQL MAIN	
	case LEX_SQL_CREATE: return L"CREATE";
	case LEX_SQL_INSERT: return L"INSERT";
	case LEX_SQL_UPDATE: return L"UPDATE";
	case LEX_SQL_SELECT: return L"SELECT";
	case LEX_SQL_DELETE: return L"DELETE";
	case LEX_SQL_DROP: return L"DROP";
	case LEX_SQL_GRANT: return L"GRANT";
	case LEX_SQL_REVOKE: return L"REVOKE";
	case LEX_SQL_ROLLBACK: return L"ROLLBACK";
	case LEX_SQL_SAVEPOINT: return L"SAVEPOINT";
	case LEX_SQL_USE: return L"USE";
	case LEX_SQL_ALTER: return L"ALTER";
	//_____________________________ SQL OBJECTS
	case LEX_SQL_TABLE: return L"TABLE";
	case LEX_SQL_VIEW: return L"VIEW";
	case LEX_SQL_TRIGGER: return L"TRIGGER";
	case LEX_SQL_INDEX: return L"INDEX";
	case LEX_SQL_PROCEDURE: return L"PROCEDURE";
	case LEX_SQL_DATABASE: return L"DATABASE";
	case LEX_SQL_CURSOR: return L"CURSOR";
	//_____________________________ SQL KEYWORDS
	case LEX_SQL_WHERE: return L"WHERE";
	case LEX_SQL_FROM: return L"FROM";
	case LEX_SQL_AS: return L"AS";
	case LEX_SQL_GROUP: return L"GROUP";
	case LEX_SQL_ORDER: return L"ORDER";
	case LEX_SQL_CONSTRAINT: return L"CONSTRAINT";
	case LEX_SQL_IDENTITY: return L"IDENTITY";
	case LEX_SQL_AUTO_INCREMENT: return L"AUTO_INCREMENT";
	case LEX_SQL_INNER: return L"INNER";
	case LEX_SQL_JOIN: return L"JOIN";
	case LEX_SQL_ON: return L"ON";
	case LEX_SQL_UNIQUE: return L"UNIQUE";
	case LEX_SQL_BY: return L"BY";
	case LEX_SQL_HAVING: return L"HAVING";
	case LEX_SQL_UNION: return L"UNION";
	case LEX_SQL_INTERSECT: return L"INTERSECT";
	case LEX_SQL_INTO: return L"INTO";
	case LEX_SQL_VALUES: return L"VALUES";
	case LEX_SQL_REPLACE: return L"REPLACE";
	case LEX_SQL_PRIMARY: return L"PRIMARY";
	case LEX_SQL_FOREIGN: return L"FOREIGN";
	case LEX_SQL_KEY: return L"KEY";
	case LEX_SQL_REFERENCES: return L"REFERENCES";
	case LEX_SQL_CASCADE: return L"CASCADE";
	case LEX_SQL_AND: return L"AND";
	case LEX_SQL_OR: return L"OR";
	case LEX_SQL_NOT: return L"NOT";
	case LEX_SQL_BEGIN: return L"BEGIN";
	case LEX_SQL_END: return L"END";
	case LEX_SQL_DISTINCT: return L"DISTINCT";
	case LEX_SQL_LIKE: return L"LIKE";
	case LEX_SQL_CHECK: return L"CHECK";
	case LEX_SQL_READ: return L"READ";
	case LEX_SQL_ONLY: return L"ONLY";
	case LEX_SQL_READ_ONLY: return L"READ_ONLY";
	case LEX_SQL_OPTION: return L"OPTION";
	case LEX_SQL_TRANSACTION: return L"TRANSACTION";
	case LEX_SQL_COMMIT: return L"COMMIT";
	case LEX_SQL_SET: return L"SET";
	case LEX_SQL_IF: return L"IF";
	case LEX_SQL_WITH: return L"WITH";
	case LEX_SQL_RAISERROR: return L"RAISERROR";
	case LEX_SQL_GO: return L"GO";
	case LEX_SQL_DECLARE: return L"DECLARE";
	case LEX_SQL_FOR: return L"FOR";
	case LEX_SQL_OPEN: return L"OPEN";
	case LEX_SQL_CLOSE: return L"CLOSE";
	case LEX_SQL_WHILE: return L"WHILE";
	case LEX_SQL_NEXT: return L"NEXT";
	case LEX_SQL_FETCH: return L"FETCH";
	case LEX_SQL_DEALLOCATE: return L"DEALLOCATE";
	case LEX_SQL_RETURN: return L"RETURN";
	case LEX_SQL_CASE: return L"CASE";
	case LEX_SQL_FETCH_STATUS: return L"FETCH_STATUS";
	case LEX_SQL_EXISTS: return L"EXISTS";
	case LEX_SQL_DBO: return L"DBO";
	case LEX_SQL_DEFAULT: return L"DEFAULT";
	case LEX_SQL_NULL: return L"NULL";
	//_____________________________ SQL FUNCTIONS
	case LEX_SQL_ABS: return L"ABS";
	case LEX_SQL_MOD: return L"MOD";
	case LEX_SQL_TRUNCATE: return L"TRUNCATE";
	case LEX_SQL_POWER: return L"POWER";
	case LEX_SQL_ROUND: return L"ROUND";
	case LEX_SQL_AVG: return L"AVG";
	case LEX_SQL_MIN: return L"MIN";
	case LEX_SQL_MAX: return L"MAX";
	case LEX_SQL_SUM: return L"SUM";
	case LEX_SQL_NVL: return L"NVL";
	case LEX_SQL_TO_NUMBER: return L"TO_NUMBER";
	case LEX_SQL_TO_CHAR: return L"TO_CHAR";
	case LEX_SQL_TO_DATE: return L"TO_DATE";
	case LEX_SQL_DATEFORMAT: return L"DATEFORMAT";
	case LEX_SQL_DATEPART: return L"DATEPART";
	case LEX_SQL_DATEDIFF: return L"DATEDIFF";
	case LEX_SQL_ISDATE: return L"ISDATE";
	case LEX_SQL_CONVERT: return L"CONVERT";
	case LEX_SQL_CAST: return L"CAST";
	case LEX_SQL_GETDATE: return L"GETDATE";
	case LEX_SQL_DB_NAME: return L"DB_NAME";
	//case LEX_FUNC_BESSELJ0: return L"besselj0";
	//case LEX_FUNC_BESSELJ1: return L"besselj1";
	//case LEX_FUNC_BESSELY0: return L"bessely0";
	//case LEX_FUNC_BESSELY1: return L"bessely1";
	case LEX_ID: return L"ID";
	}
	return NULL;
}

//_____________________________________________________________________ Compiler
Compiler::Compiler(void)
{
	variableInfo.clear();
	for(int i = 0; i<LEX_DATATYPE_COUNT; i++) memInfo[i] = 0;
	//isError = false;
}

Compiler::~Compiler(void)
{
}

bool Compiler::Compile(const wchar_t* inputString, vector<Compiler::Instruction>& outputMachineCode)
{
	Clean(outputMachineCode);
	if (lex.Create(inputString)==false) return false;
	//
	lex.GetNextToken(lookahead);
	if (lookahead.type == LEX_END_OF_FILE) return false;
	return InternalCompile(outputMachineCode);
}

bool Compiler::Compile(HWND hWnd, vector<Cpl::Compiler::Instruction>& outputMachineCode)
{
	Clean(outputMachineCode);
	if (lex.Create(hWnd)==false) return false;
	//
	lex.GetNextToken(lookahead);
	if (lookahead.type == LEX_END_OF_FILE) return false;
	return InternalCompile(outputMachineCode);
}

bool Compiler::InternalCompile(vector<Cpl::Compiler::Instruction>& outputMachineCode)
{
	intelliSenseInfo.clear();
	while(sisfi.empty() == false) sisfi.pop(); // Clean the IntelliSense stack
	try
	{
		while(lookahead.type != LEX_END_OF_FILE)
		{
			Block_SingleLine(outputMachineCode);
		}
	}
	catch(int x)
	{
		x++;
		return false;
	}
	return true;
	//return (isError==false);
}

bool Compiler::Debug(const wchar_t* inputString, wstring& outputDebugString)
{
	vector<Compiler::Instruction> machineCode;
	const bool ok = Compile(inputString, machineCode);
	ListCode(machineCode, outputDebugString);
	return ok;
}

bool Compiler::Debug(HWND hWnd, wstring& outputDebugString)
{
	vector<Compiler::Instruction> machineCode;
	const bool ok = Compile(hWnd, machineCode);
	ListCode(machineCode, outputDebugString);
	return ok;
}

void Compiler::ListCode(vector<Compiler::Instruction>& inputMachineCode, wstring& outputDebugString)
{
	wchar_t * text = NULL;
	wchar_t *tokenText = NULL;
	wchar_t info[256];
	vector<Compiler::Instruction>::iterator p;
	int i = 0;
	for(p = inputMachineCode.begin(); p != inputMachineCode.end(); p++, i++)
	{
		text = GetInstructionText(*p);
		tokenText = LexicalAnalyzer::GetTokenText(p->subtype);
		if (text == NULL) continue;
		if (tokenText)
		{
			_snwprintf_s(info, 256, _TRUNCATE, L"%02d/%03d\t%d\t%g\t%s\t%s/%s\r\n",
				i, p->line_number, p->int_value, p->double_value, p->name, text, tokenText);
		}
		else
		{
			_snwprintf_s(info, 256, _TRUNCATE, L"%02d/%03d\t%d\t%g\t%s\t%s/%d\r\n",
				i, p->line_number, p->int_value, p->double_value, p->name, text, p->subtype);
		}
		outputDebugString += info;
	}
}

wchar_t* Compiler::GetInstructionText(Compiler::Instruction& inst)
{
	switch(inst.type)
	{
	case VM_ERROR: return L"Error";
	case VM_CREATE: return L"Create";
	case VM_VALUE: return L"Value";
	case VM_REFVALUE: return L"RefVal";
	case VM_SETVALUE: return L"SetVal";
	case VM_SET_VECTORCELL: return L"SetVCell";
	case VM_SET_MATRIXCELL: return L"SetMCell";
	//case VM_SETREF_VECTORCELL: return L"SetRefVCell";
	//case VM_SETREF_MATRIXCELL: return L"SetRefMCell";
	case VM_VECTOR_CELL: return L"VCell";
	case VM_MATRIX_CELL: return L"MCell";
	case VM_OPER: return L"Oper";
	case VM_OPER_MONO: return L"OperMono";
	case VM_OPER_BINA: return L"OperBina";
	case VM_FUNC: return L"Func";
	case VM_OBJFUNC: return L"ObjFunc";
	case VM_GOTO: return L"GoTo";
	case VM_GOFALSE: return L"GoFalse";
	case VM_GOTRUE: return L"GoTrue";
	}
	return L"Error";
}

void Compiler::Clean(vector<Compiler::Instruction>& machineCode)
{
	machineCode.clear();
	variableInfo.clear();
	for(int i = 0; i<LEX_DATATYPE_COUNT; i++) memInfo[i] = 0;
	//isError = false;
}

void Compiler::Next(vector<Compiler::Instruction>& machine_code)
{
	//lex.GetNextToken(lookahead);
	//if (lookahead.type == LEX_END_OF_FILE) return false;

	lex.GetNextToken(lookahead);
	if (lex.IsError(lookahead)) AddError(machine_code, lookahead, ERROR_LEX, 0);
}

void Compiler::Match(vector<Compiler::Instruction>& machine_code, int type)
{
	if (lookahead.type != type ) AddError(machine_code, lookahead, ERROR_SYNTAX, type);	
	Next(machine_code);
}

//void Compiler::Match(vector<Compiler::Instruction>& machine_code, int type, int func_id, int datatype, int parameterIndex)
//{
//	if (lookahead.type != type ) 
//	{
//		ListMethods(func_id, datatype, NULL, parameterIndex);
//		AddError(machine_code, lookahead, ERROR_SYNTAX, type);	
//		return;
//	}
//	Next(machine_code);
//}

void Compiler::AddError(vector<Compiler::Instruction>& machineCode, LexicalAnalyzer::Token& token, int error_type, int correct_token_type)
{
	//___________________________  Create IntelliSense
	IntelliSenseFuncInfo isfi;
	while (sisfi.empty() == false)
	{
		isfi = sisfi.top();
		sisfi.pop();
		ListMethods(isfi.func_id, isfi.datatype, NULL, isfi.parameterIndex);
	}
	//
	Instruction inst;
	inst.type = VM_ERROR;
	inst.subtype = error_type;
	inst.line_number= token.line_number;
	inst.int_value = 0;
	inst.double_value = 0.0;
	wchar_t * descr = NULL;
	switch(error_type)
	{
	case ERROR_SYNTAX:
		descr = LexicalAnalyzer::GetTokenText(correct_token_type);
		if (descr)
		{			
			_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"Line %d syntax error, missing %s", inst.line_number, descr);
		}
		else
		{
			_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"Line %d syntax error", inst.line_number);
		}
		break;
	case ERROR_VARIABLE_ALLREADY_DEFINED:
		_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"Line %d the variable has already been defined", inst.line_number);
		break;
	case ERROR_VARIABLE_NOEXISTS:
		_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"Line %d the variable does not exist", inst.line_number);
		break;
	case ERROR_INVALID_OBJECT_FUNC:
		_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"Line %d the object does not support this method", inst.line_number);
		break;
	case ERROR_VARIABLE_UNINIT:
		_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"Line %d the variable has not been initialized", inst.line_number);
		break;
	case ERROR_INVALID_PARAM:
		_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"Line %d the function parameter is invalid", inst.line_number);
		break;
	case ERROR_MISSING_TOKEN:
		_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"Line %d syntax error, missing terminator", inst.line_number);
		break;
	case ERROR_INCOMPLETE_COMMAND:
		_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"Line %d the command is incomplete", inst.line_number);
		break;
	case ERROR_MISSING_VARIABLE:
		_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"Line %d a variable is missing", inst.line_number);
		break;
	case ERROR_LEX:
		{
			if (token.type == LEX_ERROR_UNRECOGNIZED_CHAR)
			{
				_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"Line %d unrecognized character %s", inst.line_number, token.string_value);
			}
			else if (token.type == LEX_ERROR_STRING_TOO_LONG)
			{
				_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"Line %d string too long %s", inst.line_number, token.string_value);
			}
			else if (token.type == LEX_ERROR_MISSING_COMMENT_TERMINATOR)
			{
				_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"Line %d missing comment terminator", inst.line_number);
			}
			else if (token.type == LEX_ERROR_MISSING_STRING_TERMINATOR)
			{
				_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"Line %d missing string terminator %s", inst.line_number, token.string_value);
			}
		}
		break;
	}
	machineCode.push_back(inst);
	throw 0;
}

void Compiler::Block_MultiLine(vector<Compiler::Instruction>& machineCode)
{
	Next(machineCode); // {
	do
	{
		Block_SingleLine(machineCode);
	}
	while (lookahead.type != LEX_RIGHT_CURLY_BRACKET);
	Next(machineCode); // }
}

void Compiler::Block_SingleLine(vector<Compiler::Instruction>& machineCode)
{
	if (LEX_DATATYPE_BOOL <= lookahead.type && lookahead.type <= LEX_DATATYPE_PROBNET)
	{
		DataType(machineCode);
	}
	else if (LEX_IF == lookahead.type)
	{
		If(machineCode);
	}
	else if (LEX_FOR == lookahead.type)
	{
		For(machineCode);
	}
	else if (LEX_WHILE == lookahead.type)
	{
		While(machineCode);
	}
	else if (LEX_DO == lookahead.type)
	{
		Do(machineCode);
	}
	//else if (LEX_SWITCH == lookahead.type)
	//{
	//	Switch(machineCode);
	//}
	else if (LEX_LEFT_CURLY_BRACKET == lookahead.type)
	{
		Block_MultiLine(machineCode);
	}
	else if (LEX_ID == lookahead.type)
	{
		VariableId(machineCode);
		Match(machineCode, LEX_SEMICOLON);
	}
	else
	{
		AddError(machineCode, lookahead, ERROR_SYNTAX, ERROR_INVALID_VALUE);
	}
}


void Compiler::DataType(vector<Compiler::Instruction>& machineCode)
{
	LexicalAnalyzer::Token tokenDataType = lookahead;
 	Next(machineCode); //Variable ID
	LexicalAnalyzer::Token tokenVariableId = lookahead;
	if (lookahead.type == LEX_ID)
	{
		CreateVariable(machineCode, tokenDataType, tokenVariableId);
		Next(machineCode);
		if (lookahead.type == LEX_EQUAL)
		{
			VariableSet(machineCode, tokenVariableId);
		}
		Match(machineCode, LEX_SEMICOLON);
	}
	else
	{
		AddError(machineCode, lookahead, ERROR_SYNTAX, ERROR_INVALID_VALUE);
		return;
	}
}

void Compiler::If(vector<Compiler::Instruction>& machineCode)
{
	// 1. Expression
	// 2. GOTOFALSE 4
	// 3. Block

	Instruction inst;
	int go_false;
	int go_to;
	int instruction_index;

	LexicalAnalyzer::Token tokenIf = lookahead;
	Next(machineCode);
	Match(machineCode, LEX_LEFT_PARENTHESIS);
	Expression(machineCode);
	Match(machineCode, LEX_RIGHT_PARENTHESIS);

	//_______________________________ inst
	inst.type = VM_GOFALSE;
	inst.subtype = 0;
	inst.line_number= tokenIf.line_number;
	inst.int_value = -1; // We will update the correct instruction_index
	inst.double_value = -1.0;
	_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"%s", tokenIf.string_value);
	machineCode.push_back(inst);
	go_false = machineCode.size()-1;
	Block(machineCode);
	instruction_index = machineCode.size();
	machineCode[go_false].int_value = instruction_index;

	if (lookahead.type == LEX_ELSE)
	{
		machineCode[go_false].int_value = instruction_index+1;
		// 1. Expression
		// 2. GOTOFALSE 5
		// 3. CommandList
		// 4. GOTO 7
		// 5. ELSE
		// 6. CommandList

		//_______________________________ inst
		inst.type = VM_GOTO;
		inst.subtype = 0;
		inst.line_number= tokenIf.line_number;
		inst.int_value = -1; // We will update the correct instruction_index
		inst.double_value = 0.0;
		_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"%s", lookahead.string_value);
		machineCode.push_back(inst);
		go_to = machineCode.size()-1;
		//
		Next(machineCode); // else
		//
		Block(machineCode);
		instruction_index = machineCode.size();
		machineCode[go_to].int_value = instruction_index;
	}
}

void Compiler::For(vector<Compiler::Instruction>& machineCode)
{
	// 1. Statement
	// 2. Expression
	// 3. GOTOFALSE 7
	// 4. Block
	// 5. Statement
	// 6. GOTO 2
	// 7.
	vector<Compiler::Instruction>::iterator p;
	Instruction inst;
	int go_to;
	int go_tofalse;
	//int instruction_index;
	vector<Compiler::Instruction> statement3;

	// for(Statement; Expression; Statement)
	LexicalAnalyzer::Token tokenFor= lookahead;
	Next(machineCode); // for
	Match(machineCode, LEX_LEFT_PARENTHESIS); // (
	Statement(machineCode); // Statement
	go_to = machineCode.size();
	Match(machineCode, LEX_SEMICOLON); // ;
	Expression(machineCode); // Expression
	Match(machineCode, LEX_SEMICOLON); // ;
	try
	{
		Statement(statement3); // Statement (We store Statement 3, so that we can add it later)
	}
	catch(int tmp)
	{
		//If there is an error in statement 3, we copy to the errors to the original code
		tmp++;
		for(p = statement3.begin(); p != statement3.end(); p++)
		{
			machineCode.push_back(*p);
		}
		throw 0;
	}
	Match(machineCode, LEX_RIGHT_PARENTHESIS); // )

	//_______________________________ inst
	inst.type = VM_GOFALSE;
	inst.subtype = 0;
	inst.line_number= tokenFor.line_number;
	inst.int_value = -1; // We will update the correct instruction_index
	inst.double_value = 0.0;
	_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"%s", tokenFor.string_value);
	go_tofalse = machineCode.size();
	machineCode.push_back(inst);
	Block(machineCode);

	//______________________________ Statement 3
	for(p = statement3.begin(); p != statement3.end(); p++)
	{
		machineCode.push_back(*p);
	}

	//_______________________________ inst
	inst.type = VM_GOTO;
	inst.subtype = 0;
	inst.line_number= tokenFor.line_number;
	inst.int_value = go_to; 
	inst.double_value = 0.0;
	_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"%s", tokenFor.string_value);
	machineCode.push_back(inst);
	//
	machineCode[go_tofalse].int_value = machineCode.size();
}

void Compiler::While(vector<Compiler::Instruction>& machineCode)
{
	// 1. Expression
	// 2. GOTOFALSE 5
	// 3. Block
	// 4. GOTO 1
	Instruction inst;
	int go_false;
	int go_to;

	LexicalAnalyzer::Token tokenWhile= lookahead; 
	Next(machineCode); // while
	Match(machineCode, LEX_LEFT_PARENTHESIS); // (
	go_to = machineCode.size();
	Expression(machineCode);
	Match(machineCode, LEX_RIGHT_PARENTHESIS); // )

	//_______________________________ inst
	inst.type = VM_GOFALSE;
	inst.subtype = 0;
	inst.line_number= tokenWhile.line_number;
	inst.int_value = -1; // We will update the correct instruction_index
	inst.double_value = 0.0;
	_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"%s", tokenWhile.string_value);
	machineCode.push_back(inst);
	go_false = machineCode.size()-1;
	Block(machineCode);
	//_______________________________ inst
	inst.type = VM_GOTO;
	inst.subtype = 0;
	inst.line_number= tokenWhile.line_number;
	inst.int_value = go_to; 
	inst.double_value = 0.0;
	_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"%s", tokenWhile.string_value);
	machineCode.push_back(inst);
	//
	machineCode[go_false].int_value = machineCode.size();
}

void Compiler::Do(vector<Compiler::Instruction>& machineCode)
{
	// 1. Block
	// 2. Expression
	// 3. GOTOTRUE 1
	Instruction inst;
	int go_true;

	LexicalAnalyzer::Token tokenDo= lookahead;
	Next(machineCode); // Do
	go_true = machineCode.size();
	Block(machineCode);
	Match(machineCode, LEX_WHILE);
	Match(machineCode, LEX_LEFT_PARENTHESIS);
	Expression(machineCode);
	Match(machineCode, LEX_RIGHT_PARENTHESIS);
	Match(machineCode, LEX_SEMICOLON);

	//_______________________________ inst
	inst.type = VM_GOTRUE;
	inst.subtype = 0;
	inst.line_number= tokenDo.line_number;
	inst.int_value = go_true; 
	inst.double_value = 0.0;
	_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"%s", tokenDo.string_value);
	machineCode.push_back(inst);
}

void Compiler::Switch(vector<Compiler::Instruction>& machineCode)
{
}

void Compiler::Block(vector<Compiler::Instruction>& machineCode)
{
	if (lookahead.type == LEX_LEFT_CURLY_BRACKET)
	{
		Block_MultiLine(machineCode);
	}
	else
	{
		Block_SingleLine(machineCode);
	}
}

//bool Compiler::IsValidId(LexicalAnalyzer::Token& token)
//{
//	map<wstring, Compiler::VariableInfo>::iterator p = variableInfo.find(token.string_value);
//	if (p ==variableInfo.end()) return false;
//	return true;
//}

void Compiler::VariableId(vector<Compiler::Instruction>& machineCode)
{
	LexicalAnalyzer::Token tokenVariableId = lookahead;
	Compiler::VariableInfo vi = GetVariableInfo(tokenVariableId);
	if (vi.datatype == ERROR_INVALID_VALUE)
	{
		AddError(machineCode, lookahead, ERROR_VARIABLE_NOEXISTS, ERROR_INVALID_VALUE);
		return;
	}
	Next(machineCode); // ID

	switch(lookahead.type)
	{
	case LEX_EQUAL:
		VariableSet(machineCode, tokenVariableId);
		//Match(machineCode, LEX_SEMICOLON);
		break;
	case LEX_DOT:
		ObjectFunction(machineCode, tokenVariableId, vi);
		break;
	case LEX_LEFT_BRACKET:
		VariableArray(machineCode, tokenVariableId, vi);
		break;
	case LEX_PLUS_PLUS:
	case LEX_MINUS_MINUS:
		OperMono(machineCode, tokenVariableId, vi);
		break;
	case LEX_PLUS_EQUAL:
	case LEX_MINUS_EQUAL:
	case LEX_PRODUCT_EQUAL:
	case LEX_DIVISION_EQUAL:
		OperBina(machineCode, tokenVariableId, vi);
		break;
	default:
		AddError(machineCode, lookahead, ERROR_SYNTAX, ERROR_INVALID_VALUE);
	}
}

void Compiler::Statement(vector<Compiler::Instruction>& machineCode)
{
	if (lookahead.type != LEX_ID)
	{
		AddError(machineCode, lookahead, ERROR_MISSING_VARIABLE, ERROR_INVALID_VALUE);
		return;
	}
	LexicalAnalyzer::Token tokenVariableId = lookahead;
	Compiler::VariableInfo vi = GetVariableInfo(tokenVariableId);
	if (vi.datatype == ERROR_INVALID_VALUE)
	{
		AddError(machineCode, lookahead, ERROR_VARIABLE_NOEXISTS, ERROR_INVALID_VALUE);
		return;
	}
	if (lookahead.type == LEX_END_OF_FILE)
	{
		AddError(machineCode, lookahead, ERROR_INCOMPLETE_COMMAND, ERROR_INVALID_VALUE);
		return;
	}
	Next(machineCode); // ID

	switch(lookahead.type)
	{
	case LEX_EQUAL:
		VariableSet(machineCode, tokenVariableId);
		break;
	case LEX_PLUS_PLUS:
	case LEX_MINUS_MINUS:
		OperMono(machineCode, tokenVariableId, vi);
		break;
	case LEX_PLUS_EQUAL:
	case LEX_MINUS_EQUAL:
	case LEX_PRODUCT_EQUAL:
	case LEX_DIVISION_EQUAL:
		OperBina(machineCode, tokenVariableId, vi);
		break;
	default:
		AddError(machineCode, lookahead, ERROR_SYNTAX, ERROR_INVALID_VALUE);
	}
}

void Compiler::OperMono(vector<Compiler::Instruction>& machineCode, LexicalAnalyzer::Token& tokenVariableId, VariableInfo vi)
{
	if (lookahead.type == LEX_PLUS_PLUS || lookahead.type ==LEX_MINUS_MINUS)
	{	
		wchar_t * descr = Cpl::LexicalAnalyzer::GetTokenText(lookahead.type);
		//___________ Instruction
		Instruction inst;
		inst.type = VM_OPER_MONO;
		inst.subtype =vi.datatype;  
		inst.line_number = lookahead.line_number;
		inst.int_value = vi.index;
		inst.double_value = lookahead.type; //LEX_PLUS_PLUS, LEX_MINUS_MINUS
		_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"%s%s", tokenVariableId.string_value, descr);
		machineCode.push_back(inst);
		Next(machineCode); // ++, --
		return;
	}
	AddError(machineCode, lookahead, ERROR_SYNTAX, ERROR_INVALID_VALUE);
}

void Compiler::OperBina(vector<Compiler::Instruction>& machineCode, LexicalAnalyzer::Token& tokenVariableId, VariableInfo vi)
{
	if (lookahead.type == LEX_PLUS_EQUAL || lookahead.type ==LEX_MINUS_EQUAL
		|| lookahead.type == LEX_PRODUCT_EQUAL || lookahead.type ==LEX_DIVISION_EQUAL)
	{	
		wchar_t * descr = Cpl::LexicalAnalyzer::GetTokenText(lookahead.type);
		Cpl::LexicalAnalyzer::Token operation = lookahead;
		Next(machineCode); // +=, -=, *=, /=
		Expression(machineCode);
		//___________ Instruction
		Instruction inst;
		inst.type = VM_OPER_BINA;
		inst.subtype =vi.datatype;  
		inst.line_number = operation.line_number;
		inst.int_value = vi.index;
		inst.double_value = operation.type; //LEX_PLUS_EQUAL, LEX_MINUS_EQUAL, LEX_PRODUCT_EQUAL, LEX_DIVISION_EQUAL
		_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"%s%s", tokenVariableId.string_value, descr);
		machineCode.push_back(inst);
		return;
	}
	AddError(machineCode, lookahead, ERROR_SYNTAX, ERROR_INVALID_VALUE);
}

// x = expression
void Compiler::VariableSet(vector<Compiler::Instruction>& machineCode, LexicalAnalyzer::Token& tokenVariableId)
{
	Compiler::VariableInfo vi = GetVariableInfo(tokenVariableId);
	if (vi.datatype == ERROR_INVALID_VALUE)
	{
		AddError(machineCode, tokenVariableId, ERROR_VARIABLE_NOEXISTS, ERROR_INVALID_VALUE);
		return;
	}
	Next(machineCode); // =
	Expression(machineCode);
	//___________ Instruction
	Instruction inst;
	inst.type = VM_SETVALUE;
	inst.subtype = vi.datatype;
	inst.line_number = tokenVariableId.line_number;
	inst.int_value = vi.index;
	inst.double_value = 0.0;
	_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"%s", tokenVariableId.string_value);
	machineCode.push_back(inst);
}

void Compiler::ListMethods(int func_id, int datatype, wchar_t* next_text,  int parameterIndex)
{
	wchar_t *func_name = NULL;
	IntelliSenseInfo isi;
	isi.type = (next_text == NULL) ? LEX_ISI_METHOD_ARG : LEX_ISI_METHOD;
	isi.func_id = func_id;

	if (next_text == NULL)//__________________________ list all methods of func_id
	{
		wchar_t * datatype_text = NULL;
		const int paramType = Cpl::Compiler::GetObjectFuncReturnType(datatype, func_id);
		if (paramType != ERROR_INVALID_VALUE)
		{
			datatype_text = Cpl::LexicalAnalyzer::GetTokenText(paramType);
		}
		func_name = GetFunctionName(datatype, func_id);
		if (func_name == NULL) return;
		if (datatype_text != NULL)
		{
			isi.name = datatype_text;
			isi.name += L" ";
			isi.name += func_name;
		}
		else
		{
			isi.name = func_name;
		}
		
		intelliSenseInfo.push_back(isi);
		ListParameters(func_id, datatype, parameterIndex);
		return;
	}

	//____________________________________________ list methods that match the next_text
	int initial_func_id = -1;
	switch(datatype)
	{
	case LEX_DATATYPE_VECTOR: 
		initial_func_id = LEX_FUNC_VECTOR_CREATE;
		break;
	case LEX_DATATYPE_MATRIX: 
		initial_func_id = LEX_FUNC_MATRIX_CREATE;
		break;
	case LEX_DATATYPE_COMPLEX_VECTOR: 
		initial_func_id = LEX_FUNC_VECTOR_CREATE;
		break;
	case LEX_DATATYPE_COMPLEX_MATRIX: 
		initial_func_id = LEX_FUNC_MATRIX_CREATE;
		break;
	case LEX_DATATYPE_LAYERNET: 
		initial_func_id = LEX_FUNC_LAYERNET_CREATE;
		break;
	case LEX_DATATYPE_KOHONET: 
		initial_func_id = LEX_FUNC_KOHONET_CREATE;
		break;
	case LEX_DATATYPE_PROBNET: 
		initial_func_id = LEX_FUNC_PROBNET_CREATE;
		break;
	}
	
	const int next_len = wcslen(next_text);
	int i;
	bool equal;
	int func_len;

	do
	{
		func_name = GetFunctionName(datatype, initial_func_id);
		if (func_name != NULL)
		{
			if (next_len == 0)
			{
				isi.name = func_name;
				intelliSenseInfo.push_back(isi);
				if (next_text == NULL) ListParameters(func_id, datatype, parameterIndex);
			}
			else //_____________ Filter functions
			{
				func_len = wcslen(func_name);
				equal = true;
				for(i = 0; i<next_len; i++)
				{
					if (next_len<=func_len)
					{
						if (next_text[i] != func_name[i])
						{
							equal = false;
							break;
						}
					}
					else
					{
						equal = false;
						break;
					}
				}
				if (equal == true)// && i != 0)
				{
					isi.name = func_name;
					intelliSenseInfo.push_back(isi);
					if (next_text == NULL) ListParameters(func_id, datatype, parameterIndex);
				}
			}
		}
		initial_func_id++;
	}
	while(func_name != NULL);
	if (next_text != NULL)
	{
		intelliSenseInfo.sort();
	}
}

void Compiler::ListParameters(int func_id, int datatype, int parameterIndex)
{
	IntelliSenseInfo isi;
	isi.type = LEX_ISI_ARGUMENT;
	isi.func_id = func_id;

	const int paramCount = GetFuncParamCount(func_id);
	int paramType = -1;
	wchar_t* datatype_text = NULL;
	wchar_t* paramName = NULL;
	for(int i = 0; i < paramCount; i++)
	{
		paramType = Cpl::Compiler::GetObjectFuncParamType(func_id, i);
		datatype_text = Cpl::LexicalAnalyzer::GetTokenText(paramType);
		if (datatype_text == NULL) continue;
		//
		paramName = GetObjectFuncParamName(func_id, i);
		if (paramName == NULL) continue;
		isi.name = datatype_text;
		isi.name += L" ";
		isi.name += paramName;
		if (i == parameterIndex)
		{
			isi.type = LEX_ISI_ARGUMENT_SEL;
		}
		else
		{
			isi.type = LEX_ISI_ARGUMENT;
		}
		if (i == paramCount -1)
		{
			if (i == parameterIndex)
			{
				isi.type = LEX_ISI_LAST_ARGUMENT_SEL;
			}
			else
			{
				isi.type = LEX_ISI_LAST_ARGUMENT;
			}
		}
		intelliSenseInfo.push_back(isi);
	}
}

void Compiler::ObjectFunction(vector<Compiler::Instruction>& machineCode, LexicalAnalyzer::Token& tokenVariableId, VariableInfo vi)
{
	wchar_t next_text[64];
	lex.GetNextText(next_text, 64);
	//_________________________________________
	Next(machineCode);  // .
	//
	LexicalAnalyzer::Token tokenFunction = lookahead;
	const int func_id = GetObjectFuncIndex(vi.datatype, tokenFunction.string_value);
	if (func_id == ERROR_INVALID_VALUE)
	{
		ListMethods(func_id, vi.datatype, next_text, -1);
		//
		AddError(machineCode, tokenFunction, ERROR_INVALID_OBJECT_FUNC, ERROR_INVALID_VALUE);
		return;
	}
	if (tokenFunction.type == ERROR_INVALID_VALUE)
	{
		AddError(machineCode, tokenFunction, ERROR_INVALID_OBJECT_FUNC, ERROR_INVALID_VALUE);
		return;
	}
	const int paramCount = GetFuncParamCount(func_id);

	Next(machineCode);  // Function Name
	//_________________________________________________________ LEFT PARENTHESIS
	IntelliSenseFuncInfo isfi;
	isfi.func_id = func_id;
	isfi.datatype = vi.datatype;
	isfi.parameterIndex = 0;
	sisfi.push(isfi);
	Match(machineCode, LEX_LEFT_PARENTHESIS);
	sisfi.pop();
	//
	for(int i=0; i<paramCount; i++)
	{
		if (lookahead.type == LEX_END_OF_FILE)
		{
			ListMethods(func_id, vi.datatype, NULL, i);
			AddError(machineCode, tokenFunction, ERROR_SYNTAX, -1);
			return;
		}
		//____________________________________________ Expression
		isfi.func_id = func_id;
		isfi.datatype = vi.datatype;
		isfi.parameterIndex = i;
		sisfi.push(isfi);
		Expression(machineCode);
		sisfi.pop();
		//____________________________________________ COMMA
		if (i<paramCount-1)
		{
			isfi.func_id = func_id;
			isfi.datatype = vi.datatype;
			isfi.parameterIndex = i;
			sisfi.push(isfi);
			Match(machineCode, LEX_COMMA);
			sisfi.pop();
		}
	}
	//__________________________________________________________ RIGHT PARENTHESIS
	isfi.func_id = func_id;
	isfi.datatype = vi.datatype;
	isfi.parameterIndex = paramCount-1;
	sisfi.push(isfi);
	Match(machineCode, LEX_RIGHT_PARENTHESIS);
	sisfi.pop();
	//
	Compiler::Instruction inst;
	//_____________________________ emitObject
	inst.type = VM_REFVALUE;
	inst.subtype = vi.datatype; // Object datatype
	inst.int_value = vi.index; // Object index
	inst.double_value = -1.0;
	_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"%s", tokenVariableId.string_value);
	inst.line_number = tokenVariableId.line_number;
	machineCode.push_back(inst);

	//_______________ emit Object Function
	inst.type = VM_OBJFUNC;
	inst.line_number = tokenFunction.line_number;
	inst.subtype = func_id;//tokenFunction.type;
	_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"%s", tokenFunction.string_value);
	inst.int_value = paramCount;
	inst.double_value = vi.datatype; // Object datatype
	machineCode.push_back(inst);
}

void Compiler::VariableArray(vector<Compiler::Instruction>& machineCode, LexicalAnalyzer::Token& tokenVariableId, VariableInfo vi)
{
	//Next(machineCode); // ID

	if (lookahead.type != LEX_LEFT_BRACKET)
	{
		AddError(machineCode, tokenVariableId, ERROR_SYNTAX, ERROR_INVALID_VALUE);
		return;
	}

	if (vi.datatype == LEX_DATATYPE_MATRIX || vi.datatype == LEX_DATATYPE_COMPLEX_MATRIX)
	{
		Next(machineCode); // [
		Expression(machineCode);
		Match(machineCode, LEX_RIGHT_BRACKET); // ]
		Match(machineCode, LEX_LEFT_BRACKET); // [
		Expression(machineCode);
		Match(machineCode, LEX_RIGHT_BRACKET); // ]
		
		
		if (lookahead.type == LEX_EQUAL)//  x = expression;
		{
			Next(machineCode); // =
			Expression(machineCode);
			//_____________________________ emit
			Compiler::Instruction inst;
			inst.type = VM_SET_MATRIXCELL;
			inst.subtype = vi.datatype;
			inst.int_value = vi.index;
			inst.double_value = 0.0;
			_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"%s[][]", tokenVariableId.string_value);
			inst.line_number = tokenVariableId.line_number;
			machineCode.push_back(inst);
		}
	}
	else if (vi.datatype == LEX_DATATYPE_VECTOR || vi.datatype == LEX_DATATYPE_COMPLEX_VECTOR)
	{
		Next(machineCode); // [
		Expression(machineCode);
		Match(machineCode, LEX_RIGHT_BRACKET); // ]
		
		if (lookahead.type == LEX_EQUAL)//  x = expression;
		{
			Next(machineCode); // =
			Expression(machineCode);
			//_____________________________ emit
			Compiler::Instruction inst;
			inst.type = VM_SET_VECTORCELL;
			inst.subtype = vi.datatype;
			inst.int_value = vi.index;
			inst.double_value = 0.0;
			_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"%s[]", tokenVariableId.string_value);
			inst.line_number = tokenVariableId.line_number;
			machineCode.push_back(inst);
		}
	}
	else
	{
		AddError(machineCode, tokenVariableId, ERROR_SYNTAX, ERROR_INVALID_VALUE);
	}
}

Compiler::VariableInfo Compiler::GetVariableInfo(LexicalAnalyzer::Token& token)
{
	Compiler::VariableInfo vi;
	vi.index = ERROR_INVALID_VALUE;
	vi.datatype = ERROR_INVALID_VALUE;
	map<wstring, Compiler::VariableInfo>::iterator p = variableInfo.find(token.string_value);
	if (p ==variableInfo.end()) return vi;
	return p->second;
}

// 5*x+8/y
void Compiler::Expression(vector<Compiler::Instruction>& machineCode)
{
	LexicalAnalyzer::Token token;
	Term(machineCode);
	while(true)
	{
		if (lookahead.type== LEX_PLUS || lookahead.type== LEX_MINUS
			|| lookahead.type == LEX_OR || lookahead.type == LEX_AND)
		{
			token = lookahead;
			Next(machineCode);
			Term(machineCode);
			//_________________________ Instruction
			Instruction inst;
			inst.type = VM_OPER;
			inst.line_number = token.line_number;
			inst.subtype = token.type;
			_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"%s", token.string_value);
			inst.int_value = -1;
			inst.double_value = -1.0;
			machineCode.push_back(inst);
			continue;
		}
		break;
	}
}

void Compiler::Term(vector<Compiler::Instruction>& machineCode)
{
	LexicalAnalyzer::Token token;
	Factor(machineCode);
	while(true)
	{
		if (lookahead.type == LEX_ASTERISK || lookahead.type == LEX_DIVISION || lookahead.type == LEX_PERCENT_SIGN
				|| lookahead.type== LEX_IS_BIGGER || lookahead.type== LEX_IS_BIGGER_EQ
				|| lookahead.type== LEX_IS_LESS || lookahead.type== LEX_IS_LESS_EQ
				|| lookahead.type== LEX_IS_EQUAL || lookahead.type== LEX_IS_DIFFERENT)
		{
			token = lookahead;
			Next(machineCode);
			Factor(machineCode);
			//___________________ Instruction
			Compiler::Instruction inst;
			inst.type = VM_OPER;
			inst.line_number = token.line_number;
			inst.subtype = token.type;
			_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"%s", token.string_value);
			inst.int_value = 2;
			inst.double_value = 2.0;
			machineCode.push_back(inst);
			continue;
		}
		break;
	}
}

void Compiler::Factor(vector<Compiler::Instruction>& machineCode)
{
	if (lookahead.type == LEX_LEFT_PARENTHESIS)
	{
		Next(machineCode);  // (
		Expression(machineCode);
		Match(machineCode, LEX_RIGHT_PARENTHESIS); // )
	}
	else if (lookahead.type == LEX_MINUS) // -2.0, -sin(x), -x
	{
		Next(machineCode); // -
		if  (lookahead.type == LEX_CONST_VALUE_INTEGER || lookahead.type == LEX_CONST_VALUE_DOUBLE)
		{
			//______________________________ Instruction
			Compiler::Instruction inst;
			inst.type = VM_VALUE;
			inst.line_number = lookahead.line_number;
			if (lookahead.type == LEX_CONST_VALUE_INTEGER)
			{
				inst.subtype = LEX_DATATYPE_INTEGER;
			}
			else if (lookahead.type == LEX_CONST_VALUE_DOUBLE)
			{
				inst.subtype = LEX_DATATYPE_DOUBLE;
			}
			inst.int_value = - lookahead.int_value;
			inst.double_value = - lookahead.double_value;
			_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"-%s", lookahead.string_value);
			machineCode.push_back(inst);
			//
			Next(machineCode); // integer or double value
		}
		else if (lookahead.type == LEX_ID)
		{
			//_______________________________________ Push a -1
			Compiler::Instruction inst;
			inst.type = VM_VALUE;
			inst.line_number = lookahead.line_number;
			inst.subtype = LEX_DATATYPE_DOUBLE;
			inst.int_value = - 1;
			inst.double_value = - 1.0;
			_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"-1.0");
			machineCode.push_back(inst);
			//
			FactorId(machineCode);
			//
			//_______________________________________ Push a product
			inst.type = VM_OPER;
			//inst.line_number = token.line_number; // Use the same line number
			inst.subtype = LEX_ASTERISK;
			_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"*");
			inst.int_value = -1;
			inst.double_value = -1.0;
			machineCode.push_back(inst);
		}
		else if (LEX_FUNC_SIN <= lookahead.type && lookahead.type<=LEX_FUNC_ISPRIME)
		{
			//_______________________________________ Push a -1
			Compiler::Instruction inst;
			inst.type = VM_VALUE;
			inst.line_number = lookahead.line_number;
			inst.subtype = LEX_DATATYPE_DOUBLE;
			inst.int_value = - 1;
			inst.double_value = - 1.0;
			_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"-1.0");
			machineCode.push_back(inst);
			//
			FunctionCall(machineCode);
			//_______________________________________ Push a product
			inst.type = VM_OPER;
			//inst.line_number = token.line_number; // Use the same line number
			inst.subtype = LEX_ASTERISK;
			_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"*");
			inst.int_value = -1;
			inst.double_value = -1.0;
			machineCode.push_back(inst);
		}
		else
		{
			AddError(machineCode, lookahead, ERROR_SYNTAX, ERROR_INVALID_VALUE);
		}
	}
	else if  ( lookahead.type == LEX_CONST_VALUE_BOOL 
		|| lookahead.type == LEX_CONST_VALUE_INTEGER 
		|| lookahead.type == LEX_CONST_VALUE_DOUBLE)
	{
		//______________________________ Instruction
		Compiler::Instruction inst;
		inst.type = VM_VALUE;
		inst.line_number = lookahead.line_number;
		if (lookahead.type == LEX_CONST_VALUE_BOOL)
		{
			inst.subtype = LEX_DATATYPE_BOOL;
		}
		else if (lookahead.type == LEX_CONST_VALUE_INTEGER)
		{
			inst.subtype = LEX_DATATYPE_INTEGER;
		}
		else if (lookahead.type == LEX_CONST_VALUE_DOUBLE)
		{
			inst.subtype = LEX_DATATYPE_DOUBLE;
		}
		inst.int_value = lookahead.int_value;
		inst.double_value = lookahead.double_value;
		_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"%s", lookahead.string_value);
		machineCode.push_back(inst);
		//
		Next(machineCode);
	}
	else if (lookahead.type == LEX_ID)
	{
		FactorId(machineCode);
	}
	else if (LEX_FUNC_SIN <= lookahead.type && lookahead.type<=LEX_FUNC_ISPRIME)
	{
		FunctionCall(machineCode);
	}
	else
	{
		AddError(machineCode, lookahead, ERROR_SYNTAX, ERROR_INVALID_VALUE);
	}
}

void Compiler::FactorId(vector<Compiler::Instruction>& machineCode)
{
	LexicalAnalyzer::Token tokenVariableId = lookahead;
	map<wstring, VariableInfo>::iterator p = variableInfo.find(lookahead.string_value);
	Next(machineCode);
	if (p== variableInfo.end())
	{
		AddError(machineCode, tokenVariableId, ERROR_VARIABLE_NOEXISTS, ERROR_INVALID_VALUE);
		return;
	}
	
	if (lookahead.type == LEX_LEFT_BRACKET)
	{
		if (p->second.datatype == LEX_DATATYPE_MATRIX || p->second.datatype == LEX_DATATYPE_COMPLEX_MATRIX)
		{
			Next(machineCode); // [
			Expression(machineCode);
			Match(machineCode, LEX_RIGHT_BRACKET); // ]
			Match(machineCode, LEX_LEFT_BRACKET); // [
			Expression(machineCode);
			Match(machineCode, LEX_RIGHT_BRACKET); // ]
			//_____________________________ emit
			Compiler::Instruction inst;
			inst.type = VM_MATRIX_CELL;
			inst.subtype = tokenVariableId.type;
			inst.int_value = p->second.index;
			inst.double_value = p->second.datatype;
			_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"%s", tokenVariableId.string_value);
			inst.line_number = tokenVariableId.line_number;
			machineCode.push_back(inst);
			return;
		}
		else if (p->second.datatype == LEX_DATATYPE_VECTOR || p->second.datatype == LEX_DATATYPE_COMPLEX_VECTOR)
		{
			Next(machineCode); // [
			Expression(machineCode);
			Match(machineCode, LEX_RIGHT_BRACKET); // ]
			//_____________________________ emit
			Compiler::Instruction inst;
			inst.type = VM_VECTOR_CELL;
			inst.subtype = tokenVariableId.type;
			inst.int_value = p->second.index;
			inst.double_value = p->second.datatype;
			_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"%s", tokenVariableId.string_value);
			inst.line_number = tokenVariableId.line_number;
			machineCode.push_back(inst);
			return;
		}
		else
		{
			AddError(machineCode, tokenVariableId, ERROR_SYNTAX, ERROR_INVALID_VALUE);
			return;
		}
	}
	else if (lookahead.type == LEX_DOT)
	{
		ObjectFunction(machineCode, tokenVariableId, p->second);
	}
	else if (tokenVariableId.type == LEX_DATATYPE_MATRIX || LEX_DATATYPE_COMPLEX_MATRIX 
		|| tokenVariableId.type == LEX_DATATYPE_VECTOR || tokenVariableId.type == LEX_DATATYPE_COMPLEX_VECTOR
		|| tokenVariableId.type == LEX_DATATYPE_BOOL || tokenVariableId.type == LEX_DATATYPE_DOUBLE
		|| tokenVariableId.type == LEX_DATATYPE_INTEGER)
	{
		//_____________________________ emit
		Compiler::Instruction inst;
		inst.type = VM_REFVALUE;
		inst.subtype = p->second.datatype;
		inst.int_value = p->second.index;
		inst.double_value = -1.0;
		_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"%s", tokenVariableId.string_value);
		inst.line_number = tokenVariableId.line_number;
		machineCode.push_back(inst);
	}
	else
	{
		AddError(machineCode, tokenVariableId, ERROR_SYNTAX, ERROR_INVALID_VALUE);
	}
}

void Compiler::FunctionCall(vector<Compiler::Instruction>& machineCode)
{
		LexicalAnalyzer::Token tokenFunction = lookahead;
		Next(machineCode);
		//
		Match(machineCode, LEX_LEFT_PARENTHESIS);
		const int paramCount = GetFuncParamCount(tokenFunction.type);
		if (paramCount == 1)
		{
			Expression(machineCode);
		}
		else if (paramCount == 2)
		{
			Expression(machineCode);
			Match(machineCode, LEX_COMMA);
			Expression(machineCode);
		}
		Match(machineCode, LEX_RIGHT_PARENTHESIS);
		//_____________________________ emit
		Compiler::Instruction inst;
		inst.type = VM_FUNC;
		inst.subtype = tokenFunction.type;
		_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"%s", tokenFunction.string_value);
		inst.line_number = tokenFunction.line_number;
		inst.int_value = GetFuncParamCount(tokenFunction.type); // The number of parameters
		inst.double_value = inst.int_value;
		machineCode.push_back(inst);
}

// It returns the next variable index
void Compiler::CreateVariable(vector<Compiler::Instruction>& machineCode, LexicalAnalyzer::Token& tokenDataType, LexicalAnalyzer::Token& tokenID)
{
	int index = -1;
	if (LEX_DATATYPE_BOOL <= tokenDataType.type  && tokenDataType.type <= LEX_DATATYPE_PROBNET)
	{
		index = memInfo[tokenDataType.type-LEX_DATATYPE_BOOL]++;
	}

	if (index == -1)
	{
		AddError(machineCode, tokenDataType, ERROR_SYNTAX, ERROR_INVALID_VALUE);
	}

	Instruction inst;
	inst.type = VM_CREATE;
	inst.subtype = tokenDataType.type;
	inst.line_number = tokenDataType.line_number;
	inst.int_value = index;
	inst.double_value = index;
	_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"%s", tokenID.string_value);
	
	//____________________________________ store IDs
	VariableInfo vi;
	vi.index = index;
	vi.datatype = tokenDataType.type;
	pair< map<wstring, VariableInfo>::iterator, bool > pr;
	pr = variableInfo.insert(std::pair<wstring, Compiler::VariableInfo>(lookahead.string_value, vi));
	if (pr.second==false)
	{
		AddError(machineCode, tokenID, ERROR_VARIABLE_ALLREADY_DEFINED, ERROR_INVALID_VALUE);
	}
	//
	machineCode.push_back(inst);
}

int Compiler::GetObjectFuncIndex(int datatype, const wchar_t* text)
{
	switch(datatype)
	{
	//case LEX_DATATYPE_BOOL:
	//case LEX_DATATYPE_DOUBLE:
	//case LEX_DATATYPE_INTEGER:
	//case LEX_DATATYPE_VOID:
	//	return LEX_ERROR;
	case LEX_DATATYPE_MATRIX:
	case LEX_DATATYPE_COMPLEX_MATRIX:
		if (wcscmp(text, L"Create")==0) return LEX_FUNC_MATRIX_CREATE;
		else if (wcscmp(text, L"CreateRandom")==0) return LEX_FUNC_MATRIX_CREATE_RANDOM;
		else if (wcscmp(text, L"Save")==0) return LEX_FUNC_MATRIX_SAVE;
		else if (wcscmp(text, L"Load")==0) return LEX_FUNC_MATRIX_LOAD;
		else if (wcscmp(text, L"AppendRight")==0) return LEX_FUNC_MATRIX_APPEND_RIGHT;
		else if (wcscmp(text, L"AppendDown")==0) return LEX_FUNC_MATRIX_APPEND_DOWN;
		else if (wcscmp(text, L"DeleteRow")==0) return LEX_FUNC_MATRIX_DELETE_ROW;
		else if (wcscmp(text, L"DeleteCol")==0) return LEX_FUNC_MATRIX_DELETE_COL;
		else if (wcscmp(text, L"InsertRow")==0) return LEX_FUNC_MATRIX_INSERT_ROW;
		else if (wcscmp(text, L"InsertCol")==0) return LEX_FUNC_MATRIX_INSERT_COL;
		else if (wcscmp(text, L"Delete")==0) return LEX_FUNC_MATRIX_DELETE;
		else if (wcscmp(text, L"GetRowCount")==0) return LEX_FUNC_MATRIX_GET_ROW_COUNT;
		else if (wcscmp(text, L"GetColCount")==0) return LEX_FUNC_MATRIX_GET_COL_COUNT;
		else if (wcscmp(text, L"GetSum")==0) return LEX_FUNC_MATRIX_GET_SUM;
		else if (wcscmp(text, L"GetDiagonalSum")==0) return LEX_FUNC_MATRIX_GET_DIAGONAL_SUM;
		else if (wcscmp(text, L"GetMean")==0) return LEX_FUNC_MATRIX_GET_MEAN;
		else if (wcscmp(text, L"GetVariance")==0) return LEX_FUNC_MATRIX_GET_VARIANCE;
		else if (wcscmp(text, L"GetMin")==0) return LEX_FUNC_MATRIX_GET_MINIMUM;
		else if (wcscmp(text, L"GetMax")==0) return LEX_FUNC_MATRIX_GET_MAXIMUM;
		else if (wcscmp(text, L"GetSumSquares")==0) return LEX_FUNC_MATRIX_GET_SUM_SQUARES;
		else if (wcscmp(text, L"GetRows")==0) return LEX_FUNC_MATRIX_GET_ROWS;
		else if (wcscmp(text, L"GetCols")==0) return LEX_FUNC_MATRIX_GET_COLS;
		else if (wcscmp(text, L"DeleteRows")==0) return LEX_FUNC_MATRIX_DELETE_ROWS;
		else if (wcscmp(text, L"DeleteCols")==0) return LEX_FUNC_MATRIX_DELETE_COLS;
		else if (wcscmp(text, L"GetClass")==0) return LEX_FUNC_MATRIX_GET_CLASS;
		else if (wcscmp(text, L"Transpose")==0) return LEX_FUNC_MATRIX_TRANSPOSE;
		else if (wcscmp(text, L"NormRows")==0) return LEX_FUNC_MATRIX_NORM_ROWS;
		else if (wcscmp(text, L"NormCols")==0) return LEX_FUNC_MATRIX_NORM_COLS;
		else if (wcscmp(text, L"RowsVar")==0) return LEX_FUNC_MATRIX_ROWS_VAR;
		else if (wcscmp(text, L"ColsVar")==0) return LEX_FUNC_MATRIX_COLS_VAR;
		else if (wcscmp(text, L"GetRow")==0) return LEX_FUNC_MATRIX_GET_ROW;
		else if (wcscmp(text, L"GetCol")==0) return LEX_FUNC_MATRIX_GET_COL;
		break;
	case LEX_DATATYPE_VECTOR:
	case LEX_DATATYPE_COMPLEX_VECTOR:
		if (wcscmp(text, L"Create")==0) return LEX_FUNC_VECTOR_CREATE;
		else if (wcscmp(text, L"CreateSeries")==0) return LEX_FUNC_VECTOR_CREATE_SERIES;
		else if (wcscmp(text, L"CreateRandom") == 0) return LEX_FUNC_VECTOR_CREATE_RANDOM;
		else if (wcscmp(text, L"CreateBinary") == 0) return LEX_FUNC_VECTOR_CREATE_BINARY;
		else if (wcscmp(text, L"Save")==0) return LEX_FUNC_VECTOR_SAVE;
		else if (wcscmp(text, L"Load")==0) return LEX_FUNC_VECTOR_LOAD;
		else if (wcscmp(text, L"InsertCell")==0) return LEX_FUNC_VECTOR_INSERT_CELL;
		else if (wcscmp(text, L"DeleteCell")==0) return LEX_FUNC_VECTOR_DELETE_CELL;
		else if (wcscmp(text, L"GetSize")==0) return LEX_FUNC_VECTOR_GET_SIZE;
		else if (wcscmp(text, L"GetSum")==0) return LEX_FUNC_VECTOR_GET_SUM;
		else if (wcscmp(text, L"GetMean")==0) return LEX_FUNC_VECTOR_GET_MEAN;
		else if (wcscmp(text, L"GetVariance")==0) return LEX_FUNC_VECTOR_GET_VARIANCE;
		else if (wcscmp(text, L"GetMin")==0) return LEX_FUNC_VECTOR_GET_MINIMUM;
		else if (wcscmp(text, L"GetMax")==0) return LEX_FUNC_VECTOR_GET_MAXIMUM;
		else if (wcscmp(text, L"GetSquaredSum")==0) return LEX_FUNC_VECTOR_GET_SQUARED_SUM;
		else if (wcscmp(text, L"CreateLoPassIR")==0) return LEX_FUNC_VECTOR_CREATE_LOW_PASS_IMP_RESP;
		else if (wcscmp(text, L"CreateLoPassFR")==0) return LEX_FUNC_VECTOR_CREATE_LOW_PASS_FREQ_RESP;
		else if (wcscmp(text, L"CreateHiPassIR")==0) return LEX_FUNC_VECTOR_CREATE_HIGH_PASS_IMP_RESP;
		else if (wcscmp(text, L"CreateHiPassFR")==0) return LEX_FUNC_VECTOR_CREATE_HIGH_PASS_FREQ_RESP;
		else if (wcscmp(text, L"CreateRandomSet")==0) return LEX_FUNC_VECTOR_CREATE_RANDOM_SET;
		else if (wcscmp(text, L"Wrap")==0) return LEX_FUNC_VECTOR_WRAP;
		else if (wcscmp(text, L"LineFit")==0) return LEX_FUNC_VECTOR_LINE_FIT;
			//	return LEX_ERROR;
	//case LEX_DATATYPE_COMPLEX:
			//	return LEX_ERROR;
	//
			//	return LEX_ERROR;
	//case LEX_DATATYPE_COMPLEX_MATRIX:
			//	return LEX_ERROR;
	//case LEX_DATATYPE_SCALER:
	//	if (wcscmp(text, L"CreateInputScaler")==0) return LEX_FUNC_SCALER_CREATEINPUTSCALER;
	//	else if (wcscmp(text, L"CreateOutputScaler")==0) return LEX_FUNC_SCALER_CREATEOUTPUTSCALER;
	//	else if (wcscmp(text, L"Delete")==0) return LEX_FUNC_SCALER_DELETE;
	//	else if (wcscmp(text, L"GetSize")==0) return LEX_FUNC_SCALER_GETSIZE;
	//	else if (wcscmp(text, L"Save")==0) return LEX_FUNC_SCALER_SAVE;
	//	else if (wcscmp(text, L"Load")==0) return LEX_FUNC_SCALER_LOAD;
	//	else if (wcscmp(text, L"Set")==0) return LEX_FUNC_SCALER_SET;
	//	else if (wcscmp(text, L"Scale")==0) return LEX_FUNC_SCALER_SCALE;
	//	else if (wcscmp(text, L"GetMinimum")==0) return LEX_FUNC_SCALER_GETMINIMUM;
	//	else if (wcscmp(text, L"GetMaximum")==0) return LEX_FUNC_SCALER_GETMAXIMUM;
	//	else if (wcscmp(text, L"AutoSetInputScaler")==0) return LEX_FUNC_SCALER_AUTOSETINPUTSCALER;
	//	else if (wcscmp(text, L"AutoSetOutputScaler")==0) return LEX_FUNC_SCALER_AUTOSETOUTPUTSCALER;
	//	break;
	case LEX_DATATYPE_LAYERNET:
		if (wcscmp(text, L"Create")==0) return LEX_FUNC_LAYERNET_CREATE;
		else if (wcscmp(text, L"Load")==0) return LEX_FUNC_LAYERNET_LOAD;
		else if (wcscmp(text, L"Save")==0) return LEX_FUNC_LAYERNET_SAVE;
		else if (wcscmp(text, L"SetWeights")==0) return LEX_FUNC_LAYERNET_SET_WEIGHTS;
		else if (wcscmp(text, L"GetWeights")==0) return LEX_FUNC_LAYERNET_GET_WEIGHTS;
		else if (wcscmp(text, L"GetInputCount")==0) return LEX_FUNC_LAYERNET_GET_INPUT_COUNT;
		else if (wcscmp(text, L"GetOutputCount")==0) return LEX_FUNC_LAYERNET_GET_OUTPUT_COUNT;
		else if (wcscmp(text, L"GetHid1NeCount")==0) return LEX_FUNC_LAYERNET_GET_HIDD1_NEU_COUNT;
		else if (wcscmp(text, L"GetHid2NeCount")==0) return LEX_FUNC_LAYERNET_GET_HIDD2_NEU_COUNT;
		else if (wcscmp(text, L"GetLayerCount")==0) return LEX_FUNC_LAYERNET_GET_LAYER_COUNT;
		else if (wcscmp(text, L"Delete")==0) return LEX_FUNC_LAYERNET_DELETE;
		else if (wcscmp(text, L"Unlearn")==0) return LEX_FUNC_LAYERNET_UNLEARN;
		else if (wcscmp(text, L"AutoSetInScaler")==0) return LEX_FUNC_LAYERNET_AUTO_SET_INPUT_SCALER;
		else if (wcscmp(text, L"AutoSetOutScaler")==0) return LEX_FUNC_LAYERNET_AUTO_SET_OUTPUT_SCALER;
		else if (wcscmp(text, L"SetInScaler")==0) return LEX_FUNC_LAYERNET_SET_INPUT_SCALER;
		else if (wcscmp(text, L"SetOutScaler")==0) return LEX_FUNC_LAYERNET_SET_OUTPUT_SCALER;
		else if (wcscmp(text, L"GetInScaler")==0) return LEX_FUNC_LAYERNET_GET_INPUT_SCALER;
		else if (wcscmp(text, L"GetOutScaler")==0) return LEX_FUNC_LAYERNET_GET_OUTPUT_SCALER;
		else if (wcscmp(text, L"SetTrainSet")==0) return LEX_FUNC_LAYERNET_SET_TRAINING_SET;
		else if (wcscmp(text, L"TrainGenetic")==0) return LEX_FUNC_LAYERNET_TRAIN_GENETIC;
		else if (wcscmp(text, L"TrainSimAnneal")==0) return LEX_FUNC_LAYERNET_TRAIN_SIMULATE_ANNEALING;
		else if (wcscmp(text, L"TrainConjGrad")==0) return LEX_FUNC_LAYERNET_TRAIN_CONJUGATE_GRADIENT;
		else if (wcscmp(text, L"TrainVarMetric")==0) return LEX_FUNC_LAYERNET_TRAIN_VARIABLE_METRIC;
		else if (wcscmp(text, L"TrainLevenMar")==0) return LEX_FUNC_LAYERNET_TRAIN_LEVENBERG_MARQUARDT;
		else if (wcscmp(text, L"TrainRegression")==0) return LEX_FUNC_LAYERNET_TRAIN_REGRESSION;
		else if (wcscmp(text, L"GetMinNoTrCs")==0) return LEX_FUNC_LAYERNET_GET_MIN_NUM_TRAIN_CASES;
		else if (wcscmp(text, L"Run")==0) return LEX_FUNC_LAYERNET_RUN;
		break;
	case LEX_DATATYPE_KOHONET:
		if (wcscmp(text, L"Create")==0) return LEX_FUNC_KOHONET_CREATE;
		else if (wcscmp(text, L"Save")==0) return LEX_FUNC_KOHONET_SAVE;
		else if (wcscmp(text, L"Load")==0) return LEX_FUNC_KOHONET_LOAD;
		break;
	case LEX_DATATYPE_PROBNET:
		if (wcscmp(text, L"Create")==0) return LEX_FUNC_PROBNET_CREATE;
		else if (wcscmp(text, L"Save")==0) return LEX_FUNC_PROBNET_SAVE;
		else if (wcscmp(text, L"Load")==0) return LEX_FUNC_PROBNET_LOAD;	
		break;
	}
	return ERROR_INVALID_VALUE;
}

int Compiler::GetObjectFuncReturnType(int datatype, int func_id)
{
	switch(func_id)
	{
	case LEX_FUNC_SIN: return datatype;
	case LEX_FUNC_COS: return datatype;
	case LEX_FUNC_TAN: return datatype;
	case LEX_FUNC_ASIN: return datatype;
	case LEX_FUNC_ACOS: return datatype;
	case LEX_FUNC_ATAN: return datatype;
	case LEX_FUNC_SINH: return datatype;
	case LEX_FUNC_COSH: return datatype;
	case LEX_FUNC_TANH: return datatype;
	case LEX_FUNC_SQRT: return datatype;
	case LEX_FUNC_LOG10: return datatype;
	case LEX_FUNC_LOG: return datatype;
	case LEX_FUNC_EXP: return datatype;
	case LEX_FUNC_POW: return datatype;
	case LEX_FUNC_ABS: return datatype;
	case LEX_FUNC_SINC: return datatype;
	case LEX_FUNC_TRIANG: return datatype;
	case LEX_FUNC_SAW: return datatype;
	case LEX_FUNC_RECT: return datatype;
	case LEX_FUNC_CEIL: return LEX_DATATYPE_DOUBLE;
	case LEX_FUNC_FLOOR: return LEX_DATATYPE_DOUBLE;
	case LEX_FUNC_TOINT: return LEX_DATATYPE_INTEGER;
	case LEX_FUNC_FFT:
		if (datatype == LEX_DATATYPE_VECTOR) return LEX_DATATYPE_COMPLEX_VECTOR;
		if (datatype == LEX_DATATYPE_MATRIX) return LEX_DATATYPE_COMPLEX_MATRIX;
		if (datatype == LEX_DATATYPE_COMPLEX_VECTOR) return LEX_DATATYPE_COMPLEX_VECTOR;
		if (datatype == LEX_DATATYPE_COMPLEX_MATRIX) return LEX_DATATYPE_COMPLEX_MATRIX;
		return LEX_DATATYPE_COMPLEX_MATRIX;
	case LEX_FUNC_IFFT:
		if (datatype == LEX_DATATYPE_COMPLEX_VECTOR) return LEX_DATATYPE_COMPLEX_VECTOR;
		if (datatype == LEX_DATATYPE_COMPLEX_MATRIX) return LEX_DATATYPE_COMPLEX_MATRIX;
		//if (datatype == LEX_DATATYPE_COMPLEX_VECTOR) return LEX_DATATYPE_COMPLEX_VECTOR;
		//if (datatype == LEX_DATATYPE_COMPLEX_MATRIX) return LEX_DATATYPE_COMPLEX_MATRIX;
		return LEX_DATATYPE_COMPLEX_MATRIX;
	case LEX_FUNC_REALFFT:
		if (datatype == LEX_DATATYPE_VECTOR) return LEX_DATATYPE_VECTOR;
		if (datatype == LEX_DATATYPE_MATRIX) return LEX_DATATYPE_MATRIX;
		return LEX_DATATYPE_MATRIX;
	case LEX_FUNC_IREALFFT:
		if (datatype == LEX_DATATYPE_VECTOR) return LEX_DATATYPE_VECTOR;
		if (datatype == LEX_DATATYPE_MATRIX) return LEX_DATATYPE_MATRIX;
		return LEX_DATATYPE_MATRIX;
	case LEX_FUNC_SPECTRUM:
		if (datatype == LEX_DATATYPE_VECTOR) return LEX_DATATYPE_VECTOR;
		if (datatype == LEX_DATATYPE_MATRIX) return LEX_DATATYPE_MATRIX;
		if (datatype == LEX_DATATYPE_COMPLEX_VECTOR) return LEX_DATATYPE_VECTOR;
		if (datatype == LEX_DATATYPE_COMPLEX_MATRIX) return LEX_DATATYPE_MATRIX;
		return LEX_DATATYPE_MATRIX;
	case LEX_FUNC_CONVOLUTION: return LEX_DATATYPE_VECTOR;
	case LEX_FUNC_SHORT_CONVOLUTION: return LEX_DATATYPE_VECTOR;
	case LEX_FUNC_COMPUTE_MSE: return LEX_DATATYPE_DOUBLE;
	case LEX_FUNC_CONFUSION_MATRIX: return LEX_DATATYPE_MATRIX;
	case LEX_FUNC_RAND: return LEX_DATATYPE_DOUBLE;
	case LEX_FUNC_RANDI: return LEX_DATATYPE_INTEGER;
	case LEX_FUNC_ISPRIME: return LEX_DATATYPE_BOOL;
	//
	case LEX_FUNC_MATRIX_CREATE: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_MATRIX_CREATE_RANDOM: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_MATRIX_SAVE: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_MATRIX_LOAD: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_MATRIX_APPEND_RIGHT: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_MATRIX_APPEND_DOWN: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_MATRIX_DELETE_ROW: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_MATRIX_DELETE_COL: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_MATRIX_INSERT_ROW: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_MATRIX_INSERT_COL: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_MATRIX_DELETE: return LEX_DATATYPE_VOID;
	case LEX_FUNC_MATRIX_GET_ROW_COUNT: return LEX_DATATYPE_INTEGER;
	case LEX_FUNC_MATRIX_GET_COL_COUNT: return LEX_DATATYPE_INTEGER;
	case LEX_FUNC_MATRIX_GET_SUM: return datatype == LEX_DATATYPE_MATRIX ? LEX_DATATYPE_DOUBLE : LEX_DATATYPE_COMPLEX;
	case LEX_FUNC_MATRIX_GET_DIAGONAL_SUM: return datatype == LEX_DATATYPE_MATRIX ? LEX_DATATYPE_DOUBLE : LEX_DATATYPE_COMPLEX;
	case LEX_FUNC_MATRIX_GET_MEAN: return datatype == LEX_DATATYPE_MATRIX ? LEX_DATATYPE_DOUBLE : LEX_DATATYPE_COMPLEX;
	case LEX_FUNC_MATRIX_GET_VARIANCE: return datatype == LEX_DATATYPE_MATRIX ? LEX_DATATYPE_DOUBLE : LEX_DATATYPE_COMPLEX;
	case LEX_FUNC_MATRIX_GET_MINIMUM: return datatype == LEX_DATATYPE_MATRIX ? LEX_DATATYPE_DOUBLE : LEX_DATATYPE_COMPLEX;
	case LEX_FUNC_MATRIX_GET_MAXIMUM: return datatype == LEX_DATATYPE_MATRIX ? LEX_DATATYPE_DOUBLE : LEX_DATATYPE_COMPLEX;
	case LEX_FUNC_MATRIX_GET_SUM_SQUARES: return datatype == LEX_DATATYPE_MATRIX ? LEX_DATATYPE_DOUBLE : LEX_DATATYPE_COMPLEX;
	case LEX_FUNC_MATRIX_GET_ROWS: return datatype;
	case LEX_FUNC_MATRIX_GET_COLS: return datatype;
	case LEX_FUNC_MATRIX_DELETE_ROWS: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_MATRIX_DELETE_COLS: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_MATRIX_GET_CLASS: return LEX_DATATYPE_VECTOR;
	case LEX_FUNC_MATRIX_TRANSPOSE: return datatype;
	case LEX_FUNC_MATRIX_NORM_ROWS: return LEX_DATATYPE_VOID;
	case LEX_FUNC_MATRIX_NORM_COLS: return LEX_DATATYPE_VOID;
	case LEX_FUNC_MATRIX_ROWS_VAR: return LEX_DATATYPE_VECTOR;
	case LEX_FUNC_MATRIX_COLS_VAR: return LEX_DATATYPE_VECTOR;
	case LEX_FUNC_MATRIX_GET_ROW: return datatype == LEX_DATATYPE_MATRIX ? LEX_DATATYPE_VECTOR : LEX_DATATYPE_COMPLEX_VECTOR;
	case LEX_FUNC_MATRIX_GET_COL: return datatype == LEX_DATATYPE_MATRIX ? LEX_DATATYPE_VECTOR : LEX_DATATYPE_COMPLEX_VECTOR;
	//________________________________________________________________________________
	case LEX_FUNC_VECTOR_CREATE: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_VECTOR_CREATE_SERIES: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_VECTOR_CREATE_RANDOM: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_VECTOR_CREATE_BINARY: return LEX_DATATYPE_INTEGER;
	case LEX_FUNC_VECTOR_SAVE: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_VECTOR_LOAD: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_VECTOR_INSERT_CELL: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_VECTOR_DELETE_CELL: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_VECTOR_GET_SIZE: return LEX_DATATYPE_INTEGER;
	case LEX_FUNC_VECTOR_GET_SUM: return datatype == LEX_DATATYPE_VECTOR ? LEX_DATATYPE_DOUBLE : LEX_DATATYPE_COMPLEX;
	case LEX_FUNC_VECTOR_GET_MEAN: return datatype == LEX_DATATYPE_VECTOR ? LEX_DATATYPE_DOUBLE : LEX_DATATYPE_COMPLEX;
	case LEX_FUNC_VECTOR_GET_VARIANCE: return datatype == LEX_DATATYPE_VECTOR ? LEX_DATATYPE_DOUBLE : LEX_DATATYPE_COMPLEX;
	case LEX_FUNC_VECTOR_GET_MINIMUM: return datatype == LEX_DATATYPE_VECTOR ? LEX_DATATYPE_DOUBLE : LEX_DATATYPE_COMPLEX;
	case LEX_FUNC_VECTOR_GET_MAXIMUM: return datatype == LEX_DATATYPE_VECTOR ? LEX_DATATYPE_DOUBLE : LEX_DATATYPE_COMPLEX;
	case LEX_FUNC_VECTOR_GET_SQUARED_SUM: return datatype == LEX_DATATYPE_VECTOR ? LEX_DATATYPE_DOUBLE : LEX_DATATYPE_COMPLEX;
	case LEX_FUNC_VECTOR_CREATE_LOW_PASS_IMP_RESP: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_VECTOR_CREATE_LOW_PASS_FREQ_RESP: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_VECTOR_CREATE_HIGH_PASS_IMP_RESP: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_VECTOR_CREATE_HIGH_PASS_FREQ_RESP: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_VECTOR_CREATE_RANDOM_SET: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_VECTOR_WRAP: return datatype == LEX_DATATYPE_VECTOR ? LEX_DATATYPE_MATRIX : LEX_DATATYPE_COMPLEX_MATRIX;
	case LEX_FUNC_VECTOR_LINE_FIT: return datatype;
	//
	//case LEX_FUNC_SCALER_CREATEINPUTSCALER: return LEX_DATATYPE_BOOL;
	//case LEX_FUNC_SCALER_CREATEOUTPUTSCALER: return LEX_DATATYPE_BOOL;
	//case LEX_FUNC_SCALER_DELETE: return LEX_DATATYPE_VOID;
	//case LEX_FUNC_SCALER_GETSIZE: return LEX_DATATYPE_INTEGER ;
	//case LEX_FUNC_SCALER_SAVE: return LEX_DATATYPE_BOOL;
	//case LEX_FUNC_SCALER_LOAD: return LEX_DATATYPE_BOOL;
	//case LEX_FUNC_SCALER_SET: return LEX_DATATYPE_BOOL;
	//case LEX_FUNC_SCALER_SCALE: return LEX_DATATYPE_BOOL;
	//case LEX_FUNC_SCALER_GETMINIMUM: return LEX_DATATYPE_DOUBLE ;
	//case LEX_FUNC_SCALER_GETMAXIMUM: return LEX_DATATYPE_DOUBLE ;
	//case LEX_FUNC_SCALER_AUTOSETINPUTSCALER: return LEX_DATATYPE_BOOL;
	//case LEX_FUNC_SCALER_AUTOSETOUTPUTSCALER: return LEX_DATATYPE_BOOL;
	//
	case LEX_FUNC_LAYERNET_CREATE: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_LAYERNET_LOAD: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_LAYERNET_SAVE: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_LAYERNET_SET_WEIGHTS: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_LAYERNET_GET_WEIGHTS: return LEX_DATATYPE_MATRIX;
	case LEX_FUNC_LAYERNET_GET_INPUT_COUNT: return LEX_DATATYPE_INTEGER;
	case LEX_FUNC_LAYERNET_GET_OUTPUT_COUNT: return LEX_DATATYPE_INTEGER;
	case LEX_FUNC_LAYERNET_GET_HIDD1_NEU_COUNT: return LEX_DATATYPE_INTEGER;
	case LEX_FUNC_LAYERNET_GET_HIDD2_NEU_COUNT: return LEX_DATATYPE_INTEGER;
	case LEX_FUNC_LAYERNET_GET_LAYER_COUNT: return LEX_DATATYPE_INTEGER;
	case LEX_FUNC_LAYERNET_DELETE: return LEX_DATATYPE_VOID;
	case LEX_FUNC_LAYERNET_UNLEARN: return LEX_DATATYPE_VOID;
	case LEX_FUNC_LAYERNET_AUTO_SET_INPUT_SCALER: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_LAYERNET_AUTO_SET_OUTPUT_SCALER: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_LAYERNET_SET_INPUT_SCALER: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_LAYERNET_SET_OUTPUT_SCALER: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_LAYERNET_GET_INPUT_SCALER: return LEX_DATATYPE_VECTOR;
	case LEX_FUNC_LAYERNET_GET_OUTPUT_SCALER: return LEX_DATATYPE_VECTOR;
	case LEX_FUNC_LAYERNET_SET_TRAINING_SET: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_LAYERNET_TRAIN_GENETIC: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_LAYERNET_TRAIN_SIMULATE_ANNEALING: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_LAYERNET_TRAIN_CONJUGATE_GRADIENT: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_LAYERNET_TRAIN_VARIABLE_METRIC: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_LAYERNET_TRAIN_LEVENBERG_MARQUARDT: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_LAYERNET_TRAIN_REGRESSION: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_LAYERNET_GET_MIN_NUM_TRAIN_CASES: return LEX_DATATYPE_INTEGER;
	case LEX_FUNC_LAYERNET_RUN: return LEX_DATATYPE_MATRIX;
	//
	case LEX_FUNC_KOHONET_CREATE: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_KOHONET_SAVE: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_KOHONET_LOAD: return LEX_DATATYPE_BOOL;
	//
	case LEX_FUNC_PROBNET_CREATE: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_PROBNET_SAVE: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_PROBNET_LOAD: return LEX_DATATYPE_BOOL;	
	}
	return ERROR_INVALID_VALUE;
}

int Compiler::GetFuncParamCount(int func_id)
{
	switch(func_id)
	{
	case LEX_FUNC_SIN: return 1;
	case LEX_FUNC_COS: return 1;
	case LEX_FUNC_TAN: return 1;
	case LEX_FUNC_ASIN: return 1;
	case LEX_FUNC_ACOS: return 1;
	case LEX_FUNC_ATAN: return 1;
	case LEX_FUNC_SINH: return 1;
	case LEX_FUNC_COSH: return 1;
	case LEX_FUNC_TANH: return 1;
	case LEX_FUNC_SQRT: return 1;
	case LEX_FUNC_LOG10: return 1;
	case LEX_FUNC_LOG: return 1;
	case LEX_FUNC_EXP: return 1;
	case LEX_FUNC_POW: return 2;
	case LEX_FUNC_ABS: return 1;
	case LEX_FUNC_SINC: return 1;
	case LEX_FUNC_TRIANG: return 1;
	case LEX_FUNC_SAW: return 1;
	case LEX_FUNC_RECT: return 1;
	case LEX_FUNC_CEIL: return 1;
	case LEX_FUNC_FLOOR: return 1;
	case LEX_FUNC_TOINT: return 1;
	case LEX_FUNC_FFT: return 1;
	case LEX_FUNC_IFFT: return 1;
	case LEX_FUNC_REALFFT: return 1;
	case LEX_FUNC_IREALFFT: return 1;
	case LEX_FUNC_SPECTRUM: return 1;
	case LEX_FUNC_CONVOLUTION: return 2;
	case LEX_FUNC_SHORT_CONVOLUTION: return 2;
	case LEX_FUNC_COMPUTE_MSE: return 2;
	case LEX_FUNC_CONFUSION_MATRIX: return 2;
	case LEX_FUNC_RAND: return 1;	
	//case LEX_FUNC_INT_BIT: return 1;
	case LEX_FUNC_RANDI: return 1;
	case LEX_FUNC_ISPRIME: return 1;
	//case LEX_FUNC_BESSELJ0: return 1;
	//case LEX_FUNC_BESSELJ1: return 1;
	//case LEX_FUNC_BESSELY0: return 1;
	//case LEX_FUNC_BESSELY1: return 1;
	//
	case LEX_FUNC_MATRIX_CREATE: return 2;
	case LEX_FUNC_MATRIX_CREATE_RANDOM: return 4;
	case LEX_FUNC_MATRIX_SAVE: return 0;
	case LEX_FUNC_MATRIX_LOAD: return 0;
	case LEX_FUNC_MATRIX_APPEND_RIGHT: return 1;
	case LEX_FUNC_MATRIX_APPEND_DOWN: return 1;
	case LEX_FUNC_MATRIX_DELETE_ROW: return 1;
	case LEX_FUNC_MATRIX_DELETE_COL: return 1;
	case LEX_FUNC_MATRIX_INSERT_ROW: return 1;
	case LEX_FUNC_MATRIX_INSERT_COL: return 1;
	case LEX_FUNC_MATRIX_DELETE: return 0;
	case LEX_FUNC_MATRIX_GET_ROW_COUNT: return 0;
	case LEX_FUNC_MATRIX_GET_COL_COUNT: return 0;
	case LEX_FUNC_MATRIX_GET_SUM: return 0;
	case LEX_FUNC_MATRIX_GET_DIAGONAL_SUM: return 0;
	case LEX_FUNC_MATRIX_GET_MEAN: return 0;
	case LEX_FUNC_MATRIX_GET_VARIANCE: return 0;
	case LEX_FUNC_MATRIX_GET_MINIMUM: return 0;
	case LEX_FUNC_MATRIX_GET_MAXIMUM: return 0;
	case LEX_FUNC_MATRIX_GET_SUM_SQUARES: return 0;
	case LEX_FUNC_MATRIX_GET_ROWS: return 1;
	case LEX_FUNC_MATRIX_GET_COLS: return 1;
	case LEX_FUNC_MATRIX_DELETE_ROWS: return 1;
	case LEX_FUNC_MATRIX_DELETE_COLS: return 1;
	case LEX_FUNC_MATRIX_GET_CLASS: return 0;
	case LEX_FUNC_MATRIX_TRANSPOSE: return 0;
	case LEX_FUNC_MATRIX_NORM_ROWS: return 0;
	case LEX_FUNC_MATRIX_NORM_COLS: return 0;
	case LEX_FUNC_MATRIX_ROWS_VAR: return 0;
	case LEX_FUNC_MATRIX_COLS_VAR: return 0;
	case LEX_FUNC_MATRIX_GET_ROW: return 1;
	case LEX_FUNC_MATRIX_GET_COL: return 1;
	//
	case LEX_FUNC_VECTOR_CREATE: return 1;
	case LEX_FUNC_VECTOR_CREATE_SERIES: return 3;
	case LEX_FUNC_VECTOR_CREATE_RANDOM: return 3;
	case LEX_FUNC_VECTOR_CREATE_BINARY: return 2;
	case LEX_FUNC_VECTOR_SAVE: return 0;
	case LEX_FUNC_VECTOR_LOAD: return 0;
	case LEX_FUNC_VECTOR_INSERT_CELL: return 2;
	case LEX_FUNC_VECTOR_DELETE_CELL: return 1;
	case LEX_FUNC_VECTOR_GET_SIZE: return 0;
	case LEX_FUNC_VECTOR_GET_SUM: return 0;
	case LEX_FUNC_VECTOR_GET_MEAN: return 0;
	case LEX_FUNC_VECTOR_GET_VARIANCE: return 0;
	case LEX_FUNC_VECTOR_GET_MINIMUM: return 0;
	case LEX_FUNC_VECTOR_GET_MAXIMUM: return 0;
	case LEX_FUNC_VECTOR_GET_SQUARED_SUM: return 0;
	case LEX_FUNC_VECTOR_CREATE_LOW_PASS_IMP_RESP: return 3;
	case LEX_FUNC_VECTOR_CREATE_LOW_PASS_FREQ_RESP: return 3;
	case LEX_FUNC_VECTOR_CREATE_HIGH_PASS_IMP_RESP: return 3;
	case LEX_FUNC_VECTOR_CREATE_HIGH_PASS_FREQ_RESP: return 3;
	case LEX_FUNC_VECTOR_CREATE_RANDOM_SET: return 2;
	case LEX_FUNC_VECTOR_WRAP: return 1;
	case LEX_FUNC_VECTOR_LINE_FIT: return 0;
	//
	//case LEX_FUNC_SCALER_CREATEINPUTSCALER: return 1;
	//case LEX_FUNC_SCALER_CREATEOUTPUTSCALER: return 1;
	//case LEX_FUNC_SCALER_DELETE: return 0;
	//case LEX_FUNC_SCALER_GETSIZE: return 0;
	//case LEX_FUNC_SCALER_SAVE: return 0;
	//case LEX_FUNC_SCALER_LOAD: return 0;
	//case LEX_FUNC_SCALER_SET: return 3;
	//case LEX_FUNC_SCALER_SCALE: return 2;
	//case LEX_FUNC_SCALER_GETMINIMUM: return 1;
	//case LEX_FUNC_SCALER_GETMAXIMUM: return 1;
	//case LEX_FUNC_SCALER_AUTOSETINPUTSCALER: return 1;
	//case LEX_FUNC_SCALER_AUTOSETOUTPUTSCALER: return 1;
	//
	case LEX_FUNC_LAYERNET_CREATE: return 4;
	case LEX_FUNC_LAYERNET_LOAD: return 0;
	case LEX_FUNC_LAYERNET_SAVE: return 0;
	case LEX_FUNC_LAYERNET_SET_WEIGHTS: return 2;
	case LEX_FUNC_LAYERNET_GET_WEIGHTS: return 1;
	case LEX_FUNC_LAYERNET_GET_INPUT_COUNT: return 0;
	case LEX_FUNC_LAYERNET_GET_OUTPUT_COUNT: return 0;
	case LEX_FUNC_LAYERNET_GET_HIDD1_NEU_COUNT: return 0;
	case LEX_FUNC_LAYERNET_GET_HIDD2_NEU_COUNT: return 0;
	case LEX_FUNC_LAYERNET_GET_LAYER_COUNT: return 0;
	case LEX_FUNC_LAYERNET_DELETE: return 0;
	case LEX_FUNC_LAYERNET_UNLEARN: return 0;
	case LEX_FUNC_LAYERNET_AUTO_SET_INPUT_SCALER: return 1;
	case LEX_FUNC_LAYERNET_AUTO_SET_OUTPUT_SCALER: return 1;
	case LEX_FUNC_LAYERNET_SET_INPUT_SCALER: return 3;
	case LEX_FUNC_LAYERNET_SET_OUTPUT_SCALER: return 3;
	case LEX_FUNC_LAYERNET_GET_INPUT_SCALER: return 1;
	case LEX_FUNC_LAYERNET_GET_OUTPUT_SCALER: return 1;
	case LEX_FUNC_LAYERNET_SET_TRAINING_SET: return 3;
	case LEX_FUNC_LAYERNET_TRAIN_GENETIC: return 6;
	case LEX_FUNC_LAYERNET_TRAIN_SIMULATE_ANNEALING: return 7;
	case LEX_FUNC_LAYERNET_TRAIN_CONJUGATE_GRADIENT: return 2;
	case LEX_FUNC_LAYERNET_TRAIN_VARIABLE_METRIC: return 2;
	case LEX_FUNC_LAYERNET_TRAIN_LEVENBERG_MARQUARDT: return 2;
	case LEX_FUNC_LAYERNET_TRAIN_REGRESSION: return 0;
	case LEX_FUNC_LAYERNET_GET_MIN_NUM_TRAIN_CASES: return 0;
	case LEX_FUNC_LAYERNET_RUN: return 1;
	//
	case LEX_FUNC_KOHONET_CREATE: return 2;
	case LEX_FUNC_KOHONET_SAVE: return 0;
	case LEX_FUNC_KOHONET_LOAD: return 0;
	//
	case LEX_FUNC_PROBNET_CREATE: return 2;
	case LEX_FUNC_PROBNET_SAVE: return 0;
	case LEX_FUNC_PROBNET_LOAD: return 0;	


	}
	return -1;
}

int Compiler::GetObjectFuncParamType(int func_id, int paramIndex)
{
	switch(func_id)
	{
	//_____________________________________________ General Functions
	case LEX_FUNC_SIN: return LEX_DATATYPE_DOUBLE;
	case LEX_FUNC_COS: return LEX_DATATYPE_DOUBLE;
	case LEX_FUNC_TAN: return LEX_DATATYPE_DOUBLE;
	case LEX_FUNC_ASIN: return LEX_DATATYPE_DOUBLE;
	case LEX_FUNC_ACOS: return LEX_DATATYPE_DOUBLE;
	case LEX_FUNC_ATAN: return LEX_DATATYPE_DOUBLE;
	case LEX_FUNC_SINH: return LEX_DATATYPE_DOUBLE;
	case LEX_FUNC_COSH: return LEX_DATATYPE_DOUBLE;
	case LEX_FUNC_TANH: return LEX_DATATYPE_DOUBLE;
	case LEX_FUNC_SQRT: return LEX_DATATYPE_DOUBLE;
	case LEX_FUNC_LOG10: return LEX_DATATYPE_DOUBLE;
	case LEX_FUNC_LOG: return LEX_DATATYPE_DOUBLE;
	case LEX_FUNC_EXP: return LEX_DATATYPE_DOUBLE;
	case LEX_FUNC_POW: return LEX_DATATYPE_DOUBLE;
	case LEX_FUNC_ABS: return LEX_DATATYPE_DOUBLE;
	case LEX_FUNC_SINC: return LEX_DATATYPE_DOUBLE;
	case LEX_FUNC_TRIANG: return LEX_DATATYPE_DOUBLE;
	case LEX_FUNC_SAW: return LEX_DATATYPE_DOUBLE;
	case LEX_FUNC_RECT: return LEX_DATATYPE_DOUBLE;
	case LEX_FUNC_CEIL: return LEX_DATATYPE_DOUBLE;
	case LEX_FUNC_FLOOR: return LEX_DATATYPE_DOUBLE;
	case LEX_FUNC_TOINT: return LEX_DATATYPE_DOUBLE;
	case LEX_FUNC_FFT: return LEX_DATATYPE_COMPLEX_MATRIX;
	case LEX_FUNC_IFFT: return LEX_DATATYPE_COMPLEX_MATRIX;
	case LEX_FUNC_REALFFT: return LEX_DATATYPE_MATRIX;
	case LEX_FUNC_IREALFFT: return LEX_DATATYPE_MATRIX;
	case LEX_FUNC_SPECTRUM: return LEX_DATATYPE_VECTOR;
	case LEX_FUNC_CONVOLUTION:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_VECTOR;
		case 1: return LEX_DATATYPE_VECTOR;
		}
		break;
	case LEX_FUNC_SHORT_CONVOLUTION:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_VECTOR;
		case 1: return LEX_DATATYPE_VECTOR;
		}
		break;
	case LEX_FUNC_COMPUTE_MSE:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_MATRIX;
		case 1: return LEX_DATATYPE_MATRIX;
		}
		break;
	case LEX_FUNC_CONFUSION_MATRIX:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_MATRIX;
		case 1: return LEX_DATATYPE_MATRIX;
		}
		break;
	case LEX_FUNC_RAND: return LEX_DATATYPE_DOUBLE;
	case LEX_FUNC_RANDI: return LEX_DATATYPE_INTEGER;
	case LEX_FUNC_ISPRIME: return LEX_DATATYPE_INTEGER;
	//_____________________________________________ Matrix
	case LEX_FUNC_MATRIX_CREATE:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		case 1: return LEX_DATATYPE_INTEGER;
		}
		break;
	case LEX_FUNC_MATRIX_CREATE_RANDOM:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		case 1: return LEX_DATATYPE_INTEGER;
		case 2: return LEX_DATATYPE_DOUBLE;
		case 3: return LEX_DATATYPE_DOUBLE;
		}
		break;
	case LEX_FUNC_MATRIX_SAVE: return ERROR_INVALID_VALUE;
	case LEX_FUNC_MATRIX_LOAD: return ERROR_INVALID_VALUE;
	case LEX_FUNC_MATRIX_APPEND_RIGHT:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_MATRIX;
		}
		break;
	case LEX_FUNC_MATRIX_APPEND_DOWN:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_MATRIX;
		}
		break;
	case LEX_FUNC_MATRIX_DELETE_ROW:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		}
		break;
	case LEX_FUNC_MATRIX_DELETE_COL:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		}
		break;
	case LEX_FUNC_MATRIX_INSERT_ROW:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		}
		break;
	case LEX_FUNC_MATRIX_INSERT_COL:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		}
		break;
	case LEX_FUNC_MATRIX_DELETE: return ERROR_INVALID_VALUE;
	case LEX_FUNC_MATRIX_GET_ROW_COUNT: return ERROR_INVALID_VALUE;
	case LEX_FUNC_MATRIX_GET_COL_COUNT: return ERROR_INVALID_VALUE;
	case LEX_FUNC_MATRIX_GET_SUM: return ERROR_INVALID_VALUE;
	case LEX_FUNC_MATRIX_GET_DIAGONAL_SUM: return ERROR_INVALID_VALUE;
	case LEX_FUNC_MATRIX_GET_MEAN: return ERROR_INVALID_VALUE;
	case LEX_FUNC_MATRIX_GET_VARIANCE: return ERROR_INVALID_VALUE;
	case LEX_FUNC_MATRIX_GET_MINIMUM: return ERROR_INVALID_VALUE;
	case LEX_FUNC_MATRIX_GET_MAXIMUM: return ERROR_INVALID_VALUE;
	case LEX_FUNC_MATRIX_GET_SUM_SQUARES: return ERROR_INVALID_VALUE;
	case LEX_FUNC_MATRIX_GET_ROWS:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_VECTOR;
		}
		break;
	case LEX_FUNC_MATRIX_GET_COLS:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_VECTOR;
		}
		break;
	case LEX_FUNC_MATRIX_DELETE_ROWS:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_VECTOR;
		}
		break;
	case LEX_FUNC_MATRIX_DELETE_COLS:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_VECTOR;
		}
		break;
	case LEX_FUNC_MATRIX_GET_CLASS: return ERROR_INVALID_VALUE;
	case LEX_FUNC_MATRIX_TRANSPOSE: return ERROR_INVALID_VALUE;
	case LEX_FUNC_MATRIX_NORM_ROWS: return ERROR_INVALID_VALUE;
	case LEX_FUNC_MATRIX_NORM_COLS: return ERROR_INVALID_VALUE;
	case LEX_FUNC_MATRIX_ROWS_VAR: return ERROR_INVALID_VALUE;
	case LEX_FUNC_MATRIX_COLS_VAR: return ERROR_INVALID_VALUE;
	case LEX_FUNC_MATRIX_GET_ROW:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		}
		break;
	case LEX_FUNC_MATRIX_GET_COL:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		}
		break;
	//___________________________________________________ Vector
	case LEX_FUNC_VECTOR_CREATE:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		}
		break;
	case LEX_FUNC_VECTOR_CREATE_SERIES:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_DOUBLE;
		case 1: return LEX_DATATYPE_DOUBLE;
		case 2: return LEX_DATATYPE_INTEGER;
		}
		break;
	case LEX_FUNC_VECTOR_CREATE_RANDOM:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		case 1: return LEX_DATATYPE_DOUBLE;
		case 2: return LEX_DATATYPE_DOUBLE;
		}
		break;
	case LEX_FUNC_VECTOR_CREATE_BINARY:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		case 1: return LEX_DATATYPE_INTEGER;
		}
		break;
	case LEX_FUNC_VECTOR_SAVE: return ERROR_INVALID_VALUE;
	case LEX_FUNC_VECTOR_LOAD: return ERROR_INVALID_VALUE;
	case LEX_FUNC_VECTOR_INSERT_CELL :
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		case 1: return LEX_DATATYPE_DOUBLE;
		}
		break;
	case LEX_FUNC_VECTOR_DELETE_CELL :
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		}
		break;
	case LEX_FUNC_VECTOR_GET_SIZE: return ERROR_INVALID_VALUE;
	case LEX_FUNC_VECTOR_GET_SUM: return ERROR_INVALID_VALUE;
	case LEX_FUNC_VECTOR_GET_MEAN: return ERROR_INVALID_VALUE;
	case LEX_FUNC_VECTOR_GET_VARIANCE: return ERROR_INVALID_VALUE;
	case LEX_FUNC_VECTOR_GET_MINIMUM: return ERROR_INVALID_VALUE;
	case LEX_FUNC_VECTOR_GET_MAXIMUM: return ERROR_INVALID_VALUE;
	case LEX_FUNC_VECTOR_GET_SQUARED_SUM: return ERROR_INVALID_VALUE;
	case LEX_FUNC_VECTOR_CREATE_LOW_PASS_IMP_RESP:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_DOUBLE;
		case 1: return LEX_DATATYPE_INTEGER;
		case 2: return LEX_DATATYPE_DOUBLE;
		}
		break;
	case LEX_FUNC_VECTOR_CREATE_LOW_PASS_FREQ_RESP:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_DOUBLE;
		case 1: return LEX_DATATYPE_INTEGER;
		case 2: return LEX_DATATYPE_DOUBLE;
		}
		break;
	case LEX_FUNC_VECTOR_CREATE_HIGH_PASS_IMP_RESP:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_DOUBLE;
		case 1: return LEX_DATATYPE_INTEGER;
		case 2: return LEX_DATATYPE_DOUBLE;
		}
		break;
	case LEX_FUNC_VECTOR_CREATE_HIGH_PASS_FREQ_RESP:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_DOUBLE;
		case 1: return LEX_DATATYPE_INTEGER;
		case 2: return LEX_DATATYPE_DOUBLE;
		}
		break;
	case LEX_FUNC_VECTOR_CREATE_RANDOM_SET:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		case 1: return LEX_DATATYPE_INTEGER;
		}
		break;
	case LEX_FUNC_VECTOR_WRAP:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		}
		break;
	case LEX_FUNC_VECTOR_LINE_FIT: return ERROR_INVALID_VALUE;
	//___________________________________________________ Scaler
	//case LEX_FUNC_SCALER_CREATEINPUTSCALER:
	//	switch(paramIndex)
	//	{
	//	case 0: return LEX_DATATYPE_INTEGER;
	//	}
	//	break;
	//case LEX_FUNC_SCALER_CREATEOUTPUTSCALER:
	//	switch(paramIndex)
	//	{
	//	case 0: return LEX_DATATYPE_INTEGER;
	//	}
	//	break;
	//case LEX_FUNC_SCALER_DELETE:
	//case LEX_FUNC_SCALER_GETSIZE:
	//case LEX_FUNC_SCALER_SAVE:
	//case LEX_FUNC_SCALER_LOAD:
	//case LEX_FUNC_SCALER_SET:
	//	switch(paramIndex)
	//	{
	//	case 0: return LEX_DATATYPE_MATRIX;
	//	case 1: return LEX_DATATYPE_INTEGER;
	//	}
	//	break;
	//case LEX_FUNC_SCALER_SCALE:
	//	switch(paramIndex)
	//	{
	//	case 0: return LEX_DATATYPE_MATRIX;
	//	case 1: return LEX_DATATYPE_MATRIX;
	//	}
	//	break;
	//case LEX_FUNC_SCALER_GETMINIMUM:
	//	switch(paramIndex)
	//	{
	//	case 0: return LEX_DATATYPE_INTEGER;
	//	}
	//	break;
	//case LEX_FUNC_SCALER_GETMAXIMUM:
	//	switch(paramIndex)
	//	{
	//	case 0: return LEX_DATATYPE_INTEGER;
	//	}
	//	break;
	//case LEX_FUNC_SCALER_AUTOSETINPUTSCALER:
	//	switch(paramIndex)
	//	{
	//	case 0: return LEX_DATATYPE_INTEGER;
	//	}
	//	break;
	//case LEX_FUNC_SCALER_AUTOSETOUTPUTSCALER:
	//	switch(paramIndex)
	//	{
	//	case 1: return LEX_DATATYPE_MATRIX;
	//	case 0: return LEX_DATATYPE_MATRIX;
	//	}
	//	break;
	//______________________________________________ LayerNet
	case LEX_FUNC_LAYERNET_CREATE:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		case 1: return LEX_DATATYPE_INTEGER;
		case 2: return LEX_DATATYPE_INTEGER;
		case 3: return LEX_DATATYPE_INTEGER;
		}
		break;
	case LEX_FUNC_LAYERNET_LOAD: return ERROR_INVALID_VALUE;
	case LEX_FUNC_LAYERNET_SAVE: return ERROR_INVALID_VALUE;
	case LEX_FUNC_LAYERNET_SET_WEIGHTS:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		case 1: return LEX_DATATYPE_MATRIX;
		}
		break;
	case LEX_FUNC_LAYERNET_GET_WEIGHTS:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		}
		break;
	case LEX_FUNC_LAYERNET_GET_INPUT_COUNT: return ERROR_INVALID_VALUE;
	case LEX_FUNC_LAYERNET_GET_OUTPUT_COUNT: return ERROR_INVALID_VALUE;
	case LEX_FUNC_LAYERNET_GET_HIDD1_NEU_COUNT: return ERROR_INVALID_VALUE;
	case LEX_FUNC_LAYERNET_GET_HIDD2_NEU_COUNT: return ERROR_INVALID_VALUE;
	case LEX_FUNC_LAYERNET_GET_LAYER_COUNT: return ERROR_INVALID_VALUE;
	case LEX_FUNC_LAYERNET_DELETE: return ERROR_INVALID_VALUE;
	case LEX_FUNC_LAYERNET_UNLEARN: return ERROR_INVALID_VALUE;
	case LEX_FUNC_LAYERNET_AUTO_SET_INPUT_SCALER:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_MATRIX;
		}
		break;
	case LEX_FUNC_LAYERNET_AUTO_SET_OUTPUT_SCALER:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_MATRIX;
		}
		break;
	case LEX_FUNC_LAYERNET_SET_INPUT_SCALER:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		case 1: return LEX_DATATYPE_DOUBLE;
		case 2: return LEX_DATATYPE_DOUBLE;
		}
		break;
	case LEX_FUNC_LAYERNET_SET_OUTPUT_SCALER:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		case 1: return LEX_DATATYPE_DOUBLE;
		case 2: return LEX_DATATYPE_DOUBLE;
		}
		break;
	case LEX_FUNC_LAYERNET_GET_INPUT_SCALER:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		}
		break;
	case LEX_FUNC_LAYERNET_GET_OUTPUT_SCALER:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		}
		break;
	case LEX_FUNC_LAYERNET_SET_TRAINING_SET:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_MATRIX;
		case 1: return LEX_DATATYPE_MATRIX;
		case 2: return LEX_DATATYPE_BOOL;
		}
		break;
	case LEX_FUNC_LAYERNET_TRAIN_GENETIC:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		case 1: return LEX_DATATYPE_INTEGER;
		case 2: return LEX_DATATYPE_DOUBLE;
		case 3: return LEX_DATATYPE_DOUBLE;
		case 4: return LEX_DATATYPE_DOUBLE;
		case 5: return LEX_DATATYPE_DOUBLE;
		}
		break;
	case LEX_FUNC_LAYERNET_TRAIN_SIMULATE_ANNEALING:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		case 1: return LEX_DATATYPE_INTEGER;
		case 2: return LEX_DATATYPE_DOUBLE;
		case 3: return LEX_DATATYPE_DOUBLE;
		case 4: return LEX_DATATYPE_BOOL;
		case 5: return LEX_DATATYPE_INTEGER;
		case 6: return LEX_DATATYPE_DOUBLE;
		}
		break;
	case LEX_FUNC_LAYERNET_TRAIN_CONJUGATE_GRADIENT:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		case 1: return LEX_DATATYPE_DOUBLE;
		}
		break;
	case LEX_FUNC_LAYERNET_TRAIN_VARIABLE_METRIC:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		case 1: return LEX_DATATYPE_DOUBLE;
		}
		break;
	case LEX_FUNC_LAYERNET_TRAIN_LEVENBERG_MARQUARDT:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		case 1: return LEX_DATATYPE_DOUBLE;
		}
		break;
	case LEX_FUNC_LAYERNET_TRAIN_REGRESSION: return ERROR_INVALID_VALUE;
	case LEX_FUNC_LAYERNET_GET_MIN_NUM_TRAIN_CASES: return ERROR_INVALID_VALUE;
	case LEX_FUNC_LAYERNET_RUN:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_MATRIX;
		}
		break;
	//______________________________________________ KohoNet
	case LEX_FUNC_KOHONET_CREATE:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		case 1: return LEX_DATATYPE_INTEGER;
		}
		break;
	case LEX_FUNC_KOHONET_LOAD: return ERROR_INVALID_VALUE;
	case LEX_FUNC_KOHONET_SAVE: return ERROR_INVALID_VALUE;
	//______________________________________________ ProbNet
	case LEX_FUNC_PROBNET_CREATE:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		case 1: return LEX_DATATYPE_INTEGER;
		}
		break;
	case LEX_FUNC_PROBNET_LOAD: return ERROR_INVALID_VALUE;
	case LEX_FUNC_PROBNET_SAVE: return ERROR_INVALID_VALUE;
	}
	return ERROR_INVALID_VALUE;
}

wchar_t* Compiler::GetObjectFuncParamName(int func_id, int paramIndex)
{
	switch(func_id)
	{
	//_____________________________________________ General Functions
	case LEX_FUNC_SIN: return L"x";
	case LEX_FUNC_COS: return L"x";
	case LEX_FUNC_TAN: return L"x";
	case LEX_FUNC_ASIN: return L"x";
	case LEX_FUNC_ACOS: return L"x";
	case LEX_FUNC_ATAN: return L"x";
	case LEX_FUNC_SINH: return L"x";
	case LEX_FUNC_COSH: return L"x";
	case LEX_FUNC_TANH: return L"x";
	case LEX_FUNC_SQRT: return L"x";
	case LEX_FUNC_LOG10: return L"x";
	case LEX_FUNC_LOG: return L"x";
	case LEX_FUNC_EXP: return L"x";
	case LEX_FUNC_POW: 
		if (paramIndex == 0) return L"x";
		return L"y";
		break;
	case LEX_FUNC_ABS: return L"x";
	case LEX_FUNC_SINC: return L"x";
	case LEX_FUNC_TRIANG: return L"x";
	case LEX_FUNC_SAW: return L"x";
	case LEX_FUNC_RECT: return L"x";
	case LEX_FUNC_CEIL: return L"x";
	case LEX_FUNC_FLOOR: return L"x";
	case LEX_FUNC_TOINT: return L"x";
	case LEX_FUNC_FFT: return L"x";
	case LEX_FUNC_IFFT: return L"x";
	case LEX_FUNC_REALFFT: return L"x";
	case LEX_FUNC_IREALFFT: return L"x";
	case LEX_FUNC_SPECTRUM: return L"x";
	case LEX_FUNC_CONVOLUTION:
		switch(paramIndex)
		{
		case 0: return L"x";
		case 1: return L"y";
		}
		break;
	case LEX_FUNC_SHORT_CONVOLUTION:
		switch(paramIndex)
		{
		case 0: return L"input";
		case 1: return L"impulseResponse";
		}
		break;
	case LEX_FUNC_COMPUTE_MSE:
		switch(paramIndex)
		{
		case 0: return L"output";
		case 1: return L"target";
		}
		break;
	case LEX_FUNC_CONFUSION_MATRIX:
		switch(paramIndex)
		{
		case 0: return L"output";
		case 1: return L"target";
		}
		break;
	case LEX_FUNC_RAND: return L"x";
	case LEX_FUNC_RANDI: return L"x";
	case LEX_FUNC_ISPRIME: return L"x";
	//_____________________________________________ Matrix
	case LEX_FUNC_MATRIX_CREATE:
		switch(paramIndex)
		{
		case 0: return L"rowCount";
		case 1: return L"colCount";
		}
		break;
	case LEX_FUNC_MATRIX_CREATE_RANDOM:
		switch(paramIndex)
		{
		case 0: return L"rowCount";
		case 1: return L"colCount";
		case 2: return L"minValue";
		case 3: return L"maxValue";
		}
		break;
	case LEX_FUNC_MATRIX_SAVE: return NULL;
	case LEX_FUNC_MATRIX_LOAD: return NULL;
	case LEX_FUNC_MATRIX_APPEND_RIGHT:
		switch(paramIndex)
		{
		case 0: return L"x";
		}
		break;
	case LEX_FUNC_MATRIX_APPEND_DOWN:
		switch(paramIndex)
		{
		case 0: return L"x";
		}
		break;
	case LEX_FUNC_MATRIX_DELETE_ROW:
		switch(paramIndex)
		{
		case 0: return L"rowIndex";
		}
		break;
	case LEX_FUNC_MATRIX_DELETE_COL:
		switch(paramIndex)
		{
		case 0: return L"colIndex";
		}
		break;
	case LEX_FUNC_MATRIX_INSERT_ROW:
		switch(paramIndex)
		{
		case 0: return L"rowIndex";
		}
		break;
	case LEX_FUNC_MATRIX_INSERT_COL:
		switch(paramIndex)
		{
		case 0: return L"colIndex";
		}
		break;
	case LEX_FUNC_MATRIX_DELETE: return NULL;
	case LEX_FUNC_MATRIX_GET_ROW_COUNT: return NULL;
	case LEX_FUNC_MATRIX_GET_COL_COUNT: return NULL;
	case LEX_FUNC_MATRIX_GET_SUM: return NULL;
	case LEX_FUNC_MATRIX_GET_DIAGONAL_SUM: return NULL;
	case LEX_FUNC_MATRIX_GET_MEAN: return NULL;
	case LEX_FUNC_MATRIX_GET_VARIANCE: return NULL;
	case LEX_FUNC_MATRIX_GET_MINIMUM: return NULL;
	case LEX_FUNC_MATRIX_GET_MAXIMUM: return NULL;
	case LEX_FUNC_MATRIX_GET_SUM_SQUARES: return NULL;
	case LEX_FUNC_MATRIX_GET_ROWS: return L"indexes";
	case LEX_FUNC_MATRIX_GET_COLS: return L"indexes";
	case LEX_FUNC_MATRIX_DELETE_ROWS: return L"indexes";
	case LEX_FUNC_MATRIX_DELETE_COLS: return L"indexes";
	case LEX_FUNC_MATRIX_GET_CLASS: return NULL;
	case LEX_FUNC_MATRIX_TRANSPOSE: return NULL;
	case LEX_FUNC_MATRIX_NORM_ROWS: return NULL;
	case LEX_FUNC_MATRIX_NORM_COLS: return NULL;
	case LEX_FUNC_MATRIX_ROWS_VAR: return NULL;
	case LEX_FUNC_MATRIX_COLS_VAR: return NULL;
	case LEX_FUNC_MATRIX_GET_ROW: return L"rowIndex";
	case LEX_FUNC_MATRIX_GET_COL: return L"colIndex";
	//___________________________________________________ Vector
	case LEX_FUNC_VECTOR_CREATE:
		switch(paramIndex)
		{
		case 0: return L"size";
		}
		break;
	case LEX_FUNC_VECTOR_CREATE_SERIES:
		switch(paramIndex)
		{
		case 0: return L"firstValue";
		case 1: return L"lastValue";
		case 2: return L"size";
		}
		break;
	case LEX_FUNC_VECTOR_CREATE_RANDOM:
		switch(paramIndex)
		{
		case 0: return L"length";
		case 1: return L"minValue";
		case 2: return L"maxValue";
		}
		break;
	case LEX_FUNC_VECTOR_CREATE_BINARY:
		switch(paramIndex)
		{
		case 0: return L"bitCount";
		case 1: return L"decimalValue";
		}
		break;
	case LEX_FUNC_VECTOR_SAVE: return NULL;
	case LEX_FUNC_VECTOR_LOAD: return NULL;
	case LEX_FUNC_VECTOR_INSERT_CELL:
		switch(paramIndex)
		{
		case 0: return L"index";
		case 1: return L"value";
		}
		break;
	case LEX_FUNC_VECTOR_DELETE_CELL:
		switch(paramIndex)
		{
		case 0: return L"index";
		}
		break;
	case LEX_FUNC_VECTOR_GET_SIZE: return NULL;
	case LEX_FUNC_VECTOR_GET_SUM: return NULL;
	case LEX_FUNC_VECTOR_GET_MEAN: return NULL;
	case LEX_FUNC_VECTOR_GET_VARIANCE: return NULL;
	case LEX_FUNC_VECTOR_GET_MINIMUM: return NULL;
	case LEX_FUNC_VECTOR_GET_MAXIMUM: return NULL;
	case LEX_FUNC_VECTOR_GET_SQUARED_SUM: return NULL;
	case LEX_FUNC_VECTOR_CREATE_LOW_PASS_IMP_RESP:
		switch(paramIndex)
		{
		case 0: return L"beta";
		case 1: return L"length";
		case 2: return L"radCutFreq";
		}
		break;
	case LEX_FUNC_VECTOR_CREATE_LOW_PASS_FREQ_RESP:
		switch(paramIndex)
		{
		case 0: return L"beta";
		case 1: return L"length";
		case 2: return L"radCutFreq";
		}
		break;
	case LEX_FUNC_VECTOR_CREATE_HIGH_PASS_IMP_RESP:
		switch(paramIndex)
		{
		case 0: return L"beta";
		case 1: return L"length";
		case 2: return L"radCutFreq";
		}
		break;
	case LEX_FUNC_VECTOR_CREATE_HIGH_PASS_FREQ_RESP:
		switch(paramIndex)
		{
		case 0: return L"beta";
		case 1: return L"length";
		case 2: return L"radCutFreq";
		}
		break;
	case LEX_FUNC_VECTOR_CREATE_RANDOM_SET:
		switch(paramIndex)
		{
		case 0: return L"length";
		case 1: return L"maxValue";
		}
		break;
	case LEX_FUNC_VECTOR_WRAP:
		switch(paramIndex)
		{
		case 0: return L"colCount";
		}
		break;
	case LEX_FUNC_VECTOR_LINE_FIT: return NULL;
	//___________________________________________________ Scaler
	//case LEX_FUNC_SCALER_CREATEINPUTSCALER:
	//	switch(paramIndex)
	//	{
	//	case 0: return L"inputCount";
	//	}
	//	break;
	//case LEX_FUNC_SCALER_CREATEOUTPUTSCALER:
	//	switch(paramIndex)
	//	{
	//	case 0: return L"outputCount";
	//	}
	//	break;
	//case LEX_FUNC_SCALER_DELETE:
	//case LEX_FUNC_SCALER_GETSIZE:
	//case LEX_FUNC_SCALER_SAVE:
	//case LEX_FUNC_SCALER_LOAD:
	//case LEX_FUNC_SCALER_SET:
	//	switch(paramIndex)
	//	{
	//	case 0: return LEX_DATATYPE_MATRIX;
	//	case 1: return LEX_DATATYPE_INTEGER;
	//	}
	//	break;
	//case LEX_FUNC_SCALER_SCALE:
	//	switch(paramIndex)
	//	{
	//	case 0: return L"input";
	//	case 1: return L"output";
	//	}
	//	break;
	//case LEX_FUNC_SCALER_GETMINIMUM:
	//	switch(paramIndex)
	//	{
	//	case 0: return LEX_DATATYPE_INTEGER;
	//	}
	//	break;
	//case LEX_FUNC_SCALER_GETMAXIMUM:
	//	switch(paramIndex)
	//	{
	//	case 0: return LEX_DATATYPE_INTEGER;
	//	}
	//	break;
	//case LEX_FUNC_SCALER_AUTOSETINPUTSCALER:
	//	switch(paramIndex)
	//	{
	//	case 0: return LEX_DATATYPE_INTEGER;
	//	}
	//	break;
	//case LEX_FUNC_SCALER_AUTOSETOUTPUTSCALER:
	//	switch(paramIndex)
	//	{
	//	case 1: return LEX_DATATYPE_MATRIX;
	//	case 0: return LEX_DATATYPE_MATRIX;
	//	}
	//	break;
	//______________________________________________ LayerNet
	case LEX_FUNC_LAYERNET_CREATE:
		switch(paramIndex)
		{
		case 0: return L"inputCount";
		case 1: return L"hidden1Count";
		case 2: return L"hidden2Count";
		case 3: return L"outputCount";
		}
		break;
	case LEX_FUNC_LAYERNET_LOAD: return NULL;
	case LEX_FUNC_LAYERNET_SAVE: return NULL;
	case LEX_FUNC_LAYERNET_SET_WEIGHTS:
		switch(paramIndex)
		{
		case 0: return L"layerIndex";
		case 1: return L"layerWeights";
		}
		break;
	case LEX_FUNC_LAYERNET_GET_WEIGHTS:
		switch(paramIndex)
		{
		case 0: return L"layerIndex";
		}
		break;
	case LEX_FUNC_LAYERNET_GET_INPUT_COUNT: return NULL;
	case LEX_FUNC_LAYERNET_GET_OUTPUT_COUNT: return NULL;
	case LEX_FUNC_LAYERNET_GET_HIDD1_NEU_COUNT: return NULL;
	case LEX_FUNC_LAYERNET_GET_HIDD2_NEU_COUNT: return NULL;
	case LEX_FUNC_LAYERNET_GET_LAYER_COUNT: return NULL;
	case LEX_FUNC_LAYERNET_DELETE: return NULL;
	case LEX_FUNC_LAYERNET_UNLEARN: return NULL;
	case LEX_FUNC_LAYERNET_AUTO_SET_INPUT_SCALER:
		switch(paramIndex)
		{
		case 0: return L"input";
		}
		break;
	case LEX_FUNC_LAYERNET_AUTO_SET_OUTPUT_SCALER:
		switch(paramIndex)
		{
		case 0: return L"output";
		}
		break;
	case LEX_FUNC_LAYERNET_SET_INPUT_SCALER:
		switch(paramIndex)
		{
		case 0: return L"index";
		case 1: return L"minimum";
		case 2: return L"maximum";
		}
		break;
	case LEX_FUNC_LAYERNET_SET_OUTPUT_SCALER:
		switch(paramIndex)
		{
		case 0: return L"index";
		case 1: return L"minimum";
		case 2: return L"maximum";
		}
		break;
	case LEX_FUNC_LAYERNET_GET_INPUT_SCALER:
		switch(paramIndex)
		{
		case 0: return L"index";
		}
		break;
	case LEX_FUNC_LAYERNET_GET_OUTPUT_SCALER:
		switch(paramIndex)
		{
		case 0: return L"index";
		}
		break;
	case LEX_FUNC_LAYERNET_SET_TRAINING_SET:
		switch(paramIndex)
		{
		case 0: return L"trainSetIn";
		case 1: return L"trainSetTarget";
		case 2: return L"ignoreWarnings";
		}
		break;
	case LEX_FUNC_LAYERNET_TRAIN_GENETIC:
		switch(paramIndex)
		{
		case 0: return L"initPopulationSize";
		case 1: return L"numGenerations";
		case 2: return L"overPopulation";
		case 3: return L"mutationProbability";
		case 4: return L"crossoverProbability";
		case 5: return L"goal";
		}
		break;
	case LEX_FUNC_LAYERNET_TRAIN_SIMULATE_ANNEALING:
		switch(paramIndex)
		{
		case 0: return L"numTemps";
		case 1: return L"numIterations";
		case 2: return L"initialTemp";
		case 3: return L"finalTemp";
		case 4: return L"isCoolingScheduleLinear";
		case 5: return L"cycles";
		case 6: return L"goal";
		}
		break;
	case LEX_FUNC_LAYERNET_TRAIN_CONJUGATE_GRADIENT:
		switch(paramIndex)
		{
		case 0: return L"epochs";
		case 1: return L"goal";
		}
		break;
	case LEX_FUNC_LAYERNET_TRAIN_VARIABLE_METRIC:
		switch(paramIndex)
		{
		case 0: return L"epochs";
		case 1: return L"goal";
		}
		break;
	case LEX_FUNC_LAYERNET_TRAIN_LEVENBERG_MARQUARDT:
		switch(paramIndex)
		{
		case 0: return L"epochs";
		case 1: return L"goal";
		}
		break;
	case LEX_FUNC_LAYERNET_TRAIN_REGRESSION: return NULL;
	case LEX_FUNC_LAYERNET_GET_MIN_NUM_TRAIN_CASES: return NULL;
	case LEX_FUNC_LAYERNET_RUN:
		switch(paramIndex)
		{
		case 0: return L"input";
		}
		break;
	//_____________________________________________________ KohoNet
	case LEX_FUNC_KOHONET_CREATE:
		switch(paramIndex)
		{
		case 0: return L"numInputs";
		case 1: return L"numOutputs";
		}
		break;
	case LEX_FUNC_KOHONET_LOAD: return NULL;
	case LEX_FUNC_KOHONET_SAVE: return NULL;
	//_____________________________________________________ ProbNet
	case  LEX_FUNC_PROBNET_CREATE:
		switch(paramIndex)
		{
		case 0: return L"numInputs";
		case 1: return L"numOutputs";
		}
		break;
	case LEX_FUNC_PROBNET_LOAD: return NULL;
	case LEX_FUNC_PROBNET_SAVE: return NULL;
	}
	return NULL;
}

wchar_t* Compiler::GetFunctionName(int datatype, int func_id)
{
	switch(datatype)
	{
	case LEX_DATATYPE_DOUBLE:
	case LEX_DATATYPE_COMPLEX:
		switch(func_id)
		{
		case LEX_FUNC_SIN: return L"sin";
		case LEX_FUNC_COS: return L"cos";
		case LEX_FUNC_TAN: return L"tan";
		case LEX_FUNC_ASIN: return L"asin";
		case LEX_FUNC_ACOS: return L"acos";
		case LEX_FUNC_ATAN: return L"atan";
		case LEX_FUNC_SINH: return L"sinh";
		case LEX_FUNC_COSH: return L"cosh";
		case LEX_FUNC_TANH: return L"tanh";
		case LEX_FUNC_SQRT: return L"sqrt";
		case LEX_FUNC_LOG10: return L"log10";
		case LEX_FUNC_LOG: return L"log";
		case LEX_FUNC_EXP: return L"exp";
		case LEX_FUNC_POW: return L"pow";
		case LEX_FUNC_ABS: return L"abs";
		case LEX_FUNC_SINC: return L"sinc";
		case LEX_FUNC_TRIANG: return L"triang";
		case LEX_FUNC_SAW: return L"saw";
		case LEX_FUNC_RECT: return L"rect";
		case LEX_FUNC_CEIL: return L"ceil";
		case LEX_FUNC_FLOOR: return L"floor";
		case LEX_FUNC_TOINT: return L"toint";
		case LEX_FUNC_FFT: return L"fft";
		case LEX_FUNC_IFFT: return L"ifft";
		case LEX_FUNC_REALFFT: return L"realfft";
		case LEX_FUNC_IREALFFT: return L"irealfft";
		case LEX_FUNC_SPECTRUM: return L"spectrum";
		case LEX_FUNC_CONVOLUTION: return L"Convolution";
		case LEX_FUNC_SHORT_CONVOLUTION: return L"ShortConvolution";
		case LEX_FUNC_COMPUTE_MSE: return L"ComputeMse";
		case LEX_FUNC_CONFUSION_MATRIX: return L"ConfusionMatrix";
		//case LEX_FUNC_BESSELJ0: return L"Returns the Bessel functions of the first kind of order zero";
		//case LEX_FUNC_BESSELJ1: return L"Returns the Bessel functions of the first kind of order one";
		//case LEX_FUNC_BESSELY0: return L"Returns the Bessel functions of the second kind of order zero";
		//case LEX_FUNC_BESSELY1: return L"Returns the Bessel functions of the second kind of order one";
		case LEX_FUNC_RAND: return L"rand";	
		}
		break;
	case LEX_DATATYPE_INTEGER:
		switch(func_id)
		{
		//case LEX_FUNC_INT_BIT: return L"It returns the indicated bit of the binary representation of the second number";
		case LEX_FUNC_RANDI: return L"randi";
		case LEX_FUNC_ISPRIME: return L"isprime";
		}
		break;
	case LEX_DATATYPE_MATRIX:
	case LEX_DATATYPE_COMPLEX_MATRIX:
		switch(func_id)
		{
		case LEX_FUNC_MATRIX_CREATE: return L"Create";
		case LEX_FUNC_MATRIX_CREATE_RANDOM: return L"CreateRandom";
		case LEX_FUNC_MATRIX_SAVE: return L"Save";
		case LEX_FUNC_MATRIX_LOAD: return L"Load";
		case LEX_FUNC_MATRIX_APPEND_RIGHT: return L"AppendRight";
		case LEX_FUNC_MATRIX_APPEND_DOWN: return L"AppendDown";
		case LEX_FUNC_MATRIX_DELETE_ROW: return L"DeleteRow";
		case LEX_FUNC_MATRIX_DELETE_COL: return L"DeleteCol";
		case LEX_FUNC_MATRIX_INSERT_ROW: return L"InsertRow";
		case LEX_FUNC_MATRIX_INSERT_COL: return L"InsertCol";
		case LEX_FUNC_MATRIX_DELETE: return L"Delete";
		case LEX_FUNC_MATRIX_GET_ROW_COUNT: return L"GetRowCount";
		case LEX_FUNC_MATRIX_GET_COL_COUNT: return L"GetColCount";
		case LEX_FUNC_MATRIX_GET_SUM: return L"GetSum";
		case LEX_FUNC_MATRIX_GET_DIAGONAL_SUM: return L"GetDiagonalSum";
		case LEX_FUNC_MATRIX_GET_MEAN: return L"GetMean";
		case LEX_FUNC_MATRIX_GET_VARIANCE: return L"GetVariance";
		case LEX_FUNC_MATRIX_GET_MINIMUM: return L"GetMin";
		case LEX_FUNC_MATRIX_GET_MAXIMUM: return L"GetMax";
		case LEX_FUNC_MATRIX_GET_SUM_SQUARES: return L"GetSumSquares";
		case LEX_FUNC_MATRIX_GET_ROWS: return L"GetRows";
		case LEX_FUNC_MATRIX_GET_COLS: return L"GetCols";
		case LEX_FUNC_MATRIX_DELETE_ROWS: return L"DeleteRows";
		case LEX_FUNC_MATRIX_DELETE_COLS: return L"DeleteCols";
		case LEX_FUNC_MATRIX_GET_CLASS: return L"GetClass";
		case LEX_FUNC_MATRIX_TRANSPOSE: return L"Transpose";
		case LEX_FUNC_MATRIX_NORM_ROWS: return L"NormRows";
		case LEX_FUNC_MATRIX_NORM_COLS: return L"NormCols";
		case LEX_FUNC_MATRIX_ROWS_VAR: return L"RowsVar";
		case LEX_FUNC_MATRIX_COLS_VAR: return L"ColsVar";
		case LEX_FUNC_MATRIX_GET_ROW: return L"GetRow";
		case LEX_FUNC_MATRIX_GET_COL: return L"GetCol";
		}
		break;
	case LEX_DATATYPE_VECTOR:
	case LEX_DATATYPE_COMPLEX_VECTOR:
		switch(func_id)
		{
		case LEX_FUNC_VECTOR_CREATE: return L"Create";
		case LEX_FUNC_VECTOR_CREATE_SERIES: return L"CreateSeries";
		case LEX_FUNC_VECTOR_CREATE_RANDOM: return L"CreateRandom";
		case LEX_FUNC_VECTOR_CREATE_BINARY: return L"CreateBinary";
		case LEX_FUNC_VECTOR_SAVE: return L"Save";
		case LEX_FUNC_VECTOR_LOAD: return L"Load";
		case LEX_FUNC_VECTOR_INSERT_CELL: return L"InsertCell";
		case LEX_FUNC_VECTOR_DELETE_CELL: return L"DeleteCell";
		case LEX_FUNC_VECTOR_GET_SIZE: return L"GetSize";
		case LEX_FUNC_VECTOR_GET_SUM: return L"GetSum";
		case LEX_FUNC_VECTOR_GET_MEAN: return L"GetMean";
		case LEX_FUNC_VECTOR_GET_VARIANCE: return L"GetVariance";
		case LEX_FUNC_VECTOR_GET_MINIMUM: return L"GetMin";
		case LEX_FUNC_VECTOR_GET_MAXIMUM: return L"GetMax";
		case LEX_FUNC_VECTOR_GET_SQUARED_SUM: return L"GetSquaredSum";
		case LEX_FUNC_VECTOR_CREATE_LOW_PASS_IMP_RESP: return L"CreateLoPassIR";
		case LEX_FUNC_VECTOR_CREATE_LOW_PASS_FREQ_RESP: return L"CreateLoPassFR";
		case LEX_FUNC_VECTOR_CREATE_HIGH_PASS_IMP_RESP: return L"CreateHiPassIR";
		case LEX_FUNC_VECTOR_CREATE_HIGH_PASS_FREQ_RESP: return L"CreateHiPassFR";
		case LEX_FUNC_VECTOR_CREATE_RANDOM_SET: return L"CreateRandomSet";
		case LEX_FUNC_VECTOR_WRAP: return L"Wrap";
		case LEX_FUNC_VECTOR_LINE_FIT: return L"LineFit";
		}
		break;
	//case LEX_DATATYPE_SCALER:
	//	switch(func_id)
	//	{
	//	case LEX_FUNC_SCALER_CREATEINPUTSCALER: return L"CreateInputScaler";
	//	case LEX_FUNC_SCALER_CREATEOUTPUTSCALER: return L"CreateOutputScaler";
	//	case LEX_FUNC_SCALER_DELETE: return L"Delete";
	//	case LEX_FUNC_SCALER_GETSIZE: return L"GetSize";
	//	case LEX_FUNC_SCALER_SAVE: return L"Save";
	//	case LEX_FUNC_SCALER_LOAD: return L"Load";
	//	case LEX_FUNC_SCALER_SET: return L"Set";
	//	case LEX_FUNC_SCALER_SCALE: return L"Scale";
	//	case LEX_FUNC_SCALER_GETMINIMUM: return L"GetMinimum";
	//	case LEX_FUNC_SCALER_GETMAXIMUM: return L"GetMaximum";
	//	case LEX_FUNC_SCALER_AUTOSETINPUTSCALER: return L"AutoSetInputScaler";
	//	case LEX_FUNC_SCALER_AUTOSETOUTPUTSCALER: return L"AutoSetOutputScaler";
	//	}
	//	break;
	case LEX_DATATYPE_LAYERNET:
		switch(func_id)
		{
		case LEX_FUNC_LAYERNET_CREATE: return L"Create";
		case LEX_FUNC_LAYERNET_LOAD: return L"Load";
		case LEX_FUNC_LAYERNET_SAVE: return L"Save";	
		case LEX_FUNC_LAYERNET_SET_WEIGHTS: return L"SetWeights";	
		case LEX_FUNC_LAYERNET_GET_WEIGHTS: return L"GetWeights";	
		case LEX_FUNC_LAYERNET_GET_INPUT_COUNT: return L"GetInputCount";	
		case LEX_FUNC_LAYERNET_GET_OUTPUT_COUNT: return L"GetOutputCount";	
		case LEX_FUNC_LAYERNET_GET_HIDD1_NEU_COUNT: return L"GetHid1NeCount";	
		case LEX_FUNC_LAYERNET_GET_HIDD2_NEU_COUNT: return L"GetHid2NeCount";	
		case LEX_FUNC_LAYERNET_GET_LAYER_COUNT: return L"GetLayerCount";
		case LEX_FUNC_LAYERNET_DELETE: return L"Delete";	
		case LEX_FUNC_LAYERNET_UNLEARN: return L"Unlearn";	
		case LEX_FUNC_LAYERNET_AUTO_SET_INPUT_SCALER: return L"AutoSetInScaler";	
		case LEX_FUNC_LAYERNET_AUTO_SET_OUTPUT_SCALER: return L"AutoSetOutScaler";	
		case LEX_FUNC_LAYERNET_SET_INPUT_SCALER: return L"SetInScaler";	
		case LEX_FUNC_LAYERNET_SET_OUTPUT_SCALER: return L"SetOutScaler";	
		case LEX_FUNC_LAYERNET_GET_INPUT_SCALER: return L"GetInScaler";	
		case  LEX_FUNC_LAYERNET_GET_OUTPUT_SCALER: return L"GetOutScaler";	
		case LEX_FUNC_LAYERNET_SET_TRAINING_SET: return L"SetTrainSet";
		case LEX_FUNC_LAYERNET_TRAIN_GENETIC: return L"TrainGenetic";
		case LEX_FUNC_LAYERNET_TRAIN_SIMULATE_ANNEALING: return L"TrainSimAnneal";	
		case LEX_FUNC_LAYERNET_TRAIN_CONJUGATE_GRADIENT: return L"TrainConjGrad";	
		case LEX_FUNC_LAYERNET_TRAIN_VARIABLE_METRIC: return L"TrainVarMetric";	
		case LEX_FUNC_LAYERNET_TRAIN_LEVENBERG_MARQUARDT: return L"TrainLevenMar";	
		case LEX_FUNC_LAYERNET_TRAIN_REGRESSION: return L"TrainRegression";
		case LEX_FUNC_LAYERNET_GET_MIN_NUM_TRAIN_CASES: return L"GetMinNoTrCs";
		case LEX_FUNC_LAYERNET_RUN: return L"Run";	
		}
		break;
	case LEX_DATATYPE_KOHONET:
		switch(func_id)
		{
		case LEX_FUNC_KOHONET_CREATE: return L"Create";
		case LEX_FUNC_KOHONET_LOAD: return L"Load";
		case LEX_FUNC_KOHONET_SAVE: return L"Save";
		}
		break;
	case LEX_DATATYPE_PROBNET:
		switch(func_id)
		{
		case LEX_FUNC_PROBNET_CREATE: return L"Create";
		case LEX_FUNC_PROBNET_LOAD: return L"Load";
		case LEX_FUNC_PROBNET_SAVE: return L"Save";
		}
		break;
	case LEX_DATATYPE_CONTROL:
		switch(func_id)
		{
		case LEX_IF: return L"if";
		case LEX_ELSE: return L"else";
		case LEX_FOR: return L"for";
		case LEX_WHILE: return L"while";
		case LEX_DO: return L"do";
		case LEX_SWITCH: return L"switch";
		case LEX_CASE: return L"case";
		case LEX_BREAK: return L"break";
		case LEX_CONTINUE: return L"continue";
		case LEX_RETURN: return L"return";
		}
		break;
	}
	return NULL;
}
wchar_t* Compiler::GetFunctionDescr(int datatype, int func_id)
{
	switch(datatype)
	{
	case LEX_DATATYPE_DOUBLE:
	case LEX_DATATYPE_COMPLEX:
		switch(func_id)
		{
		case LEX_FUNC_SIN: return L"Returns the value of the sine of the angle x (x must be in radians)";
		case LEX_FUNC_COS: return L"Returns the value of the cosine of the angle x (x must be in radians)";
		case LEX_FUNC_TAN: return L"Returns the value of the tangent of the angle x (x must be in radians)";
		case LEX_FUNC_ASIN: return L"Returns the value of the arcsine in radians of x";
		case LEX_FUNC_ACOS: return L"Returns the value of the arccosine in radians of x";
		case LEX_FUNC_ATAN: return L"Returns the value of the arctangent in radians of x";
		case LEX_FUNC_SINH: return L"Returns the value of the hyperbolic sine of x";
		case LEX_FUNC_COSH: return L"Returns the value of the hyperbolic cosine of x";
		case LEX_FUNC_TANH: return L"Returns the value of the hyperbolic tangent of x";
		case LEX_FUNC_SQRT: return L"Returns the value of the squared root of x";
		case LEX_FUNC_LOG10: return L"Returns the base 10 logarithm of x";
		case LEX_FUNC_LOG: return L"Returns the natural logarithm of x";
		case LEX_FUNC_EXP: return L"Returns the natural exponential of x";
		case LEX_FUNC_POW: return L"Returns x to the power of y";
		case LEX_FUNC_ABS: return L"Returns the absolute value of x";
		case LEX_FUNC_SINC: return L"Returns the value of the function sin(pi x)/(pi x)";
		case LEX_FUNC_TRIANG: return L"Returns the value of the triangular function of x";
		case LEX_FUNC_SAW: return L"Returns the value of the sawtooth function of x";
		case LEX_FUNC_RECT: return L"Returns the value of the rectangular function of x (a squared wave form).";
		case LEX_FUNC_CEIL: return L"Returns a double value representing the smallest integer that is greater than or equal to x";
		case LEX_FUNC_FLOOR: return L"Returns a floating-point value representing the largest integer that is less than or equal to x";
		case LEX_FUNC_TOINT: return L"Returns the integer part of a double value";
		case LEX_FUNC_FFT: return L"Returns the Fast Fourier Transform of x, length must be a power of 2";
		case LEX_FUNC_IFFT: return L"Returns the inverse Fast Fourier Transform of x, length must be a power of 2";
		case LEX_FUNC_REALFFT: return L"Returns real and imaginary values stored secuencially for the FFT of the input (which consists of real values), length must be a power of 2";
		case LEX_FUNC_IREALFFT: return L"Returns real values for the inverse FFT of the input (which consists of real and imaginary values stored secuencially), length must be a power of 2";
		case LEX_FUNC_SPECTRUM: return L"Returns the spectrum of x.  Length must be a power of 2.";
		case LEX_FUNC_CONVOLUTION: return L"Returns the convolution";
		case LEX_FUNC_SHORT_CONVOLUTION: return L"Returns the output for the specified impulse response and input";
		case LEX_FUNC_COMPUTE_MSE: return L"Returns the mean squared error";
		case  LEX_FUNC_CONFUSION_MATRIX: return L"Returns the confussion matrix used for classification";
		//case LEX_FUNC_BESSELJ0: return L"Returns the Bessel functions of the first kind of order zero";
		//case LEX_FUNC_BESSELJ1: return L"Returns the Bessel functions of the first kind of order one";
		//case LEX_FUNC_BESSELY0: return L"Returns the Bessel functions of the second kind of order zero";
		//case LEX_FUNC_BESSELY1: return L"Returns the Bessel functions of the second kind of order one";
		case LEX_FUNC_RAND: return L"Returns a random double value in the range (0   x)";	
		}
		break;
	case LEX_DATATYPE_INTEGER:
		switch(func_id)
		{
		//case LEX_FUNC_INT_BIT: return L"It returns the indicated bit of the binary representation of the second number";
		case LEX_FUNC_RANDI: return L"It returns a random integer value in the range [0   x]";
		case LEX_FUNC_ISPRIME: return L"It returns a bool value of false when x is not a prime number; it returns a bool value of true when x is a prime number";
		}
		break;
	case LEX_DATATYPE_MATRIX:
	case LEX_DATATYPE_COMPLEX_MATRIX:
		switch(func_id)
		{
		case LEX_FUNC_MATRIX_CREATE: return L"Creates a matrix";
		case LEX_FUNC_MATRIX_CREATE_RANDOM: return L"Creates a matrix of random values";
		case LEX_FUNC_MATRIX_SAVE: return L"Stores a matrix";
		case LEX_FUNC_MATRIX_LOAD: return L"Loads a matrix";
		case LEX_FUNC_MATRIX_APPEND_RIGHT: return L"Appends the matrix x at the right";
		case LEX_FUNC_MATRIX_APPEND_DOWN: return L"Appends the matrix x at the bottom";
		case LEX_FUNC_MATRIX_DELETE_ROW: return L"Removes the specified row";
		case LEX_FUNC_MATRIX_DELETE_COL: return L"Removes the specified column";
		case LEX_FUNC_MATRIX_INSERT_ROW: return L"Insert an empty row at the specified row";
		case LEX_FUNC_MATRIX_INSERT_COL: return L"Insert an empty column at the specified column";
		case LEX_FUNC_MATRIX_DELETE: return L"Deletes all elements of the matrix";
		case LEX_FUNC_MATRIX_GET_ROW_COUNT: return L"Returns the number of rows in the matrix";
		case LEX_FUNC_MATRIX_GET_COL_COUNT: return L"Returns the number of columns in the matrix";
		case LEX_FUNC_MATRIX_GET_SUM: return L"Returns the summation of the elements of the matrix";
		case LEX_FUNC_MATRIX_GET_DIAGONAL_SUM: return L"Returns the summation of the elements of the main diagonal of the matrix";
		case LEX_FUNC_MATRIX_GET_MEAN: return L"Returns the mean value of the elements of the matrix";
		case LEX_FUNC_MATRIX_GET_VARIANCE: return L"Returns the variance of the elements of the matrix";
		case LEX_FUNC_MATRIX_GET_MINIMUM: return L"Returns the minimum value of the elements of the matrix";
		case LEX_FUNC_MATRIX_GET_MAXIMUM: return L"Returns the maximum value of the elements of the matrix";
		case LEX_FUNC_MATRIX_GET_SUM_SQUARES: return L"Returns the summation of the squared of the elements of the matrix";
		case LEX_FUNC_MATRIX_GET_ROWS: return L"Returns the specified rows of the matrix";
		case LEX_FUNC_MATRIX_GET_COLS: return L"Returns the specified columns of the matrix";
		case LEX_FUNC_MATRIX_DELETE_ROWS: return L"Removes the rows of the matrix that are specified by the indexes in the vector";
		case LEX_FUNC_MATRIX_DELETE_COLS: return L"Removes the columns of the matrix thar are specified by the indexes in the vector";
		case LEX_FUNC_MATRIX_GET_CLASS: return L"Returns the class index for each row in the matrix";
		case LEX_FUNC_MATRIX_TRANSPOSE: return L"Returns the transposed of the matrix. The original matrix remains unchanged";
		case LEX_FUNC_MATRIX_NORM_ROWS: return L"Normalize the rows so that they are in range from -1 to 1";
		case LEX_FUNC_MATRIX_NORM_COLS: return L"Normalize the colums so that they are in the range from -1 to 1";
		case LEX_FUNC_MATRIX_ROWS_VAR: return L"Returns a vector with the variance of each row";
		case LEX_FUNC_MATRIX_COLS_VAR: return L"Returns a vector with the variance of each column";
		case LEX_FUNC_MATRIX_GET_ROW: return L"Returns the specified row of the matrix";
		case LEX_FUNC_MATRIX_GET_COL: return L"Returns the specified column of the matrix";
		}
		break;
	case LEX_DATATYPE_VECTOR:
	case LEX_DATATYPE_COMPLEX_VECTOR:
		switch(func_id)
		{
		case LEX_FUNC_VECTOR_CREATE: return L"Creates a vector";
		case LEX_FUNC_VECTOR_CREATE_SERIES: return L"Creates a series of values";
		case LEX_FUNC_VECTOR_CREATE_RANDOM: return L"Creates a vector with random values";
		case LEX_FUNC_VECTOR_CREATE_BINARY: return L"Creates a vector with the bits of a decimal value";
		case LEX_FUNC_VECTOR_SAVE: return L"Stores a vector into a file";
		case LEX_FUNC_VECTOR_LOAD: return L"Loads a vector from a file";
		case LEX_FUNC_VECTOR_INSERT_CELL : return L"Inserts a value in the vector";
		case LEX_FUNC_VECTOR_DELETE_CELL : return L"Removes a cell from the vector";
		case LEX_FUNC_VECTOR_GET_SIZE: return L"Returns the size of the vector";
		case LEX_FUNC_VECTOR_GET_SUM: return L"Returns the summation of the elements of the vector";
		case LEX_FUNC_VECTOR_GET_MEAN: return L"Returns the mean value of the elements of the vector";
		case LEX_FUNC_VECTOR_GET_VARIANCE: return L"Returns the variance of the elements of the vector";
		case LEX_FUNC_VECTOR_GET_MINIMUM: return L"Returns the minimum value of the elements of the vector";
		case LEX_FUNC_VECTOR_GET_MAXIMUM: return L"Returns the maximum value of the elements of the vector";
		case LEX_FUNC_VECTOR_GET_SQUARED_SUM: return L"Returns the summation of the squared of the elements of the vector";
		case LEX_FUNC_VECTOR_CREATE_LOW_PASS_IMP_RESP: return L"Creates the impulse response of a low pass filter";
		case LEX_FUNC_VECTOR_CREATE_LOW_PASS_FREQ_RESP: return L"Creates the impulse response of a high pass filter";
		case LEX_FUNC_VECTOR_CREATE_HIGH_PASS_IMP_RESP: return L"Creates the frequency response of a low pass filter";
		case LEX_FUNC_VECTOR_CREATE_HIGH_PASS_FREQ_RESP: return L"Creates the frequency response of a high pass filter";
		case LEX_FUNC_VECTOR_CREATE_RANDOM_SET: return L"Creates a random integer set";
		case LEX_FUNC_VECTOR_WRAP: return L"Wraps the elements of a vector to build a training set for prediction";
		case LEX_FUNC_VECTOR_LINE_FIT: return L"Returns the value of m and b that best fit y = mx+b, x = 0, 1, 2, 3, ... (b = vector[1], m = vector[0])";
		}
		break;
	//case LEX_DATATYPE_SCALER:
	//	switch(func_id)
	//	{
	//	case LEX_FUNC_SCALER_CREATEINPUTSCALER: return L"Creates an input scaler of the specified size";
	//	case LEX_FUNC_SCALER_CREATEOUTPUTSCALER: return L"Creates an output data scaler of the specified size";
	//	case LEX_FUNC_SCALER_DELETE: return L"Destroys the data scaler";
	//	case LEX_FUNC_SCALER_GETSIZE: return L"Returns the size of the data scaler";
	//	case LEX_FUNC_SCALER_SAVE: return L"Stores a data scaler into a file";
	//	case LEX_FUNC_SCALER_LOAD: return L"Loads a data scaler from a file";
	//	case LEX_FUNC_SCALER_SET: return L"Sets the scaling information for a specified scaler element";
	//	case LEX_FUNC_SCALER_SCALE: return L"Scales an input matrix and stores the results in the output matrix";
	//	case LEX_FUNC_SCALER_GETMINIMUM: return L"Returns the minimum scale value specified by index";
	//	case LEX_FUNC_SCALER_GETMAXIMUM: return L"Returns the maximum scale value specified by index";
	//	case LEX_FUNC_SCALER_AUTOSETINPUTSCALER: return L"Creates an input data scaler from the specified matrix";
	//	case LEX_FUNC_SCALER_AUTOSETOUTPUTSCALER: return L"Creates an output data scaler from the specified matrix";
	//	}
	//	break;
	case LEX_DATATYPE_LAYERNET:
		switch(func_id)
		{
		case LEX_FUNC_LAYERNET_CREATE: return L"Creates a multilayer artificial neural network";
		case LEX_FUNC_LAYERNET_LOAD: return L"Loads a multilayer artificial neural network from a file";
		case LEX_FUNC_LAYERNET_SAVE: return L"Stores a multilayer artificial neural network into a file";	
		case LEX_FUNC_LAYERNET_SET_WEIGHTS: return L"Set the weights for the specified layer (hidden1 = 1, hidden2 = 2, output = 3)";	
		case LEX_FUNC_LAYERNET_GET_WEIGHTS: return L"Returns the weights of the specified layer (hidden1 = 1, hidden2 = 2, output = 3)";	
		case LEX_FUNC_LAYERNET_GET_INPUT_COUNT: return L"Returns the number of inputs";	
		case LEX_FUNC_LAYERNET_GET_OUTPUT_COUNT: return L"Returns the number of outputs";	
		case LEX_FUNC_LAYERNET_GET_HIDD1_NEU_COUNT: return L"Returns the number of neurons in hidden layer 1";	
		case LEX_FUNC_LAYERNET_GET_HIDD2_NEU_COUNT: return L"Returns the number of neurons in hidden layer 2";	
		case LEX_FUNC_LAYERNET_GET_LAYER_COUNT: return L"Returns the number of layers (at least two: input and output layer)";	
		case LEX_FUNC_LAYERNET_DELETE: return L"Destroy the ANN";	
		case LEX_FUNC_LAYERNET_UNLEARN: return L"Erases any previous training";	
		case LEX_FUNC_LAYERNET_AUTO_SET_INPUT_SCALER: return L"Set the input scaler from an input matrix";	
		case LEX_FUNC_LAYERNET_AUTO_SET_OUTPUT_SCALER: return L"Set the output scaler from an output matrix";	
		case LEX_FUNC_LAYERNET_SET_INPUT_SCALER: return L"Set the scaling range for the specified input";	
		case LEX_FUNC_LAYERNET_SET_OUTPUT_SCALER: return L"Set the scaling range for the specified output";	
		case LEX_FUNC_LAYERNET_GET_INPUT_SCALER: return L"Returns the scaling range for the specified input";	
		case LEX_FUNC_LAYERNET_GET_OUTPUT_SCALER: return L"Returns the scaling range for the specified output";	
		case LEX_FUNC_LAYERNET_SET_TRAINING_SET: return L"Set the training set";
		case LEX_FUNC_LAYERNET_TRAIN_GENETIC: return L"Trains a multilayer ANN using a genetic algorithm";
		case LEX_FUNC_LAYERNET_TRAIN_SIMULATE_ANNEALING: return L"Trains a multilayer ANN using simulated annealing";	
		case LEX_FUNC_LAYERNET_TRAIN_CONJUGATE_GRADIENT: return L"Trains a multilayer ANN using the conjugate gradient";	
		case LEX_FUNC_LAYERNET_TRAIN_VARIABLE_METRIC: return L"Trains a multilayer ANN using the variable metric method";	
		case LEX_FUNC_LAYERNET_TRAIN_LEVENBERG_MARQUARDT: return L"Trains a multilayer ANN using the method of Levenberg Marquardt";	
		case LEX_FUNC_LAYERNET_TRAIN_REGRESSION: return L"Trains a multilayer ANN using regression (for zero hidden layers only)";	
		case LEX_FUNC_LAYERNET_GET_MIN_NUM_TRAIN_CASES: return L"Returns the minimum number of training cases for training the network";
		case LEX_FUNC_LAYERNET_RUN: return L"Computes the output of the ANN for a given input";	
		}
		break;
	case LEX_DATATYPE_KOHONET:
		switch(func_id)
		{
		case LEX_FUNC_KOHONET_CREATE: return L"Creates a kohonen network. Unsupported in this version of Neural Lab.";
		case LEX_FUNC_KOHONET_LOAD: return L"Load a kohonen network from a file. Unsupported in this version of Neural Lab.";
		case LEX_FUNC_KOHONET_SAVE: return L"Save a kohonen network into a file. Unsupported in this version of Neural Lab.";
		}
		break;
	case LEX_DATATYPE_PROBNET:
		switch(func_id)
		{
		case LEX_FUNC_PROBNET_CREATE: return L"Creates a probabilistic artificial neural network. Unsupported in this version of Neural Lab.";
		case LEX_FUNC_PROBNET_LOAD: return L"Loads a probabilistic artificial neural network from a file. Unsupported in this version of Neural Lab.";
		case LEX_FUNC_PROBNET_SAVE: return L"Stores a probabilistic artificial neural network into a file. Unsupported in this version of Neural Lab.";
		}
		break;
	case LEX_DATATYPE_CONTROL:
		switch(func_id)
		{
		case LEX_IF: return L"Executes if the boolean expression is true";
		case LEX_ELSE: return L"Executes when the boolean expression of the respective if statement is false";
		case LEX_FOR: return L"Executes a block of code a specified number of times";
		case LEX_WHILE: return L"Executes a block of code until a condition changes";
		case LEX_DO: return L"Executes at least once a block of code until a condition changes";
		}
		break;
	}
	return NULL;
}

//_____________________________________________________________________ VirtualMachine
VirtualMachine::VirtualMachine(void)
{
	this->errorDescr[0]='\0';
	this->path[0] = '\0';
	//
	Math::Statistics::random_generator.seed((unsigned int)::GetTickCount());
}

VirtualMachine::~VirtualMachine(void)
{
}

wchar_t* VirtualMachine::GetErrorDescr()
{
	if (errorDescr[0] == '\0') return NULL;
	return errorDescr;
}

void VirtualMachine::ClearMemory()
{
	memBool.clear();
	memDouble.clear();
	memInteger.clear();
	memMatrix.clear();
	memVector.clear();
	memComplex.clear();
	memVectorC.clear();
	memMatrixC.clear();
	//memScaler.clear();
	memLayerNet.clear();
	memKohoNet.clear();
	memProbNet.clear();
	variableName.clear();
}

void VirtualMachine::Setup(map<wstring, Cpl::Compiler::VariableInfo>& variableInfo, vector<Cpl::Compiler::Instruction>& machineCode, const wchar_t* path)
{
	this->variableInfo = variableInfo;
	this->machineCode = machineCode;
	if (path)
	{
		_snwprintf_s(this->path, MAX_PATH, _TRUNCATE, L"%s", path);
	}
}

DWORD VirtualMachine::ThreadFunc(Mt::BoolTs& running, Mt::DoubleTs& progress, Mt::BoolTs& resetTime)
{
	//________________________ reset
	this->errorDescr[0]='\0';
	line.Set(0);
	progress.Set(0.0);
	mse.Set(0.0);
	ClearMemory();
	while (stack.empty()==false) stack.pop();

	const int count = machineCode.size();
	bool isRunning = false;
	
	for(instructionIndex=0; instructionIndex<count; instructionIndex++)
	{
		resetTime.SetTry(true);
		if (Execute(machineCode[instructionIndex], running, progress)==false) break;
		if (running.GetTry(isRunning))
		{
			if (isRunning == false) break;
		}
	}
	running.Set(false);
	return 0;
}


// Fills the listview with memory information using the specified datatype
// datatype:  LEX_DATATYPE_BOOL, ..., LEX_DATATYPE_ALL
// gui_type:  VM_GUITYPE_LISTVIEW, VM_GUITYPE_DROPDOWN
void VirtualMachine::GetMemoryInfo(HWND hWnd, int gui_type, int datatype) 
{
	int rows = 0;
	int cols = 0;
	LVITEM lvi;
	ZeroMemory(&lvi, sizeof(LVITEM));
	lvi.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
	//
	if (gui_type == VM_GUITYPE_LISTVIEW)
	{
		::SendMessage(hWnd, WM_SETREDRAW, (WPARAM)(BOOL)FALSE, 0);
		::SendMessage(hWnd, (UINT)LVM_DELETEALLITEMS, 0, 0);
	}
	else if (gui_type == VM_GUITYPE_DROPDOWN)
	{
		//::SendMessage(hWnd, WM_SETREDRAW, (WPARAM)(BOOL)FALSE, 0);
		::SendMessage(hWnd, (UINT)LB_RESETCONTENT, 0, 0);
	}
	int count = 0;
	int i;
	wchar_t info[256];
	wchar_t descr[256];
	int index = 0;
	wstring variableName;
	int new_index = 0;

	//________________________________ bool
	if (datatype == LEX_DATATYPE_BOOL || datatype == LEX_DATATYPE_ALL)
	{
		count = memBool.size();
		for(i=0; i<count; i++)
		{
			variableName = this->GetVariableName(LEX_DATATYPE_BOOL, i);
			if (memBool[i] == true)
				_snwprintf_s(info, 256, _TRUNCATE, L"%s=true", variableName.c_str());
			else
				_snwprintf_s(info, 256, _TRUNCATE, L"%s=false", variableName.c_str());

			lvi.pszText = (wchar_t*)info;
			lvi.iItem = index;
			lvi.lParam = i;
			lvi.iImage = LEX_DATATYPE_BOOL-LEX_DATATYPE_BOOL;
			if (gui_type == VM_GUITYPE_LISTVIEW)
			{
				::SendMessage(hWnd, (UINT) LVM_INSERTITEM, 0, (LPARAM) (LPLVITEM)&lvi);
			}
			else if (gui_type == VM_GUITYPE_DROPDOWN)
			{
				new_index = (int)::SendMessage(hWnd, CB_INSERTSTRING, index, (LPARAM)(wchar_t*)info);
				if (new_index !=CB_ERR)
				{
					::SendMessage(hWnd, CB_SETITEMDATA, new_index, (LPARAM)i); 
				}
			}	
			index++;
		}
	}

	//________________________________ integer
	if (datatype == LEX_DATATYPE_INTEGER || datatype == LEX_DATATYPE_ALL)
	{
		count = memInteger.size();
		for(i=0; i<count; i++)
		{
			variableName = this->GetVariableName(LEX_DATATYPE_INTEGER, i);
			_snwprintf_s(info, 256, _TRUNCATE, L"%s=%d", variableName.c_str(), memInteger[i]);
			lvi.pszText = (wchar_t*)info;
			lvi.iItem = index;
			lvi.lParam = i;
			lvi.iImage = LEX_DATATYPE_INTEGER - LEX_DATATYPE_BOOL;
			if (gui_type == VM_GUITYPE_LISTVIEW)
			{
				::SendMessage(hWnd, (UINT) LVM_INSERTITEM, 0, (LPARAM) (LPLVITEM)&lvi);
			}
			else if (gui_type == VM_GUITYPE_DROPDOWN)
			{
				new_index = (int)::SendMessage(hWnd, CB_INSERTSTRING, index, (LPARAM)(wchar_t*)info);
				if (new_index !=CB_ERR)
				{
					::SendMessage(hWnd, CB_SETITEMDATA, new_index, (LPARAM)i); 
				}
			}	
			index++;
		}
	}

	//________________________________ double
	if (datatype == LEX_DATATYPE_DOUBLE || datatype == LEX_DATATYPE_ALL)
	{
		count = memDouble.size();
		for(i=0; i<count; i++)
		{
			variableName = this->GetVariableName(LEX_DATATYPE_DOUBLE, i);
			_snwprintf_s(info, 256, _TRUNCATE, L"%s=%g", variableName.c_str(), memDouble[i]);
			lvi.pszText = (wchar_t*)info;
			lvi.iItem = index;
			lvi.lParam = i;
			lvi.iImage = LEX_DATATYPE_DOUBLE - LEX_DATATYPE_BOOL;
			if (gui_type == VM_GUITYPE_LISTVIEW)
			{
				::SendMessage(hWnd, (UINT) LVM_INSERTITEM, 0, (LPARAM) (LPLVITEM)&lvi);
			}
			else if (gui_type == VM_GUITYPE_DROPDOWN)
			{
				new_index = (int)::SendMessage(hWnd, CB_INSERTSTRING, index, (LPARAM)(wchar_t*)info);
				if (new_index !=CB_ERR)
				{
					::SendMessage(hWnd, CB_SETITEMDATA, new_index, (LPARAM)i); 
				}
			}	
			index++;
		}
	}

	//________________________________ matrix
	if (datatype == LEX_DATATYPE_MATRIX || datatype == LEX_DATATYPE_ALL)
	{
		count = memMatrix.size();
		for(i=0; i<count; i++)
		{
			rows = memMatrix[i].size();
			cols = rows == 0 ? 0 : memMatrix[i][0].size();
			variableName = this->GetVariableName(LEX_DATATYPE_MATRIX, i);
			_snwprintf_s(info, 256, _TRUNCATE, L"%s [%d%c%d]", variableName.c_str(), rows, WIN_MULTIPLICATION_SIGN, cols);
			lvi.pszText = (wchar_t*)info;
			lvi.iItem = index;
			lvi.lParam = i;
			lvi.iImage = LEX_DATATYPE_MATRIX - LEX_DATATYPE_BOOL;
			if (gui_type == VM_GUITYPE_LISTVIEW)
			{
				::SendMessage(hWnd, (UINT) LVM_INSERTITEM, 0, (LPARAM) (LPLVITEM)&lvi);
			}
			else if (gui_type == VM_GUITYPE_DROPDOWN)
			{
				new_index = (int)::SendMessage(hWnd, CB_INSERTSTRING, index, (LPARAM)(wchar_t*)info);
				if (new_index !=CB_ERR)
				{
					::SendMessage(hWnd, CB_SETITEMDATA, new_index, (LPARAM)i); 
				}
			}	
			index++;
		}
	}

	//________________________________ vector
	if (datatype == LEX_DATATYPE_VECTOR || datatype == LEX_DATATYPE_ALL)
	{	
		count = memVector.size();
		for(i=0; i<count; i++)
		{
			rows = memVector[i].size();
			variableName = this->GetVariableName(LEX_DATATYPE_VECTOR, i);
			_snwprintf_s(info, 256, _TRUNCATE, L"%s [%d]", variableName.c_str(), rows);
			lvi.pszText = (wchar_t*)info;
			lvi.iItem = index;
			lvi.lParam = i;
			lvi.iImage = LEX_DATATYPE_VECTOR - LEX_DATATYPE_BOOL;
			if (gui_type == VM_GUITYPE_LISTVIEW)
			{
				::SendMessage(hWnd, (UINT) LVM_INSERTITEM, 0, (LPARAM) (LPLVITEM)&lvi);
			}
			else if (gui_type == VM_GUITYPE_DROPDOWN)
			{
				new_index = (int)::SendMessage(hWnd, CB_INSERTSTRING, index, (LPARAM)(wchar_t*)info);
				if (new_index !=CB_ERR)
				{
					::SendMessage(hWnd, CB_SETITEMDATA, new_index, (LPARAM)i); 
				}
			}	
			index++;
		}
	}

	//________________________________ complex
	if (datatype == LEX_DATATYPE_COMPLEX || datatype == LEX_DATATYPE_ALL)
	{	
		count = memComplex.size();
		for(i=0; i<count; i++)
		{
			variableName = this->GetVariableName(LEX_DATATYPE_COMPLEX, i);
			if (memComplex[i].imag()>=0)
			{
				_snwprintf_s(info, 256, _TRUNCATE, L"%s=%g + j%g", variableName.c_str(), memComplex[i].real(),
					memComplex[i].imag());
			}
			else
			{
				_snwprintf_s(info, 256, _TRUNCATE, L"%s=%g - j%g", variableName.c_str(), memComplex[i].real(),
					fabs(memComplex[i].imag()));
			}
			lvi.pszText = (wchar_t*)info;
			lvi.iItem = index;
			lvi.lParam = i;
			lvi.iImage = LEX_DATATYPE_COMPLEX - LEX_DATATYPE_BOOL;
			if (gui_type == VM_GUITYPE_LISTVIEW)
			{
				::SendMessage(hWnd, (UINT) LVM_INSERTITEM, 0, (LPARAM) (LPLVITEM)&lvi);
			}
			else if (gui_type == VM_GUITYPE_DROPDOWN)
			{
				new_index = (int)::SendMessage(hWnd, CB_INSERTSTRING, index, (LPARAM)(wchar_t*)info);
				if (new_index !=CB_ERR)
				{
					::SendMessage(hWnd, CB_SETITEMDATA, new_index, (LPARAM)i); 
				}
			}
			index++;
		}
	}

	//________________________________ Complex vector
	if (datatype == LEX_DATATYPE_COMPLEX_VECTOR || datatype == LEX_DATATYPE_ALL)
	{	
		count = memVectorC.size();
		for(i=0; i<count; i++)
		{
			rows = memVectorC[i].size();
			variableName = this->GetVariableName(LEX_DATATYPE_COMPLEX_VECTOR, i);
			_snwprintf_s(info, 256, _TRUNCATE, L"%s [%d]", variableName.c_str(), rows);
			lvi.pszText = (wchar_t*)info;
			lvi.iItem = index;
			lvi.lParam = i;
			lvi.iImage = LEX_DATATYPE_COMPLEX_VECTOR - LEX_DATATYPE_BOOL;
			if (gui_type == VM_GUITYPE_LISTVIEW)
			{
				::SendMessage(hWnd, (UINT) LVM_INSERTITEM, 0, (LPARAM) (LPLVITEM)&lvi);
			}
			else if (gui_type == VM_GUITYPE_DROPDOWN)
			{
				new_index = (int)::SendMessage(hWnd, CB_INSERTSTRING, index, (LPARAM)(wchar_t*)info);
				if (new_index !=CB_ERR)
				{
					::SendMessage(hWnd, CB_SETITEMDATA, new_index, (LPARAM)i); 
				}
			}
			index++;
		}
	}

	//________________________________ Complex matrix
	if (datatype == LEX_DATATYPE_COMPLEX_VECTOR || datatype == LEX_DATATYPE_ALL)
	{	
		count = memMatrixC.size();
		for(i=0; i<count; i++)
		{
			rows = memMatrixC[i].size();
			if (rows>0) cols = memMatrixC[0].size();
			variableName = this->GetVariableName(LEX_DATATYPE_COMPLEX_MATRIX, i);
			_snwprintf_s(info, 256, _TRUNCATE, L"%s [%d%c%d]", variableName.c_str(), rows, WIN_MULTIPLICATION_SIGN, cols);
			lvi.pszText = (wchar_t*)info;
			lvi.iItem = index;
			lvi.lParam = i;
			lvi.iImage = LEX_DATATYPE_COMPLEX_MATRIX - LEX_DATATYPE_BOOL;
			if (gui_type == VM_GUITYPE_LISTVIEW)
			{
				::SendMessage(hWnd, (UINT) LVM_INSERTITEM, 0, (LPARAM) (LPLVITEM)&lvi);
			}
			else if (gui_type == VM_GUITYPE_DROPDOWN)
			{
				new_index = (int)::SendMessage(hWnd, CB_INSERTSTRING, index, (LPARAM)(wchar_t*)info);
				if (new_index !=CB_ERR)
				{
					::SendMessage(hWnd, CB_SETITEMDATA, new_index, (LPARAM)i); 
				}
			}
			index++;
		}
	}
	////________________________________ scaler
	//if (datatype == LEX_DATATYPE_SCALER || datatype == LEX_DATATYPE_ALL)
	//{	
	//	count = memScaler.size();
	//	for(i=0; i<count; i++)
	//	{
	//		variableName = this->GetVariableName(LEX_DATATYPE_SCALER, i);
	//		memScaler[i].GetDescription(descr, 256);
	//		_snwprintf_s(info, 256, _TRUNCATE, L"%s [%s]", variableName.c_str(), descr);
	//		lvi.pszText = (wchar_t*)info;
	//		lvi.iItem = index;
	//		lvi.lParam = i;
	//		lvi.iImage = LEX_DATATYPE_SCALER - LEX_DATATYPE_BOOL;
	//		if (gui_type == VM_GUITYPE_LISTVIEW)
	//		{
	//			::SendMessage(hWnd, (UINT) LVM_INSERTITEM, 0, (LPARAM) (LPLVITEM)&lvi);
	//		}
	//		else if (gui_type == VM_GUITYPE_DROPDOWN)
	//		{
	//			new_index = (int)::SendMessage(hWnd, CB_INSERTSTRING, index, (LPARAM)(wchar_t*)info);
	//			if (new_index !=CB_ERR)
	//			{
	//				::SendMessage(hWnd, CB_SETITEMDATA, new_index, (LPARAM)i); 
	//			}
	//		}
	//		index++;
	//	}
	//}

	//________________________________ layernet
	if (datatype == LEX_DATATYPE_LAYERNET || datatype == LEX_DATATYPE_ALL)
	{	
		count = memLayerNet.size();
		for(i=0; i<count; i++)
		{
			variableName = this->GetVariableName(LEX_DATATYPE_LAYERNET, i);
			memLayerNet[i].GetDescription(descr, 256);
			_snwprintf_s(info, 256, _TRUNCATE, L"%s [%s]", variableName.c_str(), descr);
			lvi.pszText = (wchar_t*)info;
			lvi.iItem = index;
			lvi.lParam = i;
			lvi.iImage = LEX_DATATYPE_LAYERNET - LEX_DATATYPE_BOOL;
			if (gui_type == VM_GUITYPE_LISTVIEW)
			{
				::SendMessage(hWnd, (UINT) LVM_INSERTITEM, 0, (LPARAM) (LPLVITEM)&lvi);
			}
			else if (gui_type == VM_GUITYPE_DROPDOWN)
			{
				new_index = (int)::SendMessage(hWnd, CB_INSERTSTRING, index, (LPARAM)(wchar_t*)info);
				if (new_index !=CB_ERR)
				{
					::SendMessage(hWnd, CB_SETITEMDATA, new_index, (LPARAM)i); 
				}
			}
			index++;
		}
	}

	//________________________________ kohnet
	if (datatype == LEX_DATATYPE_KOHONET || datatype == LEX_DATATYPE_ALL)
	{	
		count = memKohoNet.size();
		for(i=0; i<count; i++)
		{	
			variableName = this->GetVariableName(LEX_DATATYPE_KOHONET, i);
			memKohoNet[i].GetDescription(descr, 256);
			_snwprintf_s(info, 256, _TRUNCATE, L"%s [%s]", variableName.c_str(), descr);
			lvi.pszText = (wchar_t*)info;
			lvi.iItem = index;
			lvi.lParam = i;
			lvi.iImage = LEX_DATATYPE_KOHONET - LEX_DATATYPE_BOOL;
			if (gui_type == VM_GUITYPE_LISTVIEW)
			{
				::SendMessage(hWnd, (UINT) LVM_INSERTITEM, 0, (LPARAM) (LPLVITEM)&lvi);
			}
			else if (gui_type == VM_GUITYPE_DROPDOWN)
			{
				new_index = (int)::SendMessage(hWnd, CB_INSERTSTRING, index, (LPARAM)(wchar_t*)info);
				if (new_index !=CB_ERR)
				{
					::SendMessage(hWnd, CB_SETITEMDATA, new_index, (LPARAM)i); 
				}
			}
			index++;
		}
	}
	//________________________________ probnet
	if (datatype == LEX_DATATYPE_KOHONET || datatype == LEX_DATATYPE_ALL)
	{	
		count = memProbNet.size();
		for(i=0; i<count; i++)
		{
			variableName = this->GetVariableName(LEX_DATATYPE_PROBNET, i);
			memProbNet[i].GetDescription(descr, 256);
			_snwprintf_s(info, 256, _TRUNCATE, L"%s [%s]", variableName.c_str(), descr);
			lvi.pszText = (wchar_t*)info;
			lvi.iItem = index;
			lvi.lParam = i;
			lvi.iImage = LEX_DATATYPE_PROBNET - LEX_DATATYPE_BOOL;
			if (gui_type == VM_GUITYPE_LISTVIEW)
			{
				::SendMessage(hWnd, (UINT) LVM_INSERTITEM, 0, (LPARAM) (LPLVITEM)&lvi);
			}
			else if (gui_type == VM_GUITYPE_DROPDOWN)
			{
				new_index = (int)::SendMessage(hWnd, CB_INSERTSTRING, index, (LPARAM)(wchar_t*)info);
				if (new_index !=CB_ERR)
				{
					::SendMessage(hWnd, CB_SETITEMDATA, new_index, (LPARAM)i); 
				}
			}
			index++;
		}
	}

	//__________________________________________________ Errors
	if (wcslen(errorDescr) > 0 && datatype == LEX_DATATYPE_ALL)
	{
		lvi.pszText = errorDescr;
		lvi.iItem = index;
		lvi.lParam = machineCode[instructionIndex].line_number;
		lvi.iImage = LEX_DATATYPE_PROBNET-LEX_DATATYPE_BOOL+1;
		if (gui_type == VM_GUITYPE_LISTVIEW)
		{
			::SendMessage(hWnd, (UINT) LVM_INSERTITEM, 0, (LPARAM) (LPLVITEM)&lvi);
			::SendMessage(hWnd, WM_SETREDRAW, (WPARAM)(BOOL)TRUE, 0);
		}
		else if (gui_type == VM_GUITYPE_DROPDOWN)
		{
			new_index = (int)::SendMessage(hWnd, CB_INSERTSTRING, index, (LPARAM)errorDescr);
			if (new_index !=CB_ERR)
			{
				::SendMessage(hWnd, CB_SETITEMDATA, new_index, (LPARAM)machineCode[instructionIndex].line_number); 
			}
		}
		index++;
		//return;
	}


	if (gui_type == VM_GUITYPE_LISTVIEW)
	{
		::SendMessage(hWnd, WM_SETREDRAW, (WPARAM)(BOOL)TRUE, 0);
	}
	else if (gui_type == VM_GUITYPE_DROPDOWN)
	{
		//::SendMessage(hWnd, WM_SETREDRAW, (WPARAM)(BOOL)TRUE, 0);
	}
}

wstring VirtualMachine::GetVariableName(int datatype, int index)
{
	map<wstring, Compiler::VariableInfo>::iterator p;
	for(p= variableInfo.begin(); p!= variableInfo.end(); p++)
	{
		if (p->second.index==index && p->second.datatype==datatype)
		{
			return p->first;
		}
	}

	return L"Error";
}

bool VirtualMachine::Execute(Compiler::Instruction& inst, Mt::BoolTs& running, Mt::DoubleTs& progress)
{
	this->line.SetTry(inst.line_number);
	switch(inst.type)
	{
	case VM_ERROR:
		_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %s there are compilation errors",
			machineCode[instructionIndex].line_number);
		return false;
	case VM_CREATE:
		return VmCreate(inst);
	case VM_VALUE:
		return VmValue(inst);
	case VM_REFVALUE:
		return VmRefValue(inst);
	case VM_SETVALUE:
		return VmSetValue(inst);
	case VM_SET_VECTORCELL:
		return VmSetVectorCell(inst);
	case VM_SET_MATRIXCELL:
		return VmSetMatrixCell(inst);
	//case VM_SETREF_VECTORCELL:
	//	return VmSetRefMatrixCell(inst);
	//case VM_SETREF_MATRIXCELL:
	//	return VmSetRefMatrixCell(inst);
	case VM_VECTOR_CELL:
		return VmVectorCell(inst);
	case VM_MATRIX_CELL:
		return VmMatrixCell(inst);
	case VM_OPER:
		return VmOper(inst);
	case VM_OPER_MONO:
		return VmOperMono(inst);
	case VM_OPER_BINA:
		return VmOperBina(inst);
	case VM_FUNC:
		return VmFunc(inst);
	case VM_OBJFUNC:
		return VmObjFunc(inst, running, progress);
	case VM_GOTO:
		return VmGoto(inst);
	case VM_GOFALSE:
		return VmGoFalse(inst);
	case VM_GOTRUE:
		return VmGoTrue(inst);
	}
	return false;
}

bool VirtualMachine::VmValue(Compiler::Instruction& inst)
{
	VirtualMachine::Memory memory;
	memory.datatype = inst.subtype;
	memory.double_value = 0.0;
	memory.int_value = 0;
	memory.bool_value = false;

	if (memory.datatype == LEX_DATATYPE_BOOL)
	{
		memory.datatype = LEX_DATATYPE_BOOL;
		memory.bool_value = (inst.int_value != 0);
		stack.push(memory);
		return true;
	}
	else if (memory.datatype ==LEX_DATATYPE_DOUBLE)
	{
		memory.datatype = LEX_DATATYPE_DOUBLE;
		memory.double_value = inst.double_value;
		stack.push(memory);
		return true;
	}
	else if (memory.datatype ==LEX_DATATYPE_INTEGER)
	{
		memory.datatype = LEX_DATATYPE_INTEGER;
		memory.int_value = inst.int_value;
		stack.push(memory);
		return true;
	}
	_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid value", machineCode[instructionIndex].line_number);
	return false;
}

bool VirtualMachine::VmRefValue(Compiler::Instruction& inst)
{
	VirtualMachine::Memory memory;
	memory.datatype = inst.subtype;
	memory.double_value = 0.0;
	memory.int_value = inst.int_value;
	memory.bool_value = false;
	memory.string_value = inst.name;

	if (memory.datatype == LEX_DATATYPE_BOOL)
	{
		memory.bool_value = memBool[inst.int_value];
		stack.push(memory);
		return true;
	}
	else if (memory.datatype ==LEX_DATATYPE_DOUBLE)
	{
		memory.double_value = memDouble[inst.int_value];
		stack.push(memory);
		return true;
	}
	else if (memory.datatype ==LEX_DATATYPE_INTEGER)
	{
		memory.int_value = memInteger[inst.int_value];
		stack.push(memory);
		return true;
	}
	else if (memory.datatype ==LEX_DATATYPE_MATRIX)
	{
		memory.matrix_value = memMatrix[inst.int_value];
		stack.push(memory);
		return true;
	}
	else if (memory.datatype ==LEX_DATATYPE_VECTOR)
	{
		memory.vector_value = memVector[inst.int_value];
		stack.push(memory);
		return true;
	}
	else if (memory.datatype ==LEX_DATATYPE_COMPLEX)
	{
		memory.complex_value = memComplex[inst.int_value];
		stack.push(memory);
		return true;
	}
	else if (memory.datatype ==LEX_DATATYPE_COMPLEX_VECTOR)
	{
		memory.vectorC_value = memVectorC[inst.int_value];
		stack.push(memory);
		return true;
	}
	else if (memory.datatype ==LEX_DATATYPE_COMPLEX_MATRIX)
	{
		memory.matrixC_value = memMatrixC[inst.int_value];
		stack.push(memory);
		return true;
	}
	//else if (memory.datatype ==LEX_DATATYPE_SCALER)
	//{
	//	memory.int_value = inst.int_value; // By reference
	//	stack.push(memory);
	//	return true;
	//}
	else if (memory.datatype ==LEX_DATATYPE_LAYERNET)
	{
		memory.int_value = inst.int_value; // By reference
		stack.push(memory);
		return true;
	}
	else if (memory.datatype ==LEX_DATATYPE_KOHONET)
	{
		memory.int_value = inst.int_value;  // By reference
		stack.push(memory);
		return true;
	}
	else if (memory.datatype ==LEX_DATATYPE_PROBNET)
	{
		memory.int_value = inst.int_value; // By reference
		stack.push(memory);
		return true;
	}
	_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid data type", machineCode[instructionIndex].line_number);
	return false;
}

bool VirtualMachine::VmSetValue(Compiler::Instruction& inst)
{
	VirtualMachine::Memory value = stack.top();
	stack.pop();
	int datatypeTarget = inst.subtype;
	int index = (int)inst.int_value;
	if (Convert(value, datatypeTarget, NULL) == false) return false;
	if (datatypeTarget == LEX_DATATYPE_BOOL)
	{
		memBool[index] = value.bool_value;
		return true;
	}
	else if (datatypeTarget == LEX_DATATYPE_DOUBLE)
	{
		memDouble[index] = value.double_value;
		return true;
	}
	else if (datatypeTarget == LEX_DATATYPE_INTEGER)
	{
		memInteger[index] = value.int_value;
		return true;
	}
	else if (datatypeTarget == LEX_DATATYPE_MATRIX)
	{
		memMatrix[index] = value.matrix_value;
		return true;
	}
	else if (datatypeTarget == LEX_DATATYPE_VECTOR)
	{
		memVector[index] = value.vector_value;
		return true;
	}
	else if (datatypeTarget == LEX_DATATYPE_COMPLEX)
	{
		memComplex[index] = value.complex_value;
		return true;
	}
	else if (datatypeTarget == LEX_DATATYPE_COMPLEX_VECTOR)
	{
		memVectorC[index] = value.vectorC_value;
		return true;
	}
	else if (datatypeTarget == LEX_DATATYPE_COMPLEX_MATRIX)
	{
		memMatrixC[index] = value.matrixC_value;
		return true;
	}
	//else if (datatypeTarget == LEX_DATATYPE_SCALER)
	//{
	//	memScaler[index] = memScaler[value.int_value]; // Copy
	//	return true;
	//}
	else if (datatypeTarget == LEX_DATATYPE_LAYERNET)
	{
		memLayerNet[index] = memLayerNet[value.int_value]; // Copy
		return true;
	}
	else if (datatypeTarget == LEX_DATATYPE_KOHONET)
	{
		memKohoNet[index] = memKohoNet[value.int_value];
		return true;
	}
	else if (datatypeTarget == LEX_DATATYPE_PROBNET)
	{
		memProbNet[index] = memProbNet[value.int_value];
		return true;
	}
	_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid operation", machineCode[instructionIndex].line_number);
	return false;
}

bool VirtualMachine::VmSetVectorCell(Compiler::Instruction& inst)
{	
	VirtualMachine::Memory value = stack.top();
	stack.pop();

	VirtualMachine::Memory index = stack.top();
	stack.pop();
	if (Convert(index, LEX_DATATYPE_INTEGER, NULL) == false) return false;

	if (inst.subtype == LEX_DATATYPE_VECTOR)
	{
		if (Convert(value, LEX_DATATYPE_DOUBLE, NULL) == false) return false;
		const int rows = memVector[inst.int_value].size();
		if (index.int_value<0 || index.int_value>=rows)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid index", machineCode[instructionIndex].line_number);
			return false;
		}
		memVector[inst.int_value][index.int_value]= value.double_value;
		return true;
	}
	else if (inst.subtype == LEX_DATATYPE_COMPLEX_VECTOR)
	{
		if (Convert(value, LEX_DATATYPE_COMPLEX, NULL) == false) return false;
		const int rows = memVectorC[inst.int_value].size();
		if (index.int_value<0 || index.int_value>=rows)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid index", machineCode[instructionIndex].line_number);
			return false;
		}
		memVectorC[inst.int_value][index.int_value] = value.complex_value;
		return true;
	}
	_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d a Vector or ComplexVector is expected", machineCode[instructionIndex].line_number);
	return false;
}

//bool VirtualMachine::VmSetRefVectorCell(Compiler::Instruction& inst)
//{	
//	//VirtualMachine::Memory index = stack.top();
//	//stack.pop();
//	//if (index.datatype != LEX_DATATYPE_INTEGER)
//	//{
//	//	ReportConversionError(index.datatype, LEX_DATATYPE_INTEGER, NULL);
//	//	return false;
//	//}
//
//	//VirtualMachine::Memory memory;
//	//memory.datatype = inst.subtype;
//	//memory.double_value = inst.double_value;
//	//memory.int_value = inst.int_value;
//	////
//
//	//if (memory.datatype ==LEX_DATATYPE_VECTOR)
//	//{
//	//}
//	//else if (memory.datatype ==LEX_DATATYPE_COMPLEX_VECTOR)
//	//{
//	//}
//
//	return false;
//}


bool VirtualMachine::VmSetMatrixCell(Compiler::Instruction& inst)
{
	VirtualMachine::Memory value = stack.top();
	stack.pop();

	VirtualMachine::Memory indexCol = stack.top();
	stack.pop();
	if (Convert(indexCol, LEX_DATATYPE_INTEGER, NULL) == false) return false;

	VirtualMachine::Memory indexRow = stack.top();
	stack.pop();
	if (Convert(indexRow, LEX_DATATYPE_INTEGER, NULL) == false) return false;

	if (inst.subtype == LEX_DATATYPE_MATRIX)
	{
		if (Convert(value, LEX_DATATYPE_DOUBLE, NULL) == false) return false;
		const int rows = memMatrix[inst.int_value].size();
		const int cols = rows == 0 ? 0 : memMatrix[inst.int_value][0].size();
		if (indexRow.int_value<0 || indexRow.int_value>=rows)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid row index", machineCode[instructionIndex].line_number);
			return false;
		}
		if (indexCol.int_value<0 || indexCol.int_value>=cols)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid column index", machineCode[instructionIndex].line_number);
			return false;
		}
		memMatrix[inst.int_value][indexRow.int_value][indexCol.int_value] = value.double_value;
		return true;
	}
	else if (inst.subtype == LEX_DATATYPE_COMPLEX_MATRIX)
	{
		if (Convert(value, LEX_DATATYPE_COMPLEX, NULL) == false) return false;
		const int rows = memMatrixC[inst.int_value].size();
		const int cols = rows == 0 ? 0 : memMatrixC[inst.int_value][0].size();
		if (indexRow.int_value<0 || indexRow.int_value>=rows)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid row index", machineCode[instructionIndex].line_number);
			return false;
		}
		if (indexCol.int_value<0 || indexCol.int_value>=cols)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid column index", machineCode[instructionIndex].line_number);
			return false;
		}
		memMatrixC[inst.int_value][indexRow.int_value][indexCol.int_value] = value.complex_value;
		return true;
	}
	_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d a Matrix or ComplexMatrix is expected", machineCode[instructionIndex].line_number);
	return false;
}

//bool VirtualMachine::VmSetRefMatrixCell(Compiler::Instruction& inst)
//{
//	return true;
//}

bool VirtualMachine::VmVectorCell(Compiler::Instruction& inst)
{
	VirtualMachine::Memory index = stack.top();
	stack.pop();
	if (index.datatype != LEX_DATATYPE_INTEGER)
	{
		ReportConversionError(index.datatype, LEX_DATATYPE_INTEGER, NULL);
		return false;
	}

	VirtualMachine::Memory memory;
	memory.double_value = 0.0;
	memory.int_value = 0;
	memory.bool_value = false;
	memory.datatype = (int)inst.double_value;
	//
	int count = 0;

	if (memory.datatype ==LEX_DATATYPE_VECTOR)
	{
		if (index.int_value  >= (int)memVector[inst.int_value].size() || index.int_value<0)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid index", machineCode[instructionIndex].line_number);
			return false;
		}
		memory.datatype = LEX_DATATYPE_DOUBLE;
		memory.double_value = memVector[inst.int_value][index.int_value];
		stack.push(memory);
		return true;
	}
	else if (memory.datatype ==LEX_DATATYPE_COMPLEX_VECTOR)
	{
		if (index.int_value  >= (int)memVectorC[inst.int_value].size() || index.int_value<0)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid index", machineCode[instructionIndex].line_number);
			return false;
		}
		memory.datatype = LEX_DATATYPE_COMPLEX;
		memory.complex_value = memVectorC[inst.int_value][index.int_value];
		stack.push(memory);
		return true;
	}
	_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid datatype", machineCode[instructionIndex].line_number);
	return false;
}

// A double or complex value that will be placed in the stack
bool VirtualMachine::VmMatrixCell(Compiler::Instruction& inst)
{
	VirtualMachine::Memory indexCol = stack.top();
	stack.pop();
	if (indexCol.datatype != LEX_DATATYPE_INTEGER)
	{
		ReportConversionError(indexCol.datatype, LEX_DATATYPE_INTEGER, NULL);
		return false;
	}

	VirtualMachine::Memory indexRow = stack.top();
	stack.pop();
	if (indexRow.datatype != LEX_DATATYPE_INTEGER)
	{
		ReportConversionError(indexRow.datatype, LEX_DATATYPE_INTEGER, NULL);
		return false;
	}

	VirtualMachine::Memory memory;
	memory.double_value = 0.0;
	memory.int_value = 0;
	memory.bool_value = false;
	//
	int count = 0;
	const int datatype = (int)inst.double_value;

	if (datatype ==LEX_DATATYPE_MATRIX)
	{
		if (memMatrix[inst.int_value].size() == 0)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d the matrix is empty", machineCode[instructionIndex].line_number);
			return false;
		}
		if (indexRow.int_value  >= (int)memMatrix[inst.int_value].size() || indexRow.int_value < 0)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid index", machineCode[instructionIndex].line_number);
			return false;
		}

		if (indexCol.int_value  >= (int)memMatrix[inst.int_value][0].size() || indexCol.int_value < 0)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid index", machineCode[instructionIndex].line_number);
			return false;
		}
		memory.datatype = LEX_DATATYPE_DOUBLE;
		memory.double_value = memMatrix[inst.int_value][indexRow.int_value][indexCol.int_value];
		stack.push(memory);
		return true;
	}
	else if (datatype ==LEX_DATATYPE_COMPLEX_MATRIX)
	{
		if (memMatrixC[inst.int_value].size() == 0)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d the matrix is empty", machineCode[instructionIndex].line_number);
			return false;
		}
		if (indexRow.int_value  >= (int)memMatrixC[inst.int_value].size() || indexRow.int_value < 0)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid index", machineCode[instructionIndex].line_number);
			return false;
		}

		if (indexCol.int_value  >= (int)memMatrixC[inst.int_value][0].size() || indexCol.int_value < 0)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid index", machineCode[instructionIndex].line_number);
			return false;
		}
		memory.datatype = LEX_DATATYPE_COMPLEX;
		memory.complex_value = memMatrixC[inst.int_value][indexRow.int_value][indexCol.int_value];
		stack.push(memory);
		return true;
	}
	_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid [", machineCode[instructionIndex].line_number);
	return false;
}

bool VirtualMachine::FuncLayerNet(Compiler::Instruction& objectFunction, Cpl::VirtualMachine::Memory* param, int paramCount, Cpl::VirtualMachine::Memory& object,
	Mt::BoolTs& running, Mt::DoubleTs& progress)
{
	wchar_t filename[4*MAX_PATH];
	wchar_t error[256];
	wchar_t * info = NULL;
	Cpl::VirtualMachine::Memory returnValue;

	switch(objectFunction.subtype)
	{
	case LEX_FUNC_LAYERNET_CREATE:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		if (Convert(param[0], LEX_DATATYPE_INTEGER, L"4") == false) return false;
		if (Convert(param[1], LEX_DATATYPE_INTEGER, L"3") == false) return false;
		if (Convert(param[2], LEX_DATATYPE_INTEGER, L"2") == false) return false;
		if (Convert(param[3], LEX_DATATYPE_INTEGER, L"1") == false) return false;
		returnValue.bool_value = memLayerNet[object.int_value].Create(param[3].int_value, param[2].int_value, param[1].int_value, param[0].int_value);
		stack.push(returnValue);
		if (returnValue.bool_value == false)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d unable to create layer network", machineCode[instructionIndex].line_number);
			return false;
		}
		return true;
	case LEX_FUNC_LAYERNET_LOAD:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		_snwprintf_s(filename, 4*MAX_PATH, _TRUNCATE, L"%s\\%s.lay", path, object.string_value.c_str());
		info = memLayerNet[object.int_value].Load(filename);
		returnValue.bool_value = (info ==NULL);
		stack.push(returnValue);
		if (info != NULL)
		{
			Sys::GetLastErrorInformation(error, 256);
			Sys::TextAssistant::DeleteChar(error, '\r');
			Sys::TextAssistant::DeleteChar(error, '\n');
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s %s", objectFunction.line_number, object.string_value.c_str(), error);
			return false;
		}
		return true;
	case LEX_FUNC_LAYERNET_SAVE:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		_snwprintf_s(filename, 4*MAX_PATH, _TRUNCATE, L"%s\\%s.lay", path, object.string_value.c_str());
		info = memLayerNet[object.int_value].Save(filename);
		returnValue.bool_value = (info == NULL);
		stack.push(returnValue);
		if (info != NULL)
		{
			Sys::GetLastErrorInformation(error, 256);
			Sys::TextAssistant::DeleteChar(error, '\r');
			Sys::TextAssistant::DeleteChar(error, '\n');
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s %s", objectFunction.line_number, object.string_value.c_str(), error);
			return false;
		}
		return true;
	case LEX_FUNC_LAYERNET_SET_WEIGHTS:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		if (Convert(param[0], LEX_DATATYPE_MATRIX, L"2") == false) return false;
		if (Convert(param[1], LEX_DATATYPE_INTEGER, L"1") == false) return false;
		returnValue.bool_value = memLayerNet[object.int_value].SetWeights(param[1].int_value, param[0].matrix_value);
		stack.push(returnValue);
		if (returnValue.bool_value == false)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid weight index", machineCode[instructionIndex].line_number);
			return false;
		}
		return true;
	case LEX_FUNC_LAYERNET_GET_WEIGHTS:
		returnValue.datatype = LEX_DATATYPE_MATRIX;
		if (Convert(param[0], LEX_DATATYPE_INTEGER, L"1") == false) return false;
		memLayerNet[object.int_value].GetWeights(param[0].int_value, returnValue.matrix_value);
		stack.push(returnValue);
		if (returnValue.bool_value == false)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid weight index", machineCode[instructionIndex].line_number);
			return false;
		}
		return true;
	case LEX_FUNC_LAYERNET_GET_INPUT_COUNT:
		returnValue.datatype = LEX_DATATYPE_INTEGER;
		returnValue.int_value = memLayerNet[object.int_value].GetInputCount();
		stack.push(returnValue);
		return true;
	case LEX_FUNC_LAYERNET_GET_OUTPUT_COUNT:
		returnValue.datatype = LEX_DATATYPE_INTEGER;
		returnValue.int_value = memLayerNet[object.int_value].GetOutputCount();
		stack.push(returnValue);
		return true;
	case LEX_FUNC_LAYERNET_GET_HIDD1_NEU_COUNT:
		returnValue.datatype = LEX_DATATYPE_INTEGER;
		returnValue.int_value = memLayerNet[object.int_value].GetHidden1NeuronCount();
		stack.push(returnValue);
		return true;
	case LEX_FUNC_LAYERNET_GET_HIDD2_NEU_COUNT:
		returnValue.datatype = LEX_DATATYPE_INTEGER;
		returnValue.int_value = memLayerNet[object.int_value].GetHidden2NeuronCount();
		stack.push(returnValue);
		return true;
	case LEX_FUNC_LAYERNET_GET_LAYER_COUNT:
		returnValue.datatype = LEX_DATATYPE_INTEGER;
		returnValue.int_value = memLayerNet[object.int_value].GetLayerCount();
		stack.push(returnValue);
		return true;
	case LEX_FUNC_LAYERNET_DELETE:
		returnValue.datatype = LEX_DATATYPE_VOID;
		memLayerNet[object.int_value].Delete();
		stack.push(returnValue);
		return true;
	case LEX_FUNC_LAYERNET_UNLEARN:
		returnValue.datatype = LEX_DATATYPE_VOID;
		memLayerNet[object.int_value].Unlearn();
		stack.push(returnValue);
		return true;
	case LEX_FUNC_LAYERNET_AUTO_SET_INPUT_SCALER:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		if (Convert(param[0], LEX_DATATYPE_MATRIX, L"1") == false) return false;
		returnValue.bool_value = memLayerNet[object.int_value].AutoSetInputScaler(param[0].matrix_value);
		stack.push(returnValue);
		return true;
	case LEX_FUNC_LAYERNET_AUTO_SET_OUTPUT_SCALER:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		if (Convert(param[0], LEX_DATATYPE_MATRIX, L"1") == false) return false;
		returnValue.bool_value = memLayerNet[object.int_value].AutoSetOutputScaler(param[0].matrix_value);
		stack.push(returnValue);
		return true;
	case LEX_FUNC_LAYERNET_SET_INPUT_SCALER:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		if (Convert(param[0], LEX_DATATYPE_DOUBLE, L"3") == false) return false;
		if (Convert(param[1], LEX_DATATYPE_DOUBLE, L"2") == false) return false;
		if (Convert(param[2], LEX_DATATYPE_INTEGER, L"1") == false) return false;
		returnValue.bool_value = memLayerNet[object.int_value].SetInputScaler(param[2].int_value, 
			param[1].double_value, param[0].double_value);
		stack.push(returnValue);
		if (returnValue.bool_value == false)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid input scaler index", machineCode[instructionIndex].line_number);
			return false;
		}
		return true;
	case LEX_FUNC_LAYERNET_SET_OUTPUT_SCALER:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		if (Convert(param[0], LEX_DATATYPE_DOUBLE, L"3") == false) return false;
		if (Convert(param[1], LEX_DATATYPE_DOUBLE, L"2") == false) return false;
		if (Convert(param[2], LEX_DATATYPE_INTEGER, L"1") == false) return false;
		returnValue.bool_value = memLayerNet[object.int_value].SetOutputScaler(param[2].int_value, 
			param[1].double_value, param[0].double_value);
		stack.push(returnValue);
		if (returnValue.bool_value == false)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid output scaler index", machineCode[instructionIndex].line_number);
			return false;
		}
		return true;
	case LEX_FUNC_LAYERNET_GET_INPUT_SCALER:
		returnValue.datatype = LEX_DATATYPE_VECTOR;
		returnValue.vector_value.resize(2);
		if (Convert(param[0], LEX_DATATYPE_INTEGER, L"1") == false) return false;
		if (memLayerNet[object.int_value].GetInputScaler(param[0].int_value, 
			returnValue.vector_value[0], returnValue.vector_value[1]) == false)
		{
			returnValue.vector_value.free();
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid index", machineCode[instructionIndex].line_number);
			return false;
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_LAYERNET_GET_OUTPUT_SCALER:
		returnValue.datatype = LEX_DATATYPE_VECTOR;
		returnValue.vector_value.resize(2);
		if (Convert(param[0], LEX_DATATYPE_INTEGER, L"1") == false) return false;
		if (memLayerNet[object.int_value].GetOutputScaler(param[0].int_value, 
			returnValue.vector_value[0], returnValue.vector_value[1]) == false)
		{
			returnValue.vector_value.free();
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid index", machineCode[instructionIndex].line_number);
			return false;
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_LAYERNET_SET_TRAINING_SET:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		if (Convert(param[0], LEX_DATATYPE_BOOL, L"3") == false) return false;
		if (Convert(param[1], LEX_DATATYPE_MATRIX, L"2") == false) return false;
		if (Convert(param[2], LEX_DATATYPE_MATRIX, L"1") == false) return false;
		//
		//
		info = memLayerNet[object.int_value].SetTrainingSet(param[2].matrix_value, param[1].matrix_value, param[0].bool_value);
		stack.push(returnValue);
		returnValue.bool_value = (info == NULL);
		if (returnValue.bool_value == false)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, info);
			return false;
		}
		return true;
	case LEX_FUNC_LAYERNET_TRAIN_GENETIC:
		{
			Math::GeneticParam gp;
			returnValue.datatype = LEX_DATATYPE_BOOL;
			if (Convert(param[0], LEX_DATATYPE_DOUBLE, L"6") == false) return false;
			if (Convert(param[1], LEX_DATATYPE_DOUBLE, L"5") == false) return false;
			if (Convert(param[2], LEX_DATATYPE_DOUBLE, L"4") == false) return false;
			if (Convert(param[3], LEX_DATATYPE_DOUBLE, L"3") == false) return false;
			if (Convert(param[4], LEX_DATATYPE_INTEGER, L"2") == false) return false;
			if (Convert(param[5], LEX_DATATYPE_INTEGER, L"1") == false) return false;
			//
			gp.initPopulationSize = param[5].int_value;
			gp.numGenerations = param[4].int_value;
			gp.overPopulation = param[3].double_value;
			gp.mutationProbability = param[2].double_value;
			gp.crossoverProbability = param[1].double_value;
			gp.goal = param[0].double_value;
			//
			info = memLayerNet[object.int_value].TrainGenetic(running, progress, mse, gp);
			stack.push(returnValue);
			returnValue.bool_value = (info == NULL);
			if (returnValue.bool_value == false)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, info);
				return false;
			}
		}
		return true;
	case LEX_FUNC_LAYERNET_TRAIN_SIMULATE_ANNEALING:
		{
			Math::SimAnnealParam ap;
			returnValue.datatype = LEX_DATATYPE_BOOL;
			if (Convert(param[0], LEX_DATATYPE_DOUBLE, L"7") == false) return false;
			if (Convert(param[1], LEX_DATATYPE_INTEGER, L"6") == false) return false;
			if (Convert(param[2], LEX_DATATYPE_BOOL, L"5") == false) return false;
			if (Convert(param[3], LEX_DATATYPE_DOUBLE, L"4") == false) return false;
			if (Convert(param[4], LEX_DATATYPE_DOUBLE, L"3") == false) return false;
			if (Convert(param[5], LEX_DATATYPE_INTEGER, L"2") == false) return false;
			if (Convert(param[6], LEX_DATATYPE_INTEGER, L"1") == false) return false;
			//
			ap.numTemps = param[6].int_value;
			ap.numIterations = param[5].int_value;
			ap.initialTemp = param[4].double_value;
			ap.finalTemp = param[3].double_value;
			ap.isCoolingScheduleLinear = param[2].bool_value;
			ap.cycles = param[1].int_value;
			ap.goal = param[0].double_value;
			//
			info = memLayerNet[object.int_value].TrainSimAnneal(running, progress, mse, ap);
			stack.push(returnValue);
			returnValue.bool_value = (info == NULL);
			if (returnValue.bool_value == false)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, info);
				return false;
			}
			this->mse.Set(memLayerNet[object.int_value].ComputeCurrentTrueMse());
		}
		return true;
	case LEX_FUNC_LAYERNET_TRAIN_CONJUGATE_GRADIENT:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		if (Convert(param[0], LEX_DATATYPE_DOUBLE, L"2") == false) return false;
		if (Convert(param[1], LEX_DATATYPE_INTEGER, L"1") == false) return false;
		//
		info = memLayerNet[object.int_value].TrainConjugateGradient(running, progress, mse, param[1].int_value, param[0].double_value);
		stack.push(returnValue);
		returnValue.bool_value = (info == NULL);
		if (returnValue.bool_value == false)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, info);
			return false;
		}
		return true;
	case LEX_FUNC_LAYERNET_TRAIN_VARIABLE_METRIC:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		if (Convert(param[0], LEX_DATATYPE_DOUBLE, L"2") == false) return false;
		if (Convert(param[1], LEX_DATATYPE_INTEGER, L"1") == false) return false;
		//
		info = memLayerNet[object.int_value].TrainVariableMetric(running, progress, mse, param[1].int_value, param[0].double_value);
		stack.push(returnValue);
		returnValue.bool_value = (info == NULL);
		if (returnValue.bool_value == false)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, info);
			return false;
		}
		return true;
	case LEX_FUNC_LAYERNET_TRAIN_LEVENBERG_MARQUARDT:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		if (Convert(param[0], LEX_DATATYPE_DOUBLE, L"2") == false) return false;
		if (Convert(param[1], LEX_DATATYPE_INTEGER, L"1") == false) return false;
		//
		info = memLayerNet[object.int_value].TrainLevenbergMarquardt(running, progress, mse, param[1].int_value, param[0].double_value, false);
		stack.push(returnValue);
		returnValue.bool_value = (info == NULL);
		if (returnValue.bool_value == false)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, info);
			return false;
		}
		return true;
	case LEX_FUNC_LAYERNET_TRAIN_REGRESSION:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		//
		info = memLayerNet[object.int_value].TrainRegression(running, progress, mse);
		stack.push(returnValue);
		returnValue.bool_value = (info == NULL);
		if (returnValue.bool_value == false)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, info);
			return false;
		}
		return true;
	case LEX_FUNC_LAYERNET_GET_MIN_NUM_TRAIN_CASES:
		returnValue.datatype = LEX_DATATYPE_INTEGER;
		returnValue.int_value = memLayerNet[object.int_value].GetMinNumTrainCases();
		stack.push(returnValue);
		return true;
	case LEX_FUNC_LAYERNET_RUN:
		returnValue.datatype = LEX_DATATYPE_MATRIX;
		if (Convert(param[0], LEX_DATATYPE_MATRIX, L"1") == false) return false;
		if (memLayerNet[object.int_value].Run(param[0].matrix_value, returnValue.matrix_value) == false)
		{
			returnValue.matrix_value.clear();
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid input matrix", machineCode[instructionIndex].line_number);
			return false;
		}
		stack.push(returnValue);
		return true;
	}
	return false;
}

bool VirtualMachine::FuncKohoNet(Compiler::Instruction& objectFunction, Cpl::VirtualMachine::Memory* param, int paramCount, Cpl::VirtualMachine::Memory& object,
	Mt::BoolTs& running, Mt::DoubleTs& progress)
{
	return false;
}

bool VirtualMachine::FuncProbNet(Compiler::Instruction& objectFunction, Cpl::VirtualMachine::Memory* param, int paramCount, Cpl::VirtualMachine::Memory& object,
	Mt::BoolTs& running, Mt::DoubleTs& progress)
{
	return false;
}

//bool VirtualMachine::FuncScaler(Compiler::Instruction& objectFunction, Cpl::VirtualMachine::Memory* param, int paramCount, Cpl::VirtualMachine::Memory& object)
//{
//	wchar_t filename[4*MAX_PATH];
//	wchar_t error[256];
//	wchar_t * info = NULL;
//	Cpl::VirtualMachine::Memory returnValue;
//
//	switch(objectFunction.subtype)
//	{
//	case LEX_FUNC_SCALER_CREATEINPUTSCALER:
//		returnValue.datatype = LEX_DATATYPE_BOOL;
//		if (Convert(param[0], LEX_DATATYPE_INTEGER, L"1") == false) return false;
//		if (memScaler[object.int_value].CreateInputScaler(param[0].int_value)==false)
//		{
//			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d no enough memory to create input scaler", objectFunction.line_number);
//			returnValue.bool_value = false;
//			stack.push(returnValue);
//			return false;
//		}
//		returnValue.bool_value = true;
//		stack.push(returnValue);
//		return true;
//	case LEX_FUNC_SCALER_CREATEOUTPUTSCALER:
//		returnValue.datatype = LEX_DATATYPE_BOOL;
//		if (Convert(param[0], LEX_DATATYPE_INTEGER, L"1") == false) return false;
//		if (memScaler[object.int_value].CreateOutputScaler(param[0].int_value)==false)
//		{
//			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d no enough memory to create output scaler", objectFunction.line_number);
//			returnValue.bool_value = false;
//			stack.push(returnValue);
//			return false;
//		}
//		returnValue.bool_value = true;
//		stack.push(returnValue);
//		return true;
//	case LEX_FUNC_SCALER_DELETE:
//		returnValue.datatype = LEX_DATATYPE_VOID;
//		memScaler[object.int_value].Delete();
//		stack.push(returnValue);
//		return true;
//	case LEX_FUNC_SCALER_GETSIZE:
//		returnValue.datatype = LEX_DATATYPE_INTEGER;
//		returnValue.int_value = memScaler[object.int_value].GetSize();
//		stack.push(returnValue);
//		return true;
//	case LEX_FUNC_SCALER_SAVE:
//		returnValue.datatype = LEX_DATATYPE_BOOL;
//		_snwprintf_s(filename, 4*MAX_PATH, _TRUNCATE, L"%s\\%s.sca", path, object.string_value.c_str());
//		if (memScaler[object.int_value].Save(filename)==false)
//		{
//			Sys::GetLastErrorInformation(error, 256);
//			Sys::TextAssistant::DeleteChar(error, '\r');
//			Sys::TextAssistant::DeleteChar(error, '\n');
//			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s %s", objectFunction.line_number, object.string_value.c_str(), error);
//			return false;
//		}
//		returnValue.bool_value = true;
//		stack.push(returnValue);
//		return true;
//	case LEX_FUNC_SCALER_LOAD:
//		returnValue.datatype = LEX_DATATYPE_BOOL;
//		_snwprintf_s(filename, 4*MAX_PATH, _TRUNCATE, L"%s\\%s.sca", path, object.string_value.c_str());
//		if (memScaler[object.int_value].Load(filename)==false)
//		{
//			Sys::GetLastErrorInformation(error, 256);
//			Sys::TextAssistant::DeleteChar(error, '\r');
//			Sys::TextAssistant::DeleteChar(error, '\n');
//			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s %s", objectFunction.line_number, object.string_value.c_str(), error);
//			return false;
//		}
//		returnValue.bool_value = true;
//		stack.push(returnValue);
//		return true;
//	case LEX_FUNC_SCALER_SET:
//		returnValue.datatype = LEX_DATATYPE_BOOL;
//		if (Convert(param[0], LEX_DATATYPE_DOUBLE, L"1") == false) return false;
//		if (Convert(param[1], LEX_DATATYPE_DOUBLE, L"2") == false) return false;
//		if (Convert(param[2], LEX_DATATYPE_INTEGER, L"3") == false) return false;
//		if (memScaler[object.int_value].Set(param[2].int_value, param[1].double_value, param[0].double_value)==false)
//		{
//			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid index value", objectFunction.line_number);
//			returnValue.bool_value = false;
//			stack.push(returnValue);
//			return false;
//		}
//		returnValue.bool_value = true;
//		stack.push(returnValue);
//		return true;
//	case LEX_FUNC_SCALER_SCALE:
//		returnValue.datatype = LEX_DATATYPE_BOOL;
//		if (Convert(param[0], LEX_DATATYPE_MATRIX, L"1") == false) return false;
//		if (Convert(param[1], LEX_DATATYPE_MATRIX, L"2") == false) return false;
//		info =memScaler[object.int_value].Scale(param[1].matrix_value, param[0].matrix_value);
//		if (info != NULL)
//		{
//			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", objectFunction.line_number, errorDescr);
//			returnValue.bool_value = false;
//			stack.push(returnValue);
//			return false;
//		}
//		returnValue.bool_value = true;
//		stack.push(returnValue);
//		return true;
//	case LEX_FUNC_SCALER_GETMINIMUM:
//		returnValue.datatype = LEX_DATATYPE_DOUBLE;
//		if (Convert(param[0], LEX_DATATYPE_INTEGER, L"1") == false) return false;
//		returnValue.double_value = memScaler[object.int_value].GetMinimum(param[0].int_value);
//		if (param[0].int_value < 0 || param[0].int_value>= memScaler[object.int_value].GetSize())
//		{
//			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s invalid index", objectFunction.line_number, object.string_value.c_str());
//			stack.push(returnValue);
//			return false;
//		}
//		stack.push(returnValue);
//		return true;
//	case LEX_FUNC_SCALER_GETMAXIMUM:
//		returnValue.datatype = LEX_DATATYPE_DOUBLE;
//		if (Convert(param[0], LEX_DATATYPE_INTEGER, L"1") == false) return false;
//		returnValue.double_value = memScaler[object.int_value].GetMaximum(param[0].int_value);
//		if (param[0].int_value < 0 || param[0].int_value>= memScaler[object.int_value].GetSize())
//		{
//			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s invalid index", objectFunction.line_number, object.string_value.c_str());
//			stack.push(returnValue);
//			return false;
//		}
//		stack.push(returnValue);
//		return true;
//	case LEX_FUNC_SCALER_AUTOSETINPUTSCALER:
//		returnValue.datatype = LEX_DATATYPE_BOOL;
//		if (Convert(param[0], LEX_DATATYPE_MATRIX, L"1") == false) return false;
//		if (memScaler[object.int_value].AutoSetInputScaler(param[0].matrix_value)==false)
//		{
//			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d AutoSetInputScaler invalid matrix", objectFunction.line_number);
//			returnValue.bool_value = false;
//			stack.push(returnValue);
//			return false;
//		}
//		returnValue.bool_value = true;
//		stack.push(returnValue);
//		return true;
//	case LEX_FUNC_SCALER_AUTOSETOUTPUTSCALER:
//		returnValue.datatype = LEX_DATATYPE_BOOL;
//		if (Convert(param[0], LEX_DATATYPE_MATRIX, L"1") == false) return false;
//		if (memScaler[object.int_value].AutoSetOutputScaler(param[0].matrix_value)==false)
//		{
//			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d AutoSetOutputScaler invalid matrix", objectFunction.line_number);
//			returnValue.bool_value = false;
//			stack.push(returnValue);
//			return false;
//		}
//		returnValue.bool_value = true;
//		stack.push(returnValue);
//		return true;
//	}
//	_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid scaler function", machineCode[instructionIndex].line_number);
//	return false;
//}

bool VirtualMachine::FuncMatrix(Compiler::Instruction& objectFunction, Cpl::VirtualMachine::Memory* param, int paramCount, Cpl::VirtualMachine::Memory& object, bool isComplex)
{	
	wchar_t filename[4*MAX_PATH];
	wchar_t error[256];
	wchar_t * info = NULL;
	Cpl::VirtualMachine::Memory returnValue;

	switch(objectFunction.subtype)
	{
	case LEX_FUNC_MATRIX_CREATE:
		{
			returnValue.datatype = LEX_DATATYPE_BOOL;
			if (Convert(param[0], LEX_DATATYPE_INTEGER, L"1") == false) return false;
			if (Convert(param[1], LEX_DATATYPE_INTEGER, L"2") == false) return false;
			if (isComplex)
			{
				if (Math::Oper::CreateMatrix(memMatrixC[object.int_value], param[1].int_value, param[0].int_value)==false)
				{
					_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d no enough memory to create matrix", machineCode[instructionIndex].line_number);
					return false;
				}
			}
			else
			{
				if (Math::Oper::CreateMatrix(memMatrix[object.int_value], param[1].int_value, param[0].int_value)==false)
				{
					_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d no enough memory to create matrix", machineCode[instructionIndex].line_number);
					return false;
				}
			}
		}
		returnValue.bool_value = true;
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_CREATE_RANDOM:
		{
			returnValue.datatype = LEX_DATATYPE_BOOL;
			if (Convert(param[0], LEX_DATATYPE_DOUBLE, L"4") == false) return false;
			if (Convert(param[1], LEX_DATATYPE_DOUBLE, L"3") == false) return false;
			if (Convert(param[2], LEX_DATATYPE_INTEGER, L"2") == false) return false;
			if (Convert(param[3], LEX_DATATYPE_INTEGER, L"1") == false) return false;
			if (isComplex)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d ComplexMatrix does not support this method", machineCode[instructionIndex].line_number);
				return false;
			}
			else
			{
				if (Math::Oper::CreateRandom(memMatrix[object.int_value], param[3].int_value, param[2].int_value, param[1].double_value, param[0].double_value)==false)
				{
					_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d Matrix::CreateRandom no enough memory", machineCode[instructionIndex].line_number);
					return false;
				}
			}
		}
		returnValue.bool_value = true;
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_SAVE:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		_snwprintf_s(filename, 4*MAX_PATH, _TRUNCATE, L"%s\\%s.csv", path, object.string_value.c_str());
		if (isComplex)
		{
			if (Sys::FileAssistant::CsvSave(filename, memMatrixC[object.int_value])==false)
			{
				Sys::GetLastErrorInformation(error, 256);
				Sys::TextAssistant::DeleteChar(error, '\r');
				Sys::TextAssistant::DeleteChar(error, '\n');
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s %s", objectFunction.line_number, object.string_value.c_str(), error);
				return false;
			}
		}
		else
		{
			if (Sys::FileAssistant::CsvSave(filename, memMatrix[object.int_value])==false)
			{
				Sys::GetLastErrorInformation(error, 256);
				Sys::TextAssistant::DeleteChar(error, '\r');
				Sys::TextAssistant::DeleteChar(error, '\n');
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s %s", objectFunction.line_number, object.string_value.c_str(), error);
				return false;
			}
		}
		returnValue.bool_value = true;
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_LOAD:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		_snwprintf_s(filename, 4*MAX_PATH, _TRUNCATE, L"%s\\%s.csv", path, object.string_value.c_str());
		if (isComplex)
		{
			if (Sys::FileAssistant::CsvLoad(filename, memMatrixC[object.int_value])==false)
			{
				Sys::GetLastErrorInformation(error, 256);
				Sys::TextAssistant::DeleteChar(error, '\r');
				Sys::TextAssistant::DeleteChar(error, '\n');
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s %s", objectFunction.line_number, object.string_value.c_str(), error);
				return false;
			}
		}
		else
		{
			if (Sys::FileAssistant::CsvLoad(filename, memMatrix[object.int_value])==false)
			{
				Sys::GetLastErrorInformation(error, 256);
				Sys::TextAssistant::DeleteChar(error, '\r');
				Sys::TextAssistant::DeleteChar(error, '\n');
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s %s", objectFunction.line_number, object.string_value.c_str(), error);
				return false;
			}
		}
		returnValue.bool_value = true;
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_APPEND_RIGHT:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		
		if (isComplex)
		{
			if (Convert(param[0], LEX_DATATYPE_COMPLEX_MATRIX, L"1") == false) return false;
			if (Math::Oper::AppendRight(memMatrixC[object.int_value], param[0].matrixC_value)==false)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d the matrix size is incorrect", machineCode[instructionIndex].line_number);
				return false;
			}
		}
		else
		{
			if (Convert(param[0], LEX_DATATYPE_MATRIX, L"1") == false) return false;
			if (Math::Oper::AppendRight(memMatrix[object.int_value], param[0].matrix_value)==false)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d the matrix size is incorrect", machineCode[instructionIndex].line_number);
				return false;
			}
		}
		returnValue.bool_value = true;
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_APPEND_DOWN:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		if (isComplex)
		{
			if (Convert(param[0], LEX_DATATYPE_COMPLEX_MATRIX, L"1") == false) return false;
			if (Math::Oper::AppendDown(memMatrixC[object.int_value], param[0].matrixC_value)==false)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d the matrix size is incorrect", machineCode[instructionIndex].line_number);
				return false;
			}
		}
		else
		{
			if (Convert(param[0], LEX_DATATYPE_MATRIX, L"1") == false) return false;
			if (Math::Oper::AppendDown(memMatrix[object.int_value], param[0].matrix_value)==false)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d the matrix size is incorrect", machineCode[instructionIndex].line_number);
				return false;
			}
		}
		returnValue.bool_value = true;
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_DELETE_ROW:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		if (Convert(param[0], LEX_DATATYPE_INTEGER, L"1") == false) return false;
		if (isComplex)
		{
			if (Math::Oper::DeleteRow(memMatrixC[object.int_value], param[0].int_value)==false)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d the row index is correct", machineCode[instructionIndex].line_number);
				return false;
			}
		}
		else
		{
			if (Math::Oper::DeleteRow(memMatrix[object.int_value], param[0].int_value)==false)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d the row index is correct", machineCode[instructionIndex].line_number);
				return false;
			}
		}
		returnValue.bool_value = true;
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_DELETE_COL:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		if (Convert(param[0], LEX_DATATYPE_INTEGER, L"1") == false) return false;
		if (isComplex)
		{
			if (Math::Oper::DeleteCol(memMatrixC[object.int_value], param[0].int_value)==false)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d the column index is correct", machineCode[instructionIndex].line_number);
				return false;
			}
		}
		else
		{
			if (Math::Oper::DeleteCol(memMatrix[object.int_value], param[0].int_value)==false)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d the column index is correct", machineCode[instructionIndex].line_number);
				return false;
			}
		}
		returnValue.bool_value = true;
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_INSERT_ROW:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		if (Convert(param[0], LEX_DATATYPE_INTEGER, L"1") == false) return false;
		if (isComplex)
		{
			if (Math::Oper::InsertRow(memMatrixC[object.int_value], param[0].int_value)==false)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d the row index is correct", machineCode[instructionIndex].line_number);
				return false;
			}
		}
		else
		{
			if (Math::Oper::InsertRow(memMatrix[object.int_value], param[0].int_value)==false)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d the row index is correct", machineCode[instructionIndex].line_number);
				return false;
			}
		}
		returnValue.bool_value = true;
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_INSERT_COL:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		if (Convert(param[0], LEX_DATATYPE_INTEGER, L"1") == false) return false;
		if (isComplex)
		{
			if (Math::Oper::InsertCol(memMatrixC[object.int_value], param[0].int_value)==false)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d the column index is correct", machineCode[instructionIndex].line_number);
				return false;
			}
		}
		else
		{	
			if (Math::Oper::InsertCol(memMatrix[object.int_value], param[0].int_value)==false)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d the column index is correct", machineCode[instructionIndex].line_number);
				return false;
			}
		}
		returnValue.bool_value = true;
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_DELETE:
		returnValue.datatype = LEX_DATATYPE_VOID;
		if (Convert(param[0], LEX_DATATYPE_INTEGER, L"1") == false) return false;
		if (isComplex)
		{
			memMatrixC[object.int_value].clear();
		}
		else
		{
			memMatrix[object.int_value].clear();
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_GET_ROW_COUNT:
		returnValue.datatype = LEX_DATATYPE_INTEGER;
		if (isComplex)
		{
			returnValue.int_value = memMatrixC[object.int_value].size();
		}
		else
		{
			returnValue.int_value = memMatrix[object.int_value].size();
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_GET_COL_COUNT:
		returnValue.datatype = LEX_DATATYPE_INTEGER;
		if (isComplex)
		{
			returnValue.int_value = memMatrixC[object.int_value].size() == 0 ? 0 : memMatrixC[object.int_value][0].size();
		}
		else
		{
			returnValue.int_value = memMatrix[object.int_value].size() == 0 ? 0 : memMatrix[object.int_value][0].size();
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_GET_SUM:
		if (isComplex)
		{
			returnValue.datatype = LEX_DATATYPE_COMPLEX;
			returnValue.complex_value = Math::Statistics::GetSum(memMatrixC[object.int_value]);
		}
		else
		{
			returnValue.datatype = LEX_DATATYPE_DOUBLE;
			returnValue.double_value = Math::Statistics::GetSum(memMatrix[object.int_value]);
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_GET_DIAGONAL_SUM:
		if (isComplex)
		{
			returnValue.datatype = LEX_DATATYPE_COMPLEX;
			returnValue.complex_value = Math::Statistics::GetDiagonalSum(memMatrixC[object.int_value]);
		}
		else
		{
			returnValue.datatype = LEX_DATATYPE_DOUBLE;
			returnValue.double_value = Math::Statistics::GetDiagonalSum(memMatrix[object.int_value]);
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_GET_MEAN:
		if (isComplex)
		{
			returnValue.datatype = LEX_DATATYPE_COMPLEX;
			returnValue.complex_value = Math::Statistics::MeanValue(memMatrixC[object.int_value]);
		}
		else
		{
			returnValue.datatype = LEX_DATATYPE_DOUBLE;
			returnValue.double_value = Math::Statistics::MeanValue(memMatrix[object.int_value]);
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_GET_VARIANCE:
		if (isComplex)
		{
			returnValue.datatype = LEX_DATATYPE_COMPLEX;
			returnValue.complex_value = Math::Statistics::Variance(memMatrixC[object.int_value]);
		}
		else
		{
			returnValue.datatype = LEX_DATATYPE_DOUBLE;
			returnValue.double_value = Math::Statistics::Variance(memMatrix[object.int_value]);
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_GET_MINIMUM:
		if (isComplex)
		{
			returnValue.datatype = LEX_DATATYPE_COMPLEX;
			returnValue.complex_value = Math::Statistics::GetMin(memMatrixC[object.int_value]);
		}
		else
		{
			returnValue.datatype = LEX_DATATYPE_DOUBLE;
			returnValue.double_value = Math::Statistics::GetMin(memMatrix[object.int_value]);
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_GET_MAXIMUM:
		if (isComplex)
		{
			returnValue.datatype = LEX_DATATYPE_COMPLEX;
			returnValue.complex_value = Math::Statistics::GetMax(memMatrixC[object.int_value]);
		}
		else
		{
			returnValue.datatype = LEX_DATATYPE_DOUBLE;
			returnValue.double_value = Math::Statistics::GetMax(memMatrix[object.int_value]);
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_GET_SUM_SQUARES:
		if (isComplex)
		{
			returnValue.datatype = LEX_DATATYPE_COMPLEX;
			returnValue.complex_value = Math::Statistics::GetSumOfSquares(memMatrixC[object.int_value]);
		}
		else
		{
			returnValue.datatype = LEX_DATATYPE_DOUBLE;
			returnValue.double_value = Math::Statistics::GetSumOfSquares(memMatrix[object.int_value]);
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_GET_ROWS:
		if (Convert(param[0], LEX_DATATYPE_VECTOR, L"1") == false) return false;
		{
			valarray<int> indexes;
			if (Sys::Convert::ValarrayToVectorInt(param[0].vector_value, indexes) == false)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d ComplexMatrix::GetRows no enough memory", machineCode[instructionIndex].line_number);
				return false;
			}
			if (isComplex)
			{
				returnValue.datatype = LEX_DATATYPE_COMPLEX_MATRIX;
				if (Math::Oper::GetRows(memMatrixC[object.int_value], returnValue.matrixC_value, indexes) == false)
				{
					_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d ComplexMatrix::GetRows no enough memory", machineCode[instructionIndex].line_number);
					return false;
				}
			}
			else
			{
				returnValue.datatype = LEX_DATATYPE_MATRIX;
				if (Math::Oper::GetRows(memMatrix[object.int_value], returnValue.matrix_value, indexes) == false)
				{
					_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d ComplexMatrix::GetRows no enough memory", machineCode[instructionIndex].line_number);
					return false;
				}
			}
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_GET_COLS:
		if (Convert(param[0], LEX_DATATYPE_VECTOR, L"1") == false) return false;
		{
			valarray<int> indexes;
			if (Sys::Convert::ValarrayToVectorInt(param[0].vector_value, indexes) == false)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d ComplexMatrix::GetCols no enough memory", machineCode[instructionIndex].line_number);
				return false;
			}
			if (isComplex)
			{
				returnValue.datatype = LEX_DATATYPE_COMPLEX_MATRIX;
				if (Math::Oper::GetCols(memMatrixC[object.int_value], returnValue.matrixC_value, indexes) == false)
				{
					_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d ComplexMatrix::GetCols no enough memory", machineCode[instructionIndex].line_number);
					return false;
				}
			}
			else
			{
				returnValue.datatype = LEX_DATATYPE_MATRIX;
				if (Math::Oper::GetCols(memMatrix[object.int_value], returnValue.matrix_value, indexes) == false)
				{
					_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d ComplexMatrix::GetCols no enough memory", machineCode[instructionIndex].line_number);
					return false;
				}
			}
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_DELETE_ROWS:
		if (Convert(param[0], LEX_DATATYPE_VECTOR, L"1") == false) return false;
		{
			valarray<int> indexes;
			if (Sys::Convert::ValarrayToVectorInt(param[0].vector_value, indexes) == false)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d ComplexMatrix::DeleteRows no enough memory", machineCode[instructionIndex].line_number);
				return false;
			}
			returnValue.bool_value = false;
			returnValue.datatype = LEX_DATATYPE_BOOL;
			if (isComplex)
			{
				if (Math::Oper::DeleteRows(memMatrixC[object.int_value], indexes) == false)
				{
					_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d ComplexMatrix::DeleteRows no enough memory", machineCode[instructionIndex].line_number);
					return false;
				}
			}
			else
			{
				if (Math::Oper::DeleteRows(memMatrix[object.int_value], indexes) == false)
				{
					_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d ComplexMatrix::DeleteRows no enough memory", machineCode[instructionIndex].line_number);
					return false;
				}
			}
		}
		returnValue.bool_value = true;
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_DELETE_COLS:
		if (Convert(param[0], LEX_DATATYPE_VECTOR, L"1") == false) return false;
		{
			valarray<int> indexes;
			if (Sys::Convert::ValarrayToVectorInt(param[0].vector_value, indexes) == false)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d ComplexMatrix::DeleteCols no enough memory", machineCode[instructionIndex].line_number);
				return false;
			}
			returnValue.bool_value = false;
			returnValue.datatype = LEX_DATATYPE_BOOL;
			if (isComplex)
			{
				if (Math::Oper::DeleteCols(memMatrixC[object.int_value], returnValue.matrixC_value, indexes) == false)
				{
					_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d ComplexMatrix::DeleteCols no enough memory", machineCode[instructionIndex].line_number);
					return false;
				}
			}
			else
			{
				if (Math::Oper::DeleteCols(memMatrix[object.int_value], returnValue.matrix_value, indexes) == false)
				{
					_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d ComplexMatrix::DeleteCols no enough memory", machineCode[instructionIndex].line_number);
					return false;
				}
			}
		}
		returnValue.bool_value = true;
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_GET_CLASS:
		if (isComplex == false)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d ComplexMatrix does not support this method", machineCode[instructionIndex].line_number);
			return false;
		}
		else
		{
			returnValue.datatype = LEX_DATATYPE_VECTOR;
			wchar_t * error = Math::Oper::GetClass(memMatrix[object.int_value], returnValue.vector_value);
			if (error)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d Matrix::GetClass %s", machineCode[instructionIndex].line_number, error);
				return false;
			}
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_TRANSPOSE:
		if (isComplex)
		{
			returnValue.datatype = LEX_DATATYPE_COMPLEX_MATRIX;
			if (Math::Oper::Transpose(memMatrixC[object.int_value], returnValue.matrixC_value) == false)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d CompleMatrix::Transpose no enough memory", machineCode[instructionIndex].line_number);
				return false;
			}
		}
		else
		{
			returnValue.datatype = LEX_DATATYPE_MATRIX;
			if (Math::Oper::Transpose(memMatrix[object.int_value], returnValue.matrix_value) == false)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d Matrix::Transpose no enough memory", machineCode[instructionIndex].line_number);
				return false;
			}
		}
		stack.push(returnValue);
		return true;

	case LEX_FUNC_MATRIX_NORM_ROWS:
		if (isComplex)
		{
			returnValue.datatype = LEX_DATATYPE_VOID;
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d CompleMatrix::NormRows is not supported", machineCode[instructionIndex].line_number);
			return true;
		}
		else
		{
			returnValue.datatype = LEX_DATATYPE_VOID;
			Math::Oper::NormalizeRows(memMatrix[object.int_value]);
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_NORM_COLS:
		if (isComplex)
		{
			returnValue.datatype = LEX_DATATYPE_VOID;
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d CompleMatrix::NormCols is not supported", machineCode[instructionIndex].line_number);
			return true;
		}
		else
		{
			returnValue.datatype = LEX_DATATYPE_VOID;
			Math::Oper::NormalizeCols(memMatrix[object.int_value]);
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_ROWS_VAR:
		if (isComplex)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d CompleMatrix::RowsVar is not supported", machineCode[instructionIndex].line_number);
			return false;
		}
		else
		{
			returnValue.datatype = LEX_DATATYPE_VECTOR;
			Math::Statistics::RowVariance(memMatrix[object.int_value], returnValue.vector_value);
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_COLS_VAR:
		if (isComplex)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d CompleMatrix::ColsVar is not supported", machineCode[instructionIndex].line_number);
			return false;
		}
		else
		{
			returnValue.datatype = LEX_DATATYPE_VECTOR;
			Math::Statistics::ColumnVariance(memMatrix[object.int_value], returnValue.vector_value);
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_GET_ROW:
		if (Convert(param[0], LEX_DATATYPE_INTEGER, L"1") == false) return false;
		if (isComplex)
		{
			returnValue.datatype = LEX_DATATYPE_COMPLEX_VECTOR;
			if (Math::Oper::GetRow(memMatrixC[object.int_value], returnValue.vectorC_value, param[0].int_value) == false)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d Matrix::GetRow invalid index", machineCode[instructionIndex].line_number);
				return false;
			}
		}
		else
		{
			returnValue.datatype = LEX_DATATYPE_VECTOR;
			if (Math::Oper::GetRow(memMatrix[object.int_value], returnValue.vector_value, param[0].int_value) == false)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d Matrix::GetRow invalid index", machineCode[instructionIndex].line_number);
				return false;
			}
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_GET_COL:
		if (Convert(param[0], LEX_DATATYPE_INTEGER, L"1") == false) return false;
		if (isComplex)
		{
			returnValue.datatype = LEX_DATATYPE_COMPLEX_VECTOR;
			if (Math::Oper::GetCol(memMatrixC[object.int_value], returnValue.vectorC_value, param[0].int_value) == false)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d Matrix::GetCol invalid index", machineCode[instructionIndex].line_number);
				return false;
			}
		}
		else
		{
			returnValue.datatype = LEX_DATATYPE_VECTOR;
			if (Math::Oper::GetCol(memMatrix[object.int_value], returnValue.vector_value, param[0].int_value) == false)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d Matrix::GetCol invalid index", machineCode[instructionIndex].line_number);
				return false;
			}
		}
		stack.push(returnValue);
		return true;
	}
	_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d Matrix does not support this method", machineCode[instructionIndex].line_number);
	return false;
}

bool VirtualMachine::FuncVector(Compiler::Instruction& objectFunction, Cpl::VirtualMachine::Memory* param, int paramCount, Cpl::VirtualMachine::Memory& object, bool isComplex)
{
	wchar_t filename[4*MAX_PATH];
	wchar_t error[256];
	wchar_t * info = NULL;
	Cpl::VirtualMachine::Memory returnValue;

	switch(objectFunction.subtype)
	{
	case LEX_FUNC_VECTOR_CREATE:
		{
			returnValue.datatype = LEX_DATATYPE_BOOL;
			if (Convert(param[0], LEX_DATATYPE_INTEGER, L"1") == false) return false;
			if (isComplex)
			{
				try
				{
					memVectorC[object.int_value].resize(param[0].int_value);
				}
				catch(const std::bad_alloc& )
				{
					_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d Vector::Create no enough memory", machineCode[instructionIndex].line_number);
					return false;
				}
			}
			else
			{
				try
				{
					memVector[object.int_value].resize(param[0].int_value);
				}
				catch(const std::bad_alloc& )
				{
					_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d Vector::Create no enough memory", machineCode[instructionIndex].line_number);
					return false;
				}
			}
		}
		returnValue.bool_value = true;
		stack.push(returnValue);
		return true;
	case LEX_FUNC_VECTOR_CREATE_SERIES:
		{
			returnValue.datatype = LEX_DATATYPE_BOOL;
			if (Convert(param[0], LEX_DATATYPE_INTEGER, L"3") == false) return false;
			if (Convert(param[1], LEX_DATATYPE_DOUBLE, L"2") == false) return false;
			if (Convert(param[2], LEX_DATATYPE_DOUBLE, L"1") == false) return false;
			const int count = param[0].int_value;
			const double firstValue = param[2].double_value;
			const double lastValue = param[1].double_value;
			//__________________________________________________ One element series
			if (count == 1)
			{
				if (isComplex)
				{
					try
					{
						memVectorC[object.int_value].resize(1);
					}
					catch(const std::bad_alloc& )
					{
						_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d ComplexVector::CreateSeries no enough memory", machineCode[instructionIndex].line_number);
						return false;
					}
					memVectorC[object.int_value][0] = firstValue;
				}
				else
				{
					try
					{
						memVector[object.int_value].resize(1);
					}
					catch(const std::bad_alloc& )
					{
						_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d Vector::CreateSeries no enough memory", machineCode[instructionIndex].line_number);
						return false;
					}
					memVector[object.int_value][0] = firstValue;
				}
				returnValue.bool_value = true;
				stack.push(returnValue);
				return true;
			}
			
			const double delta = (lastValue- firstValue)/(count-1);
			if (isComplex)
			{
				try
				{
					memVectorC[object.int_value].resize(count);
				}
				catch(const std::bad_alloc& )
				{
					_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d ComplexVector::CreateSeries no enough memory", machineCode[instructionIndex].line_number);
					return false;
				}
				for(int i=0; i<count; i++)
				{
					memVectorC[object.int_value][i] = firstValue + i*delta;
				}
			}
			else
			{
				try
				{
					memVector[object.int_value].resize(count);
				}
				catch(const std::bad_alloc& )
				{
					_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d Vector::CreateSeries no enough memory", machineCode[instructionIndex].line_number);
					return false;
				}
				for(int i=0; i<count; i++)
				{
					memVector[object.int_value][i] = firstValue + i*delta;
				}
			}
		}
		returnValue.bool_value = true;
		stack.push(returnValue);
		return true;
	case LEX_FUNC_VECTOR_CREATE_RANDOM:
		{
			returnValue.datatype = LEX_DATATYPE_BOOL;
			if (Convert(param[0], LEX_DATATYPE_DOUBLE, L"3") == false) return false;
			if (Convert(param[1], LEX_DATATYPE_DOUBLE, L"2") == false) return false;
			if (Convert(param[2], LEX_DATATYPE_INTEGER, L"1") == false) return false;
			const int length = param[2].int_value;
			const double minValue = param[1].double_value;
			const double maxValue = param[0].double_value;
			if (isComplex)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d ComplexVector does not support this method", machineCode[instructionIndex].line_number);
				return false;
			}
			else
			{
				if (Math::Oper::CreateRandom(memVector[object.int_value], length, minValue, maxValue) == false)
				{
					_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d Vector::CreateRandom no enough memory", machineCode[instructionIndex].line_number);
					return false;
				}
			}
		}
		returnValue.bool_value = true;
		stack.push(returnValue);
		return true;
	case LEX_FUNC_VECTOR_CREATE_BINARY:
		{
			returnValue.datatype = LEX_DATATYPE_INTEGER;
			if (Convert(param[0], LEX_DATATYPE_INTEGER, L"2") == false) return false;
			if (Convert(param[1], LEX_DATATYPE_INTEGER, L"1") == false) return false;
			const int length = param[1].int_value;
			const int decimalValue = param[0].int_value;
			if (isComplex)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d ComplexVector does not support this method", machineCode[instructionIndex].line_number);
				return false;
			}
			else
			{
				returnValue.int_value = Math::BinaryConverter::Convert(decimalValue, length, memVector[object.int_value]);
			}
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_VECTOR_SAVE:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		_snwprintf_s(filename, 4*MAX_PATH, _TRUNCATE, L"%s\\%s.csv", path, object.string_value.c_str());
		if (isComplex)
		{
			if (Sys::FileAssistant::CsvSave(filename, memVectorC[object.int_value], false)==false)
			{
				Sys::GetLastErrorInformation(error, 256);
				Sys::TextAssistant::DeleteChar(error, '\r');
				Sys::TextAssistant::DeleteChar(error, '\n');
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s %s", objectFunction.line_number, object.string_value.c_str(), error);
				return false;
			}
		}
		else
		{
			if (Sys::FileAssistant::CsvSave(filename, memVector[object.int_value], false)==false)
			{
				Sys::GetLastErrorInformation(error, 256);
				Sys::TextAssistant::DeleteChar(error, '\r');
				Sys::TextAssistant::DeleteChar(error, '\n');
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s %s", objectFunction.line_number, object.string_value.c_str(), error);
				return false;
			}
		}
		returnValue.bool_value = true;
		stack.push(returnValue);
		return true;
	case LEX_FUNC_VECTOR_LOAD:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		_snwprintf_s(filename, 4*MAX_PATH, _TRUNCATE, L"%s\\%s.csv", path, object.string_value.c_str());
		if (isComplex)
		{
			MATRIXC tmp;
			if (Sys::FileAssistant::CsvLoad(filename, tmp)==false)
			{
				Sys::GetLastErrorInformation(error, 256);
				Sys::TextAssistant::DeleteChar(error, '\r');
				Sys::TextAssistant::DeleteChar(error, '\n');
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s %s", objectFunction.line_number, object.string_value.c_str(), error);
				return false;
			}
			returnValue.bool_value = Math::Oper::GetCol(tmp, memVectorC[object.int_value], 0);
		}
		else
		{
			MATRIX tmp;
			if (Sys::FileAssistant::CsvLoad(filename, tmp)==false)
			{
				Sys::GetLastErrorInformation(error, 256);
				Sys::TextAssistant::DeleteChar(error, '\r');
				Sys::TextAssistant::DeleteChar(error, '\n');
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s %s", objectFunction.line_number, object.string_value.c_str(), error);
				return false;
			}
			returnValue.bool_value = Math::Oper::GetCol(tmp, memVector[object.int_value], 0);
		}
		stack.push(returnValue);
		return true;
		case LEX_FUNC_VECTOR_INSERT_CELL :
			{
				returnValue.datatype = LEX_DATATYPE_BOOL;
				if (Convert(param[0], LEX_DATATYPE_DOUBLE, L"2") == false) return false;
				if (Convert(param[1], LEX_DATATYPE_INTEGER, L"1") == false) return false;
				const int index = param[1].int_value;
				const double value = param[0].double_value;
				if (isComplex)
				{
					if (Math::Oper::InsertCell(memVectorC[object.int_value], index) == false)
					{
						_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid index in vector", machineCode[instructionIndex].line_number);
						return false;
					}
					memVectorC[object.int_value][index] = value;
				}
				else
				{
					if (Math::Oper::InsertCell(memVector[object.int_value], index) == false)
					{
						_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid index in vector", machineCode[instructionIndex].line_number);
						return false;
					}
					memVector[object.int_value][index] = value;
				}
			}
			returnValue.bool_value = true;
			stack.push(returnValue);
			return true;
		case LEX_FUNC_VECTOR_DELETE_CELL:
			{
				returnValue.datatype = LEX_DATATYPE_BOOL;
				if (Convert(param[0], LEX_DATATYPE_INTEGER, L"1") == false) return false;
				const int index = param[0].int_value;
				if (isComplex)
				{
					if (Math::Oper::DeleteCell(memVectorC[object.int_value], index) == false)
					{
						_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid index in vector", machineCode[instructionIndex].line_number);
						return false;
					}
				}
				else
				{
					if (Math::Oper::DeleteCell(memVector[object.int_value], index) == false)
					{
						_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"LIne %d invalid index in vector", machineCode[instructionIndex].line_number);
						return false;
					}
				}
			}
			returnValue.bool_value = true;
			stack.push(returnValue);
			return true;
	case LEX_FUNC_VECTOR_GET_SIZE:
		returnValue.datatype = LEX_DATATYPE_INTEGER;
		if (isComplex)
		{
			returnValue.int_value = memVectorC[object.int_value].size();
		}
		else
		{
			returnValue.int_value = memVector[object.int_value].size();
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_VECTOR_GET_SUM:
		if (isComplex)
		{
			returnValue.datatype = LEX_DATATYPE_COMPLEX;
			returnValue.complex_value = Math::Statistics::GetSum(memVectorC[object.int_value]);
		}
		else
		{
			returnValue.datatype = LEX_DATATYPE_DOUBLE;
			returnValue.double_value = Math::Statistics::GetSum(memVector[object.int_value]);
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_VECTOR_GET_MEAN:
		if (isComplex)
		{
			returnValue.datatype = LEX_DATATYPE_COMPLEX;
			returnValue.complex_value = Math::Statistics::MeanValue(memVectorC[object.int_value]);
		}
		else
		{
			returnValue.datatype = LEX_DATATYPE_DOUBLE;
			returnValue.double_value = Math::Statistics::MeanValue(memVector[object.int_value]);
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_VECTOR_GET_VARIANCE:
		if (isComplex)
		{
			returnValue.datatype = LEX_DATATYPE_COMPLEX;
			returnValue.complex_value = Math::Statistics::Variance(memVectorC[object.int_value]);
		}
		else
		{
			returnValue.datatype = LEX_DATATYPE_DOUBLE;
			returnValue.double_value = Math::Statistics::Variance(memVector[object.int_value]);
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_VECTOR_GET_MINIMUM:
		if (isComplex)
		{
			returnValue.datatype = LEX_DATATYPE_COMPLEX;
			returnValue.complex_value = Math::Statistics::GetMin(memVectorC[object.int_value]);
		}
		else
		{
			returnValue.datatype = LEX_DATATYPE_DOUBLE;
			returnValue.double_value = Math::Statistics::GetMin(memVector[object.int_value]);
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_VECTOR_GET_MAXIMUM:
		if (isComplex)
		{
			returnValue.datatype = LEX_DATATYPE_COMPLEX;
			returnValue.complex_value = Math::Statistics::GetMax(memVectorC[object.int_value]);
		}
		else
		{
			returnValue.datatype = LEX_DATATYPE_DOUBLE;
			returnValue.double_value = Math::Statistics::GetMax(memVector[object.int_value]);
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_VECTOR_GET_SQUARED_SUM:
		if (isComplex)
		{
			returnValue.datatype = LEX_DATATYPE_COMPLEX;
			returnValue.complex_value = Math::Statistics::GetSumOfSquares(memVectorC[object.int_value]);
		}
		else
		{
			returnValue.datatype = LEX_DATATYPE_DOUBLE;
			returnValue.double_value = Math::Statistics::GetSumOfSquares(memVector[object.int_value]);
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_VECTOR_CREATE_LOW_PASS_IMP_RESP:
		{
			returnValue.datatype = LEX_DATATYPE_BOOL;
			returnValue.bool_value = true;
			if (Convert(param[0], LEX_DATATYPE_DOUBLE, L"3") == false) return false;
			if (Convert(param[1], LEX_DATATYPE_INTEGER, L"2") == false) return false;
			if (Convert(param[2], LEX_DATATYPE_DOUBLE, L"1") == false) return false;
			const double fc = param[0].double_value;
			const int length = param[1].int_value;
			const double beta = param[2].double_value;
			if (isComplex)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d ComplexVector does not support this method", machineCode[instructionIndex].line_number);
				return false;
			}
			else
			{
				Math::Dsp::ImpulRespLowPass(beta, length, fc, memVector[object.int_value]);
			}
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_VECTOR_CREATE_LOW_PASS_FREQ_RESP:
		{
			returnValue.datatype = LEX_DATATYPE_BOOL;
			returnValue.bool_value = true;
			if (Convert(param[0], LEX_DATATYPE_DOUBLE, L"3") == false) return false;
			if (Convert(param[1], LEX_DATATYPE_INTEGER, L"2") == false) return false;
			if (Convert(param[2], LEX_DATATYPE_DOUBLE, L"1") == false) return false;
			const double fc = param[0].double_value;
			const int length = param[1].int_value;
			const double beta = param[2].double_value;
			if (isComplex)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d ComplexVector does not support this method", machineCode[instructionIndex].line_number);
				return false;
			}
			else
			{
				Math::Dsp::FreqRespLowPass(beta, length, fc, memVector[object.int_value]);
			}
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_VECTOR_CREATE_HIGH_PASS_IMP_RESP:
		{
			returnValue.datatype = LEX_DATATYPE_BOOL;
			returnValue.bool_value = true;
			if (Convert(param[0], LEX_DATATYPE_DOUBLE, L"3") == false) return false;
			if (Convert(param[1], LEX_DATATYPE_INTEGER, L"2") == false) return false;
			if (Convert(param[2], LEX_DATATYPE_DOUBLE, L"1") == false) return false;
			const double fc = param[0].double_value;
			const int length = param[1].int_value;
			const double beta = param[2].double_value;
			if (isComplex)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d ComplexVector does not support this method", machineCode[instructionIndex].line_number);
				return false;
			}
			else
			{
				Math::Dsp::ImpulRespHighPass(beta, length, fc, memVector[object.int_value]);
			}
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_VECTOR_CREATE_HIGH_PASS_FREQ_RESP:
		{
			returnValue.datatype = LEX_DATATYPE_BOOL;
			returnValue.bool_value = true;
			if (Convert(param[0], LEX_DATATYPE_DOUBLE, L"3") == false) return false;
			if (Convert(param[1], LEX_DATATYPE_INTEGER, L"2") == false) return false;
			if (Convert(param[2], LEX_DATATYPE_DOUBLE, L"1") == false) return false;
			const double fc = param[0].double_value;
			const int length = param[1].int_value;
			const double beta = param[2].double_value;
			if (isComplex)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d ComplexVector does not support this method", machineCode[instructionIndex].line_number);
				return false;
			}
			else
			{
				Math::Dsp::FreqRespHighPass(beta, length, fc, memVector[object.int_value]);
			}
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_VECTOR_CREATE_RANDOM_SET:
		{
			returnValue.datatype = LEX_DATATYPE_BOOL;
			returnValue.bool_value = true;
			if (Convert(param[0], LEX_DATATYPE_INTEGER, L"2") == false) return false;
			if (Convert(param[1], LEX_DATATYPE_INTEGER, L"1") == false) return false;
			const int length = param[1].int_value;
			const int maxValue = param[0].int_value;
			if (isComplex)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d ComplexVector does not support this method", machineCode[instructionIndex].line_number);
				return false;
			}
			else
			{
				if (Math::Oper::CreateRandomSet(memVector[object.int_value], length, maxValue) ==false)
				{
					_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d Vector::CreateRandomSet invalid argument", machineCode[instructionIndex].line_number);
					return false;
				}
			}
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_VECTOR_WRAP:
		{
			returnValue.bool_value = true;
			if (Convert(param[0], LEX_DATATYPE_INTEGER, L"1") == false) return false;
			const int colCount = param[0].int_value;
			if (isComplex)
			{
				returnValue.datatype = LEX_DATATYPE_COMPLEX_MATRIX;
				if (Math::Oper::WrapVector(memVectorC[object.int_value], colCount, returnValue.matrixC_value) ==false)
				{
					_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d ComplexVector::Wrap no enough memory", machineCode[instructionIndex].line_number);
					return false;
				}
			}
			else
			{
				returnValue.datatype = LEX_DATATYPE_MATRIX;
				if (Math::Oper::WrapVector(memVector[object.int_value], colCount, returnValue.matrix_value) ==false)
				{
					_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d Vector::Wrap no enough memory", machineCode[instructionIndex].line_number);
					return false;
				}
			}
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_VECTOR_LINE_FIT:
		if (isComplex)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d ComplexVector does not support this method", machineCode[instructionIndex].line_number);
			return false;
		}
		else
		{
			try
			{
				valarray<double> x;
				const int len = memVector[object.int_value].size();
				x.resize(len);
				for(int i = 0; i<len; i++)
				{
					x[i] = i;
				}
				returnValue.datatype = LEX_DATATYPE_VECTOR;
				returnValue.vector_value.resize(2);
				if (isComplex)
				{
					_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d ComplexVector does not support this method", machineCode[instructionIndex].line_number);
					return false;
				}
				else
				{
					Math::Oper::LineFitting(x, memVector[object.int_value], returnValue.vector_value[0], returnValue.vector_value[1]);
				}
			}
			catch(const std::bad_alloc& )
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d Vector::LineFit no enough memory", machineCode[instructionIndex].line_number);
					return false;
			}
		}
		stack.push(returnValue);
		return true;
	}
	_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d Vector does not support this method", machineCode[instructionIndex].line_number);
	return false;
}

bool VirtualMachine::FuncComplex(Compiler::Instruction& objectFunction, Cpl::VirtualMachine::Memory* param, int paramCount, Cpl::VirtualMachine::Memory& object)
{
	return true;
}

bool VirtualMachine::VmObjFunc(Compiler::Instruction& inst, Mt::BoolTs& running, Mt::DoubleTs& progress)
{
	if (inst.type != VM_OBJFUNC)
	{
		_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid virtual machine function", machineCode[instructionIndex].line_number);
		return false;
	}
	//____________________________________ pop object
	Cpl::VirtualMachine::Memory object = stack.top();
	stack.pop();
	const int datatype = (int)inst.double_value;
	if (object.datatype != datatype) 
	{
		_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid object function", machineCode[instructionIndex].line_number);
		return false;
	}

	//____________________________________ pop parameters
	const int func_id = inst.subtype;
	const int paramCount = inst.int_value;
	if (paramCount>12)
	{
		_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d exceeded number of parameter", machineCode[instructionIndex].line_number);
		return false;
	}
	Cpl::VirtualMachine::Memory param[12];
	for(int i=0; i<paramCount; i++)
	{
		param[i] = stack.top();
		stack.pop();
	}

	//____________________________________ Execute function
	switch(object.datatype)
	{
	//case LEX_DATATYPE_BOOL 700
	//case LEX_DATATYPE_INTEGER 701
	//case LEX_DATATYPE_DOUBLE 702
	//case LEX_DATATYPE_VOID 703
	case LEX_DATATYPE_VECTOR: return FuncVector(inst, param, paramCount, object, false);
	case LEX_DATATYPE_MATRIX: return FuncMatrix(inst, param, paramCount, object, false);
	case LEX_DATATYPE_COMPLEX: return FuncComplex(inst, param, paramCount, object);
	case LEX_DATATYPE_COMPLEX_VECTOR: return FuncVector(inst, param, paramCount, object, true);
	case LEX_DATATYPE_COMPLEX_MATRIX: return FuncMatrix(inst, param, paramCount, object, true);
	//case LEX_DATATYPE_SCALER: return FuncScaler(inst, param, paramCount, object);
	case LEX_DATATYPE_LAYERNET: return FuncLayerNet(inst, param, paramCount, object, running, progress);
	case LEX_DATATYPE_KOHONET: return FuncKohoNet(inst, param, paramCount, object, running, progress);
	case LEX_DATATYPE_PROBNET: return FuncProbNet(inst, param, paramCount, object, running, progress);
	}
	_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid object function", machineCode[instructionIndex].line_number);
	return false;
}

bool VirtualMachine::VmFunc(Compiler::Instruction& inst)
{
	Cpl::VirtualMachine::Memory result, operator1;
	operator1 = stack.top();
	stack.pop();
	wchar_t * error = NULL;

	int rows = 0;
	int cols = 0;
	int i = 0, j = 0;

	//__________________________________________ TWO ARGUMENT FUNCTIONS
	if (inst.subtype == LEX_FUNC_CONVOLUTION || 
		inst.subtype == LEX_FUNC_SHORT_CONVOLUTION || 
		inst.subtype == LEX_FUNC_COMPUTE_MSE || 
		inst.subtype == LEX_FUNC_POW || 
		inst.subtype == LEX_FUNC_CONFUSION_MATRIX)
	{
		Cpl::VirtualMachine::Memory operator2 = operator1; //  The first operator is now the second operator
		operator1 = stack.top();
		stack.pop();
		if (inst.subtype == LEX_FUNC_COMPUTE_MSE)
		{
			if (operator1.datatype != LEX_DATATYPE_MATRIX)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d mse cannot convert parameter 1 to Matrix", machineCode[instructionIndex].line_number);
				return false;
			}
			if (operator2.datatype != LEX_DATATYPE_MATRIX)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d mse cannot convert parameter 2 to Matrix", machineCode[instructionIndex].line_number);
				return false;
			}
			result.datatype = LEX_DATATYPE_DOUBLE;
			result.double_value = Math::Oper::ComputeMse(operator1.matrix_value, operator2.matrix_value);
			if (result.double_value < 0)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d mse both matrices must have the same size", machineCode[instructionIndex].line_number);
				return false;
			}
			stack.push(result);
			return true;
		}
		if (inst.subtype == LEX_FUNC_POW)
		{
			if (operator2.datatype != LEX_DATATYPE_DOUBLE)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d mse cannot convert parameter 2 to double", machineCode[instructionIndex].line_number);
				return false;
			}
			if (operator1.datatype == LEX_DATATYPE_DOUBLE)
			{
				result.datatype = LEX_DATATYPE_DOUBLE;
				result.double_value = pow(operator1.double_value, operator2.double_value);
			}
			else if (operator1.datatype == LEX_DATATYPE_VECTOR)
			{
				result.datatype = LEX_DATATYPE_VECTOR;
				result.vector_value = pow(operator1.vector_value, operator2.double_value);
			}
			else if (operator1.datatype == LEX_DATATYPE_MATRIX)
			{
				result.datatype = LEX_DATATYPE_MATRIX;
				const int rows = operator1.matrix_value.size();
				try
				{
					result.matrix_value.resize(rows);
					for(int i = 0; i<rows; i++)
					{
						result.matrix_value[i] = pow(operator1.matrix_value[i], operator2.double_value);
					}
				}
				catch(const std::bad_alloc&)
				{
					_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d no enough memory", machineCode[instructionIndex].line_number);
					return false;
				}
			}
			else
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d mse cannot convert parameter 1 to double", machineCode[instructionIndex].line_number);
				return false;
			}
			stack.push(result);
			return true;
		}
		else if (inst.subtype == LEX_FUNC_CONFUSION_MATRIX)
		{
			if (operator1.datatype != LEX_DATATYPE_MATRIX)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d ConfusionMatrix cannot convert parameter 1 to Matrix", machineCode[instructionIndex].line_number);
				return false;
			}
			if (operator2.datatype != LEX_DATATYPE_MATRIX)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d ConfusionMatrix cannot convert parameter 2 to Matrix", machineCode[instructionIndex].line_number);
				return false;
			}
			result.datatype = LEX_DATATYPE_MATRIX;
			wchar_t * error = Math::Oper::ConfusionMatrix(operator1.matrix_value, operator2.matrix_value, result.matrix_value);
			if (error)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d ConfussionMatrix %s", machineCode[instructionIndex].line_number, error);
				return false;
			}
			stack.push(result);
			return true;
		}
		else if (inst.subtype == LEX_FUNC_CONVOLUTION)
		{
			if (operator1.datatype != LEX_DATATYPE_VECTOR)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d Convolution cannot convert parameter 1 to Vector", machineCode[instructionIndex].line_number);
				return false;
			}
			if (operator2.datatype != LEX_DATATYPE_VECTOR)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d Convolution cannot convert parameter 2 to Vector", machineCode[instructionIndex].line_number);
				return false;
			}
			result.datatype = LEX_DATATYPE_VECTOR;
			if (Math::Dsp::Convolution(operator1.vector_value, operator2.vector_value, result.vector_value) == false)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d Convolution no enough memory", machineCode[instructionIndex].line_number);
				return false;
			}
			stack.push(result);
			return true;
		}
		else if (inst.subtype == LEX_FUNC_SHORT_CONVOLUTION)
		{
			if (operator1.datatype != LEX_DATATYPE_VECTOR)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d ShortConvolution cannot convert parameter 1 to Vector", machineCode[instructionIndex].line_number);
				return false;
			}
			if (operator2.datatype != LEX_DATATYPE_VECTOR)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d ShortConvolution cannot convert parameter 2 to Vector", machineCode[instructionIndex].line_number);
				return false;
			}
			result.datatype = LEX_DATATYPE_VECTOR;
			if (Math::Dsp::ShortConvolution(operator1.vector_value, operator2.vector_value, result.vector_value) == false)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d Convolution no enough memory", machineCode[instructionIndex].line_number);
				return false;
			}
			stack.push(result);
			return true;
		}
	}
	else if (operator1.datatype == LEX_DATATYPE_INTEGER)
	{
		result.datatype = LEX_DATATYPE_DOUBLE;
		switch(inst.subtype)
		{
		case LEX_FUNC_SIN:
			result.double_value = sin((double)operator1.int_value);
			stack.push(result);
			return true;
		case LEX_FUNC_COS:
			result.double_value = cos((double)operator1.int_value);
			stack.push(result);
			return true;
		case LEX_FUNC_TAN:
			result.double_value = tan((double)operator1.int_value);
			stack.push(result);
			return true;
		case LEX_FUNC_ASIN:
			result.double_value = asin((double)operator1.int_value);
			stack.push(result);
			return true;
		case LEX_FUNC_ACOS:
			result.double_value = acos((double)operator1.int_value);
			stack.push(result);
			return true;
		case LEX_FUNC_ATAN:
			result.double_value = atan((double)operator1.int_value);
			stack.push(result);
			return true;
		case LEX_FUNC_SINH :
			result.double_value = sinh((double)operator1.int_value);
			stack.push(result);
			return true;
		case LEX_FUNC_COSH:
			result.double_value = cosh((double)operator1.int_value);
			stack.push(result);
			return true;
		case LEX_FUNC_TANH:
			result.double_value = tanh((double)operator1.int_value);
			stack.push(result);
			return true;
		case LEX_FUNC_SQRT:
			result.double_value = sqrt((double)operator1.int_value);
			stack.push(result);
			return true;
		case LEX_FUNC_LOG10:
			result.double_value = log10((double)operator1.int_value);
			stack.push(result);
			return true;
		case LEX_FUNC_LOG:
			result.double_value = log((double)operator1.int_value);
			stack.push(result);
			return true;
		case LEX_FUNC_EXP:
			result.double_value = exp((double)operator1.int_value);
			stack.push(result);
			return true;
		case LEX_FUNC_ABS:
			result.double_value = abs((double)operator1.int_value);
			stack.push(result);
			return true;
		case LEX_FUNC_SINC:
			result.double_value = Math::Dsp::Sinc((double)operator1.int_value);
			stack.push(result);
			return true;
		case LEX_FUNC_TRIANG:
			result.double_value = Math::Dsp::Triangular((double)operator1.int_value, 2*M_PI);
			stack.push(result);
			return true;
		case LEX_FUNC_SAW:
			result.double_value = Math::Dsp::Sawtooth((double)operator1.int_value, 2*M_PI);
			stack.push(result);
			return true;
		case LEX_FUNC_RECT:
			result.double_value = Math::Dsp::Rectangular((double)operator1.int_value, 2*M_PI);
			stack.push(result);
			return true;
		case LEX_FUNC_CEIL:
			result.double_value = ceil((double)operator1.int_value);
			stack.push(result);
			return true;
		case LEX_FUNC_FLOOR:
			result.double_value = floor((double)operator1.int_value);
			stack.push(result);
			return true;
		case LEX_FUNC_RAND:
			{
				std::tr1::uniform_real<double> ur (0, operator1.int_value);
				result.double_value = ur(Math::Statistics::random_generator);
				result.datatype = LEX_DATATYPE_DOUBLE;
				stack.push(result);
				return true;
			}
		case LEX_FUNC_RANDI:
			{
				std::tr1::uniform_int<int> ui (0, operator1.int_value);
				result.int_value = ui(Math::Statistics::random_generator);
				result.datatype = LEX_DATATYPE_INTEGER;
				stack.push(result);
				return true;
			}
		case LEX_FUNC_ISPRIME:
			result.datatype = LEX_DATATYPE_BOOL;
			result.bool_value = Math::Oper::IsPrime(operator1.int_value);
			stack.push(result);
			return true;
		}
	}
	else if (operator1.datatype == LEX_DATATYPE_DOUBLE)
	{
		result.datatype = LEX_DATATYPE_DOUBLE;
		switch(inst.subtype)
		{
		case LEX_FUNC_SIN:
			result.double_value = sin((double)operator1.double_value);
			stack.push(result);
			return true;
		case LEX_FUNC_COS:
			result.double_value = cos((double)operator1.double_value);
			stack.push(result);
			return true;
		case LEX_FUNC_TAN:
			result.double_value = tan((double)operator1.double_value);
			stack.push(result);
			return true;
		case LEX_FUNC_ASIN:
			result.double_value = asin((double)operator1.double_value);
			stack.push(result);
			return true;
		case LEX_FUNC_ACOS:
			result.double_value = acos((double)operator1.double_value);
			stack.push(result);
			return true;
		case LEX_FUNC_ATAN:
			result.double_value = atan((double)operator1.double_value);
			stack.push(result);
			return true;
		case LEX_FUNC_SINH :
			result.double_value = sinh((double)operator1.double_value);
			stack.push(result);
			return true;
		case LEX_FUNC_COSH:
			result.double_value = cosh((double)operator1.double_value);
			stack.push(result);
			return true;
		case LEX_FUNC_TANH:
			result.double_value = tanh((double)operator1.double_value);
			stack.push(result);
			return true;
		case LEX_FUNC_SQRT:
			result.double_value = sqrt((double)operator1.double_value);
			stack.push(result);
			return true;
		case LEX_FUNC_LOG10:
			result.double_value = log10((double)operator1.double_value);
			stack.push(result);
			return true;
		case LEX_FUNC_LOG:
			result.double_value = log((double)operator1.double_value);
			stack.push(result);
			return true;
		case LEX_FUNC_EXP:
			result.double_value = exp((double)operator1.double_value);
			stack.push(result);
			return true;
		case LEX_FUNC_ABS:
			result.double_value = abs((double)operator1.double_value);
			stack.push(result);
			return true;
		case LEX_FUNC_SINC:
			result.double_value = Math::Dsp::Sinc((double)operator1.double_value);
			stack.push(result);
			return true;
		case LEX_FUNC_TRIANG:
			result.double_value = Math::Dsp::Triangular((double)operator1.double_value, 2*M_PI);
			stack.push(result);
			return true;
		case LEX_FUNC_SAW:
			result.double_value = Math::Dsp::Sawtooth((double)operator1.double_value, 2*M_PI);
			stack.push(result);
			return true;
		case LEX_FUNC_RECT:
			result.double_value = Math::Dsp::Rectangular((double)operator1.double_value, 2*M_PI);
			stack.push(result);
			return true;
		case LEX_FUNC_CEIL:
			result.double_value = ceil((double)operator1.double_value);
			stack.push(result);
			return true;
		case LEX_FUNC_FLOOR:
			result.double_value = floor((double)operator1.double_value);
			stack.push(result);
			return true;
		case LEX_FUNC_TOINT:
			result.datatype = LEX_DATATYPE_INTEGER;
			result.int_value = (int)operator1.double_value;
			stack.push(result);
			return true;
		case LEX_FUNC_RAND:
			{
				std::tr1::uniform_real<double> ur (0.0, operator1.double_value);
				result.double_value = ur(Math::Statistics::random_generator);
				result.datatype = LEX_DATATYPE_DOUBLE;
				stack.push(result);
				return true;
			}
		//case LEX_FUNC_RANDI:
		//	result.double_value = sin((double)operator1.double_value);
		//	stack.push(result);
		//	return true;
		//case LEX_FUNC_ISPRIME:
		//	result.double_value = sin((double)operator1.double_value);
		//	stack.push(result);
		//	return true;
		}
	}
	else if (operator1.datatype == LEX_DATATYPE_VECTOR)
	{
		result.datatype = LEX_DATATYPE_VECTOR;
		switch(inst.subtype)
		{
		case LEX_FUNC_SIN:
			result.vector_value = sin(operator1.vector_value);
			stack.push(result);
			return true;
		case LEX_FUNC_COS:
			result.vector_value = cos(operator1.vector_value);
			stack.push(result);
			return true;
		case LEX_FUNC_TAN:
			result.vector_value = tan(operator1.vector_value);
			stack.push(result);
			return true;
		case LEX_FUNC_ASIN:
			result.vector_value = asin(operator1.vector_value);
			stack.push(result);
			return true;
		case LEX_FUNC_ACOS:
			result.vector_value = acos(operator1.vector_value);
			stack.push(result);
			return true;
		case LEX_FUNC_ATAN:
			result.vector_value = atan(operator1.vector_value);
			stack.push(result);
			return true;
		case LEX_FUNC_SINH :
			result.vector_value = sinh(operator1.vector_value);
			stack.push(result);
			return true;
		case LEX_FUNC_COSH:
			result.vector_value = cosh(operator1.vector_value);
			stack.push(result);
			return true;
		case LEX_FUNC_TANH:
			result.vector_value = tanh(operator1.vector_value);
			stack.push(result);
			return true;
		case LEX_FUNC_SQRT:
			result.vector_value = sqrt(operator1.vector_value);
			stack.push(result);
			return true;
		case LEX_FUNC_LOG10:
			result.vector_value = log10(operator1.vector_value);
			stack.push(result);
			return true;
		case LEX_FUNC_LOG:
			result.vector_value = log(operator1.vector_value);
			stack.push(result);
			return true;
		case LEX_FUNC_EXP:
			result.vector_value = exp(operator1.vector_value);
			stack.push(result);
			return true;
		case LEX_FUNC_ABS:
			result.vector_value = abs(operator1.vector_value);
			stack.push(result);
			return true;
		case LEX_FUNC_SINC:
			cols = operator1.vector_value.size();
			result.vector_value.resize(cols);
			for(i=0; i<cols; i++) result.vector_value[i] = Math::Dsp::Sinc(operator1.vector_value[i]);
			stack.push(result);
			return true;
		case LEX_FUNC_TRIANG:
			cols = operator1.vector_value.size();
			result.vector_value.resize(cols);
			for(i=0; i<cols; i++) result.vector_value[i] = Math::Dsp::Triangular(operator1.vector_value[i], 2.0*M_PI);
			stack.push(result);
			return true;
		case LEX_FUNC_SAW:
			cols = operator1.vector_value.size();
			result.vector_value.resize(cols);
			for(i=0; i<cols; i++) result.vector_value[i] = Math::Dsp::Sawtooth(operator1.vector_value[i], 2.0*M_PI);
			stack.push(result);
			return true;
		case LEX_FUNC_RECT:
			cols = operator1.vector_value.size();
			result.vector_value.resize(cols);
			for(i=0; i<cols; i++) result.vector_value[i] = Math::Dsp::Rectangular(operator1.vector_value[i], 2.0*M_PI);
			stack.push(result);
			return true;
		case LEX_FUNC_CEIL:
			cols = operator1.vector_value.size();
			result.vector_value.resize(cols);
			for(i=0; i<cols; i++) result.vector_value[i] = ceil(operator1.vector_value[i]);
			stack.push(result);
			return true;
		case LEX_FUNC_FLOOR:
			cols = operator1.vector_value.size();
			result.vector_value.resize(cols);
			for(i=0; i<cols; i++) result.vector_value[i] = floor(operator1.vector_value[i]);
			stack.push(result);
			return true;
		case LEX_FUNC_FFT:
			result.datatype = LEX_DATATYPE_COMPLEX_VECTOR;
			error = Math::Dsp::Fft(operator1.vector_value, result.vectorC_value, false);
			if (error)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, error);
				return false;
			}
			stack.push(result);
			return true;
		case LEX_FUNC_IFFT:
			result.datatype = LEX_DATATYPE_COMPLEX_VECTOR;
			error = Math::Dsp::Fft(operator1.vector_value, result.vectorC_value, true);
			if (error)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, error);
				return false;
			}
			stack.push(result);
			return true;
		case LEX_FUNC_REALFFT:
			result.datatype = LEX_DATATYPE_VECTOR;
			error = Math::Dsp::RealFft(operator1.vector_value, result.vector_value, false);
			if (error)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, error);
				return false;
			}
			stack.push(result);
			return true;
		case LEX_FUNC_IREALFFT:
			result.datatype = LEX_DATATYPE_VECTOR;
			error = Math::Dsp::RealFft(operator1.vector_value, result.vector_value, true);
			if (error)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, error);
				return false;
			}
			stack.push(result);
			return true;
		case LEX_FUNC_SPECTRUM:
			result.datatype = LEX_DATATYPE_VECTOR;
			error = Math::Dsp::Spectrum(operator1.vector_value, result.vector_value);
			if (error)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, error);
				return false;
			}
			stack.push(result);
			return true;
		case LEX_FUNC_RAND:
			{
				std::tr1::uniform_real<double> ur (0.0, operator1.vector_value[0]);
				cols = operator1.vector_value.size();
				result.vector_value.resize(cols);
				for(i=0; i<cols; i++) result.vector_value[i] = ur(Math::Statistics::random_generator);
				stack.push(result);
				return true;
			}
		}
	}
	else if (operator1.datatype == LEX_DATATYPE_COMPLEX_VECTOR)
	{
		result.datatype = LEX_DATATYPE_COMPLEX_VECTOR;
		switch(inst.subtype)
		{
		case LEX_FUNC_ABS:
			result.vectorC_value = abs(operator1.vectorC_value);
			stack.push(result);
			return true;
		case LEX_FUNC_FFT:
			result.datatype = LEX_DATATYPE_COMPLEX_VECTOR;
			error = Math::Dsp::Fft(operator1.vectorC_value, result.vectorC_value, false);
			if (error)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, error);
				return false;
			}
			stack.push(result);
			return true;
		case LEX_FUNC_IFFT:
			result.datatype = LEX_DATATYPE_COMPLEX_VECTOR;
			error = Math::Dsp::Fft(operator1.vectorC_value, result.vectorC_value, true);
			if (error)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, error);
				return false;
			}
			stack.push(result);
			return true;
		case LEX_FUNC_SPECTRUM:
			result.datatype = LEX_DATATYPE_VECTOR;
			error = Math::Dsp::Spectrum(operator1.vectorC_value, result.vector_value);
			if (error)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, error);
				return false;
			}
			stack.push(result);
			return true;
		}
	}
	else if (operator1.datatype == LEX_DATATYPE_MATRIX)
	{
		result.datatype = LEX_DATATYPE_MATRIX;
		switch(inst.subtype)
		{
		case LEX_FUNC_SIN:
			rows = operator1.matrix_value.size();
			result.matrix_value.resize(rows);
			if (rows>0) cols = operator1.matrix_value[0].size();
			for(i = 0; i<rows; i++)
			{
				result.matrix_value.resize(cols);
				for(j = 0; j<cols; j++)
				{
					result.matrix_value[i][j] = sin(operator1.matrix_value[i][j]);
				}
			}
			stack.push(result);
			return true;
		case LEX_FUNC_COS:
			rows = operator1.matrix_value.size();
			result.matrix_value.resize(rows);
			if (rows>0) cols = operator1.matrix_value[0].size();
			for(i = 0; i<rows; i++)
			{
				result.matrix_value.resize(cols);
				for(j = 0; j<cols; j++)
				{
					result.matrix_value[i][j] = cos(operator1.matrix_value[i][j]);
				}
			}
			stack.push(result);
			return true;
		case LEX_FUNC_TAN:
			rows = operator1.matrix_value.size();
			result.matrix_value.resize(rows);
			if (rows>0) cols = operator1.matrix_value[0].size();
			for(i = 0; i<rows; i++)
			{
				result.matrix_value.resize(cols);
				for(j = 0; j<cols; j++)
				{
					result.matrix_value[i][j] = tan(operator1.matrix_value[i][j]);
				}
			}
			stack.push(result);
			return true;
		case LEX_FUNC_ASIN:
			rows = operator1.matrix_value.size();
			result.matrix_value.resize(rows);
			if (rows>0) cols = operator1.matrix_value[0].size();
			for(i = 0; i<rows; i++)
			{
				result.matrix_value.resize(cols);
				for(j = 0; j<cols; j++)
				{
					result.matrix_value[i][j] = asin(operator1.matrix_value[i][j]);
				}
			}
			stack.push(result);
			return true;
		case LEX_FUNC_ACOS:
			rows = operator1.matrix_value.size();
			result.matrix_value.resize(rows);
			if (rows>0) cols = operator1.matrix_value[0].size();
			for(i = 0; i<rows; i++)
			{
				result.matrix_value.resize(cols);
				for(j = 0; j<cols; j++)
				{
					result.matrix_value[i][j] = acos(operator1.matrix_value[i][j]);
				}
			}
			stack.push(result);
			return true;
		case LEX_FUNC_ATAN:
			rows = operator1.matrix_value.size();
			result.matrix_value.resize(rows);
			if (rows>0) cols = operator1.matrix_value[0].size();
			for(i = 0; i<rows; i++)
			{
				result.matrix_value.resize(cols);
				for(j = 0; j<cols; j++)
				{
					result.matrix_value[i][j] = atan(operator1.matrix_value[i][j]);
				}
			}
			stack.push(result);
			return true;
		case LEX_FUNC_SINH :
			rows = operator1.matrix_value.size();
			result.matrix_value.resize(rows);
			if (rows>0) cols = operator1.matrix_value[0].size();
			for(i = 0; i<rows; i++)
			{
				result.matrix_value.resize(cols);
				for(j = 0; j<cols; j++)
				{
					result.matrix_value[i][j] = sinh(operator1.matrix_value[i][j]);
				}
			}
			stack.push(result);
			return true;
		case LEX_FUNC_COSH:
			rows = operator1.matrix_value.size();
			result.matrix_value.resize(rows);
			if (rows>0) cols = operator1.matrix_value[0].size();
			for(i = 0; i<rows; i++)
			{
				result.matrix_value.resize(cols);
				for(j = 0; j<cols; j++)
				{
					result.matrix_value[i][j] = cosh(operator1.matrix_value[i][j]);
				}
			}
			stack.push(result);
			return true;
		case LEX_FUNC_TANH:
			rows = operator1.matrix_value.size();
			result.matrix_value.resize(rows);
			if (rows>0) cols = operator1.matrix_value[0].size();
			for(i = 0; i<rows; i++)
			{
				result.matrix_value.resize(cols);
				for(j = 0; j<cols; j++)
				{
					result.matrix_value[i][j] = tanh(operator1.matrix_value[i][j]);
				}
			}
			stack.push(result);
			return true;
		case LEX_FUNC_SQRT:
			rows = operator1.matrix_value.size();
			result.matrix_value.resize(rows);
			if (rows>0) cols = operator1.matrix_value[0].size();
			for(i = 0; i<rows; i++)
			{
				result.matrix_value.resize(cols);
				for(j = 0; j<cols; j++)
				{
					result.matrix_value[i][j] = sqrt(operator1.matrix_value[i][j]);
				}
			}
			stack.push(result);
			return true;
		case LEX_FUNC_LOG10:
			rows = operator1.matrix_value.size();
			result.matrix_value.resize(rows);
			if (rows>0) cols = operator1.matrix_value[0].size();
			for(i = 0; i<rows; i++)
			{
				result.matrix_value.resize(cols);
				for(j = 0; j<cols; j++)
				{
					result.matrix_value[i][j] = log10(operator1.matrix_value[i][j]);
				}
			}
			stack.push(result);
			return true;
		case LEX_FUNC_LOG:
			rows = operator1.matrix_value.size();
			result.matrix_value.resize(rows);
			if (rows>0) cols = operator1.matrix_value[0].size();
			for(i = 0; i<rows; i++)
			{
				result.matrix_value.resize(cols);
				for(j = 0; j<cols; j++)
				{
					result.matrix_value[i][j] = log(operator1.matrix_value[i][j]);
				}
			}
			stack.push(result);
			return true;
		case LEX_FUNC_EXP:
			rows = operator1.matrix_value.size();
			result.matrix_value.resize(rows);
			if (rows>0) cols = operator1.matrix_value[0].size();
			for(i = 0; i<rows; i++)
			{
				result.matrix_value.resize(cols);
				for(j = 0; j<cols; j++)
				{
					result.matrix_value[i][j] = exp(operator1.matrix_value[i][j]);
				}
			}
			stack.push(result);
			return true;
		case LEX_FUNC_ABS:
			rows = operator1.matrix_value.size();
			result.matrix_value.resize(rows);
			if (rows>0) cols = operator1.matrix_value[0].size();
			for(i = 0; i<rows; i++)
			{
				result.matrix_value.resize(cols);
				for(j = 0; j<cols; j++)
				{
					result.matrix_value[i][j] = abs(operator1.matrix_value[i][j]);
				}
			}
			stack.push(result);
			return true;
		case LEX_FUNC_SINC:
			rows = operator1.matrix_value.size();
			result.matrix_value.resize(rows);
			if (rows>0) cols = operator1.matrix_value[0].size();
			for(i = 0; i<rows; i++)
			{
				result.matrix_value.resize(cols);
				for(j = 0; j<cols; j++)
				{
					result.matrix_value[i][j] = Math::Dsp::Sinc(operator1.matrix_value[i][j]);
				}
			}
			stack.push(result);
			return true;
		case LEX_FUNC_TRIANG:
			rows = operator1.matrix_value.size();
			result.matrix_value.resize(rows);
			if (rows>0) cols = operator1.matrix_value[0].size();
			for(i = 0; i<rows; i++)
			{
				result.matrix_value.resize(cols);
				for(j = 0; j<cols; j++)
				{
					result.matrix_value[i][j] = Math::Dsp::Triangular(operator1.matrix_value[i][j], 2.0*M_PI);
				}
			}
			stack.push(result);
			return true;
		case LEX_FUNC_SAW:
			rows = operator1.matrix_value.size();
			result.matrix_value.resize(rows);
			if (rows>0) cols = operator1.matrix_value[0].size();
			for(i = 0; i<rows; i++)
			{
				result.matrix_value.resize(cols);
				for(j = 0; j<cols; j++)
				{
					result.matrix_value[i][j] = Math::Dsp::Sawtooth(operator1.matrix_value[i][j], 2.0*M_PI);
				}
			}
			stack.push(result);
			return true;
		case LEX_FUNC_RECT:
			rows = operator1.matrix_value.size();
			result.matrix_value.resize(rows);
			if (rows>0) cols = operator1.matrix_value[0].size();
			for(i = 0; i<rows; i++)
			{
				result.matrix_value.resize(cols);
				for(j = 0; j<cols; j++)
				{
					result.matrix_value[i][j] = Math::Dsp::Rectangular(operator1.matrix_value[i][j], 2.0*M_PI);
				}
			}
			stack.push(result);
		case LEX_FUNC_CEIL:
			rows = operator1.matrix_value.size();
			result.matrix_value.resize(rows);
			if (rows>0) cols = operator1.matrix_value[0].size();
			for(i = 0; i<rows; i++)
			{
				result.matrix_value[i].resize(cols);
				for(j = 0; j<cols; j++)
				{
					result.matrix_value[i][j] = ceil(operator1.matrix_value[i][j]);
				}
			}
			stack.push(result);
			return true;
		case LEX_FUNC_FLOOR:
			rows = operator1.matrix_value.size();
			result.matrix_value.resize(rows);
			if (rows>0) cols = operator1.matrix_value[0].size();
			for(i = 0; i<rows; i++)
			{
				result.matrix_value[i].resize(cols);
				for(j = 0; j<cols; j++)
				{
					result.matrix_value[i][j] = floor(operator1.matrix_value[i][j]);
				}
			}
			stack.push(result);
			return true;
		case LEX_FUNC_FFT:
			result.datatype = LEX_DATATYPE_COMPLEX_MATRIX;
			error = Math::Dsp::Fft(operator1.matrix_value, result.matrixC_value, false);
			if (error)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, error);
				return false;
			}
			stack.push(result);
			return true;
		case LEX_FUNC_IFFT:
			result.datatype = LEX_DATATYPE_COMPLEX_MATRIX;
			error = Math::Dsp::Fft(operator1.matrix_value, result.matrixC_value, true);
			if (error)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, error);
				return false;
			}
			stack.push(result);
			return true;
		case LEX_FUNC_REALFFT:
			result.datatype = LEX_DATATYPE_MATRIX;
			error = Math::Dsp::RealFft(operator1.matrix_value, result.matrix_value, false);
			if (error)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, error);
				return false;
			}
			stack.push(result);
			return true;
		case LEX_FUNC_IREALFFT:
			result.datatype = LEX_DATATYPE_MATRIX;
			error = Math::Dsp::RealFft(operator1.matrix_value, result.matrix_value, true);
			if (error)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, error);
				return false;
			}
			stack.push(result);
			return true;
		case LEX_FUNC_SPECTRUM:
			result.datatype = LEX_DATATYPE_MATRIX;
			error = Math::Dsp::Spectrum(operator1.matrix_value, result.matrix_value);
			if (error)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, error);
				return false;
			}
			stack.push(result);
			return true;
		case LEX_FUNC_RAND:
		{
				std::tr1::uniform_real<double> ur (0.0, operator1.matrix_value[0][0]);
				rows = operator1.matrix_value.size();
				result.matrix_value.resize(rows);
				if (rows>0) cols = operator1.matrix_value[0].size();
				for(i = 0; i<rows; i++)
				{
					result.matrix_value.resize(cols);
					for(j = 0; j<cols; j++)
					{
						result.matrix_value[i][j] = ur(Math::Statistics::random_generator);
					}
				}
				stack.push(result);
				return true;
			}
		}
	}
	else if (operator1.datatype == LEX_DATATYPE_COMPLEX_MATRIX)
	{
		result.datatype = LEX_DATATYPE_MATRIX;
		switch(inst.subtype)
		{
		case LEX_FUNC_ABS:
			rows = operator1.matrix_value.size();
			result.matrix_value.resize(rows);
			if (rows>0) cols = operator1.matrixC_value[0].size();
			for(i = 0; i<rows; i++)
			{
				result.matrix_value.resize(cols);
				for(j = 0; j<cols; j++)
				{
					result.matrix_value[i][j] = abs(operator1.matrixC_value[i][j]);
				}
			}
			stack.push(result);
			return true;
		case LEX_FUNC_FFT:
			result.datatype = LEX_DATATYPE_COMPLEX_MATRIX;
			error = Math::Dsp::Fft(operator1.matrixC_value, result.matrixC_value, false);
			if (error)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, error);
				return false;
			}
			stack.push(result);
			return true;
		case LEX_FUNC_IFFT:
			result.datatype = LEX_DATATYPE_COMPLEX_MATRIX;
			error = Math::Dsp::Fft(operator1.matrixC_value, result.matrixC_value, true);
			if (error)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, error);
				return false;
			}
			stack.push(result);
			return true;
		case LEX_FUNC_SPECTRUM:
			result.datatype = LEX_DATATYPE_MATRIX;
			error = Math::Dsp::Spectrum(operator1.matrixC_value, result.matrix_value);
			if (error)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, error);
				return false;
			}
			stack.push(result);
			return true;
		case LEX_FUNC_RAND:
		{
				std::tr1::uniform_real<double> ur (0.0, operator1.matrix_value[0][0]);
				rows = operator1.matrix_value.size();
				result.matrix_value.resize(rows);
				if (rows>0) cols = operator1.matrix_value[0].size();
				for(i = 0; i<rows; i++)
				{
					result.matrix_value.resize(cols);
					for(j = 0; j<cols; j++)
					{
						result.matrix_value[i][j] = ur(Math::Statistics::random_generator);
					}
				}
				stack.push(result);
				return true;
			}
		}
	}

	_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid function call", machineCode[instructionIndex].line_number);
	return false;
}

bool VirtualMachine::VmOper(Compiler::Instruction& inst)
{
	Cpl::VirtualMachine::Memory operator1;
	Cpl::VirtualMachine::Memory operator2;

	operator1 = stack.top();
	stack.pop();
	operator2 = stack.top();
	stack.pop();

	switch(inst.subtype)
	{
	case LEX_PLUS:
	case LEX_MINUS:
	case LEX_ASTERISK:
	case LEX_DIVISION:
	case LEX_PERCENT_SIGN:
		return OperBinary(inst, operator2, operator1);
	case LEX_IS_BIGGER:
	case LEX_IS_BIGGER_EQ:
	case LEX_IS_LESS:
	case LEX_IS_LESS_EQ:
	case LEX_IS_EQUAL:
	case LEX_IS_DIFFERENT: 
		return OperRelational(inst, operator2, operator1);
	case LEX_OR:
	case LEX_AND:
		return OperBool(inst, operator1, operator2);
	}
	_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid operation", machineCode[instructionIndex].line_number);
	return false;
}

bool VirtualMachine::VmOperMono(Compiler::Instruction& inst)
{
	int operation = (int)inst.double_value;
	if (inst.subtype == LEX_DATATYPE_INTEGER)
	{
		switch(operation)
		{
		case LEX_PLUS_PLUS:
			memInteger[inst.int_value]++;
			return true;
		case LEX_MINUS_MINUS:
			memInteger[inst.int_value]--;
			return true;
		}
	}
	else if (inst.subtype == LEX_DATATYPE_DOUBLE)
	{
		switch(operation)
		{
		case LEX_PLUS_PLUS:
			memDouble[inst.int_value]++;
			return true;
		case LEX_MINUS_MINUS:
			memDouble[inst.int_value]--;
			return true;
		}
	}
	_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid operator", machineCode[instructionIndex].line_number);
	return false;
}

bool VirtualMachine::VmOperBina(Compiler::Instruction& inst)
{
	Cpl::VirtualMachine::Memory operator1;

	operator1 = stack.top();
	stack.pop();

	if (Convert(operator1, inst.subtype, NULL) == false) return false;

	int operation = (int)inst.double_value;
	if (inst.subtype == LEX_DATATYPE_INTEGER)
	{
		switch(operation)
		{
		case LEX_PLUS_EQUAL:
			memInteger[inst.int_value]+=operator1.int_value;
			return true;
		case LEX_MINUS_EQUAL:
			memInteger[inst.int_value]-=operator1.int_value;
			return true;
		case LEX_PRODUCT_EQUAL:
			memInteger[inst.int_value]*=operator1.int_value;
			return true;
		case LEX_DIVISION_EQUAL:
			memInteger[inst.int_value]/=operator1.int_value;
			return true;
		}
	}
	else if (inst.subtype == LEX_DATATYPE_DOUBLE)
	{
		switch(operation)
		{
		case LEX_PLUS_EQUAL:
			memDouble[inst.int_value]+=operator1.double_value;
			return true;
		case LEX_MINUS_EQUAL:
			memDouble[inst.int_value]-=operator1.double_value;
			return true;
		case LEX_PRODUCT_EQUAL:
			memDouble[inst.int_value]*=operator1.double_value;
			return true;
		case LEX_DIVISION_EQUAL:
			memDouble[inst.int_value]/=operator1.double_value;
			return true;
		}
	}
	_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid operator", machineCode[instructionIndex].line_number);
	return false;
}

bool VirtualMachine::OperBinary(Compiler::Instruction& inst, VirtualMachine::Memory& operator1, VirtualMachine::Memory& operator2)
{
	Cpl::VirtualMachine::Memory result;
	int original_operator1_datatype = operator1.datatype;
	int original_operator2_datatype = operator2.datatype;
	double dtmp = 0.0;
	result.datatype = GetResultingDatatype(operator1.datatype, operator2.datatype, inst.subtype);
	int i, j, rows1, rows2, cols1, cols2;
	wchar_t* error = NULL;

	//_____________________________________________________ Vector + double
	if (operator1.datatype == LEX_DATATYPE_VECTOR && operator2.datatype == LEX_DATATYPE_DOUBLE) 
	{
		result.datatype = LEX_DATATYPE_VECTOR;
		switch(inst.subtype)
		{
		case LEX_PLUS:
			result.vector_value = operator1.vector_value + operator2.double_value;
			stack.push(result);
			return true;
		case LEX_MINUS:
			result.vector_value = operator1.vector_value - operator2.double_value;
			stack.push(result);
			return true;
		case LEX_ASTERISK:
			result.vector_value = operator1.vector_value * operator2.double_value;
			stack.push(result);
			return true;
		case LEX_DIVISION:
			result.vector_value = operator1.vector_value / operator2.double_value;
			stack.push(result);
			return true;
		}
	}
	//_____________________________________________________ Vector + integer
	if (operator1.datatype == LEX_DATATYPE_VECTOR && operator2.datatype == LEX_DATATYPE_INTEGER) 
	{
		result.datatype = LEX_DATATYPE_VECTOR;
		switch(inst.subtype)
		{
		case LEX_PLUS:
			result.vector_value = operator1.vector_value + (double)operator2.int_value;
			stack.push(result);
			return true;
		case LEX_MINUS:
			result.vector_value = operator1.vector_value - (double)operator2.int_value;
			stack.push(result);
			return true;
		case LEX_ASTERISK:
			result.vector_value = operator1.vector_value * (double)operator2.int_value;
			stack.push(result);
			return true;
		case LEX_DIVISION:
			result.vector_value = operator1.vector_value / (double)operator2.int_value;
			stack.push(result);
			return true;
		}
	}
	//_____________________________________________________ double + Vector
	if (operator1.datatype == LEX_DATATYPE_DOUBLE && operator2.datatype == LEX_DATATYPE_VECTOR) 
	{
		result.datatype = LEX_DATATYPE_VECTOR;
		switch(inst.subtype)
		{
		case LEX_PLUS:
			result.vector_value = operator1.double_value + operator2.vector_value;
			stack.push(result);
			return true;
		case LEX_MINUS:
			result.vector_value = operator1.double_value- operator2.vector_value ;
			stack.push(result);
			return true;
		case LEX_ASTERISK:
			result.vector_value = operator1.double_value * operator2.vector_value;
			stack.push(result);
			return true;
		case LEX_DIVISION:
			result.vector_value = operator1.double_value / operator2.vector_value;
			stack.push(result);
			return true;
		}
	}
	//_____________________________________________________ integer + Vector
	if (operator1.datatype == LEX_DATATYPE_INTEGER && operator2.datatype == LEX_DATATYPE_VECTOR) 
	{
		result.datatype = LEX_DATATYPE_VECTOR;
		switch(inst.subtype)
		{
		case LEX_PLUS:
			result.vector_value = (double)operator1.int_value + operator2.vector_value;
			stack.push(result);
			return true;
		case LEX_MINUS:
			result.vector_value = (double)operator1.int_value - operator2.vector_value ;
			stack.push(result);
			return true;
		case LEX_ASTERISK:
			result.vector_value = (double)operator1.int_value * operator2.vector_value;
			stack.push(result);
			return true;
		case LEX_DIVISION:
			result.vector_value = (double)operator1.int_value / operator2.vector_value;
			stack.push(result);
			return true;
		}
	}

	//_____________________________________________________ Matrix + double
	if (operator1.datatype == LEX_DATATYPE_MATRIX && operator2.datatype == LEX_DATATYPE_DOUBLE) 
	{
		result.datatype = LEX_DATATYPE_MATRIX;
		const int rows = operator1.matrix_value.size();
		const int cols = (rows == 0) ? 0 : operator1.matrix_value[0].size();
		int i;
		try
		{
			result.matrix_value.resize(rows);
			for (i=0; i<rows; i++) result.matrix_value[i].resize(cols);
		}
		catch (const std::bad_alloc& )
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d no enough memory", machineCode[instructionIndex].line_number);
			return false;
		}
		switch(inst.subtype)
		{
		case LEX_PLUS:
			for(i = 0; i<rows; i++) result.matrix_value[i] = operator1.matrix_value[i] + operator2.double_value;
			stack.push(result);
			return true;
		case LEX_MINUS:
			for(i = 0; i<rows; i++) result.matrix_value[i] = operator1.matrix_value[i] - operator2.double_value;
			stack.push(result);
			return true;
		case LEX_ASTERISK:
			for(i = 0; i<rows; i++) result.matrix_value[i] = operator1.matrix_value[i] * operator2.double_value;
			stack.push(result);
			return true;
		case LEX_DIVISION:
			for(i = 0; i<rows; i++) result.matrix_value[i] = operator1.matrix_value[i] / operator2.double_value;
			stack.push(result);
			return true;
		}
	}

	//_____________________________________________________ Matrix + integer
	if (operator1.datatype == LEX_DATATYPE_MATRIX && operator2.datatype == LEX_DATATYPE_INTEGER) 
	{
		result.datatype = LEX_DATATYPE_MATRIX;
		const int rows = operator1.matrix_value.size();
		const int cols = (rows == 0) ? 0 : operator1.matrix_value[0].size();
		int i;
		try
		{
			result.matrix_value.resize(rows);
			for (i=0; i<rows; i++) result.matrix_value[i].resize(cols);
		}
		catch (const std::bad_alloc& )
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d no enough memory", machineCode[instructionIndex].line_number);
			return false;
		}
		switch(inst.subtype)
		{
		case LEX_PLUS:
			for(i = 0; i<rows; i++) result.matrix_value[i] = operator1.matrix_value[i] + (double)operator2.int_value;
			stack.push(result);
			return true;
		case LEX_MINUS:
			for(i = 0; i<rows; i++) result.matrix_value[i] = operator1.matrix_value[i] - (double)operator2.int_value;
			stack.push(result);
			return true;
		case LEX_ASTERISK:
			for(i = 0; i<rows; i++) result.matrix_value[i] = operator1.matrix_value[i] * (double)operator2.int_value;
			stack.push(result);
			return true;
		case LEX_DIVISION:
			for(i = 0; i<rows; i++) result.matrix_value[i] = operator1.matrix_value[i] / (double)operator2.int_value;
			stack.push(result);
			return true;
		}
	}
	//_____________________________________________________ double + Matrix
	if (operator1.datatype == LEX_DATATYPE_DOUBLE && operator2.datatype == LEX_DATATYPE_MATRIX) 
	{
		result.datatype = LEX_DATATYPE_MATRIX;
		const int rows = operator2.matrix_value.size();
		const int cols = (rows == 0) ? 0 : operator2.matrix_value[0].size();
		int i;
		try
		{
			result.matrix_value.resize(rows);
			for (i=0; i<rows; i++) result.matrix_value[i].resize(cols);
		}
		catch (const std::bad_alloc& )
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d no enough memory", machineCode[instructionIndex].line_number);
			return false;
		}
		switch(inst.subtype)
		{
		case LEX_PLUS:
			for(i = 0; i<rows; i++) result.matrix_value[i] = operator1.double_value + operator2.matrix_value[i] ;
			stack.push(result);
			return true;
		case LEX_MINUS:
			for(i = 0; i<rows; i++) result.matrix_value[i]  = operator1.double_value- operator2.matrix_value[i] ;
			stack.push(result);
			return true;
		case LEX_ASTERISK:
			for(i = 0; i<rows; i++) result.matrix_value[i]  = operator1.double_value * operator2.matrix_value[i] ;
			stack.push(result);
			return true;
		case LEX_DIVISION:
			for(i = 0; i<rows; i++) result.matrix_value[i]  = operator1.double_value / operator2.matrix_value[i] ;
			stack.push(result);
			return true;
		}
	}

	//_____________________________________________________ integer + Matrix
	if (operator1.datatype == LEX_DATATYPE_INTEGER && operator2.datatype == LEX_DATATYPE_MATRIX) 
	{
		result.datatype = LEX_DATATYPE_MATRIX;
		const int rows = operator2.matrix_value.size();
		const int cols = (rows == 0) ? 0 : operator2.matrix_value[0].size();
		int i;
		try
		{
			result.matrix_value.resize(rows);
			for (i=0; i<rows; i++) result.matrix_value[i].resize(cols);
		}
		catch (const std::bad_alloc& )
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d no enough memory", machineCode[instructionIndex].line_number);
			return false;
		}
		switch(inst.subtype)
		{
		case LEX_PLUS:
			for(i = 0; i<rows; i++) result.matrix_value[i] = (double)operator1.int_value + operator2.matrix_value[i] ;
			stack.push(result);
			return true;
		case LEX_MINUS:
			for(i = 0; i<rows; i++) result.matrix_value[i]  = (double)operator1.int_value- operator2.matrix_value[i] ;
			stack.push(result);
			return true;
		case LEX_ASTERISK:
			for(i = 0; i<rows; i++) result.matrix_value[i]  = (double)operator1.int_value * operator2.matrix_value[i] ;
			stack.push(result);
			return true;
		case LEX_DIVISION:
			for(i = 0; i<rows; i++) result.matrix_value[i]  = (double)operator1.int_value / operator2.matrix_value[i] ;
			stack.push(result);
			return true;
		}
	}
		
	if (result.datatype == ERROR_INVALID_VALUE)
	{
		_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d conversion error", machineCode[instructionIndex].line_number);
		return false;
	}

	//______________________________________________________ Product:  Matrix and vectors
	switch(result.datatype)
	{
	case LEX_DATATYPE_VECTOR://_____________________________ matrix * vector
		if  (original_operator1_datatype  == LEX_DATATYPE_MATRIX && original_operator2_datatype == LEX_DATATYPE_VECTOR &&
			inst.subtype == LEX_ASTERISK)
		{
			// the number of columns of the matrix is equal to the number of rows of the vector
			error = Math::Oper::Product(operator1.matrix_value, operator2.vector_value, result.vector_value);
			if (error)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, error);
				return false;
			}
			stack.push(result);
			return true;
		}
		break;
	case LEX_DATATYPE_MATRIX://_____________________________ vector * matrix
		if  (original_operator1_datatype  == LEX_DATATYPE_VECTOR && original_operator2_datatype == LEX_DATATYPE_MATRIX &&
			inst.subtype == LEX_ASTERISK)
		{
			// the matrix must have only one row
			if (operator2.matrix_value.size() != 1)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d the number of rows in the matrix must be one", machineCode[instructionIndex].line_number);
				return false;
			}
			Math::Oper::Product(operator1.vector_value, operator2.matrix_value, 0, result.matrix_value);
			stack.push(result);
			return true;
		}
		break;
	case LEX_DATATYPE_COMPLEX_VECTOR://_____________________________ matrixC * vectorC
		if  (original_operator1_datatype  == LEX_DATATYPE_COMPLEX_MATRIX && original_operator2_datatype == LEX_DATATYPE_COMPLEX_VECTOR &&
			inst.subtype == LEX_ASTERISK)
		{
			// the number of columns of the matrix is equal to the number of rows of the vector
			error = Math::Oper::Product(operator1.matrixC_value, operator2.vectorC_value, result.vectorC_value);
			if (error)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, error);
				return false;
			}
			stack.push(result);
			return true;
		}
		break;
	case LEX_DATATYPE_COMPLEX_MATRIX://_____________________________ vectorC * matrixC
		if  (original_operator1_datatype  == LEX_DATATYPE_COMPLEX_VECTOR && original_operator2_datatype == LEX_DATATYPE_COMPLEX_MATRIX &&
			inst.subtype == LEX_ASTERISK)
		{
			// the matrix must have only one row
			if (operator2.matrixC_value.size() != 1)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d the number of rows in the matrix must be one", machineCode[instructionIndex].line_number);
				return false;
			}
			Math::Oper::Product(operator1.vectorC_value, operator2.matrixC_value, 0, result.matrixC_value);
			stack.push(result);
			return true;
		}
		break;
	}
	if (Convert(operator1, result.datatype, NULL)== false) return false;
	if (Convert(operator2,result.datatype, NULL)== false) return false;

	switch(result.datatype)
	{
	//______________________________________________________________________________
	case LEX_DATATYPE_INTEGER:
		switch(inst.subtype)
		{
		case LEX_PLUS:
			result.int_value = operator1.int_value + operator2.int_value;
			stack.push(result);
			return true;
		case LEX_MINUS:
			result.int_value = operator1.int_value - operator2.int_value;
			stack.push(result);
			return true;
		case LEX_ASTERISK:
			result.int_value = operator1.int_value * operator2.int_value;
			stack.push(result);
			return true;
		case LEX_DIVISION:
			result.int_value = operator1.int_value / operator2.int_value;
			stack.push(result);
			return true;
		case LEX_PERCENT_SIGN:
			result.int_value = operator1.int_value % operator2.int_value;
			stack.push(result);
			return true;
		}
		break;
	//______________________________________________________________________________
	case LEX_DATATYPE_DOUBLE:
		switch(inst.subtype)
		{
		case LEX_PLUS:
			result.double_value = operator1.double_value + operator2.double_value;
			stack.push(result);
			return true;
		case LEX_MINUS:
			result.double_value = operator1.double_value - operator2.double_value;
			stack.push(result);
			return true;
		case LEX_ASTERISK:
			result.double_value = operator1.double_value * operator2.double_value;
			stack.push(result);
			return true;
		case LEX_DIVISION:
			result.double_value = operator1.double_value / operator2.double_value;
			stack.push(result);
			return true;
		}
		break;
	//______________________________________________________________________________
	case LEX_DATATYPE_VECTOR:
		////_____________________________ double * vector          or                double * vector
		//if  ((original_operator1_datatype  == LEX_DATATYPE_DOUBLE && original_operator2_datatype == LEX_DATATYPE_VECTOR)
		//	|| (original_operator1_datatype  == LEX_DATATYPE_INTEGER && original_operator2_datatype == LEX_DATATYPE_VECTOR))
		//{
		//	cols1 = operator1.vector_value.size();
		//	cols2 = operator2.vector_value.size();
		//	//
		//	dtmp = operator1.vector_value[0];
		//	operator1.vector_value.resize(cols2);
		//	cols1 = operator1.vector_value.size();
		//	for(i = 0; i<cols1; i++) operator1.vector_value[i] = dtmp; 
		//}
		////_____________________________ vector * double          or                interger * vector
		//else if ((original_operator2_datatype  == LEX_DATATYPE_DOUBLE && original_operator1_datatype == LEX_DATATYPE_VECTOR)
		//	|| (original_operator2_datatype  == LEX_DATATYPE_INTEGER && original_operator1_datatype == LEX_DATATYPE_VECTOR))
		//{
		//	cols1 = operator1.vector_value.size();
		//	cols2 = operator2.vector_value.size();
		//	//
		//	dtmp = operator2.vector_value[0];
		//	operator2.vector_value.resize(cols2);
		//	cols2 = operator2.vector_value.size();
		//	for(i = 0; i<cols1; i++) operator2.vector_value[i] = dtmp; 
		//}
		
		cols1 = operator1.vector_value.size();
		cols2 = operator2.vector_value.size();
		if (cols1 != cols2)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d the vectors have different sizes", machineCode[instructionIndex].line_number);
			return false;
		}
		result.vector_value.resize(cols1);
		switch(inst.subtype)
		{
		case LEX_PLUS:
			for(i=0; i<cols1; i++) result.vector_value[i] = operator1.vector_value[i]+operator2.vector_value[i];
			stack.push(result);
			return true;
		case LEX_MINUS:
			for(i=0; i<cols1; i++) result.vector_value[i] = operator1.vector_value[i]-operator2.vector_value[i];
			stack.push(result);
			return true;
		case LEX_ASTERISK:
			for(i=0; i<cols1; i++) result.vector_value[i] = operator1.vector_value[i]*operator2.vector_value[i];
			stack.push(result);
			return true;
		case LEX_DIVISION:
			for(i=0; i<cols1; i++) result.vector_value[i] = operator1.vector_value[i]/operator2.vector_value[i];
			stack.push(result);
			return true;
		}
		break;
	//______________________________________________________________________________
	case LEX_DATATYPE_MATRIX:
		rows1 = operator1.matrix_value.size();
		rows2 = operator2.matrix_value.size();
		if (rows1>0) cols1 = operator1.matrix_value[0].size();
		if (rows2>0) cols2 = operator2.matrix_value[0].size();

		result.vector_value.resize(rows1);
		switch(inst.subtype)
		{
		case LEX_PLUS:
			if (rows1 != rows2 || cols1 != cols2)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d the matrices have different sizes", machineCode[instructionIndex].line_number);
				return false;
			}
			result.matrix_value.resize(rows1);
			for(i=0; i<rows1; i++) 
			{
				result.matrix_value[i].resize(cols1);
				for(j=0; j<cols1; j++) 
					result.matrix_value[i][j] = operator1.matrix_value[i][j]+operator2.matrix_value[i][j];
			}
			stack.push(result);
			return true;
		case LEX_MINUS:
			if (rows1 != rows2 || cols1 != cols2)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d the matrices have different sizes", machineCode[instructionIndex].line_number);
				return false;
			}
			result.matrix_value.resize(rows1);
			for(i=0; i<rows1; i++) 
			{
				result.matrix_value[i].resize(cols1);
				for(j=0; j<cols1; j++) 
					result.matrix_value[i][j] = operator1.matrix_value[i][j]-operator2.matrix_value[i][j];
			}
			stack.push(result);
			return true;
		case LEX_ASTERISK:
			if (rows1 == 1 && cols1 ==1) //____________ first element is a scalar
			{
				result.matrix_value.resize(rows2);
				for(i=0; i<rows2; i++) 
				{
					result.matrix_value[i].resize(cols2);
					for(j=0; j<cols2; j++) 
					{
						result.matrix_value[i][j] = operator1.matrix_value[0][0]*operator2.matrix_value[i][j];
					}
				}
				stack.push(result);
				return true;
			}
			if (rows2 ==1 && cols2 ==1) //____________ second element is a scalar
			{
				result.matrix_value.resize(rows1);
				for(i=0; i<rows1; i++) 
				{
					result.matrix_value[i].resize(cols1);
					for(j=0; j<cols1; j++) 
					{
						result.matrix_value[i][j] = operator1.matrix_value[i][j]*operator2.matrix_value[0][0];
					}
				}
				stack.push(result);
				return true;
			}
			if (cols1 != rows2)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d the matrices are not compatible", machineCode[instructionIndex].line_number);
				return false;
			}
			Math::Oper::Product(operator1.matrix_value, operator2.matrix_value, result.matrix_value);
			stack.push(result);
			return true;
		}
		break;
	//______________________________________________________________________________
	case LEX_DATATYPE_COMPLEX:
		switch(inst.subtype)
		{
		case LEX_PLUS:
			result.complex_value = operator1.complex_value + operator2.complex_value;
			stack.push(result);
			return true;
		case LEX_MINUS:
			result.complex_value = operator1.complex_value - operator2.complex_value;
			stack.push(result);
			return true;
		case LEX_ASTERISK:
			result.complex_value = operator1.complex_value * operator2.complex_value;
			stack.push(result);
			return true;
		case LEX_DIVISION:
			result.complex_value = operator1.complex_value / operator2.complex_value;
			stack.push(result);
			return true;
		}
		break;
	//______________________________________________________________________________
	case LEX_DATATYPE_COMPLEX_VECTOR:
		cols1 = operator1.vectorC_value.size();
		cols2 = operator2.vectorC_value.size();
		if (cols1 != cols2)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d the vectors have different sizes", machineCode[instructionIndex].line_number);
			return false;
		}
		result.vectorC_value.resize(cols1);
		switch(inst.subtype)
		{
		case LEX_PLUS:
			for(i=0; i<cols1; i++) result.vectorC_value[i] = operator1.vectorC_value[i]+operator2.vectorC_value[i];
			stack.push(result);
			return true;
		case LEX_MINUS:
			for(i=0; i<cols1; i++) result.vectorC_value[i] = operator1.vectorC_value[i]-operator2.vectorC_value[i];
			stack.push(result);
			return true;
		case LEX_ASTERISK:
			for(i=0; i<cols1; i++) result.vectorC_value[i] = operator1.vectorC_value[i]*operator2.vectorC_value[i];
			stack.push(result);
			return true;
		case LEX_DIVISION:
			for(i=0; i<cols1; i++) result.vectorC_value[i] = operator1.vectorC_value[i]/operator2.vectorC_value[i];
			stack.push(result);
			return true;
		}
		break;
	//______________________________________________________________________________
	case LEX_DATATYPE_COMPLEX_MATRIX:
		rows1 = operator1.matrixC_value.size();
		rows2 = operator2.matrixC_value.size();
		if (rows1>0) cols1 = operator1.matrixC_value[0].size();
		if (rows2>0) cols2 = operator1.matrixC_value[0].size();

		result.matrixC_value.resize(rows1);
		switch(inst.subtype)
		{
		case LEX_PLUS:
			if (rows1 != rows2 || cols1 != cols2)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d the matrices have different sizes", machineCode[instructionIndex].line_number);
				return false;
			}
			result.matrixC_value.resize(rows1);
			for(i=0; i<rows1; i++) 
			{
				result.matrixC_value[i].resize(cols1);
				for(j=0; j<cols1; j++) 
					result.matrixC_value[i][j] = operator1.matrixC_value[i][j]+operator2.matrixC_value[i][j];
			}
			stack.push(result);
			return true;
		case LEX_MINUS:
			if (rows1 != rows2 || cols1 != cols2)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d the matrices have different sizes", machineCode[instructionIndex].line_number);
				return false;
			}
			result.matrixC_value.resize(rows1);
			for(i=0; i<rows1; i++) 
			{
				result.matrixC_value[i].resize(cols1);
				for(j=0; j<cols1; j++) 
					result.matrixC_value[i][j] = operator1.matrixC_value[i][j]-operator2.matrixC_value[i][j];
			}
			stack.push(result);
			return true;
		case LEX_ASTERISK:
			if (cols1 != rows2)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d the matrices are not compatible", machineCode[instructionIndex].line_number);
				return false;
			}
			Math::Oper::Product(operator1.matrixC_value, operator2.matrixC_value, result.matrixC_value);
			stack.push(result);
			return true;
		}
		break;
	}

	_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid operator", machineCode[instructionIndex].line_number);
	return false;
}

bool VirtualMachine::OperBool(Compiler::Instruction& inst, VirtualMachine::Memory& operator1, VirtualMachine::Memory& operator2)
{
	if (operator1.datatype != LEX_DATATYPE_BOOL || operator2.datatype != LEX_DATATYPE_BOOL)
	{
		_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d a bool type is expected", machineCode[instructionIndex].line_number);
		return false;
	}
	Cpl::VirtualMachine::Memory result;
	result.datatype = LEX_DATATYPE_BOOL;
	switch(inst.subtype)
	{
	case LEX_OR:
		result.bool_value = operator1.bool_value || operator2.bool_value;
		stack.push(result);
		return true;
	case LEX_AND:
		result.bool_value = operator1.bool_value && operator2.bool_value;
		stack.push(result);
		return true;
	}
	_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid operator", machineCode[instructionIndex].line_number);
	return false;
}

bool VirtualMachine::OperRelational(Compiler::Instruction& inst, VirtualMachine::Memory& operator1, VirtualMachine::Memory& operator2)
{
	Cpl::VirtualMachine::Memory result;
	result.datatype = GetResultingDatatype(operator1.datatype, operator2.datatype, inst.subtype);
	if (result.datatype != LEX_DATATYPE_INTEGER && result.datatype != LEX_DATATYPE_DOUBLE && result.datatype != LEX_DATATYPE_BOOL)
	{
		_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid datatype", machineCode[instructionIndex].line_number);
		return false;
	}
	if (Convert(operator1, result.datatype, NULL) == false) return false;
	if (Convert(operator2, result.datatype, NULL) == false) return false;

	switch(inst.subtype)
	{
	case LEX_IS_BIGGER:
		if (result.datatype == LEX_DATATYPE_INTEGER)
		{
			result.bool_value = operator1.int_value > operator2.int_value;
		}
		else if (result.datatype == LEX_DATATYPE_DOUBLE)
		{
			result.bool_value = operator1.double_value > operator2.double_value;
		}
		else
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid datatype for the operator", machineCode[instructionIndex].line_number);
			return false;
		}
		result.datatype = LEX_DATATYPE_BOOL;
		stack.push(result);
		return true;
	case LEX_IS_BIGGER_EQ:
		if (result.datatype == LEX_DATATYPE_INTEGER)
		{
			result.bool_value = operator1.int_value >= operator2.int_value;
		}
		else if (result.datatype == LEX_DATATYPE_DOUBLE)
		{
			result.bool_value = operator1.double_value >= operator2.double_value;
		}
		else
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid datatype for the operator", machineCode[instructionIndex].line_number);
			return false;
		}
		result.datatype = LEX_DATATYPE_BOOL;
		stack.push(result);
		return true;
	case LEX_IS_LESS:
		if (result.datatype == LEX_DATATYPE_INTEGER)
		{
			result.bool_value = operator1.int_value < operator2.int_value;
		}
		else if (result.datatype == LEX_DATATYPE_DOUBLE)
		{
			result.bool_value = operator1.double_value < operator2.double_value;
		}
		else
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid datatype for the operator", machineCode[instructionIndex].line_number);
			return false;
		}
		result.datatype = LEX_DATATYPE_BOOL;
		stack.push(result);
		return true;
	case LEX_IS_LESS_EQ:
		if (result.datatype == LEX_DATATYPE_INTEGER)
		{
			result.bool_value = operator1.int_value <= operator2.int_value;
		}
		else if (result.datatype == LEX_DATATYPE_DOUBLE)
		{
			result.bool_value = operator1.double_value <= operator2.double_value;
		}
		else
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid datatype for the operator", machineCode[instructionIndex].line_number);
			return false;
		}
		result.datatype = LEX_DATATYPE_BOOL;
		stack.push(result);
		return true;
	case LEX_IS_EQUAL:
		if (result.datatype == LEX_DATATYPE_INTEGER)
		{
			result.bool_value = operator1.int_value == operator2.int_value;
		}
		else if (result.datatype == LEX_DATATYPE_DOUBLE)
		{
			result.bool_value = operator1.double_value == operator2.double_value;
		}
		else if (result.datatype == LEX_DATATYPE_BOOL)
		{
			result.bool_value = operator1.bool_value == operator2.bool_value;
		}
		result.datatype = LEX_DATATYPE_BOOL;
		stack.push(result);
		return true;
	case LEX_IS_DIFFERENT: 
		if (result.datatype == LEX_DATATYPE_INTEGER)
		{
			result.bool_value = operator1.int_value != operator2.int_value;
		}
		else if (result.datatype == LEX_DATATYPE_DOUBLE)
		{
			result.bool_value = operator1.double_value != operator2.double_value;
		}
		else if (result.datatype == LEX_DATATYPE_BOOL)
		{
			result.bool_value = operator1.bool_value != operator2.bool_value;
		}
		result.datatype = LEX_DATATYPE_BOOL;
		stack.push(result);
		return true;
	}
	_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid operator", machineCode[instructionIndex].line_number);
	return false;
}

bool VirtualMachine::VmGoto(Compiler::Instruction& inst)
{
	if (inst.int_value == -1)
	{
		instructionIndex = machineCode.size();
		return true;
	}
	instructionIndex = inst.int_value-1;
	return true;
}

bool VirtualMachine::VmGoFalse(Compiler::Instruction& inst)
{
	Cpl::VirtualMachine::Memory value = stack.top();
	stack.pop();
	if (value.datatype != LEX_DATATYPE_BOOL)
	{
		_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d bool value expected", machineCode[instructionIndex].line_number);
		return false;
	}
	if (value.bool_value == false)
	{
		if (inst.int_value == -1)
		{
			instructionIndex = machineCode.size();
			return true;
		}
		instructionIndex = inst.int_value-1;
	}
	return true;
}

bool VirtualMachine::VmGoTrue(Compiler::Instruction& inst)
{
	Cpl::VirtualMachine::Memory value = stack.top();
	stack.pop();
	if (value.datatype != LEX_DATATYPE_BOOL)
	{
		_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d bool value expected", machineCode[instructionIndex].line_number);
		return false;
	}
	if (value.bool_value == true)
	{
		if (inst.int_value == -1)
		{
			instructionIndex = machineCode.size();
			return true;
		}
		instructionIndex = inst.int_value-1;
	}
	return true;
}

bool VirtualMachine::VmCreate(Compiler::Instruction& inst)
{
	//prevent a variable from being created more than once at run time
	pair<set<wstring>::iterator, bool> returnValue = variableName.insert(inst.name);
	if (returnValue.second == false)
	{
		_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s must be declared outside: for, if, else, do-while or while", 
			machineCode[instructionIndex].line_number, inst.name);
		return false;
	}

	switch(inst.subtype)
	{
	case LEX_DATATYPE_BOOL:
		{
			bool x = false;
			memBool.push_back(x);
		}
		return true;
	case LEX_DATATYPE_DOUBLE:
		{
			double x = 0.0;
			memDouble.push_back(x);
		}
		return true;
	case LEX_DATATYPE_INTEGER:
		{
			int x = 0;
			memInteger.push_back(x);
		}
		return true;
	case LEX_DATATYPE_MATRIX: 
		{
			MATRIX x;
			memMatrix.push_back(x);
		}
		return true;
	case LEX_DATATYPE_VECTOR: 
		{
			valarray<double> x;
			memVector.push_back(x);
		}
		return true;
	case LEX_DATATYPE_COMPLEX: 
		{
			complex<double> x;
			memComplex.push_back(x);
		}
		return true;
	case LEX_DATATYPE_COMPLEX_VECTOR: 
		{
			valarray<complex<double> > x;
			memVectorC.push_back(x);
		}
		return true;
	case LEX_DATATYPE_COMPLEX_MATRIX: 
		{
			MATRIXC x;
			memMatrixC.push_back(x);
		}
		return true;
	//case LEX_DATATYPE_SCALER:
	//	{
	//		Nn::Scaler x;
	//		memScaler.push_back(x);
	//	}
	//	return true;
	case LEX_DATATYPE_LAYERNET:
		{
			Nn::LayerNet x;
			memLayerNet.push_back(x);
		}
		return true;
	case LEX_DATATYPE_KOHONET:
		{
			Nn::KohoNet x;
			memKohoNet.push_back(x);
		}
		return true;
	case LEX_DATATYPE_PROBNET:
		{
			Nn::ProbNet x;
			memProbNet.push_back(x);
		}
		return true;
	}
	_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid datatype", machineCode[instructionIndex].line_number);
	return false;
}

// It converts in place the data to the specify datatype in datatypeTarget
bool VirtualMachine::Convert(VirtualMachine::Memory& input_output, int datatypeTarget, wchar_t* caption)
{
	if (input_output.datatype == datatypeTarget) return true;


	if (datatypeTarget == LEX_DATATYPE_DOUBLE)
	{
		switch(input_output.datatype)
		{
		case LEX_DATATYPE_INTEGER:
			input_output.double_value =  input_output.int_value;
			input_output.datatype = LEX_DATATYPE_DOUBLE;
			//_____________ clean up
			input_output.int_value = 0;
			return true;
		}
	}
	else if (datatypeTarget == LEX_DATATYPE_MATRIX)
	{
		switch(input_output.datatype)
		{
		case LEX_DATATYPE_INTEGER:
			{
				valarray<double> x(1);
				x[0] = input_output.int_value;
				input_output.matrix_value.push_back(x);
				input_output.datatype = LEX_DATATYPE_MATRIX;
				//_____________ clean up
				input_output.int_value = 0;
			}
			return true;
		case LEX_DATATYPE_DOUBLE:
			{
				valarray<double> x(1);
				x[0] = input_output.double_value;
				input_output.matrix_value.push_back(x);
				input_output.datatype = LEX_DATATYPE_MATRIX;
				//_____________ clean up
				input_output.double_value = 0.0;
			}
			return true;
		case LEX_DATATYPE_VECTOR:
			Sys::Convert::ToMatrix(input_output.vector_value, input_output.matrix_value);
			input_output.datatype = LEX_DATATYPE_MATRIX;
			//_____________ clean up
			input_output.vector_value.free();
			return true;
		}
	}
	else if (datatypeTarget == LEX_DATATYPE_VECTOR)
	{
		switch(input_output.datatype)
		{
		case LEX_DATATYPE_INTEGER:
			{
				input_output.vector_value.resize(1);
				input_output.vector_value[0] = input_output.int_value;
				input_output.datatype = LEX_DATATYPE_VECTOR;
				//_____________ clean up
				input_output.int_value = 0;
			}
			return true;
		case LEX_DATATYPE_DOUBLE:
			{
				input_output.vector_value.resize(1);
				input_output.vector_value[0] = input_output.double_value;
				input_output.datatype = LEX_DATATYPE_VECTOR;
				//_____________ clean up
				input_output.double_value = 0.0;
			}
			return true;
		}
	}
	else if (datatypeTarget == LEX_DATATYPE_COMPLEX)
	{
		switch(input_output.datatype)
		{
		case LEX_DATATYPE_INTEGER:
			{
				input_output.complex_value = input_output.int_value;
				input_output.datatype = LEX_DATATYPE_COMPLEX;
				//_____________ clean up
				input_output.int_value = 0;
			}
			return true;
		case LEX_DATATYPE_DOUBLE:
			{
				input_output.complex_value = input_output.double_value;
				input_output.datatype = LEX_DATATYPE_COMPLEX;
				//_____________ clean up
				input_output.double_value = 0.0;
			}
			return true;
		}
	}
	else if (datatypeTarget == LEX_DATATYPE_COMPLEX_VECTOR)
	{
		switch(input_output.datatype)
		{
		case LEX_DATATYPE_INTEGER:
			{
				input_output.vectorC_value.resize(1);
				input_output.vectorC_value[0] = input_output.int_value;
				input_output.datatype = LEX_DATATYPE_COMPLEX_VECTOR;
				//_____________ clean up
				input_output.int_value = 0;
			}
			return true;
		case LEX_DATATYPE_DOUBLE:
			{
				input_output.vectorC_value.resize(1);
				input_output.vectorC_value[0] = input_output.double_value;
				input_output.datatype = LEX_DATATYPE_COMPLEX_VECTOR;
				//_____________ clean up
				input_output.double_value = 0.0;
			}
			return true;
		case LEX_DATATYPE_COMPLEX:
			{
				input_output.vectorC_value.resize(1);
				input_output.vectorC_value[0] = input_output.complex_value;
				input_output.datatype = LEX_DATATYPE_COMPLEX_VECTOR;
				//_____________ clean up
				input_output.complex_value = 0.0;
			}
			return true;
		}
	}
	else if (datatypeTarget == LEX_DATATYPE_COMPLEX_MATRIX)
	{
		switch(input_output.datatype)
		{
		case LEX_DATATYPE_INTEGER:
			{
				valarray<complex <double> > x(1);
				x[0] = input_output.int_value;
				input_output.matrixC_value.push_back(x);
				input_output.datatype = LEX_DATATYPE_COMPLEX_MATRIX;
				//_____________ clean up
				input_output.int_value = 0;
			}
			return true;
		case LEX_DATATYPE_DOUBLE:
			{
				valarray<complex <double> > x(1);
				x[0] = input_output.double_value;
				input_output.matrixC_value.push_back(x);
				input_output.datatype = LEX_DATATYPE_COMPLEX_MATRIX;
				//_____________ clean up
				input_output.double_value = 0.0;
			}
			return true;
		case LEX_DATATYPE_COMPLEX:
			{
				valarray<complex <double> > x(1);
				x[0] = input_output.complex_value;
				input_output.matrixC_value.push_back(x);
				input_output.datatype = LEX_DATATYPE_COMPLEX_MATRIX;
				//_____________ clean up
				input_output.complex_value = 0.0;
			}
			return true;
		case LEX_DATATYPE_VECTOR:
			{
				const int size = input_output.vector_value.size();
				valarray<complex <double> > x(size);
				if (size>0)
				{
					for(int i=0; i< size; i++)
						x = input_output.vector_value[i];
				}
				input_output.matrixC_value.push_back(x);
				input_output.datatype = LEX_DATATYPE_COMPLEX_MATRIX;
				//_____________ clean up
				input_output.vector_value.free();
			}
			return true;
		case LEX_DATATYPE_COMPLEX_VECTOR:
			input_output.matrixC_value.push_back(input_output.vectorC_value);
			input_output.datatype = LEX_DATATYPE_COMPLEX_MATRIX;
			//_____________ clean up
			input_output.vectorC_value.free();
			return true;
		
		}
	}

	ReportConversionError(input_output.datatype, datatypeTarget, caption);
	input_output.datatype = ERROR_INVALID_VALUE;
	return false;
}

void VirtualMachine::ReportConversionError(int datatypeFrom, int datatypeTo, wchar_t* caption)
{
	wchar_t * descrFrom = Cpl::LexicalAnalyzer::GetTokenText(datatypeFrom);
	wchar_t * descrTo = Cpl::LexicalAnalyzer::GetTokenText(datatypeTo);
	if (caption == NULL)
	{
		_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d cannot convert from %s to %s", 
			machineCode[instructionIndex].line_number, descrFrom, descrTo);
	}
	else
	{
		_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d parameter %s cannot be converted from %s to %s", 
			machineCode[instructionIndex].line_number, caption, descrFrom, descrTo);
	}
}

int VirtualMachine::GetResultingDatatype(int datatype1, int datatype2, int operation)
{
	if (datatype1 == datatype2) return datatype1;

	//___________________________________ Matrix * vector  (the number of columns of the matrix is equal to the number of rows of the vector)
	if (datatype1 == LEX_DATATYPE_MATRIX && datatype2 == LEX_DATATYPE_VECTOR && operation==LEX_ASTERISK)
	{
		return LEX_DATATYPE_VECTOR;
	}

	//___________________________________ vector * Matrix  (the matrix must have only one row)
	if (datatype1 == LEX_DATATYPE_VECTOR && datatype2 == LEX_DATATYPE_MATRIX && operation==LEX_ASTERISK)
	{
		return LEX_DATATYPE_MATRIX;
	}

	//___________________________________ MatrixC * vectorC  (the number of columns of the matrix is equal to the number of rows of the vector)
	if (datatype1 == LEX_DATATYPE_COMPLEX_MATRIX && datatype2 == LEX_DATATYPE_COMPLEX_VECTOR && operation==LEX_ASTERISK)
	{
		return LEX_DATATYPE_COMPLEX_VECTOR;
	}

	//___________________________________ vectorC * MatrixC  (the matrix must have only one row)
	if (datatype1 == LEX_DATATYPE_COMPLEX_VECTOR && datatype2 == LEX_DATATYPE_COMPLEX_MATRIX && operation==LEX_ASTERISK)
	{
		return LEX_DATATYPE_COMPLEX_MATRIX;
	}

	//_________________________________ be sure "a" is the smaller data type
	int a, b;
	if (datatype1<datatype2)
	{
		a = datatype1;
		b = datatype2;
	}
	else
	{
		a = datatype2;
		b = datatype1;
	}

	switch(b)
	{
	case LEX_DATATYPE_BOOL:
		return LEX_DATATYPE_BOOL;
	case LEX_DATATYPE_INTEGER:
		switch(a)
		{
		case LEX_DATATYPE_BOOL:
			return ERROR_INVALID_VALUE;
		case LEX_DATATYPE_INTEGER:
			return LEX_DATATYPE_INTEGER;
		}
		break;
	case LEX_DATATYPE_DOUBLE:
		switch(a)
		{
		case LEX_DATATYPE_BOOL:
			return ERROR_INVALID_VALUE;
		case LEX_DATATYPE_INTEGER:
		case LEX_DATATYPE_DOUBLE:
			return LEX_DATATYPE_DOUBLE;
		}
		break;
	case LEX_DATATYPE_VECTOR:
		switch(a)
		{
		case LEX_DATATYPE_BOOL:
			return ERROR_INVALID_VALUE;
		case LEX_DATATYPE_INTEGER:
		case LEX_DATATYPE_DOUBLE:
		case LEX_DATATYPE_VECTOR:
			return LEX_DATATYPE_VECTOR;
		}
		break;
	case LEX_DATATYPE_MATRIX:
		switch(a)
		{
		case LEX_DATATYPE_BOOL:
			return ERROR_INVALID_VALUE;
		case LEX_DATATYPE_INTEGER:
		case LEX_DATATYPE_DOUBLE:
		case LEX_DATATYPE_VECTOR:
		case LEX_DATATYPE_MATRIX:
			return LEX_DATATYPE_MATRIX;
		}
		break;
	case LEX_DATATYPE_COMPLEX:
		switch(a)
		{
		case LEX_DATATYPE_BOOL:
			return ERROR_INVALID_VALUE;
		case LEX_DATATYPE_INTEGER:
			return LEX_DATATYPE_COMPLEX;
		case LEX_DATATYPE_DOUBLE:
			return LEX_DATATYPE_COMPLEX;
		case LEX_DATATYPE_VECTOR:
			return LEX_DATATYPE_COMPLEX_VECTOR;
		case LEX_DATATYPE_MATRIX:
			return LEX_DATATYPE_COMPLEX_MATRIX;
		case LEX_DATATYPE_COMPLEX:
			return LEX_DATATYPE_COMPLEX;
		}
		break;
	case LEX_DATATYPE_COMPLEX_VECTOR:
		switch(a)
		{
		case LEX_DATATYPE_BOOL:
			return ERROR_INVALID_VALUE;
		case LEX_DATATYPE_INTEGER:
		case LEX_DATATYPE_DOUBLE:
		case LEX_DATATYPE_VECTOR:
			return LEX_DATATYPE_COMPLEX_VECTOR;
		case LEX_DATATYPE_MATRIX:
			return LEX_DATATYPE_COMPLEX_MATRIX;
		case LEX_DATATYPE_COMPLEX:
			return LEX_DATATYPE_COMPLEX_VECTOR;
		case LEX_DATATYPE_COMPLEX_VECTOR:
			return LEX_DATATYPE_COMPLEX_VECTOR;
		}
		break;
	case LEX_DATATYPE_COMPLEX_MATRIX:
		switch(a)
		{
		case LEX_DATATYPE_BOOL:
			return ERROR_INVALID_VALUE;
		case LEX_DATATYPE_INTEGER:
		case LEX_DATATYPE_DOUBLE:
		case LEX_DATATYPE_VECTOR:
		case LEX_DATATYPE_MATRIX:
		case LEX_DATATYPE_COMPLEX:
		case LEX_DATATYPE_COMPLEX_VECTOR:
			return LEX_DATATYPE_COMPLEX_MATRIX;
		}
		break;
	}
	return ERROR_INVALID_VALUE;
}

} //____________________________________________________ namespace Cpl::End

namespace Sql //________________________________________ namespace Sql::Ini
{

//_____________________________________________________________________ LexicalAnalyzer
LexicalAnalyzer::LexicalAnalyzer(void)
{
}

LexicalAnalyzer::~LexicalAnalyzer(void)
{
}

bool LexicalAnalyzer::ProcessComments(wchar_t& c, wchar_t& prev, Cpl::LexicalAnalyzer::Token& token, int& i)
{
	if (c != '-') return false;

	c = inputString[index++];
	if (c=='-')  //_______________________ single line comments
	{
		while(c!='\n' && c!='\0')
		{
			c = inputString[index++];
		}
	}
	else
	{
		//_____________________________________ It is not a comment
		index-=2;
		c = inputString[index++];
	}
	return false;
}

bool LexicalAnalyzer::ProcessKeywords(Cpl::LexicalAnalyzer::Token& token)
{
	if (CheckTokenNoCase(token, LEX_SQLTYPE_BIT, LEX_SQLTYPE_TIMESTAMP)) return true; //SQL DATATYPE
	if (CheckTokenNoCase(token, LEX_SQL_CREATE, LEX_SQL_ALTER)) return true; //SQL MAIN
	if (CheckTokenNoCase(token, LEX_SQL_TABLE, LEX_SQL_CURSOR)) return true; //SQL OBJECTS
	if (CheckTokenNoCase(token, LEX_SQL_WHERE, LEX_SQL_NULL)) return true; //SQL KEYWORDS
	if (CheckTokenNoCase(token, LEX_SQL_ABS, LEX_SQL_DB_NAME)) return true; //SQL FUNCTIONS
	return false;
}

bool LexicalAnalyzer::GetTokens(const wchar_t* inputString, vector<Cpl::LexicalAnalyzer::Token>& output)
{
	Sql::LexicalAnalyzer lex;
	Cpl::LexicalAnalyzer::Token token;
	if (lex.Create(inputString) == false) return false;
	do
	{
		lex.GetNextToken(token);
		output.push_back(token);
	}
	while (token.type != LEX_END_OF_FILE);// && token.type != LEX_ERROR);
	return true;
}


//_____________________________________________________________________ Column
Column::Column()
{
	name[0] = '\0';
	isPK = false;
	allowsNull = false;
	check[0]  = '\0';
	type = LEX_SQLTYPE_NVARCHAR;
	refTable[0]  = '\0';
	refPK[0]  = '\0';
	table_name[0] = '\0';
	size = 0;
}

Column::~Column()
{
}

//_____________________________________________________________________ Table
Table::Table()
{
	name[0] = '\0';
	selected = false;
}

Table::~Table()
{
}

//_____________________________________________________________________ Compiler
Compiler::Compiler()
{
}

Compiler::~Compiler()
{
}

bool Compiler::Compile(const wchar_t* inputString, vector<Sql::Table>& output)
{
	output.clear();
	if (lex.Create(inputString)==false) return false;
	//
	lex.GetNextToken(lookahead);
	if (lookahead.type == LEX_END_OF_FILE) return false;
	try
	{
		while(lookahead.type != LEX_END_OF_FILE)
		{
			Block_SingleLine(output);
		}
	}
	catch(int x)
	{
		x++;
		return false;
	}
	return true;
}

void Compiler::Next(vector<Sql::Table>& output)
{
	//lex.GetNextToken(lookahead);
	//if (lookahead.type == LEX_END_OF_FILE) return false;

	lex.GetNextToken(lookahead);
	if (lex.IsError(lookahead)) AddError(output, lookahead, ERROR_LEX, 0);
}

void Compiler::Match(vector<Sql::Table>& output, int type)
{
	if (lookahead.type != type ) AddError(output, lookahead, ERROR_SYNTAX, type);	
	Next(output);
}

void Compiler::Block_SingleLine(vector<Sql::Table>& output)
{
	switch(lookahead.type)
	{
	case LEX_SQL_CREATE:
		Create(output);
		break;
	case LEX_SQL_INSERT:
		Insert(output);
		break;
	case LEX_SQL_UPDATE:
		Update(output);
		break;
	case  LEX_SQL_SELECT:
		Select(output);
		break;
	case LEX_SQL_DELETE:
		Delete(output);
		break;
	case LEX_SQL_DROP:
		Drop(output);
		break;
	case LEX_SQL_GRANT:
		Grant(output);
		break;
	case LEX_SQL_REVOKE:
		Revoke(output);
		break;
	case LEX_SQL_ROLLBACK:
		Rollback(output);
		break;
	case LEX_SQL_SAVEPOINT:
		SavePoint(output);
		break;
	case LEX_SQL_USE:
		Use(output);
		break;
	case LEX_SQL_ALTER:
		Alter(output);
		break;
	default:
		Next(output);
		//AddError(output, lookahead, ERROR_SYNTAX, ERROR_INVALID_VALUE);
	}
}

void Compiler::Create(vector<Sql::Table>& output)
{
	Next(output); // CREATE
	switch(lookahead.type)
	{
	case LEX_SQL_TABLE:
		Table(output);
		break;
	case LEX_SQL_VIEW:
		View(output);
		break;
	case LEX_SQL_TRIGGER:
		Trigger(output);
		break;
	case LEX_SQL_INDEX:
		Index(output);
		break;
	case LEX_SQL_PROCEDURE:
		Procedure(output);
		break;
	case LEX_SQL_DATABASE:
		Database(output);
		break;
	case LEX_SQL_CURSOR:
		Cursor(output);
		break;
	default:
		Next(output);
		//AddError(output, lookahead, ERROR_SYNTAX, ERROR_INVALID_VALUE);
	}
}

void Compiler::Insert(vector<Sql::Table>& output)
{
	Next(output);
}

void Compiler::Update(vector<Sql::Table>& output)
{
	Next(output);
}

void Compiler::Select(vector<Sql::Table>& output)
{
	Next(output);
}

void Compiler::Delete(vector<Sql::Table>& output)
{
	Next(output);
}

void Compiler::Drop(vector<Sql::Table>& output)
{
	Next(output);
}

void Compiler::Grant(vector<Sql::Table>& output)
{
	Next(output);
}

void Compiler::Revoke(vector<Sql::Table>& output)
{
	Next(output);
}

void Compiler::Rollback(vector<Sql::Table>& output)
{
	Next(output);
}

void Compiler::SavePoint(vector<Sql::Table>& output)
{
	Next(output);
}

void Compiler::Use(vector<Sql::Table>& output)
{
	Next(output);
}

void Compiler::Alter(vector<Sql::Table>& output)
{
	Next(output);
}

void Compiler::Table(vector<Sql::Table>& output)
{
	Next(output); // TABLE
	if (lookahead.type == LEX_SQL_DBO)
	{
		Next(output);
		Match(output, LEX_DOT);
	}
	if (lookahead.type != LEX_ID) AddError(output, lookahead, 0, 0);
	//_________________________ TABLE NAME
	Sql::Table table;
	_snwprintf_s(table.name, SQL_NAME_MAX, _TRUNCATE, L"%s", lookahead.string_value);
	output.push_back(table);
	Next(output); // TABLE NAME
	Match(output, LEX_LEFT_PARENTHESIS);
	Columns(output);
}

void Compiler::Columns(vector<Sql::Table>& output)
{
	Column(output);
	while (lookahead.type == LEX_COMMA)
	{
		Next(output); // COMMA
		Column(output);
	}
	Match(output, LEX_RIGHT_PARENTHESIS);
}

void Compiler::Column(vector<Sql::Table>& output)
{
	if (lookahead.type == LEX_SQL_PRIMARY)
	{
		Next(output); //PRIMARY
		Match(output, LEX_SQL_KEY);
		Match(output, LEX_LEFT_PARENTHESIS);
		while(lookahead.type != LEX_RIGHT_PARENTHESIS)
		{
			if (lookahead.type == LEX_ID)
			{
				const int len = output.back().column.size();
				for(int i = 0; i < len; i++)
				{
					if (wcscmp(lookahead.string_value, output.back().column[i].name) == 0)
					{
						output.back().column[i].isPK = true;
					}
				}
			}
			Next(output);
		}
		Next(output); // )
		return;
	}
	Sql::Column column;
	//___________________________________________________________ table_name
	_snwprintf_s(column.table_name, SQL_NAME_MAX, _TRUNCATE, L"%s", output.back().name);
	//___________________________________________________________ Column Name
	if (lookahead.type != LEX_ID) AddError(output, lookahead, 0, 0);
	_snwprintf_s(column.name, SQL_NAME_MAX, _TRUNCATE, L"%s", lookahead.string_value);
	Next(output); // Column name
	//___________________________________________________________ Data type
	if (IsDataType(lookahead) == false) AddError(output, lookahead, 0, 0);
	column.type = lookahead.type;
	Next(output); //Data type
	if (RequiresSize(column.type) == true)
	{
		if (column.type == LEX_SQLTYPE_CHAR)
		{
			if (lookahead.type == LEX_LEFT_PARENTHESIS)
			{
				Match(output, LEX_LEFT_PARENTHESIS);
				if (lookahead.type == LEX_CONST_VALUE_INTEGER)
				{
					column.size = lookahead.int_value;
				}
				Match(output, LEX_CONST_VALUE_INTEGER);
				Match(output, LEX_RIGHT_PARENTHESIS);
			}
		}
		else
		{
			Match(output, LEX_LEFT_PARENTHESIS);
			if (lookahead.type == LEX_CONST_VALUE_INTEGER)
			{
				column.size = lookahead.int_value;
			}
			Match(output, LEX_CONST_VALUE_INTEGER);
			Match(output, LEX_RIGHT_PARENTHESIS);
		}
	}
	else if (RequiresDoubleSize(column.type) == true)
	{
		Match(output, LEX_LEFT_PARENTHESIS);
		Match(output, LEX_CONST_VALUE_INTEGER);
		Match(output, LEX_COMMA);
		Match(output, LEX_CONST_VALUE_INTEGER);
		Match(output, LEX_RIGHT_PARENTHESIS);
	}
	output.back().column.push_back(column);
	//___________________________________________________________  Column Param
	while(IsColumnParam(lookahead) == true)
	{
		switch(lookahead.type)
		{
		case LEX_SQL_CONSTRAINT:
			Constraint(output);
			break;
		case LEX_SQL_REFERENCES:
			References(output);
			break;
		case LEX_SQL_PRIMARY:
			Primary(output);
			break;
		case LEX_SQL_NOT:
			Not(output);
			break;
		case  LEX_SQL_NULL:
			Null(output);
			break;
		case LEX_SQL_CHECK:
			Check(output);
			break;
		case LEX_SQL_IDENTITY:
			Identity(output);
			break;
		case LEX_SQL_AUTO_INCREMENT:
			Auto_Increment(output);
			break;
		case  LEX_SQL_ON:
			On(output);
			break;
		case  LEX_SQL_UNIQUE:
			Unique(output);
			break;
		case  LEX_SQL_DEFAULT:
			Default(output);
			break;
		default:
			Next(output);
		}
	}
}

void Compiler::Constraint(vector<Sql::Table>& output)
{
	Next(output); // CONSTRAINT
	Match(output, LEX_ID);
}

void Compiler::References(vector<Sql::Table>& output)
{
	Next(output); // REFERENCES
	//_____________________________________________ REFERENCES table
	if (lookahead.type != LEX_ID) AddError(output, lookahead, 0, 0);
	_snwprintf_s(output.back().column.back().refTable, SQL_NAME_MAX, _TRUNCATE, L"%s", lookahead.string_value);
	Match(output, LEX_ID);
	Match(output, LEX_LEFT_PARENTHESIS);
	//_____________________________________________ REFERENCES column
	if (lookahead.type != LEX_ID) AddError(output, lookahead, 0, 0);
	_snwprintf_s(output.back().column.back().refPK, SQL_NAME_MAX, _TRUNCATE, L"%s", lookahead.string_value);
	Match(output, LEX_ID);
	Match(output, LEX_RIGHT_PARENTHESIS);
}

void Compiler::Primary(vector<Sql::Table>& output)
{
	Next(output); // PRIMARY
	Match(output, LEX_SQL_KEY);
	output.back().column.back().isPK = true;
}

void Compiler::Not(vector<Sql::Table>& output)
{
	Next(output); // NOT
	Match(output, LEX_SQL_NULL);
	output.back().column.back().allowsNull = false;
}

void Compiler::Null(vector<Sql::Table>& output)
{
	Next(output); // NULL
	output.back().column.back().allowsNull = true;
}

void Compiler::Default(vector<Sql::Table>& output)
{
	Next(output); // DEFAULT
	if (lookahead.type == LEX_CONST_VALUE_INTEGER)
	{
		Next(output); // INTEGER
	}
	else if (lookahead.type == LEX_CONST_VALUE_DOUBLE)
	{
		Next(output); // DOUBLE
	}
	else if (lookahead.type == LEX_CONST_VALUE_STRING)
	{
		Next(output); // STRING
	}
	else if (lookahead.type == LEX_SQL_GETDATE)
	{
		Next(output); // GETDATE
		Match(output, LEX_LEFT_PARENTHESIS);
		Match(output, LEX_RIGHT_PARENTHESIS);
	}
}

void Compiler::Check(vector<Sql::Table>& output)
{
	Next(output); // CHECK
	Match(output, LEX_LEFT_PARENTHESIS);
	while(lookahead.type != LEX_RIGHT_PARENTHESIS)
	{
		Next(output);
	}
	Next(output); // )
}

void Compiler::Identity(vector<Sql::Table>& output)
{
	Next(output);
}

void Compiler::Auto_Increment(vector<Sql::Table>& output)
{
	Next(output);
}

void Compiler::On(vector<Sql::Table>& output)
{
	Next(output); // ON
	Match(output, LEX_SQL_DELETE);
	Match(output, LEX_SQL_CASCADE);
}

void Compiler::Unique(vector<Sql::Table>& output)
{
	Next(output); // Unique
}

bool Compiler::IsColumnParam(Cpl::LexicalAnalyzer::Token& token)
{
	if (token.type == LEX_SQL_CONSTRAINT) return true;
	if (token.type == LEX_SQL_REFERENCES) return true;
	if (token.type == LEX_SQL_PRIMARY) return true;
	if (token.type == LEX_SQL_NOT) return true;
	if (token.type == LEX_SQL_NULL) return true;
	if (token.type == LEX_SQL_CHECK) return true;
	if (token.type == LEX_SQL_IDENTITY) return true;
	if (token.type == LEX_SQL_AUTO_INCREMENT) return true;
	if (token.type == LEX_SQL_ON) return true;
	if (token.type == LEX_SQL_UNIQUE) return true;
	if (token.type == LEX_SQL_DEFAULT) return true;
	return false;
}

bool Compiler::RequiresSize(int datatype)
{
	if (datatype == LEX_SQLTYPE_VARCHAR2) return true;
	if (datatype == LEX_SQLTYPE_VARCHAR) return true;
	if (datatype == LEX_SQLTYPE_CHAR) return true;
	if (datatype == LEX_SQLTYPE_TEXT) return true;
	if (datatype == LEX_SQLTYPE_NVARCHAR) return true;
	if (datatype == LEX_SQLTYPE_NCHAR) return true;
	if (datatype == LEX_SQLTYPE_NTEXT) return true;
	return false;
}

bool Compiler::RequiresDoubleSize(int datatype)
{
	if (datatype == LEX_SQLTYPE_NUMERIC) return true;
	if (datatype == LEX_SQLTYPE_DECIMAL) return true;
	return false;
}

bool Compiler::IsDataType(Cpl::LexicalAnalyzer::Token& token)
{
	if (token.type < LEX_SQLTYPE_BIT) return false;
	if (LEX_SQLTYPE_TIMESTAMP < token.type) return false;
	return true;
}

void Compiler::View(vector<Sql::Table>& output)
{
	Next(output);
}

void Compiler::Trigger(vector<Sql::Table>& output)
{
	Next(output);
}

void Compiler::Index(vector<Sql::Table>& output)
{
	Next(output);
}

void Compiler::Procedure(vector<Sql::Table>& output)
{
	Next(output);
}

void Compiler::Database(vector<Sql::Table>& output)
{
	Next(output);
}

void Compiler::Cursor(vector<Sql::Table>& output)
{
	Next(output);
}

void Compiler::AddError(vector<Sql::Table>& output, Cpl::LexicalAnalyzer::Token& token, int error_type, int correct_token_type)
{
	////___________________________  Create IntelliSense
	//IntelliSenseFuncInfo isfi;
	//while (sisfi.empty() == false)
	//{
	//	isfi = sisfi.top();
	//	sisfi.pop();
	//	ListMethods(isfi.func_id, isfi.datatype, NULL, isfi.parameterIndex);
	//}
	////
	//Instruction inst;
	//inst.type = VM_ERROR;
	//inst.subtype = error_type;
	//inst.line_number= token.line_number;
	//inst.int_value = 0;
	//inst.double_value = 0.0;
	//wchar_t * descr = NULL;
	//switch(error_type)
	//{
	//case ERROR_SYNTAX:
	//	descr = LexicalAnalyzer::GetTokenText(correct_token_type);
	//	if (descr)
	//	{			
	//		_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"Line %d syntax error, missing %s", inst.line_number, descr);
	//	}
	//	else
	//	{
	//		_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"Line %d syntax error", inst.line_number);
	//	}
	//	break;
	//case ERROR_VARIABLE_ALLREADY_DEFINED:
	//	_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"Line %d the variable has already been defined", inst.line_number);
	//	break;
	//case ERROR_VARIABLE_NOEXISTS:
	//	_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"Line %d the variable does not exist", inst.line_number);
	//	break;
	//case ERROR_INVALID_OBJECT_FUNC:
	//	_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"Line %d the object does not support this method", inst.line_number);
	//	break;
	//case ERROR_VARIABLE_UNINIT:
	//	_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"Line %d the variable has not been initialized", inst.line_number);
	//	break;
	//case ERROR_INVALID_PARAM:
	//	_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"Line %d the function parameter is invalid", inst.line_number);
	//	break;
	//case ERROR_MISSING_TOKEN:
	//	_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"Line %d syntax error, missing terminator", inst.line_number);
	//	break;
	//case ERROR_INCOMPLETE_COMMAND:
	//	_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"Line %d the command is incomplete", inst.line_number);
	//	break;
	//case ERROR_MISSING_VARIABLE:
	//	_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"Line %d a variable is missing", inst.line_number);
	//	break;
	//case ERROR_LEX:
	//	{
	//		if (token.type == LEX_ERROR_UNRECOGNIZED_CHAR)
	//		{
	//			_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"Line %d unrecognized character %s", inst.line_number, token.string_value);
	//		}
	//		else if (token.type == LEX_ERROR_STRING_TOO_LONG)
	//		{
	//			_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"Line %d string too long %s", inst.line_number, token.string_value);
	//		}
	//		else if (token.type == LEX_ERROR_MISSING_COMMENT_TERMINATOR)
	//		{
	//			_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"Line %d missing comment terminator", inst.line_number);
	//		}
	//		else if (token.type == LEX_ERROR_MISSING_STRING_TERMINATOR)
	//		{
	//			_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"Line %d missing string terminator %s", inst.line_number, token.string_value);
	//		}
	//	}
	//	break;
	//}
	//machineCode.push_back(inst);
	Next(output);
	//throw 0;
}


//_____________________________________________________________________ Tools
Tools::Tools()
{
}

Tools::~Tools()
{
}

bool Tools::ImportFromText(const wchar_t* inputSqlText, vector<Sql::Table>& output)
{
	output.clear();
	Sql::Compiler compiler;
	if (compiler.Compile(inputSqlText, output) == false) return false;
	return true;
}

bool Tools::ImportFromFile(const wchar_t* fileName, vector<Sql::Table>& output)
{
	wstring text;
	if (Sys::FileAssistant::TextLoad(fileName, text) == false) return false;
	if (Sql::Tools::ImportFromText(text.c_str(), output) == false) return false;
	return true;
}

//_____________________________________________________________________ StringBuilder
StringBuilder::StringBuilder(const wchar_t * table_name, const wchar_t * primary_key_name, int primary_key_value)
{
	this->primary_key_name = primary_key_name;
	this->primary_key_value = primary_key_value;
	query.reserve(512);
	if (primary_key_value == -1)
	{
		sqlCommand.reserve(256);
		sqlValues.reserve(256);
		sqlCommand = L"INSERT INTO ";
		sqlCommand += table_name;
		sqlCommand += L" (";
		sqlValues = L" VALUES(";
	}
	else
	{
		sqlCommand.reserve(512);
		sqlCommand = L"UPDATE ";
		sqlCommand += table_name;
		sqlCommand += L" SET ";
	}
	isFirstTime = true;
}

StringBuilder::~StringBuilder()
{
}

const wchar_t* StringBuilder::GetString()
{
	query = sqlCommand;
	if (primary_key_value == -1)
	{
		query += L") ";
		query += sqlValues;
		query += L");";		
	}
	else
	{
		query += L" WHERE ";
		query += primary_key_name;
		wchar_t text[32];
		_snwprintf_s(text, 32, _TRUNCATE, L"='%d';", primary_key_value);
		query += text;
	}
	return query.c_str();
}

int StringBuilder::BindInt(const wchar_t* column_name, int value)
{
	wchar_t text[32];
	if (isFirstTime == false) sqlCommand += L", ";
	sqlCommand += column_name;
	if (primary_key_value == -1)
	{
		if (isFirstTime == false)
		{
			_snwprintf_s(text, 32, _TRUNCATE, L", '%d'", value);
		}
		else
		{
			_snwprintf_s(text, 32, _TRUNCATE, L"'%d'", value);
		}
		sqlValues += text;
	}
	else
	{
		_snwprintf_s(text, 32, _TRUNCATE, L"='%d'", value);
		sqlCommand += text;
	}
	isFirstTime = false;
	return value;
}

double StringBuilder::BindDouble(const wchar_t* column_name, double value)
{
	wchar_t text[32];
	if (isFirstTime == false) sqlCommand += L", ";
	sqlCommand += column_name;
	if (primary_key_value == -1)
	{	
		if (isFirstTime == false)
		{
			_snwprintf_s(text, 32, _TRUNCATE, L", '%g'", value);
		}
		else
		{
			_snwprintf_s(text, 32, _TRUNCATE, L"'%g'", value);
		}
		sqlValues += text;
	}
	else
	{
		_snwprintf_s(text, 32, _TRUNCATE, L"='%g'", value);
		sqlCommand += text;
	}
	isFirstTime = false;
	return value;
}

bool StringBuilder::BindBool(const wchar_t* column_name, bool value)
{
	int nvalue = value == true ? 1 : 0;
	wchar_t text[32];
	if (isFirstTime == false) sqlCommand += L", ";
	sqlCommand += column_name;
	if (primary_key_value == -1)
	{
		if (isFirstTime == false)
		{
			_snwprintf_s(text, 32, _TRUNCATE, L", '%d'", nvalue);
		}
		else
		{
			_snwprintf_s(text, 32, _TRUNCATE, L"'%d'", nvalue);
		}
		sqlValues += text;
	}
	else
	{
		_snwprintf_s(text, 32, _TRUNCATE, L"='%d'", nvalue);
		sqlCommand += text;
	}
	isFirstTime = false;
	return value;
}

// format day: d, dd, ddd  or dddd
// format month: M, MM, MMM or MMMM
// format year: y, yy, yyy or yyyy
// format:  L"ddd',' MMM dd yyyy"
Sys::Time StringBuilder::BindDateTime(const wchar_t* column_name, Sys::Time& value, const wchar_t* format)
{
	wstring text;
	Sys::Convert::DateToString(value, (wchar_t*)format, text);
	if (isFirstTime == false) sqlCommand += L", ";
	sqlCommand += column_name;
	if (primary_key_value == -1)
	{	
		if (isFirstTime == false)
		{
			sqlValues += L", '";
		}
		else
		{
			sqlValues += L"'";
		}
		sqlValues += text;
		sqlValues += L"'";
	}
	else
	{
		sqlCommand += L"='";
		sqlCommand += text;
		sqlCommand += L"'";
	}
	isFirstTime = false;
	return value;
}

const wchar_t* StringBuilder::BindString(const wchar_t* column_name, const wstring& value)
{
	return BindString(column_name, value.c_str());
}

const wchar_t* StringBuilder::BindString(const wchar_t* column_name, const wchar_t* value)
{
	if (isFirstTime == false) sqlCommand += L", ";
	sqlCommand += column_name;
	if (primary_key_value == -1)
	{	
		if (isFirstTime == false)
		{
			sqlValues += L", '";
		}
		else
		{
			sqlValues += L"'";
		}
		sqlValues += value;
		sqlValues += L"'";
	}
	else
	{
		sqlCommand += L"='";
		sqlCommand += value;
		sqlCommand += L"'";
	}
	isFirstTime = false;
	return value;
}

LPARAM StringBuilder::Bind(const wchar_t* column_name, Sql::ISelectInt& control)
{
	control.SqlUpdate(false);
	const LPARAM value = control.SqlGetInt();
	BindInt(column_name, (int)value);
	return value;
}

bool StringBuilder::Bind(const wchar_t* column_name, Sql::ISelectBool& control)
{
	control.SqlUpdate(false);
	const bool isChecked = control.SqlGetBool();
	BindBool(column_name, isChecked);
	return isChecked;
}

// format day: d, dd, ddd  or dddd
// format month: M, MM, MMM or MMMM
// format year: y, yy, yyy or yyyy
// format:  L"ddd',' MMM dd yyyy"
Sys::Time StringBuilder::Bind(const wchar_t* column_name, Sql::ISelectTime& control, const wchar_t* format)
{
	control.SqlUpdate(false);
	//Sys::Time systime;
	//::SendMessage(dateView, (UINT) MCM_GETCURSEL, (WPARAM)0, (LPARAM)&systime);
	BindDateTime(column_name, control.SqlGetSysTime(), format);
	return control.SqlGetSysTime();
}

const wchar_t* StringBuilder::Bind(const wchar_t* column_name, Sql::ISelectString& control)
{
	control.SqlUpdate(false);
	BindString(column_name, control.SqlGetString());
	return control.SqlGetString().c_str();
}

//____________________________________________________ SqlException
SqlException::SqlException(Sql::SqlExceptInfo& exceptInfo, const wchar_t* statement, const wchar_t* funcName)
{
	description[0]='\0';
	const wchar_t * info = L"\r\n\r\nstatement: ";
	const wchar_t *temp = L"The provider did not send an error description";
	this->retcode = exceptInfo.retcode;
	if (retcode==SQL_SUCCESS) return;
	if (retcode==SQL_SUCCESS_WITH_INFO) return;
	if (retcode==SQL_NO_DATA)
	{
		if (statement==NULL) statement = L" ";
		_snwprintf_s(description, WINSQL_EXCEPT_MAX, _TRUNCATE, L"%s%s%s", temp, (wchar_t*)info, (wchar_t*)statement);
		return;
	}
	if (retcode!=SQL_ERROR) return;

	wchar_t szSqlState[10];
	SDWORD sdError=0;
	SWORD swSize;
	if (statement==NULL)
	{
		::SQLError(exceptInfo.henv, exceptInfo.hdbc, exceptInfo.hstmt, (SQLWCHAR*)szSqlState, &sdError,
			(SQLWCHAR*)description, SQL_MAX_MESSAGE_LENGTH, &swSize);
		description[SQL_MAX_MESSAGE_LENGTH-1]='\0';
	}
	else
	{
		wchar_t errorDescr[SQL_MAX_MESSAGE_LENGTH];
		::SQLError(exceptInfo.henv, exceptInfo.hdbc, exceptInfo.hstmt, (SQLWCHAR*)szSqlState, &sdError,
			(SQLWCHAR*)errorDescr, SQL_MAX_MESSAGE_LENGTH, &swSize);
		errorDescr[SQL_MAX_MESSAGE_LENGTH-1]='\0';
		_snwprintf_s(description, WINSQL_EXCEPT_MAX, _TRUNCATE, L"%s%s%s", errorDescr, (wchar_t*)info, (wchar_t*)statement);
		description[WINSQL_EXCEPT_MAX-1]='\0';
	}
}

SqlException::SqlException(const SqlException& init)
{
	this->retcode = init.retcode;
	::memcpy(this->description, init.description, WINSQL_EXCEPT_MAX*sizeof(wchar_t));
}

SqlException::~SqlException(void)
{
}

wchar_t* SqlException::GetDescription(void)
{
	return description;
}

//_____________________________________________________________________ SqlConnection
SqlConnection::SqlConnection()
{
	henv=SQL_NULL_HENV;
	hdbc=SQL_NULL_HDBC;
	hstmt = SQL_NULL_HSTMT;
	bConnected = false;
	for(int i = 0; i<SQL_BINDCOL_MAX; i++) iselect[i] = NULL;
}

SqlConnection::~SqlConnection()
{
	CloseSession();
}

void SqlConnection::BindClear()
{
	for(int i = 0; i<SQL_BINDCOL_MAX; i++) iselect[i] = NULL;
}

void SqlConnection::CloseSession()
{
	DestroyStatement();

	if (bConnected && (hdbc!=SQL_NULL_HDBC))
	{
		SQLDisconnect(hdbc);
		bConnected = false;
	}

	if (hdbc!=SQL_NULL_HDBC)   //Free connection
	{
		SQLFreeConnect(hdbc);
		hdbc = SQL_NULL_HDBC;
	}

	if (henv!=SQL_NULL_HENV)  //Free environment
	{
		SQLFreeEnv(henv);
		henv=SQL_NULL_HENV;
	}
}

//RETCODE retcode;
//if (Win::SqlConnection::IsOk(retcode= sql.OpenSession(hWnd, (SQLWCHAR*)"DRIVER={SQL Server};SERVER=ACID;DATABASE=directory;Trusted_Connection=yes")==false)
//	sql.DisplayError(hWnd, NULL, L"Open Session", retcode);
RETCODE SqlConnection::OpenSession(HWND hwnd, const wchar_t* connectionString) // It does not required ODBC
{
	Sql::SqlExceptInfo ei;

	if (connectionString==NULL) connectionString = (SQLWCHAR*)"DRIVER={SQL Server};";
	RETCODE retcode= SQL_INVALID_HANDLE;
	CloseSession();
	if (IsOk(retcode= SQLAllocEnv(&henv))==false) 
	{
		henv=SQL_NULL_HENV;
		ei.hdbc = this->hdbc;
		ei.henv = this->henv;
		ei.hstmt = this->hstmt;
		ei.retcode = retcode;
		throw Sql::SqlException(ei, NULL, L"SqlConnection::OpenSession - SQLAllocEnv");
	}
	if (IsOk(retcode= SQLAllocConnect(henv, &hdbc))==false)
	{
		hdbc = SQL_NULL_HDBC;
		if (henv!=SQL_NULL_HENV)  //Free environment
		{
			SQLFreeEnv(henv);
			henv=SQL_NULL_HENV;
		}
		ei.hdbc = this->hdbc;
		ei.henv = this->henv;
		ei.hstmt = this->hstmt;
		ei.retcode = retcode;
		throw Sql::SqlException(ei, NULL, L"SqlConnection::OpenSession - SQLAllocConnect");
	}
	wchar_t szOutConn[1024];
	SQLSMALLINT cbOutConn;
	retcode = ::SQLDriverConnect(hdbc, hwnd, (SQLWCHAR*)connectionString, SQL_NTS, (SQLWCHAR*)szOutConn,
		1024, &cbOutConn, SQL_DRIVER_COMPLETE);
	bConnected =IsOk(retcode);
	if (bConnected==false)
	{
		ei.hdbc = this->hdbc;
		ei.henv = this->henv;
		ei.hstmt = this->hstmt;
		ei.retcode = retcode;
		throw Sql::SqlException(ei, NULL, L"SqlConnection::OpenSession - SQLDriverConnect");
	}
	return retcode;
}

RETCODE SqlConnection::OpenSession(HWND hWnd, const wstring& connectionString) // It does not required ODBC
{
	return this->OpenSession(hWnd, connectionString.c_str());
}

//Win::SqlConnection sql;
//RETCODE retcode;
//
//if (Win::SqlConnection::IsOk(retcode=sql.OpenSession(L"directory", L"sa", L"123easy"))==false)
//	sql.DisplayError(hWnd, NULL, L"Open Session", retcode);
RETCODE SqlConnection::OpenSession(const wchar_t* dsn, const wchar_t* username, const wchar_t* password) //ODBC
{
	Sql::SqlExceptInfo ei;

	if (dsn==NULL) return SQL_INVALID_HANDLE;
	RETCODE retcode= SQL_INVALID_HANDLE;
	CloseSession();
	if (IsOk(retcode= SQLAllocEnv(&henv))==false) 
	{
		henv=SQL_NULL_HENV;
		ei.hdbc = this->hdbc;
		ei.henv = this->henv;
		ei.hstmt = this->hstmt;
		ei.retcode = retcode;
		throw Sql::SqlException(ei, NULL, L"SqlConnection::OpenSession - SQLAllocEnv");
	}
	if (IsOk(retcode= SQLAllocConnect(henv, &hdbc))==false)
	{
		hdbc = SQL_NULL_HDBC;
		if (henv!=SQL_NULL_HENV)  //Free environment
		{
			SQLFreeEnv(henv);
			henv=SQL_NULL_HENV;
		}
		henv=SQL_NULL_HENV;
		ei.hdbc = this->hdbc;
		ei.henv = this->henv;
		ei.hstmt = this->hstmt;
		ei.retcode = retcode;
		throw Sql::SqlException(ei, NULL, L"SqlConnection::OpenSession - SQLAllocConnect");
	}

	if  (username!=NULL && password!=NULL)
	{
		retcode = SQLConnect(hdbc, (SQLWCHAR*)dsn, SQL_NTS, (SQLWCHAR*)username, SQL_NTS,
			(SQLWCHAR*)password, SQL_NTS);
	}
	else if  (username!=NULL && password==NULL)
	{
		retcode = SQLConnect(hdbc, (SQLWCHAR*)dsn, SQL_NTS, (SQLWCHAR*)username, SQL_NTS,
			NULL, 0);
	}
	else
	{
		retcode = SQLConnect(hdbc, (SQLWCHAR*)dsn, SQL_NTS, NULL, 0, NULL, 0);
	}
	bConnected =IsOk(retcode);
	if (bConnected==false)
	{
		ei.hdbc = this->hdbc;
		ei.henv = this->henv;
		ei.hstmt = this->hstmt;
		ei.retcode = retcode;
		throw Sql::SqlException(ei, NULL, L"SqlConnection::OpenSession - SQLConnect");
	}
	return retcode;
}

RETCODE SqlConnection::OpenSession(const wstring& dsn, const wstring& username, const wstring& password) //ODBC
{
	return this->OpenSession(dsn.c_str(), username.c_str(), password.c_str());
}


RETCODE SqlConnection::BindParameter(SQLUSMALLINT ipar, SQLSMALLINT fParamType, SQLSMALLINT fCType, SQLSMALLINT fSqlType,
		SQLULEN cvColDef, SQLSMALLINT ibScale, SQLPOINTER rgbValue, SQLLEN cbValueMax, SQLLEN* pcvValue)
{
	RETCODE rt = ::SQLBindParameter(hstmt, ipar, fParamType, fCType, fSqlType, cvColDef, ibScale, rgbValue, cbValueMax, pcvValue);
	if (this->IsOk(rt)==false)
	{
		Sql::SqlExceptInfo ei;
		ei.hdbc = this->hdbc;
		ei.henv = this->henv;
		ei.hstmt = this->hstmt;
		ei.retcode = rt;
		throw Sql::SqlException(ei, NULL, L"SqlConnection::BindParameter - SQLBindParameter");
	}
	return rt;
}

//wchar_t* SqlConnection::GetErrorInformation(RETCODE retcode)
//{
//	if (retcode==SQL_SUCCESS) return NULL;
//	if (retcode==SQL_SUCCESS_WITH_INFO) return NULL;
//	if (retcode==SQL_NO_DATA) return NULL;
//	if (retcode!=SQL_ERROR) return NULL;
//	wchar_t szSqlState[10];
//	SDWORD sdError=0;
//	SWORD swSize;
//	SQLError(henv, hdbc, hstmt, (SQLWCHAR*)szSqlState, &sdError,
//			(SQLWCHAR*)errorDescr, SQL_MAX_MESSAGE_LENGTH-1, &swSize);
//	return errorDescr;
//}

int SqlConnection::GetColumCount(const wchar_t* statement)
{
	RETCODE rt = SQL_SUCCESS;
	Sql::SqlExceptInfo ei;
	if (statement ==NULL) return SQL_INVALID_HANDLE;
	CreateStatement();
	SQLSMALLINT cols = 0;
	if (IsOk(rt = ::SQLExecDirect(hstmt, (SQLWCHAR*)statement, SQL_NTS))==false)
	{
		ei.hdbc = this->hdbc;
		ei.henv = this->henv;
		ei.hstmt = this->hstmt;
		ei.retcode = rt;
		throw Sql::SqlException(ei, statement, L"SqlConnection::GetColumCount - SQLExecDirect");
	}
	if (IsOk(rt = ::SQLNumResultCols(hstmt, &cols))==false)
	{
		ei.hdbc = this->hdbc;
		ei.henv = this->henv;
		ei.hstmt = this->hstmt;
		ei.retcode = rt;
		throw Sql::SqlException(ei, statement, L"SqlConnection::GetColumCount - SQLNumResultCols");
	}
	return (int)cols;
}

RETCODE SqlConnection::BindColumn(int columnNumber, bool& value)
{
	RETCODE rt = SQL_SUCCESS;
	SQLUSMALLINT col = (SQLUSMALLINT)columnNumber;
	//if (IsOk(rt = ::SQLBindCol(hstmt, col, SQL_C_LONG, &value, 1, &bindColStr[columnNumber-1]))==false)
	if (IsOk(rt = ::SQLBindCol(hstmt, col, SQL_C_BIT, &value, 1, &bindColStr[columnNumber-1]))==false)
	{
		Sql::SqlExceptInfo ei;
		ei.hdbc = this->hdbc;
		ei.henv = this->henv;
		ei.hstmt = this->hstmt;
		ei.retcode = rt;
		throw Sql::SqlException(ei, NULL, L"SqlConnection::BindColumn - SQLBindCol");
	}
	return rt;
}

RETCODE SqlConnection::BindColumn(int columnNumber, int& value)
{
	RETCODE rt = SQL_SUCCESS;
	SQLUSMALLINT col = (SQLUSMALLINT)columnNumber;
	if (IsOk(rt = ::SQLBindCol(hstmt, col, SQL_C_LONG, &value, 1, &bindColStr[columnNumber-1]))==false)
	{
		Sql::SqlExceptInfo ei;
		ei.hdbc = this->hdbc;
		ei.henv = this->henv;
		ei.hstmt = this->hstmt;
		ei.retcode = rt;
		throw Sql::SqlException(ei, NULL, L"SqlConnection::BindColumn - SQLBindCol");
	}
	return rt;
}

RETCODE SqlConnection::BindColumn(int columnNumber, double& value)
{
	RETCODE rt = SQL_SUCCESS;
	SQLUSMALLINT col = (SQLUSMALLINT)columnNumber;
	if (IsOk(rt = ::SQLBindCol(hstmt, col, SQL_C_DOUBLE, &value, 1, &bindColStr[columnNumber-1]))==false)
	{
		Sql::SqlExceptInfo ei;
		ei.hdbc = this->hdbc;
		ei.henv = this->henv;
		ei.hstmt = this->hstmt;
		ei.retcode = rt;
		throw Sql::SqlException(ei, NULL, L"SqlConnection::BindColumn - SQLBindCol");
	}
	return rt;
}

RETCODE SqlConnection::BindColumn(int columnNumber, Sys::SqlTime& value)
{
	RETCODE rt = SQL_SUCCESS;
	SQLUSMALLINT col = (SQLUSMALLINT)columnNumber;
	if (IsOk(rt = ::SQLBindCol(hstmt, col, SQL_C_TIMESTAMP, &value, sizeof(Sys::SqlTime), &bindColStr[columnNumber-1]))==false)
	{
		Sql::SqlExceptInfo ei;
		ei.hdbc = this->hdbc;
		ei.henv = this->henv;
		ei.hstmt = this->hstmt;
		ei.retcode = rt;
		throw Sql::SqlException(ei, NULL, L"SqlConnection::BindColumn - SQLBindCol");
	}
	return rt;
}

RETCODE SqlConnection::BindColumn(int columnNumber, Sql::ISelectString& control, int bufferLength)
{
	if (columnNumber <=1) BindClear();
	control.SqlGetString().resize(bufferLength);
	this->iselect[columnNumber-1] = &control;

	RETCODE rt = SQL_SUCCESS;
	SQLUSMALLINT col = (SQLUSMALLINT)columnNumber;
	if (IsOk(rt = ::SQLBindCol(hstmt, col, SQL_C_WCHAR, (wchar_t*)control.SqlGetString().data(), bufferLength, &bindColStr[columnNumber-1]))==false)
	{
		Sql::SqlExceptInfo ei;
		ei.hdbc = this->hdbc;
		ei.henv = this->henv;
		ei.hstmt = this->hstmt;
		ei.retcode = rt;
		throw Sql::SqlException(ei, NULL, L"SqlConnection::BindColumn - SQLBindCol");
	}
	return rt;
}

RETCODE SqlConnection::BindColumn(int columnNumber, Sql::ISelectTime& control)
{
	if (columnNumber <=1) BindClear();
	this->iselect[columnNumber-1] = &control;
	RETCODE rt = SQL_SUCCESS;
	SQLUSMALLINT col = (SQLUSMALLINT)columnNumber;
	if (IsOk(rt = ::SQLBindCol(hstmt, col, SQL_C_TIMESTAMP, &control.SqlGetTime(), sizeof(Sys::SqlTime), &bindColStr[columnNumber-1]))==false)
	{
		Sql::SqlExceptInfo ei;
		ei.hdbc = this->hdbc;
		ei.henv = this->henv;
		ei.hstmt = this->hstmt;
		ei.retcode = rt;
		throw Sql::SqlException(ei, NULL, L"SqlConnection::BindColumn - SQLBindCol");
	}
	return rt;
}

RETCODE SqlConnection::BindColumn(int columnNumber, Sql::ISelectInt& control)
{
	if (columnNumber <=1) BindClear();
	this->iselect[columnNumber-1] = &control;
	RETCODE rt = SQL_SUCCESS;
	SQLUSMALLINT col = (SQLUSMALLINT)columnNumber;
	if (IsOk(rt = ::SQLBindCol(hstmt, col, SQL_C_LONG, &control.SqlGetInt(), 1, &bindColStr[columnNumber-1]))==false)
	{
		Sql::SqlExceptInfo ei;
		ei.hdbc = this->hdbc;
		ei.henv = this->henv;
		ei.hstmt = this->hstmt;
		ei.retcode = rt;
		throw Sql::SqlException(ei, NULL, L"SqlConnection::BindColumn - SQLBindCol");
	}
	return rt;
}

RETCODE SqlConnection::BindColumn(int columnNumber, Sql::ISelectDouble& control)
{
	if (columnNumber <=1) BindClear();
	this->iselect[columnNumber-1] = &control;
	RETCODE rt = SQL_SUCCESS;
	SQLUSMALLINT col = (SQLUSMALLINT)columnNumber;
	if (IsOk(rt = ::SQLBindCol(hstmt, col, SQL_C_DOUBLE, &control.SqlGetDouble(), 1, &bindColStr[columnNumber-1]))==false)
	{
		Sql::SqlExceptInfo ei;
		ei.hdbc = this->hdbc;
		ei.henv = this->henv;
		ei.hstmt = this->hstmt;
		ei.retcode = rt;
		throw Sql::SqlException(ei, NULL, L"SqlConnection::BindColumn - SQLBindCol");
	}
	return rt;
}

RETCODE SqlConnection::BindColumn(int columnNumber, Sql::ISelectBool& control)
{
	if (columnNumber <=1) BindClear();
	this->iselect[columnNumber-1] = &control;
	RETCODE rt = SQL_SUCCESS;
	SQLUSMALLINT col = (SQLUSMALLINT)columnNumber;
	//if (IsOk(rt = ::SQLBindCol(hstmt, col, SQL_C_LONG, &iselect.SqlGetBool(), 1, &bindColStr[columnNumber-1]))==false)
	if (IsOk(rt = ::SQLBindCol(hstmt, col, SQL_C_BIT, &control.SqlGetBool(), 1, &bindColStr[columnNumber-1]))==false)
	{
		Sql::SqlExceptInfo ei;
		ei.hdbc = this->hdbc;
		ei.henv = this->henv;
		ei.hstmt = this->hstmt;
		ei.retcode = rt;
		throw Sql::SqlException(ei, NULL, L"SqlConnection::BindColumn - SQLBindCol");
	}
	return rt;
}

RETCODE SqlConnection::BindColumn(int columnNumber, wchar_t* value, int bufferLength)
{
	RETCODE rt = SQL_SUCCESS;
	SQLUSMALLINT col = (SQLUSMALLINT)columnNumber;
	if (IsOk(rt = ::SQLBindCol(hstmt, col, SQL_C_WCHAR, value, sizeof(wchar_t)*bufferLength, &bindColStr[columnNumber-1]))==false)
	{
		Sql::SqlExceptInfo ei;
		ei.hdbc = this->hdbc;
		ei.henv = this->henv;
		ei.hstmt = this->hstmt;
		ei.retcode = rt;
		throw Sql::SqlException(ei, NULL, L"SqlConnection::BindColumn - SQLBindCol");
	}
	return rt;
}

//RETCODE SqlConnection::BindColumn(int columnNumber, wstring& value, int columnLength)
//{
//	value.resize(columnLength+1);
//	RETCODE rt = SQL_SUCCESS;
//	SQLUSMALLINT col = (SQLUSMALLINT)columnNumber;
//	if (IsOk(rt = ::SQLBindCol(hstmt, col, SQL_C_WCHAR, (wchar_t*)value.c_str(), sizeof(wchar_t)*columnLength, &bindColStr[columnNumber-1]))==false)
//	{
//		Sql::SqlExceptInfo ei;
//		ei.hdbc = this->hdbc;
//		ei.henv = this->henv;
//		ei.hstmt = this->hstmt;
//		ei.retcode = rt;
//		throw Sql::SqlException(ei, NULL, L"SqlConnection::BindColumn - SQLBindCol");
//	}
//	return rt;
//}

bool SqlConnection::Fetch(void)
{
	RETCODE rt = SQL_INVALID_HANDLE;

	if (IsOk(rt=SQLFetch(hstmt))==false)
	{
		this->CloseCursor();
		//Sql::SqlExceptInfo ei;
		//ei.hdbc = this->hdbc;
		//ei.henv = this->henv;
		//ei.hstmt = this->hstmt;
		//ei.retcode = rt;
		//throw Sql::SqlException(ei, NULL, L"SqlConnection::Fetch - SQLFetch");
		return false;
	}
	for(int i = 0; i<SQL_BINDCOL_MAX; i++)
	{
		if (iselect[i] != NULL)
		{
			iselect[i]->SqlUpdate(true);
		}
		else
		{
			break;
		}
	}
	return true;
}

int SqlConnection::GetInt(const wchar_t* statement)
{
	int value = 0;
	this->GetColumn(statement, 1, SQL_C_LONG, &value, 1);
	return value;
}

int SqlConnection::GetInt(const wstring& statement)
{
	return GetInt(statement.c_str());
}

bool SqlConnection::GetBool(const wchar_t* statement)
{
	bool value = 0;
	this->GetColumn(statement, 1, SQL_C_BIT, &value, 1);
	return value;
}

bool SqlConnection::GetBool(const wstring& statement)
{
	return GetBool(statement.c_str());
}

double SqlConnection::GetDouble(const wchar_t* statement)
{
	double value = 0.0;
	this->GetColumn(statement, 1, SQL_C_DOUBLE, &value, 1);
	return value;
}

double SqlConnection::GetDouble(const wstring& statement)
{
	return this->GetDouble(statement.c_str());
}

Sys::Time SqlConnection::GetDate(const wchar_t* statement)
{
	Sys::SqlTime value;
	Sys::Time output;
	this->GetColumn(statement, 1, SQL_C_TIMESTAMP, &value, sizeof(Sys::SqlTime));
	Sys::Convert::SqlTimeToSysTime(value, output);
	return output;
}

Sys::Time SqlConnection::GetDate(const wstring& statement)
{
	return this->GetDate(statement.c_str());
}

RETCODE SqlConnection::GetString(const wchar_t* statement, wchar_t* buffer, int bufferLength)
{
	return this->GetColumn(statement, 1, SQL_C_WCHAR, buffer, bufferLength*sizeof(wchar_t));
}

RETCODE SqlConnection::GetString(const wstring& statement, wchar_t* buffer, int bufferLength)
{
	return this->GetColumn(statement.c_str(), 1, SQL_C_WCHAR, buffer, bufferLength*sizeof(wchar_t));
}

RETCODE SqlConnection::GetString(const wstring& statement, wstring& buffer, int bufferLength)
{
	buffer.resize(bufferLength);
	RETCODE result =  this->GetColumn(statement.c_str(), 1, SQL_C_WCHAR, (wchar_t*)buffer.data(), bufferLength*sizeof(wchar_t));
	const int len = wcslen(buffer.c_str());
	buffer.resize(len);
	return result;
}

// columnIndex starts at one
// targetType: SQL_C_TCHAR
//SQL_C_LONG
//SQL_C_SHORT
//SQL_C_FLOAT
//SQL_C_DOUBLE
//SQL_C_NUMERIC
//SQL_C_DATE
//SQL_C_TIME
//SQL_C_TIMESTAMP
RETCODE SqlConnection::GetColumn(const wchar_t* statement, int columnIndex, SQLSMALLINT targetType,
		SQLPOINTER targetValue, SQLINTEGER bufferLength)
{
	RETCODE rt = SQL_SUCCESS;
	SQLINTEGER len = 0;
	if (statement ==NULL) return SQL_INVALID_HANDLE;
	int cols = GetColumCount(statement);
	if (cols!=1) return SQL_NO_DATA;
	if (IsOk(rt = ::SQLBindCol(hstmt, columnIndex, targetType, targetValue, bufferLength, &len))==false) 
	{
		Sql::SqlExceptInfo ei;
		ei.hdbc = this->hdbc;
		ei.henv = this->henv;
		ei.hstmt = this->hstmt;
		ei.retcode = rt;
		throw Sql::SqlException(ei, statement, L"SqlConnection::GetColumn - SQLBindCol");
	}
	rt = ::SQLFetch(hstmt);
	::SQLCloseCursor(hstmt);
	DestroyStatement();
	//
	if (IsOk(rt)==false) 
	{
		Sql::SqlExceptInfo ei;
		ei.hdbc = this->hdbc;
		ei.henv = this->henv;
		ei.hstmt = this->hstmt;
		ei.retcode = rt;
		throw Sql::SqlException(ei, statement, L"SqlConnection::GetColumn - SQLFetch");
	}

	return rt;
}


// You may pass an objet that implements Win::ISqlNumerator
//	conn.OpenSession(L"directory", L"sa", L"123easy");
//	conn.ExecuteSelect(L"SELECT * FROM department", 100, *this);
//
//void Prueba::Enumerate(wchar_t** data, int colCount, int rowIndex)
//{
//	wchar_t texto[256];
//	for(int j=0; j<colCount; j++)
//	{
//		_snwprintf_s(texto, 256, L"row = %d, col = %d, data = %s", rowIndex, j, data[j]);
//		this->MessageBox(texto);
//	}
//}
RETCODE SqlConnection::ExecuteSelect(const wchar_t *statement, unsigned int maxNumberOfChar, Sql::ISqlNumerator& num)
{
	int row = 0;
	Sql::SqlExceptInfo ei;
	RETCODE rt = SQL_SUCCESS;
	const int cols = this->GetColumCount(statement);
	int i = 0;

	wchar_t** pData=new wchar_t* [cols];
	if (pData==NULL)
	{
		DestroyStatement();
		return SQL_INVALID_HANDLE;
	}
	for(i=0; i<cols; i++)
	{
		pData[i]=new wchar_t [maxNumberOfChar];
		pData[i][0]='\0';
	}

	//*********************************************************** BindCol
	for (i=0; i<cols; i++)
	{
		if (IsOk(rt = ::SQLBindCol(hstmt, i+1, SQL_C_TCHAR, pData[i], maxNumberOfChar, &bindColStr[i]))==false)
		{
			if (pData)
			{
				for (i=0; i<cols; i++) if (pData[i]) delete [] pData[i];
				delete [] pData;
			}
			this->DestroyStatement();
			ei.hdbc = this->hdbc;
			ei.henv = this->henv;
			ei.hstmt = this->hstmt;
			ei.retcode = rt;
			throw Sql::SqlException(ei, NULL, L"SqlConnection::ExecuteSelect - SQLBindCol");
		}
	}

	//************************************************************ Fetch
	while (IsOk(::SQLFetch(hstmt)))
	{
		num.Enumerate(pData, cols, row);
		for(i=0; i<cols; i++) pData[i][0]='\0';
		row++;
	}
	::SQLCloseCursor(hstmt);

	if (pData)
	{
		for (i=0; i<cols; i++) if (pData[i]) delete [] pData[i];
		delete [] pData;
	}
	this->DestroyStatement();

	return rt;
}

RETCODE SqlConnection::ExecuteSelect(const wstring& statement, unsigned int maxNumberOfChar, Sql::ISqlNumerator& num)
{
	return this->ExecuteSelect(statement.c_str(), maxNumberOfChar, num);
}

RETCODE SqlConnection::ExecuteSelect(const wchar_t *statement, unsigned int maxNumberOfChar, vector<vector<wstring> >& output)
{
	Sql::SqlExceptInfo ei;
	RETCODE rt = SQL_SUCCESS;
	const int cols = this->GetColumCount(statement);
	int i = 0;

	wchar_t** pData=new wchar_t* [cols];
	if (pData==NULL)
	{
		DestroyStatement();
		return SQL_INVALID_HANDLE;
	}
	for(i=0; i<cols; i++)
	{
		pData[i]=new wchar_t [maxNumberOfChar];
		pData[i][0]='\0';
	}

	//*********************************************************** BindCol
	for (i=0; i<cols; i++)
	{
		if (IsOk(rt = ::SQLBindCol(hstmt, i+1, SQL_C_TCHAR, pData[i], maxNumberOfChar, &bindColStr[i]))==false)
		{
			if (pData)
			{
				for (i=0; i<cols; i++) if (pData[i]) delete [] pData[i];
				delete [] pData;
			}
			this->DestroyStatement();
			ei.hdbc = this->hdbc;
			ei.henv = this->henv;
			ei.hstmt = this->hstmt;
			ei.retcode = rt;
			throw Sql::SqlException(ei, NULL, L"SqlConnection::ExecuteSelect - SQLBindCol");
		}
	}

	//************************************************************ Fetch
	vector<wstring> row;
	row.resize(cols);
	while (IsOk(::SQLFetch(hstmt)))
	{
		for(i = 0; i <cols; i++)
		{
			row[i] = pData[i];
			pData[i][0]='\0';
		}
		output.push_back(row);
	}
	::SQLCloseCursor(hstmt);

	if (pData)
	{
		for (i=0; i<cols; i++) if (pData[i]) delete [] pData[i];
		delete [] pData;
	}
	this->DestroyStatement();

	return rt;
}

RETCODE SqlConnection::ExecuteSelect(const wstring& statement, unsigned int maxNumberOfChar, vector<vector<wstring> >& output)
{
	return ExecuteSelect(statement.c_str(), maxNumberOfChar, output);
}

RETCODE SqlConnection::CloseCursor()
{
	RETCODE rt = ::SQLCloseCursor(hstmt);
	this->DestroyStatement();
	return rt;
}

// Use this for UPDATE, DELETE and INSERT
// Returns the number of rows affected
int SqlConnection::ExecuteNonQuery(const wchar_t* statement)
{
	RETCODE rc = SQL_SUCCESS;

	this->CreateStatement();
	int rows = ExecDirect(statement);
	this->DestroyStatement();
	return rows;
}

// Use this for UPDATE, DELETE and INSERT
// Returns the number of rows affected
int SqlConnection::ExecuteNonQuery(const wstring& statement)
{
	return this->ExecuteNonQuery(statement.c_str());
}

RETCODE SqlConnection::CreateStatement()
{
	DestroyStatement();
	if (bConnected==true && hdbc!=SQL_NULL_HDBC) 
	{
		RETCODE rt = SQLAllocStmt(hdbc, &hstmt);
		if (IsOk(rt)==false)
		{
			Sql::SqlExceptInfo ei;
			ei.hdbc = this->hdbc;
			ei.henv = this->henv;
			ei.hstmt = this->hstmt;
			ei.retcode = rt;
			throw Sql::SqlException(ei, NULL, L"SqlConnection::CreateStatement - SQLAllocStmt");
			return rt;
		}
		return rt;
	}
	return SQL_INVALID_HANDLE;
}

int SqlConnection::ExecuteSelect(const wchar_t *statement)
{
	for(int i = 0; i<SQL_BINDCOL_MAX; i++) iselect[i] = NULL;
	return this->GetColumCount(statement);
}

int SqlConnection::ExecuteSelect(const wstring& statement)
{
	return this->ExecuteSelect(statement.c_str());
}

void SqlConnection::DestroyStatement()
{
	if (hstmt!=SQL_NULL_HSTMT)
	{
		SQLFreeStmt(hstmt, SQL_DROP);
		hstmt = SQL_NULL_HSTMT;
	}
}

// You can use this function to call stored procedures
int SqlConnection::ExecDirect(const wchar_t* statement)
{
	Sql::SqlExceptInfo ei;
	RETCODE rt = SQL_SUCCESS;
	if (statement ==NULL) return SQL_INVALID_HANDLE;
	if (bConnected == false) return SQL_INVALID_HANDLE;
	SQLINTEGER rows = -1;

	if (IsOk(rt = ::SQLExecDirect(hstmt, (SQLWCHAR*)statement, SQL_NTS))==false) 
	{
		ei.hdbc = this->hdbc;
		ei.henv = this->henv;
		ei.hstmt = this->hstmt;
		ei.retcode = rt;
		throw Sql::SqlException(ei, statement, L"SqlConnection::ExecDirect - SQLExecDirect");
	}
	if (IsOk(rt = ::SQLRowCount(hstmt, &rows))==false)
	{
		ei.hdbc = this->hdbc;
		ei.henv = this->henv;
		ei.hstmt = this->hstmt;
		ei.retcode = rt;
		throw Sql::SqlException(ei, statement, L"SqlConnection::ExecDirect - SQLExecDirect");
	}
	return (int)rows;
}

// You can use this function to call stored procedures
int SqlConnection::ExecDirect(const wstring& statement)
{
	return this->ExecDirect(statement.c_str());
}

RETCODE SqlConnection::BindInputParameter(int parameterNumber, double& parameter)
{
	SQLUSMALLINT ipar = (SQLUSMALLINT)parameterNumber;
	bindColStr[ipar-1] = 0;
	RETCODE rt = ::SQLBindParameter(hstmt, ipar, SQL_PARAM_INPUT, 
		SQL_C_DOUBLE, SQL_DOUBLE, sizeof(double), 0, &parameter, 0, &bindColStr[ipar-1]); 
	if (IsOk(rt)==false)
	{
		Sql::SqlExceptInfo ei;
		ei.hdbc = this->hdbc;
		ei.henv = this->henv;
		ei.hstmt = this->hstmt;
		ei.retcode = rt;
		throw Sql::SqlException(ei, NULL, L"SqlConnection::BindInputParameter - SQLBindParameter");
	}
	return rt;
}

RETCODE SqlConnection::BindOutputParameter(int parameterNumber, double& parameter)
{
	SQLUSMALLINT ipar = (SQLUSMALLINT)parameterNumber;
	bindColStr[ipar-1] = 0;
	RETCODE rt = ::SQLBindParameter(hstmt, ipar, SQL_PARAM_OUTPUT, 
		SQL_C_DOUBLE, SQL_DOUBLE, sizeof(double), 0, &parameter, 0, &bindColStr[ipar-1]); 
	if (IsOk(rt)==false)
	{
		Sql::SqlExceptInfo ei;
		ei.hdbc = this->hdbc;
		ei.henv = this->henv;
		ei.hstmt = this->hstmt;
		ei.retcode = rt;
		throw Sql::SqlException(ei, NULL, L"SqlConnection::BindInputParameter - SQLBindParameter");
	}
	return rt;
}

RETCODE SqlConnection::BindInputParameter(int parameterNumber, int& parameter)
{
	SQLUSMALLINT ipar = (SQLUSMALLINT)parameterNumber;
	bindColStr[ipar-1] = 0;
	RETCODE rt = ::SQLBindParameter(hstmt, ipar, SQL_PARAM_INPUT, 
		SQL_C_LONG, SQL_INTEGER, sizeof(int), 0, &parameter, 0, &bindColStr[ipar-1]); 
	if (IsOk(rt)==false)
	{
		Sql::SqlExceptInfo ei;
		ei.hdbc = this->hdbc;
		ei.henv = this->henv;
		ei.hstmt = this->hstmt;
		ei.retcode = rt;
		throw Sql::SqlException(ei, NULL, L"SqlConnection::BindInputParameter - SQLBindParameter");
	}
	return rt;
}

RETCODE SqlConnection::BindOutputParameter(int parameterNumber, int& parameter)
{
	SQLUSMALLINT ipar = (SQLUSMALLINT)parameterNumber;
	bindColStr[ipar-1] = 0;
	RETCODE rt = ::SQLBindParameter(hstmt, ipar, SQL_PARAM_OUTPUT, 
		SQL_C_LONG, SQL_INTEGER, sizeof(int), 0, &parameter, 0, &bindColStr[ipar-1]); 
	if (IsOk(rt)==false)
	{
		Sql::SqlExceptInfo ei;
		ei.hdbc = this->hdbc;
		ei.henv = this->henv;
		ei.hstmt = this->hstmt;
		ei.retcode = rt;
		throw Sql::SqlException(ei, NULL, L"SqlConnection::BindInputParameter - SQLBindParameter");
	}
	return rt;
}

RETCODE SqlConnection::BindInputParameter(int parameterNumber, Sys::SqlTime& parameter)
{
	SQLUSMALLINT ipar = (SQLUSMALLINT)parameterNumber;
	bindColStr[ipar-1] = 0;
	RETCODE rt = ::SQLBindParameter(hstmt, ipar, SQL_PARAM_INPUT, 
		SQL_C_TIMESTAMP, SQL_TIMESTAMP, sizeof(Sys::SqlTime), 0, &parameter, 0, &bindColStr[ipar-1]); 
	if (IsOk(rt)==false)
	{
		Sql::SqlExceptInfo ei;
		ei.hdbc = this->hdbc;
		ei.henv = this->henv;
		ei.hstmt = this->hstmt;
		ei.retcode = rt;
		throw Sql::SqlException(ei, NULL, L"SqlConnection::BindInputParameter - SQLBindParameter");
	}
	return rt;
}

RETCODE SqlConnection::BindOutputParameter(int parameterNumber, Sys::SqlTime& parameter)
{
	SQLUSMALLINT ipar = (SQLUSMALLINT)parameterNumber;
	bindColStr[ipar-1] = 0;
	RETCODE rt = ::SQLBindParameter(hstmt, ipar, SQL_PARAM_OUTPUT, 
		SQL_C_TIMESTAMP, SQL_TIMESTAMP, sizeof(Sys::SqlTime), 0, &parameter, 0, &bindColStr[ipar-1]); 
	if (IsOk(rt)==false)
	{
		Sql::SqlExceptInfo ei;
		ei.hdbc = this->hdbc;
		ei.henv = this->henv;
		ei.hstmt = this->hstmt;
		ei.retcode = rt;
		throw Sql::SqlException(ei, NULL, L"SqlConnection::BindInputParameter - SQLBindParameter");
	}
	return rt;
}

RETCODE SqlConnection::BindInputParameter(int parameterNumber, const wchar_t* parameter)
{
	SQLUSMALLINT ipar = (SQLUSMALLINT)parameterNumber;
	bindColStr[ipar-1] = SQL_NTS;
	RETCODE rt = ::SQLBindParameter(hstmt, ipar, SQL_PARAM_INPUT, 
		SQL_C_WCHAR, 
		SQL_WVARCHAR, //SQL_WCHAR, SQL_WVARCHAR, SQL_WLONGVARCHAR
		(wcslen(parameter)+1)*sizeof(wchar_t), 0, (wchar_t*)parameter, 0, &bindColStr[ipar-1]); 

	if (IsOk(rt)==false)
	{
		Sql::SqlExceptInfo ei;
		ei.hdbc = this->hdbc;
		ei.henv = this->henv;
		ei.hstmt = this->hstmt;
		ei.retcode = rt;
		throw Sql::SqlException(ei, NULL, L"SqlConnection::BindInputParameter - SQLBindParameter");
	}
	return rt;
}

RETCODE SqlConnection::BindOutputParameter(int parameterNumber, wchar_t* parameter, int maxNumberOfChar)
{
	SQLUSMALLINT ipar = (SQLUSMALLINT)parameterNumber;
	bindColStr[ipar-1] = SQL_NTS;
	RETCODE rt = ::SQLBindParameter(hstmt, ipar, SQL_PARAM_OUTPUT, 
		SQL_C_WCHAR, 
		SQL_WCHAR, //SQL_WCHAR, SQL_WVARCHAR, SQL_WLONGVARCHAR
		maxNumberOfChar*sizeof(wchar_t), 0, parameter, 0, &bindColStr[ipar-1]); 
	if (IsOk(rt)==false)
	{
		Sql::SqlExceptInfo ei;
		ei.hdbc = this->hdbc;
		ei.henv = this->henv;
		ei.hstmt = this->hstmt;
		ei.retcode = rt;
		throw Sql::SqlException(ei, NULL, L"SqlConnection::BindOutputParameter - SQLBindParameter");
	}
	return rt;
}

// Returns the number of attributes on a SQL statement without a connection
// If you have a Connection, use GetColCount();
int SqlConnection::GetAttributeCount(const wchar_t* statement)
{
	int iCount=0;
	int iParenthesis=0;
	
	if (statement ==NULL) return 0;
	const int len = wcslen(statement);
	if (len == 0) return 0;

	// ___________________________________________We search for FROM
	const wchar_t* pFrom = wcsstr(statement, L"FROM");
	if (pFrom==NULL) pFrom = wcsstr (statement, L"from");
	if (pFrom != NULL)
	{
		pFrom--;
		iCount=1;
		for(const wchar_t* p=statement; p != pFrom; p++)
		{
			switch(*p)
			{
			case ',':
				if (iParenthesis==0)
					iCount++;
				break;
			case '(':
				iParenthesis++;
				break;
			case ')':
				iParenthesis--;
				break;
			}
		}
	}

	//_________________________________________ We search for DESCRIBE
	if (iCount==0)
	{
		pFrom=wcsstr (statement, L"DESCRIBE");
		if (pFrom==NULL) pFrom=wcsstr (statement, L"describe");
		if (pFrom) iCount =1;
	}

	return iCount;
}

//Returns the number of attributes on a SQL statement and the attribute names without an SQL connection
int SqlConnection::GetAttributeNames(const wchar_t* statement, vector<wstring>& output)
{
	output.clear();
	const int len = wcslen(statement);
	if (len == 0) return 0;
	const int count = Sql::SqlConnection::GetAttributeCount(statement);
	if (count==0) return 0;
	int iParenthesis=0;
	bool bComma=false;
	wstring columnName;
	

	//********************************** We search for SELECT
	const wchar_t* pSelect = wcsstr(statement, L"SELECT");
	if (pSelect==NULL) pSelect=wcsstr (statement, L"select");

	if (pSelect)
	{
		pSelect+=6;
		const int lenSelect = wcslen(pSelect)+1;
		wchar_t* pData=new wchar_t[lenSelect];
		wcscpy_s(pData, lenSelect, pSelect);
		//________________________________________ We search for FROM
		wchar_t * pFrom=wcsstr (pData, L"FROM");
		if (pFrom==NULL) pFrom=wcsstr (pData, L"from");
		if (pFrom==NULL) return 0;
		pFrom--;
		*pFrom=','; // We add an extra comma to easy the column reading
		pFrom++;
		*pFrom='\0';
		int i=0;
		wchar_t* pBegin = NULL;
		wchar_t* pEnd = NULL;
		
		for(pEnd = pData; *pEnd!=NULL; pEnd++)
		{
			if (i>=count) break;
			switch(*pEnd)
			{
			case ',':
				if (iParenthesis==0) bComma=true;
				break;
			case '(':
				iParenthesis++;
				break;
			case ')':
				iParenthesis--;
				break;
			}
			if (bComma == true)
			{
				bComma=false;
				pBegin = pEnd;
				*pEnd='\0';
				pBegin--;
				if (*pBegin == '\'') //______________________________ AS 'column description'
				{
					pBegin--;
					while(*pBegin!='\'' && *pBegin!='\n' && *pBegin!='\r')
					{
						pBegin--;
					}
					pBegin++;
					columnName.assign(pBegin, pEnd-pBegin-1);					
				}
				else
				{
					while(*pBegin!=' ' && *pBegin!='\n' && *pBegin!='\r')
					{
						pBegin--;
					}
					pBegin++;
					columnName.assign(pBegin, pEnd-pBegin+1);
				}
				output.push_back(columnName);
			}
		}
		if (pData) delete [] pData;
	}
	else
	{
		//********************************** We search for DESCRIBE
		pSelect = wcsstr(statement, L"DESCRIBE");
		if (pSelect==NULL) pSelect=wcsstr(statement, L"describe");
		if (pSelect==NULL) return 0;
		pSelect += wcslen(L"DESCRIBE ");
		columnName.assign(pSelect, len-wcslen(L"DESCRIBE"));
		if (columnName.back() == ';') columnName.resize(columnName.length()-1); // Remove semicolon
		output.push_back(columnName);
	}

	return output.size();
}

} //____________________________________________________ namespace Sql::End

namespace Web //________________________________________ namespace Web::Ini
{

//__________________________________________________  CssType
CssType::CssType()
{
}

CssType::~CssType()
{
}

//__________________________________________________ Helper
Helper::Helper()
{
}

 Helper::~Helper()
 {
 }

wchar_t* Helper::GetTagDesc(int type)
{
	switch(type)
	{
	case HTML_TND_SPAN: return L"<span>text</span>";
	case HTML_TND_P: return L"<p>text</p>";
	case HTML_TND_SMALL: return L"<small>text</small>";
	case HTML_TND_PRE: return L"<pre>text</pre>";
	case HTML_TND_TT: return L"<tt>text</tt>";
	case HTML_TND_B: return L"<b>text</b>";
	case HTML_TND_I: return L"<i>text</i>";
	case HTML_TND_U: return L"<u>text</u>";
	case HTML_TND_STRIKE: return L"<strike>text</strike>";
	case HTML_TND_Q: return L"<q>text</q>";
	case HTML_TND_H1: return L"<h1>text</h1>";
	case HTML_TND_H2: return L"<h2>text</h2>";
	case HTML_TND_H3: return L"<h3>text</h3>";
	case HTML_TND_H4: return L"<h4>text</h4>";
	case HTML_TND_H5: return L"<h5>text</h5>";
	case HTML_TND_H6: return L"<h6>text</h6>";
	case HTML_TND_NONE: return L"text";
	//
	case HTML_PND_ONE_ROW_TABLE: return L"<table>\r\n   <tr>  <td>child</td><td>child</td>... <td>child</td>  </tr>\r\n</table>";
	case HTML_PND_ONE_COLUMN_TABLE: return L"<table>\r\n   <tr>  <td>child</td>  </tr>\r\n   <tr>  <td>child</td>  </tr>\r\n</table>";
	case HTML_PND_ROW_CONTAINER_TABLE: return L"<table>\r\n   <tr>child</tr>\r\n   <tr>child</tr>\r\n</table>";
	case HTML_PND_ROW: return L"<td>child</td>\r\n<td>child</td>\r\n...\r\n<td>child</td>";
	case HTML_PND_UL: return L"<ul>\r\n   <li>child</li>\r\n   <li>child</li>\r\n</ul>";
	case HTML_PND_OL: return L"<ol>\r\n   <li>child</li>\r\n   <li>child</li>\r\n</ol>";
	case HTML_PND_DL: return L"<dl>\r\n   <dd>child</dd>\r\n   <dd>child</dd>\r\n</dl>";
	case HTML_PND_HR: return L"child<hr />\r\nchild<hr />\r\n...\r\nchild";
	case HTML_PND_BR: return L"child<br />\r\nchild<br />\r\n...\r\nchild";
	case HTML_PND_SPACE: return L"child child child ... child";
	case HTML_PND_COMMA: return L"child, child, child, ... child";
	case HTML_PND_SEMICOLON: return L"child; child; child; ... child";
	case HTML_PND_PARENTHESIS: return L"(child) (child) (child) ...(child)";
	case HTML_PND_BRACKETS: return L"[child] [child] [child] ...[child]";
	case HTML_PND_NONE: return L"childchildchild";
	}
	return NULL;
}

wchar_t* Helper::GetTag(int type)
{
	switch(type)
	{
	case HTML_TND_SPAN: return L"span";
	case HTML_TND_P: return L"p";
	case HTML_TND_SMALL: return L"small";
	case HTML_TND_PRE: return L"pre";
	case HTML_TND_TT: return L"tt";
	case HTML_TND_B: return L"b";
	case HTML_TND_I: return L"i";
	case HTML_TND_U: return L"u";
	case HTML_TND_STRIKE: return L"strike";
	case HTML_TND_Q: return L"q";
	case HTML_TND_H1: return L"h1";
	case HTML_TND_H2: return L"h2";
	case HTML_TND_H3: return L"h3";
	case HTML_TND_H4: return L"h4";
	case HTML_TND_H5: return L"h5";
	case HTML_TND_H6: return L"h6";
	//
	case HTML_PND_ONE_ROW_TABLE: return L"table";
	case HTML_PND_ONE_COLUMN_TABLE: return L"table";
	case HTML_PND_ROW_CONTAINER_TABLE: return L"table";
	case HTML_PND_UL: return L"ul";
	case HTML_PND_OL: return L"ol";
	case HTML_PND_DL: return L"dl";
	//
	case HTML_TD: return L"td";
	case HTML_TR: return L"tr";
	case HTML_TH: return L"th";
	case HTML_DIV: return L"div";
	case HTML_LI: return L"li";
	case HTML_DD: return L"dd";
	case HTML_FORM: return L"form";
	case HTML_BODY: return L"body";
	case HTML_HEAD: return L"head";
	case HTML_INPUT: return L"input";
	case HTML_BR: return L"br";
	case HTML_HR: return L"hr";
	case HTML_SELECTX: return L"select";
	case HTML_TEXTAREA: return L"textarea";
	case HTML_META: return L"meta";
	case HTML_HTML: return L"html";
	case HTML_DOCTYPE: return L"!DOCTYPE";
	case HTML_TITLE: return L"title";
	case HTML_LINK: return L"link";
	case HTML_SCRIPT: return L"script";
	case HTML_IMG: return L"img";
	case HTML_A: return L"a";
	case HTML_OPTION: return L"option";
	case HTML_OBJECT: return L"object";
	case HTML_COMMENT: return L"!--";
	}
	return NULL;
}

bool Helper::RequiresClosingTag(int type)
{
	switch(type)
	{
	case HTML_TND_SPAN: return true;
	case HTML_TND_P: return true;
	case HTML_TND_SMALL: return true;
	case HTML_TND_PRE: return true;
	case HTML_TND_TT: return true;
	case HTML_TND_B: return true;
	case HTML_TND_I: return true;
	case HTML_TND_U: return true;
	case HTML_TND_STRIKE: return true;
	case HTML_TND_Q: return true;
	case HTML_TND_H1: return true;
	case HTML_TND_H2: return true;
	case HTML_TND_H3: return true;
	case HTML_TND_H4: return true;
	case HTML_TND_H5: return true;
	case HTML_TND_H6: return true;
	//
	case HTML_PND_ONE_ROW_TABLE: return true;
	case HTML_PND_ONE_COLUMN_TABLE: return true;
	case HTML_PND_ROW_CONTAINER_TABLE: return true;
	case HTML_PND_UL: return true;
	case HTML_PND_OL: return true;
	case HTML_PND_DL: return true;
	//
	case HTML_TD: return true;
	case HTML_TR: return true;
	case HTML_TH: return true;
	case HTML_DIV: return true;
	case HTML_LI: return true;
	case HTML_DD: return true;
	case HTML_FORM: return true;
	case HTML_BODY: return true;
	case HTML_HEAD: return true;
	case HTML_INPUT: return false;
	case HTML_BR: return false;
	case HTML_HR: return false;
	case HTML_SELECTX: return true;
	case HTML_TEXTAREA: return true;
	case HTML_META: return false;
	case HTML_HTML: return true;
	case HTML_DOCTYPE: return false;
	case HTML_TITLE: return true;
	case HTML_LINK: return false;
	case HTML_SCRIPT: return true;
	case HTML_IMG: return false;
	case HTML_A: return true;
	case HTML_OPTION: return true;
	case HTML_OBJECT: return true;
	case HTML_COMMENT: return false;
	}
	return NULL;
}

wchar_t* Helper::GetTagName(int type)
{
	switch(type)
	{
	case HTML_TND_SPAN: return L"Text Section";
	case HTML_TND_P: return L"Paragraph";
	case HTML_TND_SMALL: return L"Small Text";
	case HTML_TND_PRE: return L"Monospaced Text";
	case HTML_TND_TT: return L"Monospaced Text";
	case HTML_TND_B: return L"Bold Text";
	case HTML_TND_I: return L"Italics Text";
	case HTML_TND_U: return L"Underline Text";
	case HTML_TND_STRIKE: return L"Strike Text";
	case HTML_TND_Q: return L"Quotation";
	case HTML_TND_H1: return L"Heading 1";
	case HTML_TND_H2: return L"Heading 2";
	case HTML_TND_H3: return L"Heading 3";
	case HTML_TND_H4: return L"Heading 4";
	case HTML_TND_H5: return L"Heading 5";
	case HTML_TND_H6: return L"Heading 6";
	case HTML_TND_NONE: return L"None";
	//
	case HTML_PND_ONE_ROW_TABLE: return L"One row Table";
	case HTML_PND_ONE_COLUMN_TABLE: return L"One col Table";
	case HTML_PND_ROW_CONTAINER_TABLE: return L"Container Table";
	case HTML_PND_UL: return L"Unordered List";
	case HTML_PND_OL: return L"Ordered List";
	case HTML_PND_DL: return L"Definition List";
	case HTML_PND_ROW: return L"Single Row";
	case HTML_PND_HR: return L"Horizontal Line";
	case HTML_PND_BR: return L"New Line";
	case HTML_PND_SPACE: return L"One Space";
	case HTML_PND_COMMA: return L"Commas";
	case HTML_PND_SEMICOLON: return L"Semicolon";
	case HTML_PND_PARENTHESIS: return L"Parenthesis";
	case HTML_PND_BRACKETS: return L"Brackets";
	case HTML_PND_NONE: return L"None";
	}
	return NULL;
}

wchar_t* Helper::GetNodeTypeText(int type)
{
	switch(type)
	{
	case HTML_TND_SPAN: return L"HTML_TND_SPAN";
	case HTML_TND_P: return L"HTML_TND_P";
	case HTML_TND_SMALL: return L"HTML_TND_SMALL";
	case HTML_TND_PRE: return L"HTML_TND_PRE";
	case HTML_TND_TT: return L"HTML_TND_TT";
	case HTML_TND_B: return L"HTML_TND_B";
	case HTML_TND_I: return L"HTML_TND_I";
	case HTML_TND_U: return L"HTML_TND_U";
	case HTML_TND_STRIKE: return L"HTML_TND_STRIKE";
	case HTML_TND_Q: return L"HTML_TND_Q";
	case HTML_TND_H1: return L"HTML_TND_H1";
	case HTML_TND_H2: return L"HTML_TND_H2";
	case HTML_TND_H3: return L"HTML_TND_H3";
	case HTML_TND_H4: return L"HTML_TND_H4";
	case HTML_TND_H5: return L"HTML_TND_H5";
	case HTML_TND_H6: return L"HTML_TND_H6";
	case HTML_TND_NONE: return L"HTML_TND_NONE";
	//
	case HTML_PND_ONE_ROW_TABLE: return L"HTML_PND_ONE_ROW_TABLE";
	case HTML_PND_ONE_COLUMN_TABLE: return L"HTML_PND_ONE_COLUMN_TABLE";
	case HTML_PND_ROW_CONTAINER_TABLE: return L"HTML_PND_ROW_CONTAINER_TABLE";
	case HTML_PND_UL: return L"HTML_PND_UL";
	case HTML_PND_OL: return L"HTML_PND_OL";
	case HTML_PND_DL: return L"HTML_PND_DL";
	case HTML_PND_ROW: return L"HTML_PND_ROW";
	case HTML_PND_HR: return L"HTML_PND_HR";
	case HTML_PND_BR: return L"HTML_PND_BR";
	case HTML_PND_SPACE: return L"HTML_PND_SPACE";
	case HTML_PND_COMMA: return L"HTML_PND_COMMA";
	case HTML_PND_SEMICOLON: return L"HTML_PND_SEMICOLON";
	case HTML_PND_PARENTHESIS: return L"HTML_PND_PARENTHESIS";
	case HTML_PND_BRACKETS: return L"HTML_PND_BRACKETS";
	case HTML_PND_NONE: return L"HTML_PND_NONE";
	}
	return NULL;
}

wchar_t* Helper::GetControlClass(int type_id)
{
	switch(type_id)
	{
	case HTML_BARCHART: return L"Web::BarChart";
	case HTML_BUTTON: return L"Web::Button";
	case HTML_CHECKBOX: return L"Web::CheckBox";
	case HTML_CHECKBOXLIST: return L"Web::CheckBoxList";
	//case HTML_CUSTOMCONTROL: return L"Web::CustomControl";
	case HTML_DATETIMEBOX: return L"Web::DateTimeBox";
	case HTML_DATEVIEW: return L"Web::DateView";
	case HTML_DROPDOWNLIST: return L"Web::DropDownList";
	case HTML_HIDDENVALUE: return L"Web::HiddenValue";
	case HTML_HISTOGRAM: return L"Web::Histogram";
	case HTML_IMAGE: return L"Web::Image";
	case HTML_IMAGELINK: return L"Web::ImageLink";
	case HTML_LABEL: return L"Web::Label";
	case HTML_LISTBOX: return L"Web::ListBox";
	case HTML_LISTVIEW: return L"Web::ListView";
	case HTML_PARENTNODE: return L"Web::ParentNode";
	case HTML_PIECHART: return L"Web::PieChart";
	case HTML_PLUGIN: return L"Web::PlugIn";
	case HTML_POLARCHART: return L"Web::PolarChart";
	case HTML_RADIOBUTTON: return L"Web::RadioButton";
	case HTML_TEXTBOX: return L"Web::Textbox";
	case HTML_TEXTLINK: return L"Web::TextLink";
	case HTML_XYCHART: return L"Web::XyChart";
	case HTML_PAGE: return L"Web::Page";
	}
	return NULL;
}

wchar_t* Helper::GetControlDescr(int type_id)
{
	switch(type_id)
	{
	case HTML_BARCHART: return L"Bar Chart";
	case HTML_BUTTON: return L"Button";
	case HTML_CHECKBOX: return L"Check Box";
	case HTML_CHECKBOXLIST: return L"Check Box List";
	case HTML_CUSTOMCONTROL: return L"Custom Control";
	case HTML_DATETIMEBOX: return L"Date Time Box";
	case HTML_DATEVIEW: return L"Date View";
	case HTML_DROPDOWNLIST: return L"Drop Down List";
	case HTML_HIDDENVALUE: return L"Hidden Value";
	case HTML_HISTOGRAM: return L"Histogram";
	case HTML_IMAGE: return L"Image";
	case HTML_IMAGELINK: return L"Image Link";
	case HTML_LABEL: return L"Label";
	case HTML_LISTBOX: return L"List Box";
	case HTML_LISTVIEW: return L"List View";
	case HTML_PARENTNODE: return L"Parent Node";
	case HTML_PIECHART: return L"Pie Chart";
	case HTML_PLUGIN: return L"Plug In";
	case HTML_POLARCHART: return L"Polar Chart";
	case HTML_RADIOBUTTON: return L"Radio Button";
	case HTML_TEXTBOX: return L"Text Box";
	case HTML_TEXTLINK: return L"Text Link";
	case HTML_XYCHART: return L"XY Chart";
	case HTML_PAGE: return L"Page";
	}
	return NULL;
}

wchar_t * Helper::GetControlCaption(int type_id)
{
	switch(type_id)
	{
	case HTML_BARCHART: return L"bchart";
	case HTML_BUTTON: return L"bt";
	case HTML_CHECKBOX: return L"ck";
	case HTML_CHECKBOXLIST: return L"cl";
	case HTML_CUSTOMCONTROL: return L"customControl";
	case HTML_DATETIMEBOX: return L"dtbox";
	case HTML_DATEVIEW: return L"dv";
	case HTML_DROPDOWNLIST: return L"dd";
	case HTML_HIDDENVALUE: return L"hd";
	case HTML_HISTOGRAM: return L"hist";
	case HTML_IMAGE: return L"img";
	case HTML_IMAGELINK: return L"imk";
	case HTML_LABEL: return L"lb";
	case HTML_LISTBOX: return L"lbx";
	case HTML_LISTVIEW: return L"lv";
	case HTML_PARENTNODE: return L"pnd";
	case HTML_PIECHART: return L"pie";
	case HTML_PLUGIN: return L"pgi";
	case HTML_POLARCHART: return L"polar";
	case HTML_RADIOBUTTON: return L"radio";
	case HTML_TEXTBOX: return L"tbx";
	case HTML_TEXTLINK: return L"txk";
	case HTML_XYCHART: return L"xy";
	case HTML_PAGE: return L"this->";
	}
	return NULL;
}

wchar_t* Helper::GetEventDesc(int type)
{
	switch(type)
	{
	//case HTML_BUTTONSUBMIT: 
	//	return L"clicks a submit button";
	case HTML_CLICK: 
		return L"clicks the control";
	case HTML_DBLCLICK: 
		return L"double-clicks the control";
	case HTML_MOUSEDOWN: 
		return L"presses the mouse button";
	case HTML_MOUSEUP: 
		return L"releases the mouse button";
	case HTML_MOUSEMOVE: 
		return L"moves the mouse whithin the control";
	case HTML_MOUSEOUT:
		return L"moves the mouse away from the control";
	case HTML_FOCUS: 
		return L"sends the keyboard focus to the control";
	case HTML_BLUR: 
		return L"moves the focus away from the control";
	case HTML_KEYPRESS: 
		return L"presses and releases a key on the keyboard";
	case HTML_KEYDOWN: 
		return L"presses a key on the keyboard";
	case HTML_KEYUP: 
		return L"releases a key on the keyboard";
	case HTML_SELECT: 
		return L"selects text";
	case HTML_CHANGE: 
		return L"changes an element's value";// and then leaves the element";
	case HTML_SUBMIT: 
		return L"submits a form";
	case HTML_RESET:
		 return L"clicks the reset button on a form";
	case HTML_LOAD: 
		return L"opens the Web page";
	case HTML_UNLOAD: 
		return L"closes the Web page";
	}
	return NULL;
}

wchar_t* Helper::GetEventName(int type)
{
switch(type)
	{
	case HTML_CLICK: 
		return L"onclick";
	case HTML_DBLCLICK: 
		return L"ondblclick";
	case HTML_MOUSEDOWN: 
		return L"onmousedown";
	case HTML_MOUSEUP: 
		return L"onmouseup";
	case HTML_MOUSEMOVE: 
		return L"onmousemove";
	case HTML_MOUSEOUT:
		return L"onmouseout";
	case HTML_FOCUS: 
			return L"onfocus";
	case HTML_BLUR: 
		return L"onblur";
	case HTML_KEYPRESS: 
		return L"onkeypress";
	case HTML_KEYDOWN: 
			return L"onkeydown";
	case HTML_KEYUP: 
		return L"onkeyup";
	case HTML_SELECT: 
		return L"onselect";
	case HTML_CHANGE: 
		return L"onchange";
	case HTML_SUBMIT: 
		return L"onsubmit";
	case HTML_RESET:
		 return L"onreset";
	case HTML_LOAD: 
		return L"onload";
	case HTML_UNLOAD: 
		return L"onunload";
	}
	return NULL;
}

wchar_t* Helper::GetEventShortName(int type)
{
switch(type)
	{
	case HTML_CLICK: 
		return L"Click";
	case HTML_DBLCLICK: 
		return L"DblClick";
	case HTML_MOUSEDOWN: 
		return L"MouseDown";
	case HTML_MOUSEUP: 
		return L"MouseUp";
	case HTML_MOUSEMOVE: 
		return L"MouseMove";
	case HTML_MOUSEOUT:
		return L"MouseOut";
	case HTML_FOCUS: 
			return L"Focus";
	case HTML_BLUR: 
		return L"Blur";
	case HTML_KEYPRESS: 
		return L"KeyPress";
	case HTML_KEYDOWN: 
			return L"KeyDown";
	case HTML_KEYUP: 
		return L"KeyUp";
	case HTML_SELECT: 
		return L"Select";
	case HTML_CHANGE: 
		return L"Change";
	case HTML_SUBMIT: 
		return L"Submit";
	case HTML_RESET:
		 return L"Reset";
	case HTML_LOAD: 
		return L"Load";
	case HTML_UNLOAD: 
		return L"Unload";
	}
	return NULL;
}

wchar_t* Helper::GetEventID(int type)
{
	switch(type)
	{
	case HTML_CLICK: return L"HTML_CLICK";
	case HTML_DBLCLICK: return L"HTML_DBLCLICK";
	case HTML_MOUSEDOWN: return L"HTML_MOUSEDOWN";
	case HTML_MOUSEUP: return L"HTML_MOUSEUP";
	case HTML_MOUSEMOVE: return L"HTML_MOUSEMOVE";
	case HTML_MOUSEOUT: return L"HTML_MOUSEOUT";
	case HTML_FOCUS: return L"HTML_FOCUS";
	case HTML_BLUR: return L"HTML_BLUR";
	case HTML_KEYPRESS: return L"HTML_KEYPRESS";
	case HTML_KEYDOWN: return L"HTML_KEYDOWN";
	case HTML_KEYUP: return L"HTML_KEYUP";
	case HTML_SELECT: return L"HTML_SELECT";
	case HTML_CHANGE: return L"HTML_CHANGE";
	case HTML_SUBMIT: return L"HTML_SUBMIT";
	case HTML_RESET: return L"HTML_RESET";
	case HTML_LOAD: return L"HTML_LOAD";
	case HTML_UNLOAD: return L"HTML_UNLOAD";
	}
	return NULL;
}

wchar_t* Helper::GetEventProperty(int type)
{
	switch(type)
	{
	case HTML_CLICK: return L"OnClick";
	case HTML_DBLCLICK: return L"OnDblClick";
	case HTML_MOUSEDOWN: return L"OnMouseDown";
	case HTML_MOUSEUP: return L"OnMouseUp";
	case HTML_MOUSEMOVE: return L"OnMouseMove";
	case HTML_MOUSEOUT: return L"OnMouseOut";
	case HTML_FOCUS: return L"OnFocus";
	case HTML_BLUR: return L"OnBlur";
	case HTML_KEYPRESS: return L"OnKeyPress";
	case HTML_KEYDOWN: return L"OnKeyDown";
	case HTML_KEYUP: return L"OnKeyUp";
	case HTML_SELECT: return L"OnSelect";
	case HTML_CHANGE: return L"OnChange";
	case HTML_SUBMIT: return L"OnSubmit";
	case HTML_RESET: return L"OnReset";
	case HTML_LOAD: return L"OnLoad";
	case HTML_UNLOAD: return L"OnUnload";
	//
	case HTML_JSCLICK: return L"OnJsClick";
	case HTML_JSDBLCLICK: return L"OnJsDblClick";
	case HTML_JSMOUSEDOWN: return L"OnJsMouseDown";
	case HTML_JSMOUSEUP: return L"OnJsMouseUp";
	case HTML_JSMOUSEMOVE: return L"OnJsMouseMove";
	case HTML_JSMOUSEOUT: return L"OnJsMouseOut";
	case HTML_JSFOCUS: return L"OnJsFocus";
	case HTML_JSBLUR: return L"OnJsBlur";
	case HTML_JSKEYPRESS: return L"OnJsKeyPress";
	case HTML_JSKEYDOWN: return L"OnJsKeyDown";
	case HTML_JSKEYUP: return L"OnJsKeyUp";
	case HTML_JSSELECT: return L"OnJsSelect";
	case HTML_JSCHANGE: return L"OnJsChange";
	case HTML_JSSUBMIT: return L"OnJsSubmit";
	case HTML_JSRESET: return L"OnJsReset";
	case HTML_JSLOAD: return L"OnJsLoad";
	case HTML_JSUNLOAD: return L"OnJsUnload";
	}
	return NULL;
}

wchar_t* Helper::GetPositionDescr(Web::CssType::Position position)
{
	switch(position)
	{
	case Web::CssType::PositionAuto: return L"Automatic"; 
	case Web::CssType::PositionAbsolute: return L"Absolute"; 
	case Web::CssType::PositionRelative: return L"Relative";
	}
	return NULL;
}

wchar_t* Helper::GetPositionValue(Web::CssType::Position position)
{
	switch(position)
	{
	//case Web::CssType::PositionAuto: return L"auto"; 
	case Web::CssType::PositionAbsolute: return L"absolute"; 
	case Web::CssType::PositionRelative: return L"relative";
	}
	return NULL;
}

wchar_t* Helper::GetPositionEnum(Web::CssType::Position position)
{
	switch(position)
	{
	case Web::CssType::PositionAuto: return L"Web::CssType::PositionAuto"; 
	case Web::CssType::PositionAbsolute: return L"Web::CssType::PositionAbsolute"; 
	case Web::CssType::PositionRelative: return L"Web::CssType::PositionRelative";
	}
	return NULL;
}

wchar_t* Helper::GetFontFamilyDescr(Web::CssType::FontFamily font_family)
{
	switch(font_family)
	{
	case Web::CssType::FontFamilyAuto: return L"Automatic"; 
	case Web::CssType::FontFamilyArial: return L"Arial"; 
	case Web::CssType::FontFamilyCourier: return L"Courier"; 
	case Web::CssType::FontFamilyTimesNewRoman: return L"Times New Roman";  
	}
	return NULL;
}

wchar_t* Helper::GetFontFamilyValue(Web::CssType::FontFamily font_family)
{
	switch(font_family)
	{
	//case Web::CssType::FontFamilyAuto: return L"auto"; 
	case Web::CssType::FontFamilyArial: return L"'Arial', 'Helvetica', 'sans-serif'"; 
	case Web::CssType::FontFamilyCourier: return L"'Courier New', 'Courier', 'monospace'"; 
	case Web::CssType::FontFamilyTimesNewRoman: return L"'Times New Roman', 'Times', 'serif'";  
	}
	return NULL;
}

wchar_t* Helper::GetFontFamilyEnum(Web::CssType::FontFamily font_family)
{
	switch(font_family)
	{
	case Web::CssType::FontFamilyAuto: return L"Web::CssType::FontFamilyAuto"; 
	case Web::CssType::FontFamilyArial: return L"Web::CssType::FontFamilyArial"; 
	case Web::CssType::FontFamilyCourier: return L"Web::CssType::FontFamilyCourier"; 
	case Web::CssType::FontFamilyTimesNewRoman: return L"Web::CssType::FontFamilyTimesNewRoman";  
	}
	return NULL;
}

wchar_t* Helper::GetTextAlignDescr(Web::CssType::TextAlign text_align)
{
	switch(text_align)
	{
	case Web::CssType::TextAlignAuto: return L"Automatic"; 
	case Web::CssType::TextAlignCenter: return L"Center"; 
	case Web::CssType::TextAlignJustify: return L"Justify"; 
	case Web::CssType::TextAlignLeft: return L"Left"; 
	case Web::CssType::TextAlignRight: return L"Right";
	}
	return NULL;
}

wchar_t* Helper::GetTextAlignValue(Web::CssType::TextAlign text_align)
{
	switch(text_align)
	{
	//case Web::CssType::TextAlignAuto: return L"auto"; 
	case Web::CssType::TextAlignCenter: return L"center"; 
	case Web::CssType::TextAlignJustify: return L"justify"; 
	case Web::CssType::TextAlignLeft: return L"left"; 
	case Web::CssType::TextAlignRight: return L"right";
	}
	return NULL;
}

wchar_t* Helper::GetTextAlignEnum(Web::CssType::TextAlign text_align)
{
	switch(text_align)
	{
	case Web::CssType::TextAlignAuto: return L"Web::CssType::TextAlignAuto"; 
	case Web::CssType::TextAlignCenter: return L"Web::CssType::TextAlignCenter"; 
	case Web::CssType::TextAlignJustify: return L"Web::CssType::TextAlignJustify"; 
	case Web::CssType::TextAlignLeft: return L"Web::CssType::TextAlignLeft"; 
	case Web::CssType::TextAlignRight: return L"Web::CssType::TextAlignRight";
	}
	return NULL;
}

wchar_t* Helper::GetVerticalAlignDescr(Web::CssType::VerticalAlign vertical_align)
{
	switch(vertical_align)
	{
	case Web::CssType::VerticalAlignAuto: return L"Automatic"; 
	case Web::CssType::VerticalAlignBaseline: return L"Baseline";  
	case Web::CssType::VerticalAlignBottom: return L"Bottom"; 
	case Web::CssType::VerticalAlignMiddle: return L"Middle"; 
	case Web::CssType::VerticalAlignSub: return L"Sub-index"; 
	case Web::CssType::VerticalAlignSuper: return L"Superscript"; 
	case Web::CssType::VerticalAlignTextBottom: return L"Text-bottom"; 
	case Web::CssType::VerticalAlignTextTop: return L"Text-top"; 
	case Web::CssType::VerticalAlignTop: return L"Top";
	}
	return NULL;
}

wchar_t* Helper::GetVerticalAlignValue(Web::CssType::VerticalAlign vertical_align)
{
	switch(vertical_align)
	{
	//case Web::CssType::VerticalAlignAuto: return L"auto"; 
	case Web::CssType::VerticalAlignBaseline: return L"baseline";  
	case Web::CssType::VerticalAlignBottom: return L"bottom"; 
	case Web::CssType::VerticalAlignMiddle: return L"middle"; 
	case Web::CssType::VerticalAlignSub: return L"sub"; 
	case Web::CssType::VerticalAlignSuper: return L"super"; 
	case Web::CssType::VerticalAlignTextBottom: return L"text-bottom"; 
	case Web::CssType::VerticalAlignTextTop: return L"text-top"; 
	case Web::CssType::VerticalAlignTop: return L"top";
	}
	return NULL;
}

wchar_t* Helper::GetVerticalAlignEnum(Web::CssType::VerticalAlign vertical_align)
{
	switch(vertical_align)
	{
	case Web::CssType::VerticalAlignAuto: return L"Web::CssType::VerticalAlignAuto"; 
	case Web::CssType::VerticalAlignBaseline: return L"Web::CssType::VerticalAlignBaseline";  
	case Web::CssType::VerticalAlignBottom: return L"Web::CssType::VerticalAlignBottom"; 
	case Web::CssType::VerticalAlignMiddle: return L"Web::CssType::VerticalAlignMiddle"; 
	case Web::CssType::VerticalAlignSub: return L"Web::CssType::VerticalAlignSub"; 
	case Web::CssType::VerticalAlignSuper: return L"Web::CssType::VerticalAlignSuper"; 
	case Web::CssType::VerticalAlignTextBottom: return L"Web::CssType::VerticalAlignTextBottom"; 
	case Web::CssType::VerticalAlignTextTop: return L"Web::CssType::VerticalAlignTextTop"; 
	case Web::CssType::VerticalAlignTop: return L"Web::CssType::VerticalAlignTop";
	}
	return NULL;
}


wchar_t* Helper::GetTextDecorationDescr(Web::CssType::TextDecoration text_decoration)
{
	switch(text_decoration)
	{
	case Web::CssType::TextDecorationAuto: return L"Automatic"; 
	case Web::CssType::TextDecorationBlink: return L"Blink"; 
	case Web::CssType::TextDecorationLineThrough: return L"Line-through"; 
	case Web::CssType::TextDecorationNone: return L"None";
	case Web::CssType::TextDecorationOverline: return L"Overline"; 
	case Web::CssType::TextDecorationUnderline: return L"Underline"; 
	}
	return NULL;
}

wchar_t* Helper::GetTextDecorationValue(Web::CssType::TextDecoration text_decoration)
{
	switch(text_decoration)
	{
	//case Web::CssType::TextDecorationAuto: return L"auto"; 
	case Web::CssType::TextDecorationBlink: return L"blink"; 
	case Web::CssType::TextDecorationLineThrough: return L"line-through"; 
	case Web::CssType::TextDecorationNone: return L"none";
	case Web::CssType::TextDecorationOverline: return L"overline"; 
	case Web::CssType::TextDecorationUnderline: return L"underline"; 
	}
	return NULL;
}

wchar_t* Helper::GetTextDecorationEnum(Web::CssType::TextDecoration text_decoration)
{
	switch(text_decoration)
	{
	case Web::CssType::TextDecorationAuto: return L"Web::CssType::TextDecorationAuto"; 
	case Web::CssType::TextDecorationBlink: return L"Web::CssType::TextDecorationBlink"; 
	case Web::CssType::TextDecorationLineThrough: return L"Web::CssType::TextDecorationLineThrough"; 
	case Web::CssType::TextDecorationNone: return L"Web::CssType::TextDecorationNone";
	case Web::CssType::TextDecorationOverline: return L"Web::CssType::TextDecorationOverline"; 
	case Web::CssType::TextDecorationUnderline: return L"Web::CssType::TextDecorationUnderline"; 
	}
	return NULL;
}

wchar_t* Helper::GetVisibilityDescr(Web::CssType::Visibility visibility)
{
	switch(visibility)
	{
	case Web::CssType::VisibilityAuto: return L"Automatic"; 
	case Web::CssType::VisibilityHidden: return L"Hidden"; 
	case Web::CssType::VisibilityVisible: return L"Visible";
	}
	return NULL;
}

wchar_t* Helper::GetVisibilityValue(Web::CssType::Visibility visibility)
{
	switch(visibility)
	{
	//case Web::CssType::VisibilityAuto: return L"auto"; 
	case Web::CssType::VisibilityHidden: return L"hidden"; 
	case Web::CssType::VisibilityVisible: return L"visible";
	}
	return NULL;
}

wchar_t* Helper::GetVisibilityEnum(Web::CssType::Visibility visibility)
{
	switch(visibility)
	{
	case Web::CssType::VisibilityAuto: return L"Web::CssType::VisibilityAuto"; 
	case Web::CssType::VisibilityHidden: return L"Web::CssType::VisibilityHidden"; 
	case Web::CssType::VisibilityVisible: return L"Web::CssType::VisibilityVisible";
	}
	return NULL;
}

wchar_t* Helper::GetBorderStyleDescr(Web::CssType::BorderStyle border_style)
{
	switch(border_style)
	{
	case Web::CssType::BorderStyleAuto: return L"Automatic"; 
	case Web::CssType::BorderStyleDotted: return L"Dotted"; 
	case Web::CssType::BorderStyleGroove: return L"Groove"; 
	case Web::CssType::BorderStyleInset: return L"Inset"; 
	case Web::CssType::BorderStyleNone: return L"None"; 
	case Web::CssType::BorderStyleOutset: return L"Outset"; 
	case Web::CssType::BorderStyleRidge: return L"Ridge"; 
	case Web::CssType::BorderStyleSolid: return L"Solid"; 
	}
	return NULL;
}

wchar_t* Helper::GetBorderStyleValue(Web::CssType::BorderStyle border_style)
{
	switch(border_style)
	{
	//case Web::CssType::BorderStyleAuto: return L"auto"; 
	case Web::CssType::BorderStyleDotted: return L"dotted"; 
	case Web::CssType::BorderStyleGroove: return L"groove"; 
	case Web::CssType::BorderStyleInset: return L"inset"; 
	case Web::CssType::BorderStyleNone: return L"none"; 
	case Web::CssType::BorderStyleOutset: return L"outset"; 
	case Web::CssType::BorderStyleRidge: return L"ridge"; 
	case Web::CssType::BorderStyleSolid: return L"solid"; 
	}
	return NULL;
}

wchar_t* Helper::GetBorderStyleEnum(Web::CssType::BorderStyle border_style)
{
	switch(border_style)
	{
	case Web::CssType::BorderStyleAuto: return L"Web::CssType::BorderStyleAuto"; 
	case Web::CssType::BorderStyleDotted: return L"Web::CssType::BorderStyleDotted"; 
	case Web::CssType::BorderStyleGroove: return L"Web::CssType::BorderStyleGroove"; 
	case Web::CssType::BorderStyleInset: return L"Web::CssType::BorderStyleInset"; 
	case Web::CssType::BorderStyleNone: return L"Web::CssType::BorderStyleNone"; 
	case Web::CssType::BorderStyleOutset: return L"Web::CssType::BorderStyleOutset"; 
	case Web::CssType::BorderStyleRidge: return L"Web::CssType::BorderStyleRidge"; 
	case Web::CssType::BorderStyleSolid: return L"Web::CssType::BorderStyleSolid"; 
	}
	return NULL;
}

wchar_t* Helper::GetDisplayDescr(Web::CssType::Display display)
{
	switch(display)
	{
	case Web::CssType::DisplayAuto: return L"Automatic"; 
	case Web::CssType::DisplayBlock: return L"Block"; 	
	case Web::CssType::DisplayInline: return L"Inline"; 
	case Web::CssType::DisplayListItem: return L"List-item";
	case Web::CssType::DisplayNone: return L"None"; 
	}
	return NULL;
}

wchar_t* Helper::GetDisplayValue(Web::CssType::Display display)
{
	switch(display)
	{
	//case Web::CssType::DisplayAuto: return L"auto"; 	
	case Web::CssType::DisplayBlock: return L"block"; 
	case Web::CssType::DisplayInline: return L"inline"; 
	case Web::CssType::DisplayListItem: return L"list-item";
	case Web::CssType::DisplayNone: return L"none"; 
	}
	return NULL;
}

wchar_t* Helper::GetDisplayEnum(Web::CssType::Display display)
{
	switch(display)
	{
	case Web::CssType::DisplayAuto: return L"Web::CssType::DisplayAuto"; 	
	case Web::CssType::DisplayBlock: return L"Web::CssType::DisplayBlock"; 
	case Web::CssType::DisplayInline: return L"Web::CssType::DisplayInline"; 
	case Web::CssType::DisplayListItem: return L"Web::CssType::DisplayListItem";
	case Web::CssType::DisplayNone: return L"Web::CssType::DisplayNone"; 
	}
	return NULL;
}

wchar_t* Helper::GetCursorDescr(Web::CssType::Cursor cursor)
{
	switch(cursor)
	{
	case Web::CssType::CursorAuto: return L"Automatic"; 
	case Web::CssType::CursorCrosshair: return L"Crosshair"; 
	case Web::CssType::CursorDefault: return L"Default"; 
	case Web::CssType::CursorEResize: return L"East resize"; 
	case Web::CssType::CursorHelp: return L"Help"; 
	case Web::CssType::CursorMove: return L"Move"; 
	case Web::CssType::CursorNeResize: return L"NE resize"; 
	case Web::CssType::CursorNResize: return L"North resize"; 
	case Web::CssType::CursorNwResize: return L"NW resize"; 
	case Web::CssType::CursorPointer: return L"Pointer"; 
	case Web::CssType::CursorSeResize: return L"SE resize"; 
	case Web::CssType::CursorSResize: return L"South resize"; 
	case Web::CssType::CursorSwResize: return L"SW resize"; 
	case Web::CssType::CursorText: return L"Text";  
	case Web::CssType::CursorWait: return L"Wait";  
	case Web::CssType::CursorWResize: return L"West resize";
	}
	return NULL;
}

wchar_t* Helper::GetCursorValue(Web::CssType::Cursor cursor)
{
	switch(cursor)
	{
	//case Web::CssType::CursorAuto: return L"auto"; 
	case Web::CssType::CursorCrosshair: return L"crosshair"; 
	case Web::CssType::CursorDefault: return L"default"; 
	case Web::CssType::CursorEResize: return L"e-resize"; 
	case Web::CssType::CursorHelp: return L"help"; 
	case Web::CssType::CursorMove: return L"move"; 
	case Web::CssType::CursorNeResize: return L"ne-resize"; 
	case Web::CssType::CursorNResize: return L"n-resize"; 
	case Web::CssType::CursorNwResize: return L"nw-resize"; 
	case Web::CssType::CursorPointer: return L"pointer"; 
	case Web::CssType::CursorSeResize: return L"se-resize"; 
	case Web::CssType::CursorSResize: return L"s-resize"; 
	case Web::CssType::CursorSwResize: return L"sw_resize"; 
	case Web::CssType::CursorText: return L"text";  
	case Web::CssType::CursorWait: return L"wait";  
	case Web::CssType::CursorWResize: return L"w-resize";
	}
	return NULL;
}

wchar_t* Helper::GetCursorEnum(Web::CssType::Cursor cursor)
{
	switch(cursor)
	{
	case Web::CssType::CursorAuto: return L"Web::CssType::CursorAuto"; 
	case Web::CssType::CursorCrosshair: return L"Web::CssType::CursorCrosshair"; 
	case Web::CssType::CursorDefault: return L"Web::CssType::CursorDefault"; 
	case Web::CssType::CursorEResize: return L"Web::CssType::CursorEResize"; 
	case Web::CssType::CursorHelp: return L"Web::CssType::CursorHelp"; 
	case Web::CssType::CursorMove: return L"Web::CssType::CursorMove"; 
	case Web::CssType::CursorNeResize: return L"Web::CssType::CursorNeResize"; 
	case Web::CssType::CursorNResize: return L"Web::CssType::CursorNResize"; 
	case Web::CssType::CursorNwResize: return L"Web::CssType::CursorNwResize"; 
	case Web::CssType::CursorPointer: return L"Web::CssType::CursorPointer"; 
	case Web::CssType::CursorSeResize: return L"Web::CssType::CursorSeResize"; 
	case Web::CssType::CursorSResize: return L"Web::CssType::CursorSResize"; 
	case Web::CssType::CursorSwResize: return L"Web::CssType::CursorSwResize"; 
	case Web::CssType::CursorText: return L"Web::CssType::CursorText";  
	case Web::CssType::CursorWait: return L"Web::CssType::CursorWait";  
	case Web::CssType::CursorWResize: return L"Web::CssType::CursorWResize";
	}
	return NULL;
}

Web::CssType::Position Helper::GetPositionType(const wchar_t* text)
{
	//if (wcscmp(text, L"PositionAuto") == 0) return Web::CssType::PositionAuto; 
	if (wcscmp(text, L"PositionAbsolute")==0) return Web::CssType::PositionAbsolute;
	if (wcscmp(text, L"PositionRelative") == 0) return Web::CssType::PositionRelative;
	return Web::CssType::PositionAuto;
}

Web::CssType::FontFamily Helper::GetFontFamilyType(const wchar_t* text)
{
	//if (wcscmp(text, L"FontFamilyAuto") == 0) return Web::CssType::FontFamilyAuto, 
	if (wcscmp(text, L"FontFamilyArial") == 0) return Web::CssType::FontFamilyArial;
	if (wcscmp(text, L"FontFamilyCourier") == 0) return Web::CssType::FontFamilyCourier;
	if (wcscmp(text, L"FontFamilyTimesNewRoman") == 0) return Web::CssType::FontFamilyTimesNewRoman;  
	return Web::CssType::FontFamilyAuto;
}

Web::CssType::TextAlign Helper::GetTextAlignType(const wchar_t* text)
{
	//if (wcscmp(text, L"TextAlignAuto") == 0) return Web::CssType::TextAlignAuto, 
	if (wcscmp(text, L"TextAlignCenter") == 0) return Web::CssType::TextAlignCenter; 
	if (wcscmp(text, L"TextAlignJustify") == 0) return Web::CssType::TextAlignJustify; 
	if (wcscmp(text, L"TextAlignLeft") == 0) return Web::CssType::TextAlignLeft;
	if (wcscmp(text, L"TextAlignRight") == 0) return Web::CssType::TextAlignRight;
	return Web::CssType::TextAlignAuto;
}

Web::CssType::VerticalAlign Helper::GetVerticalAlignType(const wchar_t* text)
{
	//if (wcscmp(text, L"VerticalAlignAuto") == 0) return Web::CssType::VerticalAlignAuto, 
	if (wcscmp(text, L"VerticalAlignBaseline") == 0) return Web::CssType::VerticalAlignBaseline;
	if (wcscmp(text, L"VerticalAlignBottom") == 0) return Web::CssType::VerticalAlignBottom;
	if (wcscmp(text, L"VerticalAlignMiddle") == 0) return Web::CssType::VerticalAlignMiddle; 
	if (wcscmp(text, L"VerticalAlignSub") == 0) return Web::CssType::VerticalAlignSub;
	if (wcscmp(text, L"VerticalAlignSuper") == 0) return Web::CssType::VerticalAlignSuper; 
	if (wcscmp(text, L"VerticalAlignTextBottom") == 0) return Web::CssType::VerticalAlignTextBottom; 
	if (wcscmp(text, L"VerticalAlignTextTop") == 0) return Web::CssType::VerticalAlignTextTop;
	if (wcscmp(text, L"VerticalAlignTop") == 0) return Web::CssType::VerticalAlignTop;
	return Web::CssType::VerticalAlignAuto;
}

Web::CssType::TextDecoration Helper::GetTextDecorationType(const wchar_t* text)
{
	//if (wcscmp(text, L"TextDecorationAuto") == 0) return Web::CssType::TextDecorationAuto, 
	if (wcscmp(text, L"TextDecorationBlink") == 0) return Web::CssType::TextDecorationBlink;
	if (wcscmp(text, L"TextDecorationLineThrough") == 0) return Web::CssType::TextDecorationLineThrough; 
	if (wcscmp(text, L"TextDecorationNone") == 0) return Web::CssType::TextDecorationNone;
	if (wcscmp(text, L"TextDecorationOverline") == 0) return Web::CssType::TextDecorationOverline; 
	if (wcscmp(text, L"TextDecorationUnderline") == 0) return Web::CssType::TextDecorationUnderline;
	return Web::CssType::TextDecorationAuto;
}

Web::CssType::Visibility Helper::GetVisibilityType(const wchar_t* text)
{
	//if (wcscmp(text, L"VisibilityAuto") == 0) return Web::CssType::VisibilityAuto, 
	if (wcscmp(text, L"VisibilityHidden") == 0) return Web::CssType::VisibilityHidden;
	if (wcscmp(text, L"VisibilityVisible") == 0) return Web::CssType::VisibilityVisible;
	return Web::CssType::VisibilityAuto;
}

Web::CssType::BorderStyle Helper::GetBorderStyleType(const wchar_t* text)
{
	//if (wcscmp(text, L"BorderStyleAuto") == 0) return Web::CssType::BorderStyleAuto, 
	if (wcscmp(text, L"BorderStyleDotted") == 0) return Web::CssType::BorderStyleDotted;
	if (wcscmp(text, L"BorderStyleGroove") == 0) return Web::CssType::BorderStyleGroove; 
	if (wcscmp(text, L"BorderStyleInset") == 0) return Web::CssType::BorderStyleInset;
	if (wcscmp(text, L"BorderStyleNone") == 0) return Web::CssType::BorderStyleNone; 
	if (wcscmp(text, L"BorderStyleOutset") == 0) return Web::CssType::BorderStyleOutset; 
	if (wcscmp(text, L"BorderStyleRidge") == 0) return Web::CssType::BorderStyleRidge;
	if (wcscmp(text, L"BorderStyleSolid") == 0) return Web::CssType::BorderStyleSolid;
	return Web::CssType::BorderStyleAuto;
}

Web::CssType::Display Helper::GetDisplayType(const wchar_t* text)
{
	//if (wcscmp(text, L"DisplayAuto") == 0) return Web::CssType::DisplayAuto, 
	if (wcscmp(text, L"DisplayBlock") == 0) return Web::CssType::DisplayBlock;
	if (wcscmp(text, L"DisplayInline") == 0) return Web::CssType::DisplayInline; 
	if (wcscmp(text, L"DisplayListItem") == 0) return Web::CssType::DisplayListItem;
	if (wcscmp(text, L"DisplayNone") == 0) return Web::CssType::DisplayNone;
	return Web::CssType::DisplayAuto;
}

Web::CssType::Cursor Helper::GetCursorType(const wchar_t* text)
{
	//if (wcscmp(text, L"CursorAuto") == 0) return Web::CssType::CursorAuto;
	if (wcscmp(text, L"CursorCrosshair") == 0) return Web::CssType::CursorCrosshair;
	if (wcscmp(text, L"CursorDefault") == 0) return Web::CssType::CursorDefault;
	if (wcscmp(text, L"CursorEResize") == 0) return Web::CssType::CursorEResize; 
	if (wcscmp(text, L"CursorHelp") == 0) return Web::CssType::CursorHelp;
	if (wcscmp(text, L"CursorMove") == 0) return Web::CssType::CursorMove;
	if (wcscmp(text, L"CursorNeResize") == 0) return Web::CssType::CursorNeResize; 
	if (wcscmp(text, L"CursorNResize") == 0) return Web::CssType::CursorNResize;
	if (wcscmp(text, L"CursorNwResize") == 0) return Web::CssType::CursorNwResize; 
	if (wcscmp(text, L"CursorPointer") == 0) return Web::CssType::CursorPointer;
	if (wcscmp(text, L"CursorSeResize") == 0) return Web::CssType::CursorSeResize; 
	if (wcscmp(text, L"CursorSResize") == 0) return Web::CssType::CursorSResize;
	if (wcscmp(text, L"CursorSwResize") == 0) return Web::CssType::CursorSwResize; 
	if (wcscmp(text, L"CursorText") == 0) return Web::CssType::CursorText;
	if (wcscmp(text, L"CursorWait") == 0) return Web::CssType::CursorWait;
	if (wcscmp(text, L"CursorWResize") == 0) return Web::CssType::CursorWResize;
	return Web::CssType::CursorAuto;
}

Web::CssType::OverflowX Helper::GetOverflowXType(const wchar_t* text)
{
	//if (wcscmp(text, L"OverflowXNone") == 0) 
	if (wcscmp(text, L"OverflowXVisible")==0) return Web::CssType::OverflowXVisible; 
	if (wcscmp(text, L"OverflowXHidden")==0) return Web::CssType::OverflowXHidden; 
	if (wcscmp(text, L"OverflowXScroll")==0)  return Web::CssType::OverflowXScroll; 
	if (wcscmp(text, L"OverflowXAuto")==0)  return Web::CssType::OverflowXAuto; 
	if (wcscmp(text, L"OverflowXInherit")==0)  return Web::CssType::OverflowXInherit; 
	return Web::CssType::OverflowXNone;
}

Web::CssType::OverflowY Helper::GetOverflowYType(const wchar_t* text)
{
	//if (wcscmp(text, L"OverflowYNone") == 0) 
	if (wcscmp(text, L"OverflowYVisible")==0) return Web::CssType::OverflowYVisible; 
	if (wcscmp(text, L"OverflowYHidden")==0) return Web::CssType::OverflowYHidden; 
	if (wcscmp(text, L"OverflowYScroll")==0)  return Web::CssType::OverflowYScroll; 
	if (wcscmp(text, L"OverflowYAuto")==0)  return Web::CssType::OverflowYAuto; 
	if (wcscmp(text, L"OverflowYInherit")==0)  return Web::CssType::OverflowYInherit; 
	return Web::CssType::OverflowYNone;
}

wchar_t* Helper::GetOverflowXValue(Web::CssType::OverflowX overflowX)
{
	switch(overflowX)
	{
	//case Web::CssType::OverflowXNone = 0x00000000, 
	case Web::CssType::OverflowXVisible: return L"visible"; 
	case Web::CssType::OverflowXHidden: return L"hidden"; 
	case Web::CssType::OverflowXScroll: return L"scroll"; 
	case Web::CssType::OverflowXAuto: return L"auto"; 
	case Web::CssType::OverflowXInherit: return L"inherit"; 
	}
	return NULL;
}

wchar_t* Helper::GetOverflowXEnum(Web::CssType::OverflowX overflowX)
{
	switch(overflowX)
	{
	case Web::CssType::OverflowXNone: return L"Web::CssType::OverflowXNone";
	case Web::CssType::OverflowXVisible: return L"Web::CssType::OverflowXVisible"; 
	case Web::CssType::OverflowXHidden: return L"Web::CssType::OverflowXHidden"; 
	case Web::CssType::OverflowXScroll: return L"Web::CssType::OverflowXScroll"; 
	case Web::CssType::OverflowXAuto: return L"Web::CssType::OverflowXAuto"; 
	case Web::CssType::OverflowXInherit: return L"Web::CssType::OverflowXInherit"; 
	}
	return NULL;
}

wchar_t* Helper::GetOverflowYValue(Web::CssType::OverflowY overflowY)
{
	switch(overflowY)
	{
	//case Web::CssType::OverflowYNone = 0x00000000, 
	case Web::CssType::OverflowYVisible: return L"visible"; 
	case Web::CssType::OverflowYHidden: return L"hidden"; 
	case Web::CssType::OverflowYScroll: return L"scroll"; 
	case Web::CssType::OverflowYAuto: return L"auto"; 
	case Web::CssType::OverflowYInherit: return L"inherit"; 
	}
	return NULL;
}

wchar_t* Helper::GetOverflowYEnum(Web::CssType::OverflowY overflowY)
{
	switch(overflowY)
	{
	case Web::CssType::OverflowYNone: return L"Web::CssType::OverflowYNone";
	case Web::CssType::OverflowYVisible: return L"Web::CssType::OverflowYVisible"; 
	case Web::CssType::OverflowYHidden: return L"Web::CssType::OverflowYHidden"; 
	case Web::CssType::OverflowYScroll: return L"Web::CssType::OverflowYScroll"; 
	case Web::CssType::OverflowYAuto: return L"Web::CssType::OverflowYAuto"; 
	case Web::CssType::OverflowYInherit: return L"Web::CssType::OverflowYInherit"; 
	}
	return NULL;
}


//__________________________________________________ HttpConnector
HttpConnector::HttpConnector(EXTENSION_CONTROL_BLOCK* pECB)
{
	httpCode = 200; // 200 OK
	ContentType = HTML_CONTENT_TYPE_TEXT_HTML;
	postData = NULL;
	windowID[0] = '\0';
	this->pECB = NULL;
	if (pECB != NULL) this->pECB = pECB;
	_hasRequestBeenHandled = false;
	ReadQueryString();
	ReadPostData();
	UpdateUrl();

	//__________________________________  Is XML?
	multimap<wstring, wstring>::iterator p; 
	p = value.find(L"ajax");
	if (p != value.end())
	{
		ContentType = HTML_CONTENT_TYPE_TEXT_XML;
		p = value.find(L"windowID");
		if (p != value.end())
		{
			_snwprintf_s(windowID, 64, _TRUNCATE, L"%s", p->second.c_str());
		}
		return;
	}
	
	//_________________________________________ Is custom image?
	p = value.find(L"windowID");
	if (p == value.end()) return;
	//__________________________________  Is ProgressBar?
	if (p->second == L"ProgressBar")
	{
		ContentType = HTML_CONTENT_TYPE_IMAGE_GIF;
		_hasRequestBeenHandled = true;
		Web::ProgressBar chart;
		//chart.Sync(*this);
		chart.RenderImage(responseData);
	}
#ifdef WIN_GDI_PLUS_ON
	//__________________________________  Is BarChart?
	else if (p->second == L"BarChart")
	{
		ContentType = HTML_CONTENT_TYPE_IMAGE_PNG;
		_hasRequestBeenHandled = true;
		Web::BarChart chart;
		chart.Sync(*this);
		chart.RenderImage(responseData);
	}
	//__________________________________  Is PolarChart?
	else if (p->second == L"PolarChart")
	{
		ContentType = HTML_CONTENT_TYPE_IMAGE_PNG;
		_hasRequestBeenHandled = true;
		Web::PolarChart chart;
		chart.Sync(*this);
		chart.RenderImage(responseData);
	}
	//__________________________________  Is PieChart?
	else if (p->second == L"PieChart")
	{
		ContentType = HTML_CONTENT_TYPE_IMAGE_PNG;
		_hasRequestBeenHandled = true;
		Web::PieChart chart;
		chart.Sync(*this);
		chart.RenderImage(responseData);
	}
	//__________________________________  Is XyChart?
	else if (p->second == L"XyChart")
	{
		ContentType = HTML_CONTENT_TYPE_IMAGE_PNG;
		_hasRequestBeenHandled = true;
		Web::XyChart chart;
		chart.Sync(*this);
		chart.RenderImage(responseData);
	}
	//__________________________________  Is Histogram?
	else if (p->second == L"Histogram")
	{
		ContentType = HTML_CONTENT_TYPE_IMAGE_PNG;
		_hasRequestBeenHandled = true;
		Web::Histogram chart;
		chart.Sync(*this);
		chart.RenderImage(responseData);
	}
#endif
	_snwprintf_s(windowID, 64, _TRUNCATE, L"%s", p->second.c_str());
}

HttpConnector::~HttpConnector()
{
	if (postData != NULL) delete [] postData;
}

bool HttpConnector::IsFirstTime()
{
	multimap<wstring, wstring>::iterator state;
	//____________________________________ ajax?
	state = value.find(L"ajax");
	if (state != value.end())
	{
		if (Sys::Convert::ToBool(state->second) == true) return false;
	}
	//____________________________________ onclickSrc ?
	state = value.find(L"onclickSrc");
	if (state == value.end()) return true;
	if (state->second == L"0") return true;
	return false;
}

//returns any of:
//HTML_BROWSER_UNKNOWN
//HTML_BROWSER_IE
//HTML_BROWSER_SAFARI
//HTML_BROWSER_CHROME
//HTML_BROWSER_OPERA
//HTML_BROWSER_FIREFOX
int HttpConnector::GetExplorerID()
{
	wstring user_agent;
	if (this->GetServerVariable("HTTP_USER_AGENT", user_agent) == false) return HTML_BROWSER_UNKNOWN;

	std::transform(user_agent.begin(), user_agent.end(), user_agent.begin(), toupper);
	size_t pos = user_agent.find(L"MSIE");
	if (pos != std::wstring::npos) return HTML_BROWSER_IE;
	//
	pos = user_agent.find(L"SAFARI");
	if (pos != std::wstring::npos) return HTML_BROWSER_SAFARI;
	//
	pos = user_agent.find(L"CHROME");
	if (pos != std::wstring::npos) return HTML_BROWSER_CHROME;
	//
	pos = user_agent.find(L"OPERA");
	if (pos != std::wstring::npos) return HTML_BROWSER_OPERA;
	//
	pos = user_agent.find(L"FIREFOX");
	if (pos != std::wstring::npos) return HTML_BROWSER_FIREFOX;
	//
	return HTML_BROWSER_UNKNOWN;
}

void HttpConnector::UpdateUrl()
{
	wstring unencoded_url;
	if (this->GetServerVariable("HTTP_HOST", url) == false)
	{
		url.clear();
		return;
	}
	if (this->GetServerVariable("UNENCODED_URL", unencoded_url)==false)
	{
		url.clear();
		return;
	}
	//___________________________________ Remove after question mark
	size_t pos = unencoded_url.find('?');
	if (pos != std::wstring::npos)
	{
		unencoded_url.resize(pos);
	}
	url += unencoded_url;
}

void HttpConnector::SetRequestEvent()
{
	_hasRequestBeenHandled = true;
}

bool HttpConnector::ReadPostData()
{
	if (pECB == NULL) return false;
	const DWORD len = pECB->cbTotalBytes;
	if (len == 0) return true;
	if (postData != NULL) delete [] postData;
	postData = new char[len]; 
	if (postData == NULL) return false;

	::memcpy_s(postData, len, pECB->lpbData, pECB->cbAvailable);//strncpy(lpszTemp, (CHAR *)pECB->lpbData, pECB->cbAvailable ); 

	DWORD remaining = pECB->cbTotalBytes - pECB->cbAvailable; 
	if (remaining > 0)
	{
		pECB->ReadClient(pECB->ConnID, (LPVOID)(postData+pECB->cbAvailable), &remaining);
	}
	wstring value;
	if (GetServerVariable("CONTENT_TYPE", value) == true)
	{
		if (value.find(L"form-urlencoded") != std::wstring::npos) ReadVariables(postData, len);
	}
	
	return true;
}

void HttpConnector::ReadQueryString()
{
	if (pECB == NULL) return;
	if (pECB->lpszQueryString == NULL) return;
	const int len = strlen(pECB->lpszQueryString); 
	ReadVariables(pECB->lpszQueryString, len);
}

void HttpConnector::ReadVariables(const char* data, DWORD len)
{
	if (len == 0) return;
	len++; // We add one to consider a last &
	string name;
	wstring wname;
	string utf8name;
	//
	string val;
	wstring wval;
	string utf8val;
	//
	size_t posIni = 0;
	size_t posEqual = 0;
	DWORD i;
	bool isName = true;
	char c;
	for(i = 0; i<len; i++)
	{
		if (i == len-1)
		{
			c = '&'; // We append a last & to separate the last data
		}
		else
		{
			c = data[i];
		}
		if (c == '&')
		{
			if (isName == true)
			{
			}
			else
			{
				Sys::Convert::HexToUTF8(name.c_str(), utf8name);
				Sys::Convert::HexToUTF8(val.c_str(), utf8val);
				//
				Sys::Convert::UTF8ToWstring(utf8name, wname);
				Sys::Convert::UTF8ToWstring(utf8val, wval);
				value.insert(pair<wstring, wstring>(wname, wval));
				isName = true;
				name.clear();
				val.clear();
			}
		}
		else if (c == '=')
		{
			if (isName == true)
			{
				isName = false;
			}
			else
			{
			}
		}
		else
		{
			if (isName == true)
			{
				name += c;
			}
			else
			{
				val += c;
			}
		}
	}	
}

char* HttpConnector::GetMimeContentType(const char* fileExtension)
{
	if (strcmp(fileExtension, "htm") == 0) return "text/html";
	if (strcmp(fileExtension, "html") == 0) return "text/html";
	if (strcmp(fileExtension, "txt") == 0) return "text/plain";
	if (strcmp(fileExtension, "css") == 0) return "text/css";
	if (strcmp(fileExtension, "csv") == 0) return "text/plain";
	if (strcmp(fileExtension, "xml") == 0) return "text/plain";
	if (strcmp(fileExtension, "svg") == 0) return "text/plain";
	if (strcmp(fileExtension, "h") == 0) return "text/plain";
	if (strcmp(fileExtension, "c") == 0) return "text/plain";
	if (strcmp(fileExtension, "cpp") == 0) return "text/plain";
	if (strcmp(fileExtension, "m") == 0) return "text/plain";
	if (strcmp(fileExtension, "talk") == 0) return "text/x-speech";
	if (strcmp(fileExtension, "css") == 0) return "text/css";
	if (strcmp(fileExtension, "gif") == 0) return "image/gif";
	if (strcmp(fileExtension, "xbm") == 0) return "image/x-xbitmap";
	if (strcmp(fileExtension, "xpm") == 0) return "image/x-xpixmap";
	if (strcmp(fileExtension, "png") == 0) return "image/x-png";
	if (strcmp(fileExtension, "ief") == 0) return "image/ief";
	if (strcmp(fileExtension, "jpg") == 0) return "image/jpeg";
	if (strcmp(fileExtension, "tiff") == 0) return "image/tiff";
	if (strcmp(fileExtension, "tif") == 0) return "image/tiff";
	if (strcmp(fileExtension, "rgb") == 0) return "image/rgb";
	if (strcmp(fileExtension, "g3f") == 0) return "image/g3fax";
	if (strcmp(fileExtension, "xwd") == 0) return "image/x-xwindowdump";
	if (strcmp(fileExtension, "pict") == 0) return "image/x-pict";
	if (strcmp(fileExtension, "ppm") == 0) return "image/x-portable-pixmap";
	if (strcmp(fileExtension, "pgm") == 0) return "image/x-portable-graymap";
	if (strcmp(fileExtension, "pbm") == 0) return "image/x-portable-bitmap";
	if (strcmp(fileExtension, "pnm") == 0) return "image/x-portable-anymap";
	if (strcmp(fileExtension, "bmp") == 0) return "image/x-ms-bmp";
	if (strcmp(fileExtension, "ras") == 0) return "image/x-cmu-raster";
	if (strcmp(fileExtension, "pcd") == 0) return "image/x-photo-cd";
	if (strcmp(fileExtension, "cgm") == 0) return "image/cgm";
	if (strcmp(fileExtension, "cal") == 0) return "image/x-cals";
	if (strcmp(fileExtension, "fif") == 0) return "image/fif";
	if (strcmp(fileExtension, "dsf") == 0) return "image/x-mgx-dsf";
	if (strcmp(fileExtension, "cmx") == 0) return "image/x-cmx";
	if (strcmp(fileExtension, "wi") == 0) return "image/wavelet";
	if (strcmp(fileExtension, "dwg") == 0) return "image/vnd.dwg";
	if (strcmp(fileExtension, "dxf") == 0) return "image/vnd.dxf";
	if (strcmp(fileExtension, "svf") == 0) return "image/vnd.svf";
	if (strcmp(fileExtension, "aif") == 0) return "audio/x-aiff";
	if (strcmp(fileExtension, "wav") == 0) return "audio/x-wav";
	if (strcmp(fileExtension, "es") == 0) return "audio/echospeech";
	if (strcmp(fileExtension, "vox") == 0) return "audio/voxware";
	if (strcmp(fileExtension, "lcc") == 0) return "application/fastman";
	if (strcmp(fileExtension, "mmid") == 0) return "x-music/x-midi";
	if (strcmp(fileExtension, "skp") == 0) return "application/vnd.koan";
	if (strcmp(fileExtension, "talk") == 0) return "text/x-speech";
	if (strcmp(fileExtension, "mpeg") == 0) return "video/mpeg";
	if (strcmp(fileExtension, "mov") == 0) return "video/quicktime";
	if (strcmp(fileExtension, "avi") == 0) return "video/x-msvideo";
	if (strcmp(fileExtension, "movie") == 0) return "video/x-sgi-movie";
	if (strcmp(fileExtension, "vdo") == 0) return "video/vdo";
	if (strcmp(fileExtension, "viv") == 0) return "video/vnd.vivo";
	if (strcmp(fileExtension, "pac") == 0) return "application/x-ns-proxy-autoconfig";
	if (strcmp(fileExtension, "ice") == 0) return "x-conference/x-cooltalk";
	if (strcmp(fileExtension, "ps") == 0) return "application/postscript";
	if (strcmp(fileExtension, "eps") == 0) return "application/postscript";
	if (strcmp(fileExtension, "rtf") == 0) return "application/rtf";
	if (strcmp(fileExtension, "pdf") == 0) return "application/pdf";
	if (strcmp(fileExtension, "cdr") == 0) return "application/cdr";
	if (strcmp(fileExtension, "mif") == 0) return "application/vnd.mif";
	if (strcmp(fileExtension, "roff") == 0) return "application/x-troff";
	if (strcmp(fileExtension, "man") == 0) return "application/x-troff-man";
	if (strcmp(fileExtension, "me") == 0) return "application/x-troff-me";
	if (strcmp(fileExtension, "ms") == 0) return "application/x-troff-ms";
	if (strcmp(fileExtension, "latex") == 0) return "application/x-latex";
	if (strcmp(fileExtension, "tex") == 0) return "application/x-tex";
	if (strcmp(fileExtension, "texinfo") == 0) return "application/x-texinfo";
	if (strcmp(fileExtension, "dvi") == 0) return "application/x-dvi";
	if (strcmp(fileExtension, "oda") == 0) return "application/oda";
	if (strcmp(fileExtension, "evy") == 0) return "application/envoy";
	if (strcmp(fileExtension, "gtar") == 0) return "application/x-gtar";
	if (strcmp(fileExtension, "tar") == 0) return "application/x-tar";
	if (strcmp(fileExtension, "ustar") == 0) return "application/x-ustar";
	if (strcmp(fileExtension, "bcpio") == 0) return "application/x-bcpio";
	if (strcmp(fileExtension, "cpio") == 0) return "application/x-cpio";
	if (strcmp(fileExtension, "shar") == 0) return "application/x-shar";
	if (strcmp(fileExtension, "zip") == 0) return "application/zip";
	if (strcmp(fileExtension, "hqx") == 0) return "application/mac-binhex40";
	if (strcmp(fileExtension, "sit") == 0) return "application/x-stuffit";
	if (strcmp(fileExtension, "fif") == 0) return "application/fractals";
	if (strcmp(fileExtension, "bin") == 0) return "application/octet-stream";
	if (strcmp(fileExtension, "lib") == 0) return "application/octet-stream";
	if (strcmp(fileExtension, "dll") == 0) return "application/octet-stream";
	if (strcmp(fileExtension, "exe") == 0) return "application/octet-stream";
	if (strcmp(fileExtension, "hdf") == 0) return "application/hdf";
	if (strcmp(fileExtension, "js") == 0) return "text/javascript";
	if (strcmp(fileExtension, "sh") == 0) return "application/x-sh";
	if (strcmp(fileExtension, "csh") == 0) return "application/x-csh";
	if (strcmp(fileExtension, "pl") == 0) return "application/x-perl";
	if (strcmp(fileExtension, "tcl") == 0) return "application/x-tcl";
	if (strcmp(fileExtension, "spl") == 0) return "application/futuresplash";
	if (strcmp(fileExtension, "mbd") == 0) return "application/mbedlet";
	if (strcmp(fileExtension, "rad") == 0) return "application/x-rad-powermedia";
	if (strcmp(fileExtension, "ppz") == 0) return "application/mspowerpoint";
	if (strcmp(fileExtension, "asp") == 0) return "application/x-asap";
	if (strcmp(fileExtension, "asn") == 0) return "application/astound";
	if (strcmp(fileExtension, "axs") == 0) return "application/x-olescript";
	if (strcmp(fileExtension, "ods") == 0) return "application/x-oleobject";
	if (strcmp(fileExtension, "opp") == 0) return "x-form/x-openscape";
	if (strcmp(fileExtension, "wba") == 0) return "application/x-webbasic";
	if (strcmp(fileExtension, "frm") == 0) return "application/x-alpha-form";
	if (strcmp(fileExtension, "wfx") == 0) return "x-script/x-wfxclient";
	if (strcmp(fileExtension, "pcn") == 0) return "application/x-pcn";
	if (strcmp(fileExtension, "xlsx") == 0) return "application/x-msexcel";
	if (strcmp(fileExtension, "xls") == 0) return "application/ms-excel";
	if (strcmp(fileExtension, "docx") == 0) return "application/x-msword";
	if (strcmp(fileExtension, "doc") == 0) return "application/ms-word";
	if (strcmp(fileExtension, "ppt") == 0) return "application/ms-powerpoint";
	if (strcmp(fileExtension, "pptx") == 0) return "application/x-mspowerpoint";
	if (strcmp(fileExtension, "svd") == 0) return "application/vnd.svd";
	if (strcmp(fileExtension, "ins") == 0) return "application/x-net-install";
	if (strcmp(fileExtension, "ccv") == 0) return "application/ccv";
	if (strcmp(fileExtension, "vts") == 0) return "workbook/formulaone";
	if (strcmp(fileExtension, "vrw") == 0) return "x-world/x-vream";
	if (strcmp(fileExtension, "p3d") == 0) return "application/x-p3d";
	if (strcmp(fileExtension, "svr") == 0) return "x-world/x-svr";
	if (strcmp(fileExtension, "wvr") == 0) return "x-world/x-wvr";
	if (strcmp(fileExtension, "3dmf") == 0) return "x-world/x-3dmf";
	if (strcmp(fileExtension, "ma") == 0) return "application/mathematica";
	if (strcmp(fileExtension, "v5d") == 0) return "application/vis5d";
	if (strcmp(fileExtension, "dwf") == 0) return "drawing/x-dwf";
	if (strcmp(fileExtension, "show") == 0) return "application/x-showcase";
	if (strcmp(fileExtension, "ins") == 0) return "application/x-insight";
	if (strcmp(fileExtension, "ano") == 0) return "application/x-annotator";
	if (strcmp(fileExtension, "dir") == 0) return "application/x-dirview";
	if (strcmp(fileExtension, "lic") == 0) return "application/x-enterlicense";
	if (strcmp(fileExtension, "faxmgr") == 0) return "application/x-fax-manager";
	if (strcmp(fileExtension, "faxmgrjob") == 0) return "application/x-fax-manager-job";
	if (strcmp(fileExtension, "icnbk") == 0) return "application/x-iconbook";
	if (strcmp(fileExtension, "wb") == 0) return "application/x-inpview";
	if (strcmp(fileExtension, "inst") == 0) return "application/x-install";
	if (strcmp(fileExtension, "mail") == 0) return "application/x-mailfolder";
	if (strcmp(fileExtension, "pp") == 0) return "application/x-ppages";
	if (strcmp(fileExtension, "sgi-lpr") == 0) return "application/x-sgi-lpr";
	if (strcmp(fileExtension, "tardist") == 0) return "application/x-tardist";
	if (strcmp(fileExtension, "ztardist") == 0) return "application/x-ztardist";
	if (strcmp(fileExtension, "wkz") == 0) return "application/x-wingz";
	if (strcmp(fileExtension, "iv") == 0) return "graphics/x-inventor";
	return "application/octet-stream";
}

void HttpConnector::GetHttpDateHeader(char* buffer, int bufferSize)
{
	const char* days[]={"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};
	const char* months[]={"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
		//_______________________________ rfc1123-date
	SYSTEMTIME now;
	::GetSystemTime(&now); // UTC time
	_snprintf_s(buffer, bufferSize, _TRUNCATE, "Date: %s, %02d %s %04d %02d:%02d:%02d GMT\r\n", 
		days[now.wDayOfWeek], now.wDay, months[now.wMonth-1], now.wYear,
		now.wHour, now.wMinute, now.wSecond);

	//HTTP-date    = rfc1123-date | rfc850-date | asctime-date
//       rfc1123-date = wkday "," SP date1 SP time SP "GMT"
//       rfc850-date  = weekday "," SP date2 SP time SP "GMT"
//       asctime-date = wkday SP date3 SP time SP 4DIGIT
//       date1        = 2DIGIT SP month SP 4DIGIT
//                      ; day month year (e.g., 02 Jun 1982)
//       date2        = 2DIGIT "-" month "-" 2DIGIT
//                      ; day-month-year (e.g., 02-Jun-82)
//       date3        = month SP ( 2DIGIT | ( SP 1DIGIT ))
//                      ; month day (e.g., Jun  2)
//       time         = 2DIGIT ":" 2DIGIT ":" 2DIGIT
//                      ; 00:00:00 - 23:59:59
//       wkday        = "Mon" | "Tue" | "Wed"
//                    | "Thu" | "Fri" | "Sat" | "Sun"
//       weekday      = "Monday" | "Tuesday" | "Wednesday"
//                    | "Thursday" | "Friday" | "Saturday" | "Sunday"
//       month        = "Jan" | "Feb" | "Mar" | "Apr"
//                    | "May" | "Jun" | "Jul" | "Aug"
//                    | "Sep" | "Oct" | "Nov" | "Dec"
}

void HttpConnector::GetTimeHeader(char* buffer, int bufferSize)
{
	const char* days[]={"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};
	const char* months[]={"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
	
	//_______________________________ Get Date and Time
	SYSTEMTIME now;
	::GetLocalTime(&now);

	//_______________________________ Get Time Zone
	TIME_ZONE_INFORMATION timeZoneInfo;
	const DWORD zoneId = ::GetTimeZoneInformation(&timeZoneInfo);
	
	int hours=(int)(timeZoneInfo.Bias/60);
	int minutes=(int)(timeZoneInfo.Bias%60);
	if (zoneId==TIME_ZONE_ID_STANDARD)
	{
		hours+=(int)(timeZoneInfo.StandardBias/60);
		minutes+=(int)(timeZoneInfo.StandardBias%60);
	}
	else
	{
		hours+=(int)(timeZoneInfo.DaylightBias/60);
		minutes+=(int)(timeZoneInfo.DaylightBias%60);
	}
	const char zone = (hours<0) ? '+' : '-';
	const int year = now.wYear - (now.wYear/100)*100;
	_snprintf_s(buffer, bufferSize, _TRUNCATE, "Date: %s, %02d %s %02d %02d:%02d:%02d %c%02d%02d\r\n", 
		days[now.wDayOfWeek], now.wDay, months[now.wMonth-1], year,
		now.wHour, now.wMinute, now.wSecond, zone, hours, minutes);
}

char* HttpConnector::GetHttpCodeDescr(int code)
{
	switch(code)
	{
	//_______________________________________Informational - Request received, continuing process
	case 100: return "100 Continue";
	case 101: return "101 Switching Protocols";
	//_______________________________________Informational - Request received, continuing process
	case 200: return "200 OK";
	case 201: return "201 Created";
	case 202: return "202 Accepted";
	case 203: return "203 Non-Authoritative Information";
	case 204: return "204 No Content";
	case 205: return "205 Reset Content";
	case 206: return "206 Partial Content";
	//_______________________________________Redirection - Further action must be taken in order tocomplete the request
	case 300: return "300 Multiple Choices";
	case 301: return "301 Moved Permanently";
	case 302: return "302 Found";
	case 303: return "303 See Other";
	case 304: return "304 Not Modified";
	case 305: return "305 Use Proxy";
	case 307: return "307 Temporary Redirect";
	//_______________________________________Client Error - The request contains bad syntax or cannot be fulfilled
	case 400: return "400 Bad Request";
	case 401: return "401 Unauthorized";  //WWW-Authenticate: Basic realm="WallyWorld"
	case 402: return "402 Payment Required";
	case 403: return "403 Forbidden"; 
	case 404: return "404 Not Found";
	case 405: return "405 Method Not Allowed";
	case 406: return "406 Not Acceptable";
	case 407: return "407 Proxy Authentication Required";
	case 408: return "408 Request Time-out";
	case 409: return "409 Conflict";
	case 410: return "410 Gone";
	case 411: return "411 Length Required";
	case 412: return "412 Precondition Failed";
	case 413: return "413 Request Entity Too Large";
	case 414: return "414 Request-URI Too Large";
	case 415: return "415 Unsupported Media Type";
	case 416: return "416 Requested range not satisfiable";
	case 417: return "417 Expectation Failed";
	//_______________________________________Server Error - The server failed to fulfill an apparently valid request
	case 500: return "500 Internal Server Error";
	case 501: return "501 Not Implemented";
	case 502: return "502 Bad Gateway";
	case 503: return "503 Service Unavailable";
	case 504: return "504 Gateway Time-out";
	case 505: return "505 HTTP Version not supported";
	}
	return "500 Internal Server Error";
}

void HttpConnector::AddVariable(const wchar_t* variableName, const wchar_t* variableValue)
{
	value.insert(pair<wstring, wstring>(variableName, variableValue));
}

bool HttpConnector::SetVariable(const wchar_t* variableName, const wchar_t* variableValue)
{
	multimap<wstring, wstring>::iterator p = value.find(variableName);
	if (p == value.end()) return false;
	p->second = variableValue;
	return true;
}

bool HttpConnector::GetVariable(const wchar_t* variableName, wstring& out_variableValue)
{
	multimap<wstring, wstring>::iterator p = value.find(variableName);
	if (p == value.end()) return false;
	out_variableValue = p->second;
	return true;
}


bool HttpConnector::HasRequestBeenHandled()
{
	return _hasRequestBeenHandled;
}

void HttpConnector::NavigateTo(const wchar_t* windowID)
{
	if (windowID == NULL) return;
	if (wcslen(windowID) == 0) return;
	_hasRequestBeenHandled = false;
	_snwprintf_s(this->windowID, 64, _TRUNCATE, L"%s", windowID);

	multimap<wstring, wstring>::iterator state;
	//_________________________________________ remove onclickSrc
	state = value.find(L"onclickSrc");
	if (state == value.end()) return;
	value.erase(state);
	//_________________________________________ replace windowID in the values
	state = value.find(L"windowID");
	if (state == value.end()) return;
	state->second = windowID;
}

  BOOL (WINAPI * GetServerVariable) ( HCONN       hConn,
                                        LPSTR       lpszVariableName,
                                        LPVOID      lpvBuffer,
                                        LPDWORD     lpdwSize );

bool HttpConnector::IsIndent()
{
	if (pECB == NULL) return false;
	DWORD dwSize = 32;
	char buffer[32];
	buffer[0] = '\0';
	if (pECB->GetServerVariable(pECB->ConnID, "WIN_INDENT", buffer, &dwSize)== TRUE)
	{
		if (strlen(buffer) > 0) return true;
	}
	return false;
}

wchar_t* HttpConnector::GetWindowID()
{
	return windowID;
}

bool HttpConnector::CheckEvent(const wstring& ID, int notification)
{
	multimap<wstring, wstring>::iterator p;

	//______________________________________ Submit Buttons
	p = value.find(L"onclickSrc");
	if (p != value.end())
	{
		if (p->second == ID && notification == HTML_CLICK) return true;
	}

	//______________________________________ Check sourceID
	p = value.find(L"sourceID");
	if (p == value.end()) return false;
	if (p->second != ID) return false;
	//______________________________________ Check eventID
	p = value.find(L"eventID");
	if (p == value.end()) return false;
	wchar_t * eventShortName = Web::Helper::GetEventShortName(notification);
	if (eventShortName == NULL) return false;
	if (p->second != eventShortName) return false;
	return true;
}

bool HttpConnector::GetServerVariable(char* variableName, char* buffer, DWORD bufferLen)
{
	if (pECB == NULL)
	{
		buffer[0] = '\0';
		return false;
	}
	if (pECB->GetServerVariable(pECB->ConnID, variableName, buffer, &bufferLen)== TRUE) return true;
	return false;
}

// AUTH_PASSWORD, AUTH_USER, QUERY_STRING,SCRIPT_NAME
// SERVER_NAME, REQUEST_METHOD, SERVER_PORT, HTTP_ACCEPT
// HTTP_ACCEPT_LANGUAGE, HTTP_CONNECTION, HTTP_HOST
// HTTP_USER_AGENT, HTTP_ACCEPT_ENCODING, AUTH_TYPE
// CONTENT_LENGTH, CONTENT_TYPE, HTTP_URL, UNENCODED_URL
// URL
bool HttpConnector::GetServerVariable(char* variableName, string& out_value)
{
	if (pECB == NULL)
	{
		out_value.clear();
		return false;
	}
	char *buffer = NULL;
	DWORD size = 128;
	DWORD dw;

	do
	{
		if (buffer != NULL) delete [] buffer;
		buffer = new char[size];
		dw = size;
		if (pECB->GetServerVariable(pECB->ConnID, variableName, buffer, &dw)== TRUE)
		{
			out_value = buffer;
			if (buffer != NULL) delete [] buffer;
			return true;
		}
		if (size >=2048) break;
		size *= 2;
	}
	while(GetLastError() == ERROR_INSUFFICIENT_BUFFER);
	//
	out_value = buffer;
	if (buffer != NULL) delete [] buffer;
	return false;
}

// AUTH_PASSWORD, AUTH_USER, QUERY_STRING,SCRIPT_NAME
// SERVER_NAME, REQUEST_METHOD, SERVER_PORT, HTTP_ACCEPT
// HTTP_ACCEPT_LANGUAGE, HTTP_CONNECTION, HTTP_HOST
// HTTP_USER_AGENT, HTTP_ACCEPT_ENCODING, AUTH_TYPE
// CONTENT_LENGTH, CONTENT_TYPE, HTTP_URL, UNENCODED_URL
// URL
bool HttpConnector::GetServerVariable(char* variableName, wstring& out_value)
{
	string value;
	if (GetServerVariable(variableName, value) == true)
	{
		Sys::Convert::StringToWstring(value, out_value);
		return true;
	}
	out_value.clear();
	return false;
}

// To send a custom response manually set: ContentType and responseData
DWORD HttpConnector::SendResponse(EXTENSION_CONTROL_BLOCK* pECB)
{
	char * codeDescr = GetHttpCodeDescr(httpCode);
	char* content_type = "text/html;  charset=utf-8";
	//_____________________________________ Header
	char header[512];

	HSE_SEND_HEADER_EX_INFO shei;
	::memset(&shei, 0, sizeof(HSE_SEND_HEADER_EX_INFO));
	shei.fKeepConn = TRUE;
	DWORD len = responseData.size();
	if (httpCode == 200)
	{
		//_________________________________________ Content-type:
		switch(ContentType)
		{
		case HTML_CONTENT_TYPE_TEXT_HTML:
			content_type = "text/html;  charset=utf-8";
			break;
		case HTML_CONTENT_TYPE_TEXT_XML:
			content_type = "text/xml;  charset=utf-8";
			break;
		case HTML_CONTENT_TYPE_IMAGE_GIF:
			content_type = "image/gif";
			break;
		case HTML_CONTENT_TYPE_IMAGE_PNG:
			content_type = "image/png";
			break;
		case HTML_CONTENT_TYPE_IMAGE_XPNG:
			content_type = "image/x-png";
			break;
		case HTML_CONTENT_TYPE_IMAGE_JPG:
			content_type = "image/jpg";
			break;
		}
		shei.pszStatus = "200 OK";
		shei.cchStatus = 6; //strlen (shei.pszStatus);
		if (len == 0)
		{
			responseData.reserve(html.size());
			Sys::Convert::WstringToUTF8(html, responseData);
			len = responseData.size();	
		}
		shei.cchHeader  = _snprintf_s(header, 512, _TRUNCATE, "Content-Type: %s\r\nContent-Length: %d\r\n\r\n", content_type, len);
		shei.pszHeader = header;
	}
	else if (httpCode == 401)
	{
		char script_name[256];
		if (this->GetServerVariable("SCRIPT_NAME", script_name, 256) == true)
		{
			const int realm_len = strlen(script_name);
			if (realm_len >= 5) script_name[realm_len-4] = '\0'; // Remove file extension from the script_name
			//shei.cchHeader  = _snprintf_s(header, 512, _TRUNCATE, 
			//	"HTTP/1.1 %s\r\nWWW-Authenticate: Basic realm=\"%s\"\r\n", 
			//	codeDescr, script_name);
			shei.cchHeader  = _snprintf_s(header, 512, _TRUNCATE, "WWW-Authenticate: Basic realm=\"%s\"\r\n", script_name);
		}
		else
		{
			//shei.cchHeader  = _snprintf_s(header, 512, _TRUNCATE, 
			//	"HTTP/1.1 %s\r\nWWW-Authenticate: Basic realm=\"private\"\r\n",
			//	codeDescr);
			shei.cchHeader  = _snprintf_s(header, 512, _TRUNCATE, "WWW-Authenticate: Basic realm=\"private\"\r\n");
		}
		shei.pszStatus = GetHttpCodeDescr(httpCode);
		shei.cchStatus = strlen(shei.pszStatus);
		shei.pszHeader = header;
	}
	else
	{
		shei.pszStatus = GetHttpCodeDescr(httpCode);
		shei.cchStatus = strlen(shei.pszStatus);
		//shei.cchHeader  = _snprintf_s(header, 256, _TRUNCATE, "HTTP/1.1 %s\r\nContent-Type: %s\r\nContent-Length: %d\r\n\r\n", content_type, len);
		shei.cchHeader  = _snprintf_s(header, 256, _TRUNCATE, "Content-Type: %s\r\nContent-Length: %d\r\n\r\n", content_type, len);
		shei.pszHeader = header;
	}

	if (pECB->ServerSupportFunction (pECB->ConnID, HSE_REQ_SEND_RESPONSE_HEADER_EX, 
						&shei, NULL, NULL) == FALSE)
	{
		return HSE_STATUS_ERROR;
	}
	if (len == 0) return HSE_STATUS_SUCCESS_AND_KEEP_CONN;
	if (pECB->WriteClient(pECB->ConnID, (LPVOID)responseData.c_str(), &len, 0) == FALSE)
	{
		return HSE_STATUS_ERROR;
	}
    return HSE_STATUS_SUCCESS_AND_KEEP_CONN;
}

bool HttpConnector::WriteText(const wstring& source)
{
	if (source.length() == 0) return true;
	try
	{
		html += source;
	}
	catch(const std::bad_alloc& )
	{
		return false;
	}
	return true;
}

#ifdef WIN_SOCKETS_SUPPORT
//__________________________________________________ ConnectionHandle
ConnectionHandle::ConnectionHandle()
{
	postData = NULL;
	Clear();
}

ConnectionHandle::~ConnectionHandle()
{
	if (postData != NULL) delete [] postData;
}

void ConnectionHandle::Clear()
{
	requestMethod = HTTP_METHOD_ERROR;
	httpMajorVersion = 0;
	httpMinorVersion = 0;
	url.clear();
	unencodedUrl.clear();
	uriPath.clear();
	uriFileName.clear();
	uriFileExt.clear();
	query_string.clear();
	authorization.clear();
	accept.clear();
	accept_language.clear();
	accept_encoding.clear();
	user_agent.clear();
	host.clear();
	connection.clear();
	username.clear();
	password.clear();
	contentType.clear();
	contentLength = 0;
	if (postData != NULL) delete [] postData;
	postData = NULL;
}

bool ConnectionHandle::SendHttpResponse(int code, int length, const char* fileExt, bool closeConnection, bool gzip)
{
	char * codeDescr = Web::HttpConnector::GetHttpCodeDescr(code);
	char buffer[256];
	_snprintf_s(buffer, 256, _TRUNCATE, "HTTP/1.1 %s\r\n", codeDescr);
	if (socket.Send(buffer)== INVALID_SOCKET) return false;

	if (code == 401)
	{
		if (socket.Send("WWW-Authenticate: Basic Realm=\"private\"\r\n")== INVALID_SOCKET) return false;
		return true;
	}

	//____________________________________________________________ Server Name
	char serverName[64];
	GetServerName(serverName, 64);
	_snprintf_s(buffer, 256, _TRUNCATE, "Server: %s\r\n", serverName);
	if (socket.Send(buffer) == INVALID_SOCKET) return false;

	//____________________________________________________________ Date
	Web::HttpConnector::GetHttpDateHeader(buffer, 256);
	if (socket.Send(buffer) == INVALID_SOCKET) return false;

	if (gzip == true)
	{
		if (socket.Send("Content-Encoding: gzip\r\n")== INVALID_SOCKET) return false;
	}
	//
	if (closeConnection == true)
	{
		if (socket.Send("Connection: close\r\n") == INVALID_SOCKET) return false;
	}
	//_______________________________________________ Content-Type
	char *contentType = Web::HttpConnector::GetMimeContentType(fileExt);
	if (strcmp(fileExt, "htm") == 0)
	{
		_snprintf_s(buffer, 256, _TRUNCATE, "Content-Type: %s;  charset=utf-8\r\n", contentType);
	}
	else
	{
		_snprintf_s(buffer, 256, _TRUNCATE, "Content-Type: %s\r\n", contentType);
	}
	socket.Send(buffer);
	//______________________________________________ Content-Length
	_snprintf_s(buffer, 256, _TRUNCATE, "Content-Length: %d\r\n\r\n", length);
	if (socket.Send(buffer) == INVALID_SOCKET) return false;
	return true;
}


bool ConnectionHandle::GetServerName(char* buffer, int bufferLength)
{
	const int len = host.length();
	for(int i = 0; i<bufferLength && i<len; i++)
	{
		buffer[i] = host[i];
		if (buffer[i] == ':')
		{
			buffer[i] = '\0';
			return true;
		}
	}
	return false;
}

int ConnectionHandle::GetPort()
{
	char buffer[16];
	const int len = host.length();
	bool found = false;
	int i = 0;
	for(i = 0; i<len; i++)
	{
		if (host[i] == ':')
		{
			found = true;
			break;
		}
	}
	if (found == true)
	{
		int j = 0;
		i++;
		for( j = 0; j<16 && i<len; j++, i++)
		{
			buffer[j] = host[i];
		}
		buffer[j] = '\0';
	}
	else
	{
		return 0;
	}
	return atoi(buffer);
}

// The input line has three strings separated by an space, i.e., string1 string2 string3
// Input: line
// Output: out1, out2, out3
// Returns: the number of strings
int ConnectionHandle::SeparateBySpace(string& line, string& out1, string& out2, string& out3)
{
	const int len = line.size();
	int count = 0;
	int i = 0;
	bool isStart = false;

	//_________ Skip spaces
	while(line[i] ==' ' && i<len) i++;
	if (i == len-1) return 0;

	//_____________________________ Try to get first string
	for(; i < len; i++)
	{
		if (line[i] == ' ') break;
		out1.push_back(line[i]);
	}

	//________ Skip spaces
	while(line[i] ==' ' && i<len) i++;
	if (i == len-1) return 1;

	//_____________________________ Try to get second string
	for(; i < len; i++)
	{
		if (line[i] == ' ') break;
		out2.push_back(line[i]);
	}

	//________Skip spaces
	while(line[i] ==' ' && i<len) i++;
	if (i == len-1) return 2;

	//_____________________________ Try to get last string
	for(; i < len; i++)
	{
		if (line[i] == ' ') break;
		out3.push_back(line[i]);
	}
	return 3;
}

bool ConnectionHandle::SendErrorCode(int code, bool readRemaining, wchar_t* details)
{
	if (readRemaining == true)
	{
		string line;
		//____________________________ Accept remaining lines
		for(int n = 0; n<100; n++)
		{
			socket.ReceiveLine(line);
			if (line.empty()) break;
		}
	}
	char * codeDescr = Web::HttpConnector::GetHttpCodeDescr(code);
	char buffer[256];
	if (details == NULL)
	{
		_snprintf_s(buffer, 256, _TRUNCATE, "%s\r\n\r\n", codeDescr);
	}
	else
	{
		const int lenDetails = wcslen(details);
		const int lenCode = strlen(codeDescr)+6;
		const int remaining = 256 - lenCode;
		if (remaining <= lenDetails) details[remaining-1]='\0';
		string asciiDetails;
		Sys::Convert::WstringToString(details, asciiDetails);
		_snprintf_s(buffer, 256, _TRUNCATE, "%s %s\r\n\r\n", codeDescr, asciiDetails.c_str());
	}
	return (socket.Send(buffer)!= INVALID_SOCKET);
}

DWORD ConnectionHandle::ThreadFunc(Mt::BoolTs& running, Mt::DoubleTs& progress, Mt::BoolTs& resetTime)
{
	//http://localhost:8080/hola.dll?name=hola
	//http://localhost:8080/hola.gif
	Clear();
	string line;

	socket.ReceiveLine(line);
	if (line.empty()) return 0;
	string text1, text3;
	if (SeparateBySpace(line, text1, url, text3) != 3) return SendErrorCode(400, true, NULL); //Bad request
	requestMethod = GetMethod(text1);
	if (requestMethod == HTTP_METHOD_ERROR) return SendErrorCode(400, true, NULL); //Bad request
	if (ExtractVersion(text3) == false) return SendErrorCode(400, true, NULL); //Bad request
	if (ExtractUri(url) == false) return SendErrorCode(400, true, NULL); //Bad request
	//_______________________________ Extract unencodedUrl
	size_t questionMark = url.find('?');
	if (questionMark != std::string::npos)
	{
		const size_t len = url.length();
		unencodedUrl.assign(url, 0, questionMark);
	}
	else
	{
		unencodedUrl = url;
	}
	//________________________
	size_t pos;
	string tmp;
	size_t len;
	for(int n = 0; n<32; n++)
	{
		socket.ReceiveLine(line);
		if (line.empty()) break;
		if (line.find_first_of("\x0a\x0d") == 0) break;
		//______________________ Get remaining lines
		len = line.length();
		pos = line.find_first_of(":");
		if (pos == std::string::npos) continue;
		tmp.assign(line, 0, pos);
		Sys::TextAssistant::ToLower(tmp);
		if (tmp == "authorization")
		{
			tmp.assign(line, pos+1, len-pos);
			pos = tmp.find_first_of("Basic ");
			if (pos == std::string::npos) continue;
			len = tmp.length();
			//
			string encoded;
			string decoded;
			encoded.assign(tmp, pos+1+6, len-7);
			Sys::Convert::Base64BitDecode(encoded.c_str(), encoded.length(), decoded);
			pos = decoded.find_first_of(":");
			if (pos == std::string::npos) continue;
			len = tmp.length();
			username.assign(decoded, 0, pos);
			password.assign(decoded, pos+1, len-pos);
			continue;
		}
		if (tmp == "accept")
		{
			accept.assign(line, pos+1, len-pos-2);
			Sys::TextAssistant::RemoveTrailingSpaces(accept);
			continue;
		}
		if (tmp == "accept-language")
		{
			accept_language.assign(line, pos+1, len-pos-2);
			Sys::TextAssistant::RemoveTrailingSpaces(accept_language);
			continue;
		}
		if (tmp == "accept-encoding")
		{
			accept_encoding.assign(line, pos+1, len-pos-2);
			Sys::TextAssistant::RemoveTrailingSpaces(accept_encoding);
			continue;
		}
		if (tmp == "user-agent")
		{
			user_agent.assign(line, pos+1, len-pos-2);
			Sys::TextAssistant::RemoveTrailingSpaces(user_agent);
			continue;
		}
		if (tmp == "host")
		{
			host.assign(line, pos+1, len-pos-2);
			Sys::TextAssistant::RemoveTrailingSpaces(host);
			continue;
		}
		if (tmp == "connection")
		{
			connection.assign(line, pos+1, len-pos-2);
			Sys::TextAssistant::RemoveTrailingSpaces(connection);
			continue;
		}
		if (tmp == "content-type")
		{
			contentType.assign(line, pos+1, len-pos-2);
			Sys::TextAssistant::RemoveTrailingSpaces(contentType);
			continue;
		}
		if (tmp == "content-length")
		{
			string length;
			length.assign(line, pos+1, len-pos-2);
			Sys::TextAssistant::RemoveTrailingSpaces(length);
			contentLength = atoi(length.c_str());
			continue;
		}
	}

	//_______________________ To request authorization
	// When the response is 401, the authentication dialog is open in the explorer to collect the username and password
	//if (username != L"selo" || password != L"sergio")
	//{
	//	SendResponse(401, 0); //Unauthorized"
	//	socket.Close();
	//	running.Set(false);
	//	return 0;
	//}

	//________________________________________ Read Post Data
	if (contentLength > 0)
	{
		if (postData != NULL) delete [] postData;
		postData = new char[contentLength];
		if (postData != NULL)
		{
			socket.Receive(postData, contentLength);// It is not NULL terminated 
		}
	}

	if (uriFileExt == "dll") //_______________________ CGI BIN
	{
		ExecuteDll();
	}
	else //______________________________________ Regular File
	{
		SendFile();
	}
	socket.Close();
	running.Set(false);
	return 0;
}

bool ConnectionHandle::ExecuteDll()
{
	//http://localhost:8080/SiteTest.dll?name=sergio
	EXTENSION_CONTROL_BLOCK ecb;
	::memset(&ecb, 0, sizeof(EXTENSION_CONTROL_BLOCK));
	ecb.ConnID = this;
	ecb.cbAvailable = contentLength;
	ecb.cbTotalBytes = contentLength;
	ecb.lpbData = contentLength > 0 ? (LPBYTE)postData : NULL;
	ecb.lpszQueryString = (char*)query_string.c_str();
	ecb.WriteClient = WriteClient_;
	ecb.ServerSupportFunction = ServerSupportFunction_;
	ecb.GetServerVariable = GetServerVariable_;
	//
	//__________________________________________________ Call the HttpExtensionProc in the dll
	wchar_t filename[1024];
	if (GetDllFileName(filename, 1024) ==  false ) return SendErrorCode(500, false, NULL); // Internal Server Error";

	HINSTANCE hdll = ::LoadLibrary(filename); 
	if (hdll == NULL) return SendErrorCode(404, false, filename); //Not Found

	//________________________________________________ GetExtensionVersion
	GET_EXTENSION_VERSION funcGetExtensionVersion = (GET_EXTENSION_VERSION)::GetProcAddress(hdll, "GetExtensionVersion");
	if (funcGetExtensionVersion == NULL)
	{
		::FreeLibrary(hdll); 
		return SendErrorCode(503, false, NULL); // Service Unavailable
	}
	HSE_VERSION_INFO hseVersionInfo;
	funcGetExtensionVersion(&hseVersionInfo);

	//________________________________________________ HttpExtensionProc
	HTTP_EXTENSION_PROC funcHttpExtensionProc = (HTTP_EXTENSION_PROC)::GetProcAddress(hdll, "HttpExtensionProc");
	if (funcHttpExtensionProc == NULL)
	{
		::FreeLibrary(hdll); 
		return SendErrorCode(503, false, NULL); // Service Unavailable
	}
	funcHttpExtensionProc(&ecb);

	//________________________________________________ TerminateExtension
	TERMINATE_EXTENSION funcTerminateExtension = (TERMINATE_EXTENSION)::GetProcAddress(hdll, "TerminateExtension");
	if (funcTerminateExtension == NULL)
	{
		::FreeLibrary(hdll); 
		return SendErrorCode(503, false, NULL); // Service Unavailable
	}
	DWORD dword = 0;
	funcTerminateExtension(dword);

   ::FreeLibrary(hdll); 
   return true;
}

BOOL WINAPI ConnectionHandle::ServerSupportFunction_(HCONN hConn, 
								   DWORD dwHSERequest, LPVOID lpvBuffer, LPDWORD lpdwSize, LPDWORD lpdwDataType)
{
	if (dwHSERequest == HSE_REQ_SEND_RESPONSE_HEADER_EX)
	{
		Web::ConnectionHandle* ch = (Web::ConnectionHandle*)hConn;
		if (ch == NULL) return FALSE;
		char server_name[256];
		char buffer[256];
		//_____________________________________________________________ HTTP CODE
		HSE_SEND_HEADER_EX_INFO* shei = (HSE_SEND_HEADER_EX_INFO*) lpvBuffer;
		int len = _snprintf_s(buffer, 256, _TRUNCATE, "HTTP/1.1 %s\r\n", shei->pszStatus);
		if (ch->socket.Send(buffer, len, 0) == INVALID_SOCKET) return false;

		//____________________________________________________________ Server
		ch->GetServerName(server_name, 256);
		len = _snprintf_s(buffer, 256, _TRUNCATE, "Server: %s\r\n", server_name);
		if (ch->socket.Send(buffer, len, 0) == INVALID_SOCKET) return false;

		//_____________________________________________________________Date
		Web::HttpConnector::GetHttpDateHeader(buffer, 256);
		if (ch->socket.Send(buffer, strlen(buffer), 0) == INVALID_SOCKET) return false;

		//____________________________________________________________ Remaining Header
		const char* header = shei->pszHeader;
		len = shei->cchHeader;
		if (ch->socket.Send(header, len, 0) == INVALID_SOCKET) return false;
		return TRUE;
	}
	return FALSE;
}

BOOL WINAPI ConnectionHandle::WriteClient_(HCONN hConn, LPVOID Buffer, LPDWORD lpdwBytes, DWORD dwReserved)
{
	Web::ConnectionHandle* ch = (Web::ConnectionHandle*)hConn;
	if (ch == NULL) return FALSE;
	const int len = (int)*lpdwBytes;
	if (ch->socket.Send((const char*) Buffer, len, 0) == INVALID_SOCKET) return FALSE;
	return TRUE;
}

BOOL WINAPI ConnectionHandle::GetServerVariable_ ( HCONN hConn, LPSTR lpszVariableName, LPVOID lpvBuffer, LPDWORD lpdwSize)
{
	Web::ConnectionHandle* p = (Web::ConnectionHandle*)hConn;
	DWORD dwSize = *lpdwSize;
	char* buffer = (char*)lpvBuffer; 
	if (dwSize > 0) buffer[0] = '\0'; // Be sure to return a clean value

	if (strcmp(lpszVariableName, "AUTH_PASSWORD")==0)
	{
		*lpdwSize = _snprintf_s((char*)lpvBuffer, dwSize, _TRUNCATE, "%s", p->password.c_str());
		return TRUE;
	}
	else if (strcmp(lpszVariableName, "AUTH_USER")==0)
	{
		*lpdwSize = _snprintf_s((char*)lpvBuffer, dwSize, _TRUNCATE, "%s", p->username.c_str());
		return TRUE;
	}
	else if (strcmp(lpszVariableName, "QUERY_STRING")==0)
	{
		*lpdwSize = _snprintf_s((char*)lpvBuffer, dwSize, _TRUNCATE, "%s", p->query_string.c_str());
		return TRUE;
	}
	else if (strcmp(lpszVariableName, "SCRIPT_NAME")==0)
	{
		*lpdwSize = _snprintf_s((char*)lpvBuffer, dwSize, _TRUNCATE, "%s.%s", p->uriFileName.c_str(), p->uriFileExt.c_str());
		return TRUE;
	}
	else if (strcmp(lpszVariableName, "SERVER_NAME")==0)
	{
		*lpdwSize = p->GetServerName((char*)lpvBuffer, dwSize);
		return TRUE;
	}
	else if (strcmp(lpszVariableName, "REQUEST_METHOD")==0)
	{
		*lpdwSize = _snprintf_s((char*)lpvBuffer, dwSize, _TRUNCATE, "%s", p->GetMethodDesc(p->requestMethod));
		return TRUE;
	}
	else if (strcmp(lpszVariableName, "SERVER_PORT")==0)
	{
		*lpdwSize = _snprintf_s((char*)lpvBuffer, dwSize, _TRUNCATE, "%d", p->GetPort());
		return TRUE;
	}
	else if (strcmp(lpszVariableName, "HTTP_ACCEPT")==0)
	{
		*lpdwSize = _snprintf_s((char*)lpvBuffer, dwSize, _TRUNCATE, "%s", p->accept.c_str());
		return TRUE;
	}
	else if (strcmp(lpszVariableName, "HTTP_ACCEPT_LANGUAGE")==0)
	{
		*lpdwSize = _snprintf_s((char*)lpvBuffer, dwSize, _TRUNCATE, "%s", p->accept_language.c_str());
		return TRUE;
	}
	else if (strcmp(lpszVariableName, "HTTP_CONNECTION")==0)
	{
		*lpdwSize = _snprintf_s((char*)lpvBuffer, dwSize, _TRUNCATE, "%s", p->connection.c_str());
		return TRUE;
	}
	else if (strcmp(lpszVariableName, "HTTP_HOST")==0)
	{
		*lpdwSize = _snprintf_s((char*)lpvBuffer, dwSize, _TRUNCATE, "%s", p->host.c_str());
		return TRUE;
	}
	else if (strcmp(lpszVariableName, "HTTP_USER_AGENT")==0)
	{
		*lpdwSize = _snprintf_s((char*)lpvBuffer, dwSize, _TRUNCATE, "%s", p->user_agent.c_str());
		return TRUE;
	}
	else if (strcmp(lpszVariableName, "HTTP_ACCEPT_ENCODING")==0)
	{
		*lpdwSize = _snprintf_s((char*)lpvBuffer, dwSize, _TRUNCATE, "%s", p->accept_encoding.c_str());
		return TRUE;
	}
	else if (strcmp(lpszVariableName, "AUTH_TYPE")==0)
	{
		*lpdwSize = _snprintf_s((char*)lpvBuffer, dwSize, _TRUNCATE, "%s", p->authorization.c_str());
		return TRUE;
	}
	else if (strcmp(lpszVariableName, "CONTENT_LENGTH")==0)
	{
		*lpdwSize = _snprintf_s((char*)lpvBuffer, dwSize, _TRUNCATE, "%d", p->contentLength);
		return TRUE;
	}
	else if (strcmp(lpszVariableName, "CONTENT_TYPE")==0)
	{
		*lpdwSize = _snprintf_s((char*)lpvBuffer, dwSize, _TRUNCATE, "%s", p->contentType.c_str());
		return TRUE;
	}
	else if (strcmp(lpszVariableName, "WIN_INDENT")==0)
	{
		*lpdwSize = _snprintf_s((char*)lpvBuffer, dwSize, _TRUNCATE, "true");
		return TRUE;
	}
	else if (strcmp(lpszVariableName, "HTTP_URL")==0)
	{
		*lpdwSize = _snprintf_s((char*)lpvBuffer, dwSize, _TRUNCATE, "%s", p->unencodedUrl.c_str());
		return TRUE;
	}
	else if (strcmp(lpszVariableName, "UNENCODED_URL")==0)
	{
		*lpdwSize = _snprintf_s((char*)lpvBuffer, dwSize, _TRUNCATE, "%s", p->unencodedUrl.c_str());
		return TRUE;
	}
	else if (strcmp(lpszVariableName, "URL")==0)
	{
		*lpdwSize = _snprintf_s((char*)lpvBuffer, dwSize, _TRUNCATE, "%s", p->url.c_str());
		return TRUE;
	}

	/* ALL_HTTP
	ALL_RAW
	APPL_MD_PATH
	APPL_PHYSICAL_PATH
	CERT_COOKIE
	CERT_FLAGS
	CERT_ISSUER
	CERT_KEYSIZE
	CERT_SECRETKEYSIZE
	CERT_SERIALNUMBER
	CERT_SERVER_ISSUER
	CERT_SERVER_SUBJECT
	CERT_SUBJECT
	CONTENT_LENGTH
	CONTENT_TYPE
	GATEWAY_INTERFACE
	HTTPS
	HTTPS_KEYSIZE
	HTTPS_SECRETKEYSIZE
	HTTPS_SERVER_ISSUER
	HTTPS_SERVER_SUBJECT
	INSTANCE_ID
	INSTANCE_META_PATH
	LOCAL_ADDR
	LOGON_USER
	PATH_INFO
	PATH_TRANSLATED
	REMOTE_ADDR
	REMOTE_HOST
	REMOTE_USER
	SERVER_PORT_SECURE
	SERVER_PROTOCOL
	SERVER_SOFTWARE
	URL
	HTTP_COOKIE
	  */
	*lpdwSize = 0;
	return FALSE;
}

bool ConnectionHandle::SendFile()
{
	//http://localhost:8080/selo.gif
	//string response = "<html><head><title>Hola</title></head><body>HELLO</body></html>";
	wchar_t filename[1024];
	if (GetFileName(filename, 1024) ==  false ) return SendErrorCode(500, false, NULL); // Internal Server Error";

	DWORD highSize;
	char buffer[512];
	DWORD dwRead = 1;
	DWORD bytesToRead = 0;
	HANDLE hFile = ::CreateFile(filename, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
	if  (hFile == INVALID_HANDLE_VALUE) return SendErrorCode(404, false, filename); //Not Found
	const int responseLength = (int)::GetFileSize(hFile, &highSize);
	if (responseLength < 512)
	{
		bytesToRead = responseLength;
		::ReadFile(hFile, buffer, bytesToRead, &dwRead, NULL);
		if (dwRead != responseLength)
		{
			if (hFile!=INVALID_HANDLE_VALUE) ::CloseHandle(hFile);
			return SendErrorCode(500, false, NULL); // Internal Server Error";
		}
		SendHttpResponse(200, responseLength, uriFileExt.c_str(), true, false);//OK
		socket.Send(buffer, (int)responseLength, (int)0);
	}
	else
	{
		SendHttpResponse(200, responseLength, uriFileExt.c_str(), true, false);//OK
		bytesToRead = 512;
		while (dwRead != 0)
		{
			::ReadFile(hFile, buffer, bytesToRead, &dwRead, NULL);
			if (dwRead == 0) break;
			socket.Send(buffer, (int)dwRead, (int)0);
		}
	}
	if  (hFile != INVALID_HANDLE_VALUE) ::CloseHandle(hFile);
	return true;
}

bool ConnectionHandle::GetDllFileName(wchar_t* buffer, int bufferLength)
{
	wchar_t currentDirectory[1024];
	const int size = ::GetCurrentDirectory(0, NULL);
	if (size>=1024) return false;
	::GetCurrentDirectory(1024, currentDirectory);
	//_____________________________ Remove last back slash
	for(int i = size-1; i>0; i--)
	{
		if (currentDirectory[i] == '\\')
		{
			currentDirectory[i] ='\0';
			break;
		}
	}

	//________________________________________________ Convert filename to wstring
	wstring wuriFileName;
	wstring wuriFileExt;
	Sys::Convert::StringToWstring(uriFileName, wuriFileName);
	Sys::Convert::StringToWstring(uriFileExt, wuriFileExt);
	
	_snwprintf_s(buffer, bufferLength, _TRUNCATE, L"%s\\Debug\\%s.%s", currentDirectory, 
			wuriFileName.c_str(), wuriFileExt.c_str());
	//_snwprintf_s(buffer, bufferLength, _TRUNCATE, L"%s\\%s.%s", currentDirectory, 
	//		wuriFileName.c_str(), wuriFileExt.c_str());
	return true;
}

bool ConnectionHandle::GetFileName(wchar_t* buffer, int bufferLength)
{
	wchar_t currentDirectory[1024];
	const int size = ::GetCurrentDirectory(0, NULL);
	if (size>=1024) return false;
	::GetCurrentDirectory(1024, currentDirectory);

	//________________________________________________ Convert filename to wstring
	wstring wuriFileName;
	wstring wuriFileExt;
	Sys::Convert::StringToWstring(uriFileName, wuriFileName);
	Sys::Convert::StringToWstring(uriFileExt, wuriFileExt);

	if (uriPath == "\\")
	{
		_snwprintf_s(buffer, bufferLength, _TRUNCATE, L"%s\\%s.%s", currentDirectory, 
			wuriFileName.c_str(), wuriFileExt.c_str());
	}
	else
	{	
		wstring wuriPath;
		Sys::Convert::StringToWstring(uriPath, wuriPath);
		_snwprintf_s(buffer, bufferLength, _TRUNCATE, L"%s\\%s\\%s.%s", currentDirectory, 
			wuriPath.c_str(), wuriFileName.c_str(), wuriFileExt.c_str());
	}
	return true;
}

int ConnectionHandle::GetMethod(string& text1)
{
	Sys::TextAssistant::ToUpper(text1);
	for(int i = HTTP_METHOD_GET; i <= HTTP_METHOD_CONNECT; i++)
	{
		if (text1.find(GetMethodDesc(i)) == 0) return i;
	}
	return HTTP_METHOD_ERROR;
}

bool ConnectionHandle::ExtractVersion(string& text3)
{
	Sys::TextAssistant::ToUpper(text3);
	size_t pos = 0;
	char text[32];
	int i = 0;
	//__________________ major
	pos = text3.find("HTTP/");
	if (pos != std::string::npos)
	{
		pos+=5;
		i = 0;
		while(pos != std::string::npos && i<5)
		{
			text[i] = text3[pos];
			if (Sys::TextAssistant::IsDigit(text[i]) == false)
			{
				text[i] = '\0';
				httpMajorVersion = atoi(text);
				pos++; // Go beyond the dot
				break;
			}
			i++;
			pos++;
		}
	}
	//__________________ minor
	if (pos != std::string::npos)
	{
		i = 0;
		while(pos != std::string::npos && i<5)
		{
			text[i] = text3[pos];
			if (Sys::TextAssistant::IsDigit(text[i]) == false)
			{
				text[i] = '\0';
				httpMinorVersion = atoi(text);
				return true;
			}
			i++;
			pos++;
		}
	}
	return false;
}

bool ConnectionHandle::ExtractUri(string& text2)
{
	//http://localhost:8080/selo/doc/hola.htm?datos=100&peso=50
	//GET /selodoc/hola.htm?datos=100&peso=50 HTTP/1.1
	const size_t len = text2.length();
	const size_t pQuestionMark = text2.find('?');
	const bool hasQueryString = (pQuestionMark != std::string::npos);
	size_t pDot = std::string::npos;
	size_t p;
	int i;

	//_________________________________________________ Get file extension
	if (hasQueryString == true)
	{
		//____________________ Find dot
		for(i = pQuestionMark-1; i>0; i--)
		{
			if (text2[i] == '.')
			{
				pDot = i;
				break;
			}
		}	
		if (pDot != std::string::npos)
		{
			p = pDot+1;// Move one position after the dot
			if (p != std::string::npos)
			{
				uriFileExt.assign(text2, p, pQuestionMark-p);
				Sys::TextAssistant::ToLower(uriFileExt);
			}
		}
		// Get Query String
		p = pQuestionMark+1;// Move one position after question mark
		if (p != std::string::npos)
		{
			const int lenQS = len - p;
			query_string.assign(text2, p, lenQS);
			Sys::TextAssistant::RemoveTrailingSpaces(query_string);
		}
	}
	else
	{
		//____________________ Find dot
		for(i = len-1; i>0; i--)
		{
			if (text2[i] == '.')
			{
				pDot = i;
				break;
			}
		}
		if (pDot != std::string::npos)
		{
			p = pDot+1;// Move one position after the dot
			if (p != std::string::npos)
			{
				uriFileExt.assign(text2, p, len-p+1);
				Sys::TextAssistant::ToLower(uriFileExt);
			}
		}
	}
	size_t begin_filename = std::string::npos;
	// ____________________________________________ Get filename
	if (pDot != std::string::npos)
	{
		for(i = pDot; i >= 0; i--)
		{
			if (text2[i] == '/')
			{
				begin_filename = i;
				break;
			}
		}
		if (begin_filename != std::string::npos)
		{
			p = begin_filename+1; // Move after /
			if (p != std::string::npos)
			{
				uriFileName.assign(text2, p, pDot-p);
			}
		}
	}

	//___________________________________________ Get path
	size_t firstSlash = std::string::npos;
	for(p = 0; p<pDot; i++)
	{
		if (text2[p] == '/')
		{
			firstSlash = p;
			break;
		}
	}
	
	if (firstSlash == std::string::npos || begin_filename == std::string::npos)
	{
		uriPath.clear();
	}
	else if (firstSlash == begin_filename)
	{
		uriPath = "\\";
	}
	else
	{
		p = firstSlash+1;
		if (p != std::string::npos)
		{
			uriPath.assign(text2, p, begin_filename-p);
		}
	}

	Sys::TextAssistant::ReplaceChar(uriPath, '/', '\\');
	if (uriPath.empty() == true) uriPath = "\\";
	return (uriFileName.length() > 0 && uriFileExt.length() > 0);
}

wchar_t * ConnectionHandle::GetMethodDescW(int method)
{
	switch(method)
	{
	case HTTP_METHOD_GET: return L"GET";
	case HTTP_METHOD_HEAD: return L"HEAD";
	case HTTP_METHOD_POST: return L"POST";
	case HTTP_METHOD_PUT: return L"PUT";
	case HTTP_METHOD_DELETE: return L"DELETE";
	case HTTP_METHOD_TRACE: return L"TRACE";
	case HTTP_METHOD_CONNECT: return L"CONNECT";
	}
	return L"ERROR";
}

char  * ConnectionHandle::GetMethodDesc(int method)
{
	switch(method)
	{
	case HTTP_METHOD_GET: return "GET";
	case HTTP_METHOD_HEAD: return "HEAD";
	case HTTP_METHOD_POST: return "POST";
	case HTTP_METHOD_PUT: return "PUT";
	case HTTP_METHOD_DELETE: return "DELETE";
	case HTTP_METHOD_TRACE: return "TRACE";
	case HTTP_METHOD_CONNECT: return "CONNECT";
	}
	return "ERROR";
}

//__________________________________________________ Server
Server::Server()
{
}

Server::~Server()
{
}

wchar_t* Server::Start(unsigned int port, const int numClients)
{
	wchar_t* error = socketListen.StartServer(port, numClients);
	return error;
}

wchar_t* Server::Run(unsigned int port, const int numClients)
{
	//______________________________________________ Create the thread objects
	Mt::ThreadObject * thread = new Mt::ThreadObject[numClients];
	if (thread == NULL) return L"No enough memory";
	//______________________________________________ Create the connection handles
	Web::ConnectionHandle * connHandle = new Web::ConnectionHandle[numClients];
	if (connHandle == NULL)
	{
		if (thread != NULL) delete [] thread;
		return L"No enough memory";
	}

	SOCKET socketAccept = INVALID_SOCKET;
	int i;
	while(true)
	{
		socketAccept = socketListen.Accept();
		if (socketAccept == INVALID_SOCKET) continue;
		//___________________________ Search for an available thread and connection handle
		for(i = 0; i < numClients; i++)
		{
			if (thread[i].running.Get() == true) continue;
			connHandle[i].socket.Attach(socketAccept);
			thread[i].StartThread(connHandle[i]);
			break;
		}
	}

	if (thread != NULL) delete [] thread;
	if (connHandle != NULL) delete [] connHandle;
	return NULL;
}

#endif

//________________________________________________________ Css
Css::Css(void)
{
	background = CSS_COLOR_AUTO; 
	border_color = CSS_COLOR_AUTO; 
	color = CSS_COLOR_AUTO; 
	//additionalStyles;
	font_size = HTML_SIZE_AUTO; 
	width = HTML_SIZE_AUTO; 
	height = HTML_SIZE_AUTO; 
	border_width = HTML_SIZE_AUTO; 
	padding_left = HTML_SIZE_AUTO; 
	padding_right = HTML_SIZE_AUTO; 
	padding_top = HTML_SIZE_AUTO; 
	padding_bottom = HTML_SIZE_AUTO; 
	margin = HTML_SIZE_AUTO; 
	memoryBlock1 = 0;
	memoryBlock2 = 0;
	memoryBlock3 = 0;
}

bool Css::HasStyle()
{
	if (background != CSS_COLOR_AUTO) return true;
	if (border_color != CSS_COLOR_AUTO) return true;
	if (color != CSS_COLOR_AUTO) return true;
	if (additionalStyles.empty() == false) return true;
	if (font_size != HTML_SIZE_AUTO) return true;
	if (width != HTML_SIZE_AUTO) return true;
	if (height != HTML_SIZE_AUTO) return true;
	if (border_width != HTML_SIZE_AUTO) return true;
	if (padding_left != HTML_SIZE_AUTO) return true;
	if (padding_right != HTML_SIZE_AUTO) return true;
	if (padding_top != HTML_SIZE_AUTO) return true;
	if (padding_bottom != HTML_SIZE_AUTO) return true;
	if (margin != HTML_SIZE_AUTO) return true;
	if (memoryBlock1 != 0) return true;
	if (memoryBlock2 != 0) return true;
	if (memoryBlock3 != 0) return true;
	return false;
}

Css::~Css(void)
{
}

//__________________________________ IObject
void Css::GetHtml(Sys::ITextWriterW& out_html)
{
	if (HasStyle() == false) return;
	//
	wchar_t* descr =  NULL;
	out_html.WriteText(L" style=\"");
	bool semicolon = false;
	semicolon |= RenderColor(semicolon, L"background", background, out_html);
	semicolon |= RenderColor(semicolon, L"border-color", border_color, out_html);
	semicolon |= RenderColor(semicolon, L"color", color, out_html);
	semicolon |= RenderInteger(semicolon, L"font-size", font_size, out_html);
	semicolon |= RenderInteger(semicolon, L"width", width, out_html);
	semicolon |= RenderInteger(semicolon, L"height", height, out_html);
	semicolon |= RenderInteger(semicolon, L"border-width", border_width, out_html);
	semicolon |= RenderInteger(semicolon, L"padding-left", padding_left, out_html);
	semicolon |= RenderInteger(semicolon, L"padding-top", padding_top, out_html);
	semicolon |= RenderInteger(semicolon, L"padding-right", padding_right, out_html);
	semicolon |= RenderInteger(semicolon, L"padding-bottom", padding_bottom, out_html);
	semicolon |= RenderInteger(semicolon, L"margin", margin, out_html);
	//_____________________________________ Additional Styles
	if (additionalStyles.empty() == false)
	{
		if (semicolon == true) out_html.WriteText(L";");
		out_html.WriteText(additionalStyles);
		semicolon = true;
	}
	//_____________________________________  Font Family
	if (this->font_family != Web::CssType::FontFamilyAuto)
	{
		if (semicolon == true) out_html.WriteText(L";");
		out_html.WriteText(L"font-family:");
		wchar_t* descr = Web::Helper::GetFontFamilyValue(font_family);
		if (descr != NULL) out_html.WriteText(descr);
		semicolon = true;
	}
	//_____________________________________  Vertical Align
	if (this->vertical_align != Web::CssType::VerticalAlignAuto)
	{
		if (semicolon == true) out_html.WriteText(L";");
		out_html.WriteText(L"vertical-align:");
		wchar_t* descr = Web::Helper::GetVerticalAlignValue(vertical_align);
		if (descr != NULL) out_html.WriteText(descr);
		semicolon = true;
	}
	//_____________________________________  Text Align
	if (this->text_align != Web::CssType::TextAlignAuto)
	{
		if (semicolon == true) out_html.WriteText(L";");
		out_html.WriteText(L"text-align:");
		wchar_t* descr = Web::Helper::GetTextAlignValue(text_align);
		if (descr != NULL) out_html.WriteText(descr);
		semicolon = true;
	}

	//_____________________________________  Border Style
	if (this->border_style != Web::CssType::BorderStyleAuto)
	{
		if (semicolon == true) out_html.WriteText(L";");
		out_html.WriteText(L"border-style:");
		wchar_t* descr = Web::Helper::GetBorderStyleValue(border_style);
		if (descr != NULL) out_html.WriteText(descr);
		semicolon = true;
	}

	//_____________________________________  Text Decoration
	if (this->text_decoration != Web::CssType::TextDecorationAuto)
	{
		if (semicolon == true) out_html.WriteText(L";");
		out_html.WriteText(L"text-decoration:");
		wchar_t* descr = Web::Helper::GetTextDecorationValue(text_decoration);
		if (descr != NULL) out_html.WriteText(descr);
		semicolon = true;
	}

	//_____________________________________  Display
	if (this->display != Web::CssType::DisplayAuto)
	{
		if (semicolon == true) out_html.WriteText(L";");
		out_html.WriteText(L"display:");
		wchar_t* descr = Web::Helper::GetDisplayValue(display);
		if (descr != NULL) out_html.WriteText(descr);
		semicolon = true;
	}

	//_____________________________________  Cursor
	if (this->cursor != Web::CssType::CursorAuto)
	{
		if (semicolon == true) out_html.WriteText(L";");
		out_html.WriteText(L"cursor:");
		wchar_t* descr = Web::Helper::GetCursorValue(cursor);
		if (descr != NULL) out_html.WriteText(descr);
		semicolon = true;
	}

	//_____________________________________  Position
	if (this->position != Web::CssType::PositionAuto)
	{
		if (semicolon == true) out_html.WriteText(L";");
		out_html.WriteText(L"position:");
		wchar_t* descr = Web::Helper::GetPositionValue(position);
		if (descr != NULL) out_html.WriteText(descr);
		semicolon = true;
	}

	//_____________________________________  Visibility
	if (this->visibility != Web::CssType::VisibilityAuto)
	{
		if (semicolon == true) out_html.WriteText(L";");
		out_html.WriteText(L"visibilitiy:");
		wchar_t* descr = Web::Helper::GetVisibilityValue(visibility);
		if (descr != NULL) out_html.WriteText(descr);
		semicolon = true;
	}

	//_____________________________________  Overflow X
	if (this->overflow_x != Web::CssType::OverflowXNone)
	{
		if (semicolon == true) out_html.WriteText(L";");
		out_html.WriteText(L"overflow-x:");
		wchar_t* descr = Web::Helper::GetOverflowXValue(overflow_x);
		if (descr != NULL) out_html.WriteText(descr);
		semicolon = true;
	}

	//_____________________________________  Overflow Y
	if (this->overflow_y != Web::CssType::OverflowYNone)
	{
		if (semicolon == true) out_html.WriteText(L";");
		out_html.WriteText(L"overflow-y:");
		wchar_t* descr = Web::Helper::GetOverflowYValue(overflow_y);
		if (descr != NULL) out_html.WriteText(descr);
		semicolon = true;
	}

	out_html.WriteText(L"\"");
}

bool  Css::RenderColor(bool semicolon, const wchar_t* name, COLORREF color, Sys::ITextWriterW& out_html)
{
	if (color == CSS_COLOR_AUTO) return false;
	if (semicolon == true) out_html.WriteText(L";");
	wchar_t text[32];
	_snwprintf_s(text, 32, _TRUNCATE, L"%s:#%02X%02X%02X", name, 
		GetRValue(color) ,GetGValue(color), GetBValue(color));
	out_html.WriteText(text);
	return true;
}

bool Css::RenderInteger(bool semicolon, const wchar_t* name, int value, Sys::ITextWriterW& out_html)
{
	if (value == HTML_SIZE_AUTO) return false;
	if (semicolon == true) out_html.WriteText(L";");
	
	wchar_t text[32];
	if (value >= 0)
	{
		_snwprintf_s(text, 32, _TRUNCATE, L"%s:%dpx", name, value);
	}
	else
	{
		_snwprintf_s(text, 32, _TRUNCATE, L"%s:%d%%", name, -value);
	}
	out_html.WriteText(text);
	return true;
}

void Css::SetPosition(Web::CssType::Position position)
{
	//memoryBlock1: X000 0000
	memoryBlock1 &= 0x0FFFFFFF;
	memoryBlock1 |= position;
}

Web::CssType::Position Css::GetPosition()
{
	//memoryBlock1: X000 0000
	return (Web::CssType::Position) (memoryBlock1 & 0xF0000000);
}

void Css::SetFontFamily(Web::CssType::FontFamily font)
{
	//memoryBlock1: 0XX0 0000
	memoryBlock1 &= 0xF00FFFFF;
	memoryBlock1 |= font;
}

Web::CssType::FontFamily Css::GetFontFamily()
{
	//memoryBlock1: 0XX0 0000
	return (Web::CssType::FontFamily) (memoryBlock1 & 0x0FF00000);
}

void Css::SetTextAlign(Web::CssType::TextAlign text_align)
{
	//memoryBlock1: 000X 0000
	memoryBlock1 &= 0xFFF0FFFF;
	memoryBlock1 |= text_align;
}

Web::CssType::TextAlign Css::GetTextAlign()
{
	//memoryBlock1: 000X 0000
	return (Web::CssType::TextAlign) (memoryBlock1 & 0x000F0000);
}

void Css::SetVerticalAlign(Web::CssType::VerticalAlign vertical_align)
{
	//memoryBlock1: 0000 XX00
	memoryBlock1 &= 0xFFFF00FF;
	memoryBlock1 |= vertical_align;
}

Web::CssType::VerticalAlign Css::GetVerticalAlign()
{
	//memoryBlock1: 0000 XX00
	return (Web::CssType::VerticalAlign) (memoryBlock1 & 0x0000FF00);
}

void Css::SetTextDecoration(Web::CssType::TextDecoration text_decoration)
{
	//memoryBlock1: 0000 00XX
	memoryBlock1 &= 0xFFFFFF00;
	memoryBlock1 |= text_decoration;
}

Web::CssType::TextDecoration Css::GetTextDecoration()
{
	//memoryBlock1: 0000 00XX
	return (Web::CssType::TextDecoration) (memoryBlock1 & 0x000000FF);
}

void Css::SetVisibility(Web::CssType::Visibility visibility)
{
	//memoryBlock2: X000 0000
	memoryBlock2 &= 0x0FFFFFFF;
	memoryBlock2 |= visibility;
}

Web::CssType::Visibility Css::GetVisibility()
{
	//memoryBlock2: X000 0000
	return (Web::CssType::Visibility) (memoryBlock2 & 0xF0000000);
}

void Css::SetBorderStyle(Web::CssType::BorderStyle border_style)
{
	//memoryBlock2: 0XX0 0000
	memoryBlock2 &= 0xF00FFFFF;
	memoryBlock2 |= border_style;
}

Web::CssType::BorderStyle Css::GetBorderStyle()
{
	//memoryBlock2: 0XX0 0000
	return (Web::CssType::BorderStyle) (memoryBlock2 & 0x0FF00000);
}

void Css::SetDisplay(Web::CssType::Display display)
{
	//memoryBlock2: 000X 0000
	memoryBlock2 &= 0xFFF0FFFF;
	memoryBlock2 |= display;
}

Web::CssType::Display Css::GetDisplay()
{
	//memoryBlock2: 000X 0000
	return (Web::CssType::Display) (memoryBlock2 & 0x000F0000);
}

void Css::SetCursor(Web::CssType::Cursor cursor)
{
	//memoryBlock2: 0000 XXXX
	memoryBlock2 &= 0xFFFF0000;
	memoryBlock2 |= cursor;
}

Web::CssType::Cursor Css::GetCursor()
{
	//memoryBlock2: 0000 XXXX
	return (Web::CssType::Cursor) (memoryBlock2 & 0x0000FFFF);
}

void Css::SetOverflowX(Web::CssType::OverflowX overflowX)
{
	//memoryBlock3: XX00 0000
	memoryBlock3 &= 0x00FFFFFF;
	memoryBlock3 |= overflowX;
}

Web::CssType::OverflowX Css::GetOverflowX()
{
	//memoryBlock3: XX00 0000
	return (Web::CssType::OverflowX) (memoryBlock3 & 0xFF000000);
}

void Css::SetOverflowY(Web::CssType::OverflowY overflowY)
{
	//memoryBlock3: 00FF 0000
	memoryBlock3 &= 0xFF00FFFF;
	memoryBlock3 |= overflowY;
}

Web::CssType::OverflowY Css::GetOverflowY()
{
	//memoryBlock3: 00XX 0000
	return (Web::CssType::OverflowY) (memoryBlock3 & 0x00FF0000);
}

//________________________________________________________ Object
Object::Object(void)
{
}

Object::~Object(void)
{
}

void Object::OnNavigateAway(Web::HttpConnector& httpConnector)
{
}

bool Object::IsEvent(Web::HttpConnector& httpConnector, int notification)
{
	if (httpConnector.CheckEvent(ID, notification) == false) return false;
	return true;
}

wchar_t* Object::RenderTagAndId(bool increaseIndent, int& indentCount, Sys::ITextWriterW& out_html)
{
	Indent(indentCount, out_html);
	if (BeginHtml.length() > 0) out_html.WriteText(BeginHtml);
	//______________________________________ tag
	wchar_t * tag = GetTag();
	if (tag == NULL) return NULL;
	out_html.WriteText(L"<");
	out_html.WriteText(GetTag());
	//______________________________________ id
	RenderPair(L"id", ID, out_html);
	return tag;
}

void Object::RenderHiddenValue(bool increaseIndent, int& indentCount, const wchar_t* value, Sys::ITextWriterW& out_html)
{
	Indent(indentCount, out_html);
	out_html.WriteText(L"<input type=\"hidden\" name=\"");
	out_html.WriteText(ID);
	out_html.WriteText(L"\" Data=\"");
	out_html.WriteText(value);
	out_html.WriteText(L"\" />");
}

void Object::RenderPair(const wchar_t* name, wstring& value, Sys::ITextWriterW& out_html)
{
	if (value.length() == 0) return;
	out_html.WriteText(L" ");
	out_html.WriteText(name);
	out_html.WriteText(L"=\"");
	out_html.WriteText(value);
	out_html.WriteText(L"\"");
}

void Object::RenderPair(const wchar_t* name, const wchar_t* value, Sys::ITextWriterW& out_html)
{
	if (wcslen(name) == 0) return;
	out_html.WriteText(L" ");
	out_html.WriteText(name);
	out_html.WriteText(L"=\"");
	out_html.WriteText(value);
	out_html.WriteText(L"\"");
}

void Object::RenderPair(const wchar_t* name, int value, Sys::ITextWriterW& out_html)
{
	out_html.WriteText(L" ");
	out_html.WriteText(name);
	//
	wchar_t text[32];
	_snwprintf_s(text, 32, _TRUNCATE, L"=\"%d\"", value);
	out_html.WriteText(text);
}

void Object::RenderFunction(int eventID, Sys::ITextWriterW& out_html, const wchar_t* url)
{
	wchar_t *eventName = Web::Helper::GetEventName(eventID);
	wchar_t *eventShortName = Web::Helper::GetEventShortName(eventID);
	//wchar_t *eventIdText = Web::Helper::GetEventID(eventID);
	if (eventName == NULL) return;
	if (eventShortName == NULL) return;
	out_html.WriteText(L" ");
	out_html.WriteText(eventName);
	//
	wchar_t text[128];
	_snwprintf_s(text, 128, _TRUNCATE, L"=\"%s_%s(\'%s\', \'%s\', \'%s\');\"", 
		ID.c_str(), eventShortName, url, ID.c_str(), eventShortName);
	out_html.WriteText(text);
}

void Object::Indent(int indentCount, Sys::ITextWriterW& out_html)
{
	if (indentCount == -1) return;
	if (indentCount>0) out_html.WriteText(L"\r\n");
	int i = 0;
	//if (comment != NULL)
	//{
	//	for (int i=0; i<indentCount; i++) out_html.WriteText(L"  ");
	//	out_html.WriteText(L"<!-- ======================================");
	//	out_html.WriteText(comment);
	//	out_html.WriteText(L" -->\r\n");
	//}
	for (int i=0; i<indentCount; i++) out_html.WriteText(L"  ");
}

void Object::EndIndent(int& indentCount, bool newLine, Sys::ITextWriterW& out_html)
{
	if (indentCount == -1) return;
	if (newLine == true) out_html.WriteText(L"\r\n");
	indentCount--;
	if (newLine == true) 
	{
		for (int i=0; i<indentCount; i++) out_html.WriteText(L"  ");
	}
}

/* vaData has three columns as follows:
0 -> Caption                 1 -> Value               2 -> Color
each row is an entry 
 You can define css.background and css.background before 
calling BarGraph*/
//void Shtml::BarGraph(vector<StrArray>& vaData, 
//					int nWidth, 
//					int nHeight, 
//					int nPositionX, 
//					int nPositionY,
//					int nFontSize,
//					int nDecimals)
//{
//	int nMaxIndex=0;//flData.GetMaxValue(1);
//	double dMaxValue=-1000000;
//	int i=0;
//	int j=0;
//	int nDigitCount=0;
//	int nRowCount=(int)vaData.size();
//	double dCaptionPositionX=0;
//	double dCaptionPositionY=0;
//	double dDeltaX=0;
//	double dDeltaY=0;
//	double dMaxY=0;
//	double dDeltaValue=0;
//	double dMarkDeltaX=0;
//	double dMarkY=0;
//	double dDotsPerY=0;
//	double dBarSizeY=0;
//	double dBarPositionX=0;
//	double dBarPositionY=0;
//	double dTablePositionX=0;
//	StrArray sa;
//
//	sa.SetColumnCount(3);
//
//	if (nRowCount>0)
//	{
//		/****************************** We compute the MAXIMUM value */
//		for(i=0; i<nRowCount; i++)
//		{
//			sa=vaData[i];
//			if (   StrArray::ToDouble(sa.GetValue(1))  >dMaxValue)
//			{
//				dMaxValue=StrArray::ToDouble(sa.GetValue(1));
//				nMaxIndex=i;
//			}
//		}
//		//
//		dDeltaX=nWidth/(nRowCount+1);
//		dDeltaY=nHeight/10;
//		dTablePositionX=nPositionX+4*nFontSize+0.5;
//
//		/****************************************************** Border */
//		css.size((int)(nWidth-0.5*dDeltaX), nHeight);
//		css.xy((int)dTablePositionX, (int)nPositionY);
//		table(NULL);
//		tr(NULL);
//		td(NULL);
//		Spaces(1);
//		tdtrtableEnd();
//
//		span(NULL);
//		
//		/**************************************************** X Caption */
//		dCaptionPositionY=nHeight+nPositionY+0.5*nFontSize;
//		for (i=0; i<nRowCount; i++)
//		{
//			sa=vaData[i];
//			//
//			if (sa.GetValue(0))
//			{
//				dCaptionPositionX=dDeltaX*i+dTablePositionX+0.4*dDeltaX;
//				css.xy((int)dCaptionPositionX, (int)dCaptionPositionY);
//				css.font("Times New Roman", nFontSize);
//				Text(sa.GetValue(0), NULL);
//			}
//		}
//
//		/***************************************************** Y Caption */
//		dMaxY=dMaxValue;
//		dDeltaValue=dMaxY/10;
//		for(i=0; i<11; i++)
//		{
//			dMarkY=nPositionY+nHeight-dDeltaY*i-0.5*nFontSize;
//			// Number 
//			css.xy(nPositionX, (int)dMarkY);
//			css.font("Times New Roman", nFontSize);
//			span(NULL);
//			SendDouble(i*dDeltaValue, 1);
//			spanEnd();
//			/* Mark */
//			if (i!=0 && i!=10)
//			{
//				dMarkDeltaX=nWidth;
//				dMarkY=nPositionY+nHeight-dDeltaY*i;
//				Line((int)dTablePositionX, 
//					(int)dMarkY,
//					(int)(dTablePositionX+dMarkDeltaX),
//					(int)dMarkY,
//					1,
//					"ffffff");
//			}
//		}
//		nPositionX+=10;
//
//		/********************************************************** Bars */
//		dDotsPerY=nHeight/dMaxY;
//		for (i=0; i<nRowCount; i++)
//		{
//			sa=vaData[i];
//			if (StrArray::ToDouble(sa.GetValue(1))>0)
//			{
//				dBarPositionX=dDeltaX*i+dTablePositionX+0.3*dDeltaX;
//				dBarSizeY=dDotsPerY*(StrArray::ToDouble(sa.GetValue(1)));
//				dBarPositionY=nPositionY+nHeight-(int)(dBarSizeY+0.5);
//				css.xy((int)(dBarPositionX+0.5), (int)(dBarPositionY+0.5));
//				css.size((int)(dDeltaX*0.80), (int)(dBarSizeY+0.5));
//				css.font("Times New Roman", 1);
//				if (sa.GetValue(2))
//					css.background(NULL, sa.GetValue(2));
//				Text("&nbsp;", NULL);
//			}
//		}
//	}
//	spanEnd();
//}


/* bPictureServerName indicates whether or not you want to include the
name of the server of the PictureFile */
//void Shtml::Mail(char* cTo, char* cSubject, char* cBody, char* cCC, char* cClass)
//{	
//	ostream& o=Out();
//	m_nTag_link++;
//	TagIni("A", cClass, false, false);
//	o<<" href=\"mailto: "<<cTo;
//	if (cSubject)
//		o<<"?subject="<<cSubject;
//	if (cBody)
//		o<<"&body="<<cBody;
//	if (cCC)
//		o<<"&cc="<<cCC;
//	o<<"\">";
//	o.flush();
//}

///* va =>  Date, Caption, Class, Link, VariableValue
//       "01/02/2002", "Dinner with President", "Elegant", "dinner.htm", NULL
//	   Please define the css class CalendarHeader */
//bool Shtml::CalendarView(int nMonth, int nDay, int nYear,
//				  bool bDisplayHeader,
//				  bool bDisplayWeekend,
//				  vector<StrArray>& va)
//{
//	bool bOK=false;
//	int nRow;
//	int nColumn;
//	int i=0;
//	time_t lLocalTime;
//	time_t lTime;
//	int nLocalMonth;
//	int nLocalDay;
//	int nLocalYear;
//	struct tm  *today;
//	struct tm When;
//	char cTmp[20];
//	char cDate[20];// It saves the date on the format MM/DD/YYYY
//	char cBorder[]="groove";
//	const int nBorder=1;
//	StrArray sa;
//
//	sa.SetColumnCount(5);
//
//	if ((nMonth==0) && (nDay==0) && (nYear==0))
//	{
//		time(&lTime);
//		today=localtime(&lTime);
//		nMonth=today->tm_mon;
//		nDay=today->tm_mday;
//		nYear=today->tm_year;
//		lLocalTime=FindFirstSunday(lTime);
//		bOK=true;
//	}
//
//	if  (  (0<nMonth) && (nMonth<=12) && (1900<nYear) && (nYear<=9999))
//	{
//		nMonth--;
//		nYear-=1900;
//		When.tm_year=nYear;
//		When.tm_mon=nMonth;
//		When.tm_mday=1;
//		When.tm_hour=12;
//		When.tm_min=0;
//		When.tm_sec=0;
//
//		if ( (lLocalTime=mktime(&When))  !=(time_t)-1)
//		{
//			lLocalTime=FindFirstSunday(lLocalTime);
//			bOK=true;
//		}
//		else
//			bOK=false;
//	}
//
//	if (bOK)
//	{
////		css.background(NULL, "d0d0ff");
//		css.border(3, "outset", "c0c0c0");
//		css.width("100%");
////		css.height("100%");
////		SetCustom("border=\"1\"");
//		table(NULL); // This table has two rows.  Each row is another table
//		tr(NULL);
//		td(NULL);
//		//
//		css.width("100%");
//		table(NULL);
//		tr(NULL);
//		//
//		css.textAlign("right");
//		td(NULL);	
//		if (bDisplayHeader)
//		{
//		/******************************************************************* Main Label */
//			// We create the previous month button
//			if (nMonth==0)
//			{	
//				itoa(nYear+1900-1, cTmp, 10);
//				SetVariable("nCalendarYear", cTmp);
//				SetVariable("nCalendarMonth", "12");	
//			}
//			else
//			{
//				itoa(nYear+1900, cTmp, 10);
//				SetVariable("nCalendarYear", cTmp);
//				itoa(nMonth, cTmp, 10); // it should be (nMonth+1)-1
//				SetVariable("nCalendarMonth", cTmp);
//			}
//			ActiveLink(NULL);
//			css.border(0, "solid", "ffffff");
//			css.textDecoration("none");
//			Text("<b>&lt;&lt;</b>", "CalendarHeader");
//			ActiveLinkEnd();
//		}
//		else
//			Spaces(1);
//		tdEnd();
//		//
//		css.textAlign("center");
//		td("CalendarHeader");
//		s(MonthName(nMonth, true));
//		Spaces(2);
//		SendInt(nYear+1900);
//		tdEnd();
//		//
//		css.textAlign("left");
//		td(NULL);
//				
//		if (bDisplayHeader)
//		{
//			// We create the next month button
//			if (nMonth==11)
//			{	
//				itoa(nYear+1900+1, cTmp, 10);
//				SetVariable("nCalendarYear", cTmp);
//				SetVariable("nCalendarMonth", "1");
//			}
//			else
//			{
//				itoa(nYear+1900, cTmp, 10);
//				SetVariable("nCalendarYear", cTmp);
//				itoa(nMonth+2, cTmp, 10); // it should be (nMonth+1)+1
//				SetVariable("nCalendarMonth", cTmp);
//			}
//			ActiveLink(NULL);
//			css.border(0, "solid", "ffffff");
//			css.textDecoration("none");
//			Text("<b>&gt;&gt;</b>", "CalendarHeader");
//			ActiveLinkEnd();
//		}
//		else
//			Spaces(1);
//		tdEnd();
//		//
//		trEnd();
//		tableEnd(); // End of the first table
//		//
//		tdtrEnd();
//        /******************************************************************* Days of the month */
//		css.width("100%");
//		css.height("100%");
//		tr(NULL);
//		css.width("100%");
//		css.height("100%");
//		td(NULL);
//		css.border(nBorder, cBorder, "ffffff");
//		//SetCustom("border=\"1\"");
//		css.width("100%");
//		css.height("100%");
//		table(NULL);
//		//
//		css.height("30px");
//		tr(NULL);
//		//
//		if (bDisplayWeekend)
//		{
//			css.border(nBorder, cBorder, "ffffff");
//			css.background(NULL, "c0d0ff");
//			css.textAlign("center");
//			td(NULL);		
//			Text("Sunday", "CalendarHeader");
//			tdEnd();
//		}
//		//
//		css.border(nBorder, cBorder, "ffffff");
//		css.background(NULL, "d0f0ff");
//		css.textAlign("center");
//		td(NULL);	
//		Text("Monday", "CalendarHeader");
//		tdEnd();
//		//
//		css.border(nBorder, cBorder, "ffffff");
//		css.background(NULL, "d0f0ff");
//		css.textAlign("center");
//		td(NULL);	
//		Spaces(1);
//		Text("Tuesday", "CalendarHeader");
//		Spaces(1);
//		tdEnd();
//		//
//		css.border(nBorder, cBorder, "ffffff");
//		css.background(NULL, "d0f0ff");
//		css.textAlign("center");
//		td(NULL);	
//		Text("Wednesday", "CalendarHeader");
//		tdEnd();
//		//
//		css.border(nBorder, cBorder, "ffffff");
//		css.background(NULL, "d0f0ff");
//		css.textAlign("center");
//		td(NULL);	
//		Text("Thursday", "CalendarHeader");
//		tdEnd();
//		//
//		css.border(nBorder, cBorder, "ffffff");
//		css.background(NULL, "d0f0ff");
//		css.textAlign("center");
//		td(NULL);	
//		Spaces(2);
//		Text("Friday", "CalendarHeader");
//		Spaces(2);
//		tdEnd();
//		//
//		if (bDisplayWeekend)
//		{
//			css.border(nBorder, cBorder, "ffffff");
//			css.background(NULL, "c0d0ff");
//			css.textAlign("center");
//			td(NULL);	
//			Text("Saturday", "CalendarHeader");
//			tdEnd();
//		}
//		//
//		trEnd();
//
//		today=localtime(&lLocalTime);
//		nLocalDay=today->tm_mday;
//		nLocalMonth=today->tm_mon;
//		nLocalYear=today->tm_year;
//		for (nRow=0; nRow<6; nRow++)
//		{
//			css.verticalAlign("top");
//			tr(NULL);
//			for(nColumn=0; nColumn<7; nColumn++)
//			{
//				if (  (nColumn!=0 && nColumn!=6) || bDisplayWeekend )
//				{
//					if (nLocalMonth==nMonth)
//						css.background(NULL, "ffffff");
//					else
//						css.background(NULL, "c0c0c0");
//					
//					if (bDisplayWeekend)
//						css.width("14.29%");
//					else
//						css.width("20%");
//					css.border(nBorder, cBorder, "ffffff");
//					td(NULL); // Another color
//			
//					/* We create cDate MM/DD/YYYY */
//					itoa(nLocalMonth+1, cTmp, 10);
//					if (nLocalMonth+1<10)
//						strcpy(cDate, "0");
//					else
//						cDate[0]='\0';
//					strcat(cDate, cTmp);
//					strcat(cDate, "/");
//					//
//					itoa(nLocalDay, cTmp, 10);
//					if (nLocalDay<10)
//						strcat(cDate, "0");
//					strcat(cDate, cTmp);
//					strcat(cDate, "/");
//					itoa(nLocalYear+1900, cTmp, 10);
//					strcat(cDate, cTmp);
//				
//					if (nLocalMonth==nMonth)
//					{
//						css.fontWeight("bold");
//						css.font("Times New Roman", 17);
//						css.color("f00000");
//						span(NULL);
//						SendInt(nLocalDay);
//						spanEnd();
//						NewLine(1);
//						for (i=0; i<(int)va.size(); i++)
//						{
//							/* Date, Caption, Class, Link, VariableValue */
//							sa=va[i];
//							if (strcmp(cDate, sa.GetValue(0))==0)
//							{
//								if (sa.GetValue(4))
//								{
//									SetVariable("nCalendarIndex", sa.GetValue(4));
//									ActiveLink(NULL);
//								}
//								else if (sa.GetValue(3))
//									Link(sa.GetValue(3), NULL);
//								span(sa.GetValue(2));
//								s(sa.GetValue(1));
//								spanEnd();
//								if (sa.GetValue(4))
//									ActiveLinkEnd();
//								else if (sa.GetValue(3))
//									LinkEnd();
//							}
//						}
//					}
//					else
//					{
//						css.fontWeight("bold");
//						css.font("Times New Roman", 17);
//						css.color("e0e0e0");
//						span(NULL);
//						SendInt(nLocalDay);
//						spanEnd();
//					}
//					tdEnd();
//				}
//				lLocalTime=lLocalTime+86400;
//				today=localtime(&lLocalTime);
//				nLocalDay=today->tm_mday;
//				nLocalMonth=today->tm_mon;
//				nLocalYear=today->tm_year;
//			}
//			trEnd();
//		}
//		tableEnd();
//		tdtrEnd();
//		tableEnd();
//	}
//	return bOK;
//}


//________________________________________________________ VisibleObject
VisibleObject::VisibleObject(void)
{
	Visible = true;
	memoryBlock1 = 0;
	memoryBlock2 = 0;
	Visible = true;
	Enabled = true;
}

VisibleObject::~VisibleObject(void)
{
}

void VisibleObject::RenderClassAndStyle(Sys::ITextWriterW& out_html)
{
	css.GetHtml(out_html);
	if (cssClass.length()>0)
	{
		out_html.WriteText(L" class=\"");
		out_html.WriteText(cssClass);
		out_html.WriteText(L"\"");
	}
}

void VisibleObject::SetOnClick(bool fireEvent)
{
	// memoryBlock1: X000 0000
	if (fireEvent == true)
	{
		memoryBlock1 |= 0x80000000;
		memoryBlock1 &= 0xBFFFFFFF;
	}
	else
	{
		memoryBlock1 &= 0x7FFFFFFF;
	}
}

bool VisibleObject::GetOnClick()
{
	 // memoryBlock1: X000 0000
	return ((memoryBlock1 & 0x80000000) != 0);
}

void VisibleObject::SetOnJsClick(bool fireEvent)
{ 
	// memoryBlock1: X000 0000
	if (fireEvent == true)
	{
		memoryBlock1 |= 0x40000000;
		memoryBlock1 &= 0x7FFFFFFF;
	}
	else
	{
		memoryBlock1 &= 0xBFFFFFFF;
	}
}

bool VisibleObject::GetOnJsClick()
{
	 // memoryBlock1: X000 0000
	return ((memoryBlock1 & 0x40000000) != 0);
}

void VisibleObject::SetOnDblClick(bool fireEvent)
{
	// memoryBlock1: 0X00 0000
	if (fireEvent == true)
	{
		memoryBlock1 |= 0x08000000;
		memoryBlock1 &= 0xFBFFFFFF;
	}
	else
	{
		memoryBlock1 &= 0xF7FFFFFF;
	}
}

bool VisibleObject::GetOnDblClick()
{
	// memoryBlock1: 0X00 0000
	return ((memoryBlock1 & 0x08000000) != 0);
}

void VisibleObject::SetOnJsDblClick(bool fireEvent)
{
	// memoryBlock1: 0X00 0000
	if (fireEvent == true)
	{
		memoryBlock1 |= 0x04000000;
		memoryBlock1 &= 0xF7FFFFFF;
	}
	else
	{
		memoryBlock1 &= 0xFBFFFFFF;
	}
}

bool VisibleObject::GetOnJsDblClick()
{
	// memoryBlock1: 0X00 0000
	return ((memoryBlock1 & 0x04000000) != 0);
}

void VisibleObject::SetOnMouseDown(bool fireEvent)
{
	// memoryBlock1: 00X0 0000
	if (fireEvent == true)
	{
		memoryBlock1 |= 0x00800000;
		memoryBlock1 &= 0xFFBFFFFF;
	}
	else
	{
		memoryBlock1 &= 0xFF7FFFFF;
	}
}

bool VisibleObject::GetOnMouseDown()
{
	// memoryBlock1: 00X0 0000
	return ((memoryBlock1 & 0x00800000) != 0);
}

void VisibleObject::SetOnJsMouseDown(bool fireEvent)
{
	// memoryBlock1: 00X0 0000
	if (fireEvent == true)
	{
		memoryBlock1 |= 0x00400000;
		memoryBlock1 &= 0xFF7FFFFF;
	}
	else
	{
		memoryBlock1 &= 0xFFBFFFFF;
	}
}

bool VisibleObject::GetOnJsMouseDown()
{
	// memoryBlock1: 00X0 0000
	return ((memoryBlock1 & 0x00400000) != 0);
}

void VisibleObject::SetOnMouseUp(bool fireEvent)
{
	// memoryBlock1: 000X 0000
	if (fireEvent == true)
	{
		memoryBlock1 |= 0x00080000;
		memoryBlock1 &= 0xFFFBFFFF;
	}
	else
	{
		memoryBlock1 &= 0xFFF7FFFF;
	}
}

bool VisibleObject::GetOnMouseUp()
{
	// memoryBlock1: 000X 0000
	return ((memoryBlock1 & 0x00080000) != 0);
}

void VisibleObject::SetOnJsMouseUp(bool fireEvent)
{
	// memoryBlock1: 000X 0000
	if (fireEvent == true)
	{
		memoryBlock1 |= 0x00040000;
		memoryBlock1 &= 0xFFF7FFFF;
	}
	else
	{
		memoryBlock1 &= 0xFFFBFFFF;
	}
}

bool VisibleObject::GetOnJsMouseUp()
{
	// memoryBlock1: 000X 0000
	return ((memoryBlock1 & 0x00040000) != 0);
}

void VisibleObject::SetOnMouseMove(bool fireEvent)
{
	// memoryBlock1: 0000 X000
	if (fireEvent == true)
	{
		memoryBlock1 |= 0x00008000;
		memoryBlock1 &= 0xFFFFBFFF;
	}
	else
	{
		memoryBlock1 &= 0xFFFF7FFF;
	}
}

bool VisibleObject::GetOnMouseMove()
{
	// memoryBlock1: 0000 X000
	return ((memoryBlock1 & 0x00008000) != 0);
}

void VisibleObject::SetOnJsMouseMove(bool fireEvent)
{
	// memoryBlock1: 0000 X000
	if (fireEvent == true)
	{
		memoryBlock1 |= 0x00004000;
		memoryBlock1 &= 0xFFFF7FFF;
	}
	else
	{
		memoryBlock1 &= 0xFFFFBFFF;
	}
}

bool VisibleObject::GetOnJsMouseMove()
{
	// memoryBlock1: 0000 X000
	return ((memoryBlock1 & 0x00004000) != 0);
}

void VisibleObject::SetOnMouseOut(bool fireEvent)
{
	// memoryBlock1: 0000 0X00
	if (fireEvent == true)
	{
		memoryBlock1 |= 0x00000800;
		memoryBlock1 &= 0xFFFFFBFF;
	}
	else
	{
		memoryBlock1 &= 0xFFFFF7FF;
	}
}

bool VisibleObject::GetOnMouseOut()
{
	// memoryBlock1: 0000 0X00
	return ((memoryBlock1 & 0x00000800) != 0);
}

void VisibleObject::SetOnJsMouseOut(bool fireEvent)
{
	// memoryBlock1: 0000 0X00
	if (fireEvent == true)
	{
		memoryBlock1 |= 0x00000400;
		memoryBlock1 &= 0xFFFFF7FF;
	}
	else
	{
		memoryBlock1 &= 0xFFFFFBFF;
	}
}

bool VisibleObject::GetOnJsMouseOut()
{
	// memoryBlock1: 0000 0X00
	return ((memoryBlock1 & 0x00000400) != 0);
}

void VisibleObject::SetOnFocus(bool fireEvent)
{
	// memoryBlock1: 0000 00X0
	if (fireEvent == true)
	{
		memoryBlock1 |= 0x00000080;
		memoryBlock1 &= 0xFFFFFFBF;
	}
	else
	{
		memoryBlock1 &= 0xFFFFFF7F;
	}
}

bool VisibleObject::GetOnFocus()
{
	// memoryBlock1: 0000 00X0
	return ((memoryBlock1 & 0x00000080) != 0);
}

void VisibleObject::SetOnJsFocus(bool fireEvent)
{
	// memoryBlock1: 0000 00X0
	if (fireEvent == true)
	{
		memoryBlock1 |= 0x00000040;
		memoryBlock1 &= 0xFFFFFF7F;
	}
	else
	{
		memoryBlock1 &= 0xFFFFFFBF;
	}
}

bool VisibleObject::GetOnJsFocus()
{
	// memoryBlock1: 0000 00X0
	return ((memoryBlock1 & 0x00000040) != 0);
}

void VisibleObject::SetOnBlur(bool fireEvent)
{
	// memoryBlock1: 0000 000X
	if (fireEvent == true)
	{
		memoryBlock1 |= 0x00000008;
		memoryBlock1 &= 0xFFFFFFFB;
	}
	else
	{
		memoryBlock1 &= 0xFFFFFFF7;
	}
}

bool VisibleObject::GetOnBlur()
{
	// memoryBlock1: 0000 000X
	return ((memoryBlock1 & 0x00000008) != 0);
}

void VisibleObject::SetOnJsBlur(bool fireEvent)
{
	// memoryBlock1: 0000 000X
	if (fireEvent == true)
	{
		memoryBlock1 |= 0x00000004;
		memoryBlock1 &= 0xFFFFFFF7;
	}
	else
	{
		memoryBlock1 &= 0xFFFFFFFB;
	}
}

bool VisibleObject::GetOnJsBlur()
{
	// memoryBlock1: 0000 000X
	return ((memoryBlock1 & 0x00000004) != 0);
}

void VisibleObject::SetOnKeyPress(bool fireEvent)
{
	// memoryBlock2: X000 0000
	if (fireEvent == true)
	{
		memoryBlock2 |= 0x80000000;
		memoryBlock2 &= 0xBFFFFFFF;
	}
	else
	{
		memoryBlock2 &= 0x7FFFFFFF;
	}
}

bool VisibleObject::GetOnKeyPress()
{
	// memoryBlock2: X000 0000
	return ((memoryBlock2 & 0x80000000) != 0);
}

void VisibleObject::SetOnJsKeyPress(bool fireEvent)
{
	// memoryBlock2: X000 0000
	if (fireEvent == true)
	{
		memoryBlock2 |= 0x40000000;
		memoryBlock2 &= 0x7FFFFFFF;
	}
	else
	{
		memoryBlock2 &= 0xBFFFFFFF;
	}
}

bool VisibleObject::GetOnJsKeyPress()
{
	// memoryBlock2: X000 0000
	return ((memoryBlock2 & 0x40000000) != 0);
}

void VisibleObject::SetOnKeyDown(bool fireEvent)
{
	// memoryBlock2: 0X00 0000
	if (fireEvent == true)
	{
		memoryBlock2 |= 0x08000000;
		memoryBlock2 &= 0xFBFFFFFF;
	}
	else
	{
		memoryBlock2 &= 0xF7FFFFFF;
	}
}

bool VisibleObject::GetOnKeyDown()
{
	// memoryBlock2: 0X00 0000
	return ((memoryBlock2 & 0x08000000) != 0);
}

void VisibleObject::SetOnJsKeyDown(bool fireEvent)
{
	// memoryBlock2: 0X00 0000
	if (fireEvent == true)
	{
		memoryBlock2 |= 0x04000000;
		memoryBlock2 &= 0xF7FFFFFF;
	}
	else
	{
		memoryBlock2 &= 0xFBFFFFFF;
	}
}

bool VisibleObject::GetOnJsKeyDown()
{
	// memoryBlock2: 0X00 0000
	return ((memoryBlock2 & 0x04000000) != 0);
}

void VisibleObject::SetOnKeyUp(bool fireEvent)
{
	// memoryBlock2: 00X0 0000
	if (fireEvent == true)
	{
		memoryBlock2 |= 0x00800000;
		memoryBlock2 &= 0xFFBFFFFF;
	}
	else
	{
		memoryBlock2 &= 0xFF7FFFFF;
	}
}

bool VisibleObject::GetOnKeyUp()
{
	// memoryBlock2: 00X0 0000
	return ((memoryBlock2 & 0x00800000) != 0);
}

void VisibleObject::SetOnJsKeyUp(bool fireEvent)
{
	// memoryBlock2: 00X0 0000
	if (fireEvent == true)
	{
		memoryBlock2 |= 0x00400000;
		memoryBlock2 &= 0xFF7FFFFF;
	}
	else
	{
		memoryBlock2 &= 0xFFBFFFFF;
	}
}

bool VisibleObject::GetOnJsKeyUp()
{
	// memoryBlock2: 00X0 0000
	return ((memoryBlock2 & 0x00400000) != 0);
}

void VisibleObject::SetOnSelect(bool fireEvent)
{
	// memoryBlock2: 000X 0000
	if (fireEvent == true)
	{
		memoryBlock2 |= 0x00080000;
		memoryBlock2 &= 0xFFFBFFFF;
	}
	else
	{
		memoryBlock2 &= 0xFFF7FFFF;
	}
}

bool VisibleObject::GetOnSelect()
{
	// memoryBlock2: 000X 0000
	return ((memoryBlock2 & 0x00080000) != 0);
}

void VisibleObject::SetOnJsSelect(bool fireEvent)
{
	// memoryBlock2: 000X 0000
	if (fireEvent == true)
	{
		memoryBlock2 |= 0x00040000;
		memoryBlock2 &= 0xFFF7FFFF;
	}
	else
	{
		memoryBlock2 &= 0xFFFBFFFF;
	}
}

bool VisibleObject::GetOnJsSelect()
{
	// memoryBlock2: 000X 0000
	return ((memoryBlock2 & 0x00040000) != 0);
}

void VisibleObject::SetOnChange(bool fireEvent)
{
	// memoryBlock2: 0000 X000
	if (fireEvent == true)
	{
		memoryBlock2 |= 0x00008000;
		memoryBlock2 &= 0xFFFFBFFF;
	}
	else
	{
		memoryBlock2 &= 0xFFFF7FFF;
	}
}

bool VisibleObject::GetOnChange()
{
	// memoryBlock2: 0000 X000
	return ((memoryBlock2 & 0x00008000) != 0);
}

void VisibleObject::SetOnJsChange(bool fireEvent)
{
	// memoryBlock2: 0000 X000
	if (fireEvent == true)
	{
		memoryBlock2 |= 0x00004000;
		memoryBlock2 &= 0xFFFF7FFF;
	}
	else
	{
		memoryBlock2 &= 0xFFFFBFFF;
	}
}

bool VisibleObject::GetOnJsChange()
{
	// memoryBlock2: 0000 X000
	return ((memoryBlock2 & 0x00004000) != 0);
}

void VisibleObject::SetVisible(bool visible)
{
	// memoryBlock2: 0000 0000 0000 0000 00000 1000 0000 0000
	if (visible == true)
	{
		memoryBlock2 |= 0x00000800;
	}
	else
	{
		memoryBlock2 &= 0xFFFFF7FF;
	}
}

bool VisibleObject::GetVisible()
{
	// memoryBlock2: 0000 0000 0000 0000 00000 1000 0000 0000
	return ((memoryBlock2 & 0x00000800) != 0);
}

void VisibleObject::SetEnabled(bool enabled)
{
	// memoryBlock2: 0000 0000 0000 0000 00000 0100 0000 0000
	if (enabled == true)
	{
		memoryBlock2 |= 0x00000400;
	}
	else
	{
		memoryBlock2 &= 0xFFFFFBFF;
	}
}

bool VisibleObject::GetEnabled()
{
	// memoryBlock2: 0000 0000 0000 0000 00000 0100 0000 0000
	return ((memoryBlock2 & 0x00000400) != 0);
}

void VisibleObject::RenderJavascriptEvents(Sys::ITextWriterW& out_html, const wchar_t* url)
{
	if (GetOnClick() == true || GetOnJsClick() == true) RenderFunction(HTML_CLICK, out_html, url);
	if (GetOnDblClick() == true || GetOnJsDblClick() == true) RenderFunction(HTML_DBLCLICK, out_html, url);
	if (GetOnMouseDown() == true || GetOnJsMouseDown() == true) RenderFunction(HTML_MOUSEDOWN, out_html, url);
	if (GetOnMouseUp() == true || GetOnJsMouseUp() == true) RenderFunction(HTML_MOUSEUP, out_html, url);
	if (GetOnMouseMove() == true || GetOnJsMouseMove() == true) RenderFunction(HTML_MOUSEMOVE, out_html, url);
	if (GetOnMouseOut() == true || GetOnJsMouseOut() == true) RenderFunction(HTML_MOUSEOUT, out_html, url);
	if (GetOnFocus() == true || GetOnJsFocus() == true) RenderFunction(HTML_FOCUS, out_html, url);
	if (GetOnBlur() == true || GetOnJsBlur() == true) RenderFunction(HTML_BLUR, out_html, url);
	if (GetOnKeyPress() == true || GetOnJsKeyPress() == true) RenderFunction(HTML_KEYPRESS, out_html, url);
	if (GetOnKeyDown() == true || GetOnJsKeyDown() == true) RenderFunction(HTML_KEYDOWN, out_html, url);
	if (GetOnKeyUp() == true || GetOnJsKeyUp() == true) RenderFunction(HTML_KEYUP, out_html, url);
	if (GetOnSelect() == true || GetOnJsSelect() == true) RenderFunction(HTML_SELECT, out_html, url);
	if (GetOnChange() == true || GetOnJsChange() == true) RenderFunction(HTML_CHANGE, out_html, url);
}

void VisibleObject::RenderName(Sys::ITextWriterW& out_html)
{
	if (ID.length() == 0) return;
	out_html.WriteText(L" name=\"");
	out_html.WriteText(ID);
	out_html.WriteText(L"Data\"");
}

//________________________________________________________ Button
Button::Button()
{
	SetSubmit(true);
}

Button::~Button()
{
}

void Button::OnNavigateAway(Web::HttpConnector& httpConnector)
{
}

void Button::GetPreview(int& indentCount, Sys::ITextWriterW& out_html)
{
	if (Visible == false) return;
	RenderTagAndId(false, indentCount, out_html);
	if (Submit == true)
	{
		out_html.WriteText(L" type=\"submit\"");
	}
	else
	{
		out_html.WriteText(L" type=\"button\"");
	}
	RenderClassAndStyle(out_html);
	RenderPair(L"value", Text, out_html);
	if (Enabled == false) RenderPair(L"disabled", L"true", out_html);
	
	out_html.WriteText(L" />");
	if (EndHtml.length() > 0) out_html.WriteText(EndHtml);
}

void Button::GetHtml(int& indentCount, Sys::ITextWriterW& out_html, Web::HttpConnector& httpConnector)
{
	if (Visible == false) return;
	RenderTagAndId(false, indentCount, out_html);
	if (Submit == true)
	{
		out_html.WriteText(L" type=\"submit\"");
	}
	else
	{
		out_html.WriteText(L" type=\"button\"");
	}
	RenderClassAndStyle(out_html);
	//RenderPair(L"name", L"ButtonEvent", out_html);
	RenderPair(L"value", Text, out_html);
	if (Enabled == false) RenderPair(L"disabled", L"true", out_html);
	
	if (Submit == true)
	{
		//________________________________________________ onclick Javascript event
		wchar_t onclickFunc[128];
		_snwprintf_s(onclickFunc, 128, _TRUNCATE,  
			L"var hid = document.getElementById('serverClick'); if (hid!=null){hid.value='%s';}", ID.c_str());
		RenderPair(L"onclick", onclickFunc, out_html);
	}
	else
	{
		RenderJavascriptEvents(out_html, httpConnector.url.c_str());
	}
	out_html.WriteText(L" />");
	if (EndHtml.length() > 0) out_html.WriteText(EndHtml);
}

void Button::GetXml(Web::HttpConnector& httpConnector)
{
}

void Button::LoadState(Web::HttpConnector& httpConnector)
{
}

wchar_t* Button::GetTag()
{
	return L"input";
}

void Button::SetSubmit(bool isSubmit)
{
	// memoryBlock2:0000 0000 0000 0000 00000 0000 0100 0000
	if (isSubmit == true)
	{
		memoryBlock2 |= 0x00000040;
	}
	else
	{
		memoryBlock2 &= 0xFFFFFFBF;
	}
}

bool Button::IsSubmit()
{
	// mmemoryBlock2:0000 0000 0000 0000 00000 0000 0100 0000
	return ((memoryBlock2 & 0x00000040) != 0);
}

//________________________________________________________ Textbox
Textbox::Textbox()
{
	MaxLength = 32;
	RowCount = 1;
	ColCount = 16;
	ReadOnly = false;
	Password = false;
	//
	//_balloonCaption;
	//_balloonText;
	_balloonIcon = -1;
}

Textbox::~Textbox()
{
}

//Textbox::operator wstring&()
//{
//	return Text;
//}

void Textbox::OnNavigateAway(Web::HttpConnector& httpConnector)
{
}

void Textbox::ShowBalloonTip(const wchar_t* caption, const wchar_t* text, int icon)
{
	//icon: TTI_INFO, TTI_WARNING, TTI_ERROR
	_balloonCaption = caption;
	_balloonText = text;
	_balloonIcon = icon;
}

void Textbox::ShowBalloonTip(const wstring& caption, const wstring& text, int icon)
{
	//icon: TTI_INFO, TTI_WARNING, TTI_ERROR
	_balloonCaption = caption;
	_balloonText = text;
	_balloonIcon = icon;
}

void Textbox::SetPassword(bool isPassword)
{
	// memoryBlock2: 0000 0000 0000 0000 00000 0000 0010 0000
	if (isPassword == true)
	{
		memoryBlock2 |= 0x00000020;
	}
	else
	{
		memoryBlock2 &= 0xFFFFFFDF;
	}
}

bool Textbox::GetPassword()
{
	// memoryBlock2: 0000 0000 0000 0000 00000 0000 0010 0000
	return ((memoryBlock2 & 0x00000020) != 0);
}

void Textbox::SetReadOnly(bool readOnly)
{
	// memoryBlock2: 0000 0000 0000 0000 00000 0000 0001 0000
	if (readOnly == true)
	{
		memoryBlock2 |= 0x00000010;
	}
	else
	{
		memoryBlock2 &= 0xFFFFFFEF;
	}
}

bool Textbox::GetReadOnly()
{
	// memoryBlock2: 0000 0000 0000 0000 00000 0000 0001 0000
	return ((memoryBlock2 & 0x00000010) != 0);
}

void Textbox::RenderBalloon(int& indentCount, Sys::ITextWriterW& out_html)
{
	if (_balloonIcon != TTI_WARNING && _balloonIcon != TTI_ERROR && _balloonIcon != TTI_INFO) return;

	if (_balloonIcon == TTI_WARNING)
	{
		out_html.WriteText(L"<span style=\"border-color:#CFCF00");
	}
	else if (_balloonIcon == TTI_ERROR)
	{
		out_html.WriteText(L"<span style=\"border-color:#FF4040");
	}
	else if (_balloonIcon == TTI_INFO)
	{
		out_html.WriteText(L"<span style=\"border-color:#50B0FF");
	}
	out_html.WriteText(L";border-width:1px;border-style:solid;background:#ECECEC;font-family:Arial;font-size:12px;color:#000000;\"><span style=\"background:#");
	if (_balloonIcon == TTI_WARNING)
	{
		out_html.WriteText(L"FFFF20");
	}
	else if (_balloonIcon == TTI_ERROR)
	{
		out_html.WriteText(L"FF5050");
	}
	else if (_balloonIcon == TTI_INFO)
	{
		out_html.WriteText(L"50B0FF");
	}
	out_html.WriteText(L";text-align:center;font-weight:900\">&nbsp;!&nbsp;</span>");
	if (_balloonCaption.length() > 0)
	{
		out_html.WriteText(L"<b>");
		out_html.WriteText(_balloonCaption);
		out_html.WriteText(L"</b>:&nbsp;");
	}
	
	out_html.WriteText(_balloonText);
	out_html.WriteText(L"</span>");
}

void Textbox::GetPreview(int& indentCount, Sys::ITextWriterW& out_html, bool isBrowserView)
{
	RenderTagAndId(false, indentCount, out_html);
	RenderClassAndStyle(out_html);
	RenderName(out_html);
	if (Enabled == false) RenderPair(L"disabled", L"true", out_html);
	if (ReadOnly == true) RenderPair(L"readonly", L"true", out_html);

	if (RowCount <= 1 || Password == true) //______________________________ type="text"
	{
		RenderPair(L"type", L"text", out_html);
		if (MaxLength > 0) RenderPair(L"maxlength", MaxLength, out_html);
		if (ColCount > 0) RenderPair(L"size", ColCount, out_html);
		if (Text.length() > 0) RenderPair(L"value", Text, out_html);
		out_html.WriteText(L" />");
	}
	else //__________________________________________ Text Area
	{
		if (RowCount > 0) RenderPair(L"rows", RowCount, out_html);
		if (ColCount > 0) RenderPair(L"cols", ColCount, out_html);
		out_html.WriteText(L">");
		out_html.WriteText(Text);
		out_html.WriteText(L"</textarea>");
	}

	if (EndHtml.length() > 0) out_html.WriteText(EndHtml);
}

void Textbox::GetHtml(int& indentCount, Sys::ITextWriterW& out_html, Web::HttpConnector& httpConnector)
{
	if (Visible == false)
	{
		if (Text.length() > 0) RenderHiddenValue(false, indentCount, Text.c_str(), out_html);
		return;
	}
	RenderTagAndId(false, indentCount, out_html);
	RenderClassAndStyle(out_html);
	RenderName(out_html);
	if (Enabled == false) RenderPair(L"disabled", L"true", out_html);
	if (ReadOnly == true) RenderPair(L"readonly", L"true", out_html);
	RenderJavascriptEvents(out_html, httpConnector.url.c_str());

	if (RowCount <= 1 || Password == true) //______________________________ type="text"
	{
		if (Password == true)
		{
			RenderPair(L"type", L"password", out_html);
		}
		else
		{
			RenderPair(L"type", L"text", out_html);
		}
		if (MaxLength > 0) RenderPair(L"maxlength", MaxLength, out_html);
		if (ColCount > 0) RenderPair(L"size", ColCount, out_html);
		if (Text.length() > 0) RenderPair(L"value", Text, out_html);
		out_html.WriteText(L" />");
	}
	else //__________________________________________ Text Area
	{
		if (RowCount > 0) RenderPair(L"rows", RowCount, out_html);
		if (ColCount > 0) RenderPair(L"cols", ColCount, out_html);
		//if (Wrap == true) RenderPair(L"wrap", L"hard", out_html);
		out_html.WriteText(L">");
		out_html.WriteText(Text);
		out_html.WriteText(L"</textarea>");
	}
	//_________________________________ Render Ballon Tip
	RenderBalloon(indentCount, out_html);

	if (EndHtml.length() > 0) out_html.WriteText(EndHtml);
}

void Textbox::GetXml(Web::HttpConnector& httpConnector)
{
	//____ If value is the same as original, Xml Data for this control is not necessary
	wstring name(ID);
	name += L"Data";
	multimap<wstring, wstring>::iterator state = httpConnector.value.find(name);
	if (state == httpConnector.value.end()) return;
	if (state->second.length() == 0)
	{
		if (Text.length() == 0) return;
	}
	else
	{
		if (Text == state->second) return;
	}
	//_____ Create a Control Node for the Xml Data
	httpConnector.WriteText(L"<control><id>");
	httpConnector.WriteText(ID);
	httpConnector.WriteText(L"</id><type>Textbox</type><value>");
	if (Text.length() > 0)
	{
		wstring xmlValue;
		Sys::Convert::ToXml(Text.c_str(), xmlValue);
		httpConnector.WriteText(xmlValue);
	}
	httpConnector.WriteText(L"</value></control>");
}

void Textbox::LoadState(Web::HttpConnector& httpConnector)
{
	wstring name(ID);
	name += L"Data";
	multimap<wstring, wstring>::iterator state = httpConnector.value.find(name);
	if (state == httpConnector.value.end()) return;
	if (state->second.length() == 0)
	{
		Text = L"";
	}
	else
	{
		Text = state->second;
	}
}

//_____________________________________________________________________ ISelectString
wstring& Textbox::SqlGetString()
{
	return Text;
}

void Textbox::SqlUpdate(bool toGui)
{
	if (toGui == true)
	{
		this->Text.resize(wcslen(this->Text.c_str()));
	}
}

wchar_t* Textbox::GetTag()
{
	if (Password == true) return L"input";
	if (RowCount <= 1) return L"input";
	return L"textarea";
}

int Textbox::GetInt(void)
{
	return Sys::Convert::ToInt(Text);
}

void Textbox::SetInt(int value)
{
	this->Text = Sys::Convert::ToString(value);
}

double Textbox::GetDouble()
{
	return Sys::Convert::ToDouble(Text);
}

void Textbox::SetDouble(double value, const wchar_t* format)
{
	if (format==NULL) format = L"%g";
	Sys::Format(Text, format, value);
}

void Textbox::SetDouble(double value)
{
	this->SetDouble(value, L"%g");
}

//_____________________________________________________________________ ListItem
ListItem::ListItem()
{
}

ListItem::~ListItem()
{
}

bool ListItem::operator==(const ListItem& init) const
{
	if (Text != init.Text) return false;
	if (Data != init.Data) return false;
	if (Selected != init.Selected) return false;
	return true;
}

bool ListItem::operator!=(const ListItem& init) const
{
	if (Text != init.Text) return true;
	if (Data != init.Data) return true;
	if (Selected != init.Selected) return true;
	return false;
}

//_____________________________________________________________________ ListItemCollection
ListItemCollection::ListItemCollection(void)
{
	_selectedIndex = -1;
}

ListItemCollection::~ListItemCollection(void)
{
}

bool ListItemCollection::operator==(const ListItemCollection& init) const
{
	const size_t len = storage.size();
	if (len != init.storage.size()) return false;
	for(size_t i = 0; i<len; i++)
	{
		if (storage[i] != init.storage[i]) return false;
	}
	if (this->_selectedIndex != init._selectedIndex) return false;
	return true;
}

Web::ListItem& ListItemCollection::operator[](long index)
{
	return storage[index];
}

bool ListItemCollection::Delete(int index)
{
	const int len = storage.size();
	if (index < 0 || index >= len) return false;
	vector<Web::ListItem>::iterator p = storage.begin()+index;
	storage.erase(p);
	return true;
}

//___________________________ returns the index if the data is already set during LoadState
int ListItemCollection::GetLoadItemIndex(const wchar_t* data)
{
	if (data == NULL) return -1;
	const vector<Web::ListItem>::iterator itemEnd = storage.end();
	vector<Web::ListItem>::iterator p;
	int index = 0;
	for(p = storage.begin(); p != itemEnd; p++, index++)
	{
		if (p->Text.length() != 1) continue;
		if (p->Text[0] != '-') continue;
		if (p->Data == data) return index;
	}
	return -1;
}

void ListItemCollection::Add(const wchar_t* text, const wchar_t* data, bool selected)
{
	Web::ListItem item;
	item.Text = text;
	item.Data = data;
	item.Selected = selected;
	const int index = GetLoadItemIndex(data);
	if (index == -1)
	{
		storage.push_back(item);
		if (selected == true)
		{
			_selectedIndex = storage.size()-1;
		}
	}
	else
	{
		storage[index] = item;
		if (selected == true)
		{
			_selectedIndex = index;
		}
	}
}

void ListItemCollection::Add(const wstring& text, const wstring& data, bool selected)
{
	Add(text.c_str(), data.c_str(), selected);
}

void ListItemCollection::Add(const wchar_t* text, const wchar_t* data)
{
	Web::ListItem item;
	item.Text = text;
	item.Data = data;
	const int index = GetLoadItemIndex(data);
	if (index == -1)
	{
		if (_selectedIndex == storage.size()-1)
		{
			item.Selected = true;
		}
		else
		{
			item.Selected = false;
		}
		storage.push_back(item);
	}
	else
	{
		if (_selectedIndex == index)
		{
			item.Selected = true;
		}
		else
		{
			item.Selected = false;
		}
		storage[index] = item;
	}
}

void ListItemCollection::Add(const wstring& text, const wstring& data)
{
	Add(text.c_str(), data.c_str());
}

int ListItemCollection::GetCount()
{
	return storage.size();
}

//The return value is the zero-based index of the matching item. If the search is unsuccessful, it is -1
int ListItemCollection::GetIndex(const wchar_t* text)
{
	vector<Web::ListItem>::iterator pEnd = storage.end();
	int index = 0;
	for (vector<Web::ListItem>::iterator p = storage.begin(); p != pEnd; p++, index++)
	{
		if (p->Text == text)
		{
			return index;
		}
	}
	return -1;
}

void ListItemCollection::DeleteAll()
{
	storage.clear();
	_selectedIndex = -1;
}

//________________________________________________________ DropDownList
DropDownList::DropDownList()
{
	_rowCount = 1;
	AjaxUpdate = false;
}

DropDownList::~DropDownList()
{
}

void DropDownList::OnNavigateAway(Web::HttpConnector& httpConnector)
{
}

//_____________________________________________________________________ ISelectString
wstring& DropDownList::SqlGetString()
{
	return _sqlData;
}

void DropDownList::SqlUpdate(bool toGui)
{
	_sqlData.resize(wcslen(_sqlData.c_str()));
	if (toGui == true)
	{
		const int count = this->Items.GetCount();
		for(int i=0; i<count; i++)
		{
			if (this->Items[i].Data == _sqlData)
			{
				this->SetSelected(i);
				break;
			}
		}
	}
	else
	{
		_sqlData = this->GetSelectedData();
	}
}

void DropDownList::SetAjaxUpdate(bool update)
{
	// memoryBlock2: 0000 0000 0000 0000 00000 0010 0000 0000
	if (update == true)
	{
		memoryBlock2 |= 0x00000200;
	}
	else
	{
		memoryBlock2 &= 0xFFFFFDFF;
	}
}

bool DropDownList::GetAjaxUpdate()
{
	// memoryBlock2: 0000 0000 0000 0000 00000 0010 0000 0000
	return ((memoryBlock2 & 0x00000200) != 0);
}

wstring DropDownList::GetSelectedData()
{
	vector<Web::ListItem>::iterator pEnd = Items.storage.end();
	for (vector<Web::ListItem>::iterator p = Items.storage.begin(); p != pEnd; p++)
	{
		if (p->Selected == true)
		{
			return p->Data;
		}
	}
	return L"";
}

// data[0] must be an integer primary key, data[1] must be the caption shown to the user
void DropDownList::Enumerate(wchar_t** data, int colCount, int rowIndex)
{
	if (colCount>=2)
	{
		this->Items.Add(data[1], data[0]);
	}
	else if (colCount==1)
	{
		this->Items.Add(data[0], L"");
	}
}

bool DropDownList::SetSelected(int index)
{
	const int len = Items.storage.size();
	bool ok = false;
	for(int i = 0; i<len; i++)
	{
		if (i == index)
		{
			Items.storage[i].Selected =  true;
			Items._selectedIndex = i;
			ok = true;
		}
		else
		{
			Items.storage[i].Selected = false;
		}
	}
	return ok;
}

int DropDownList::GetSelectedIndex()
{
	const int len = Items.storage.size();
	bool ok = false;
	for(int i = 0; i<len; i++)
	{
		if (Items.storage[i].Selected ==  true) return i;
	}
	return -1;
}

bool DropDownList::SetSelected(const wchar_t* text)
{
	const int len = Items.storage.size();
	bool ok = false;
	for(int i = 0; i<len; i++)
	{
		if (Items.storage[i].Text ==  text)
		{
			Items.storage[i].Selected = true;
			Items._selectedIndex = i;
			ok = true;
		}
		else
		{
			Items.storage[i].Selected = false;
		}
	}
	return ok;
}

bool DropDownList::SetSelectedByData(const wstring& data)
{
	//_selectedData = data; // We store a copy in case there are no items
	const int len = Items.storage.size();
	bool ok = false;
	for(int i = 0; i<len; i++)
	{
		if (Items.storage[i].Data ==  data)
		{
			Items.storage[i].Selected = true;
			Items._selectedIndex = i;
			ok = true;
		}
		else
		{
			Items.storage[i].Selected = false;
		}
	}
	return ok;
}

void DropDownList::RenderInvisible(int& indentCount, Sys::ITextWriterW& out_html)
{
	RenderHiddenValue(false, indentCount, GetSelectedData().c_str(), out_html);
}

void DropDownList::RenderMultipleSelection(Sys::ITextWriterW& out_html)
{
}

void DropDownList::GetHtml(int& indentCount, Sys::ITextWriterW& out_html, Web::HttpConnector& httpConnector)
{
	if (Visible == false)
	{
		RenderInvisible(indentCount, out_html);
		return;
	}
	//_______________________________________________________ <input type ="select"
	RenderTagAndId(true, indentCount, out_html);
	RenderClassAndStyle(out_html);
	RenderName(out_html);
	if (Enabled == false) RenderPair(L"disabled", L"true", out_html);
	if (_rowCount == HTML_SIZE_AUTO)
	{
		RenderPair(L"size", 8, out_html);
	}
	else
	{
		RenderPair(L"size", _rowCount, out_html);
	}
	RenderJavascriptEvents(out_html, httpConnector.url.c_str());
	RenderMultipleSelection(out_html);
	out_html.WriteText(L" />");
	indentCount++;
	//____________________________________________________ Options
	vector<Web::ListItem>::iterator p = Items.storage.begin();
	const vector<Web::ListItem>::iterator pEnd = Items.storage.end();
	for(; p != pEnd; p++)
	{
		Indent(indentCount, out_html);
		out_html.WriteText(L"<option value=\"");
		out_html.WriteText(p->Data);
		out_html.WriteText(L"\"");
		if (p->Selected == true) out_html.WriteText(L" selected=\"true\"");
		out_html.WriteText(L">");
		out_html.WriteText(p->Text);
		out_html.WriteText(L"</option>");
	}
	indentCount--;
	Indent(indentCount, out_html);
	out_html.WriteText(L"</select>");
	if (EndHtml.length() > 0) out_html.WriteText(EndHtml);
}

void DropDownList::GetXml(Web::HttpConnector& httpConnector)
{
	if (GetAjaxUpdate() == false) return;
	//if (Items == _prevItems) return;  // _prevItems is initialized during LoadState
	const int itemCount = Items.storage.size();
	if (itemCount == 0) return;
	const vector<Web::ListItem>::iterator itemEnd = Items.storage.end();
	vector<Web::ListItem>::iterator item;
	wstring xmlValue;
	
	httpConnector.WriteText(L"<control><id>");
	httpConnector.WriteText(ID);
	httpConnector.WriteText(L"</id><type>Select</type><value>None</value><options>");
	//__________________________________ Items (Options)
	for(item = Items.storage.begin(); item != itemEnd; item++)
	{
		httpConnector.WriteText(L"<option><name>");
		Sys::Convert::ToXml(item->Text, xmlValue);
		httpConnector.WriteText(xmlValue);
		httpConnector.WriteText(L"</name><value>");
		Sys::Convert::ToXml(item->Data, xmlValue);
		httpConnector.WriteText(xmlValue);
		if (item->Selected == true)
		{
			httpConnector.WriteText(L"</value><selected>true</selected></option>");
		}
		else
		{
			httpConnector.WriteText(L"</value><selected>false</selected></option>");
		}
	}
	httpConnector.WriteText(L"</options></control>");
}

void DropDownList::LoadState(Web::HttpConnector& httpConnector)
{
	SelectedIndex = -1;
	//
	wstring name(ID);
	name += L"Data";
	pair<multimap<wstring,wstring>::iterator,multimap<wstring,wstring>::iterator> ret;
	ret = httpConnector.value.equal_range(name);
	if (ret.first == httpConnector.value.end()) return;
	if (ret.second == httpConnector.value.end()) return;
	//
	Web::ListItem listItem;
	listItem.Selected = true;
	listItem.Text = L"-";
	for (multimap<wstring, wstring>::iterator state = ret.first; state != ret.second; ++state)
	{
		listItem.Data = (*state).second;
		Items.storage.push_back(listItem);
	}
	if (Items.storage.size() > 0) Items._selectedIndex = 0;
}

wchar_t* DropDownList::GetTag()
{
	return L"select";
}

//________________________________________________________ ListBox
ListBox::ListBox()
{
	_rowCount = 8;
	MultipleSelection = false;
}

ListBox::~ListBox()
{
}

void ListBox::RenderMultipleSelection(Sys::ITextWriterW& out_html)
{
	if (MultipleSelection == true) out_html.WriteText(L" multiple=\"multiple\"");
}

//void ListBox::LoadState(Web::HttpConnector& httpConnector)
//{
//	const int len = Items.storage.size();
//	int i = 0;
//	wstring name(ID);
//	name += L"Data";
//	SetSelected(-1, false); // Unselect All
//	pair<multimap<wstring,wstring>::iterator,multimap<wstring,wstring>::iterator> ret;
//	ret = httpConnector.value.equal_range(name);
//	bool found = false;
//	if (ret.first == httpConnector.value.end()) return;
//	if (ret.second == httpConnector.value.end()) return;
//
//	if (len == 0) //__________________________________ If empty, then insert all the selected items
//	{
//		Web::ListItem listItem;
//		listItem.Selected = true;
//		listItem.Text = L"-";
//		for (multimap<wstring, wstring>::iterator state = ret.first; state != ret.second; ++state)
//		{
//			listItem.Data = (*state).second;
//			Items.storage.push_back(listItem);
//		}
//	}
//	else//__________________________________ If NOT empty, then sync the selection
//	{
//		for (multimap<wstring, wstring>::iterator state = ret.first; state != ret.second; ++state)
//		{
//			for(i = 0; i<len; i++)
//			{
//				if (Items.storage[i].Data ==  (*state).second)
//				{
//					Items.storage[i].Selected = true;
//					if (found == false) // Set the selected index to the first selected element
//					{
//						Items._selectedIndex = i;
//						found = true;
//					}
//				}
//			}
//		}
//	}
//}

void ListBox::SetHeight(int height)
{
	_rowCount = height;
}

int ListBox::GetHeight()
{
	return _rowCount;
}

void ListBox::RenderInvisible(int& indentCount, Sys::ITextWriterW& out_html)
{
	const vector<ListItem>::iterator itemEnd = Items.storage.end();
	for(vector<ListItem>::iterator item = Items.storage.begin(); item != itemEnd; item++)
	{
		if (item->Selected == true)
		{
			RenderHiddenValue(false, indentCount, item->Data.c_str(), out_html);
		}
	}
}

bool ListBox::SetSelected(int itemIndex, bool selected)// Indexes start at 0. Use itemIndex=-1 to affect all rows
{
	if (itemIndex == -1)
	{
		if (selected == true)
		{
			for_each(Items.storage.begin(), Items.storage.end(), [] (Web::ListItem& n) { n.Selected = true; });
		}
		else
		{
			for_each(Items.storage.begin(), Items.storage.end(), [] (Web::ListItem& n) { n.Selected = false; });
		}
		return true;
	}
	else
	{
		const int len = Items.storage.size();
		if (itemIndex < 0 || itemIndex >= len) return false;
		Items.storage[itemIndex].Selected = selected;
	}
	return true;
}

//_____________________________________________________________________ ListViewItem
ListViewItem::ListViewItem()
{
}

ListViewItem::~ListViewItem()
{
}

bool ListViewItem::operator==(const ListViewItem& init) const
{
	if (Text != init.Text) return false;
	if (Data != init.Data) return false;
	if (Selected != init.Selected) return false;
	return true;
}

bool ListViewItem::operator!=(const ListViewItem& init) const
{
	if (Text != init.Text) return true;
	if (Data != init.Data) return true;
	if (Selected != init.Selected) return true;
	return false;
}

//_____________________________________________________________________ CheckBoxItem
CheckBoxItem::CheckBoxItem()
{
}

CheckBoxItem::~CheckBoxItem()
{
}

bool CheckBoxItem::operator==(const CheckBoxItem& init) const
{
	if (Text != init.Text) return false;
	if (Data != init.Data) return false;
	if (Checked != init.Checked) return false;
	return true;
}

bool CheckBoxItem::operator!=(const CheckBoxItem& init) const
{
	if (Text != init.Text) return true;
	if (Data != init.Data) return true;
	if (Checked != init.Checked) return true;
	return false;
}
//_____________________________________________________________________ ListViewColumn

//_____________________________________________________________________ CheckBoxColumn

//_____________________________________________________________________ ListViewItemCollection
ListViewItemCollection::ListViewItemCollection(void)
{
	colsCollection = NULL;
	_selectedIndex = -1;
}

ListViewItemCollection::~ListViewItemCollection(void)
{
}

bool ListViewItemCollection::operator==(const ListViewItemCollection& init) const
{
	const size_t len = storage.size();
	if (len != init.storage.size()) return false;
	for(size_t i = 0; i<len; i++)
	{
		if (storage[i] != init.storage[i]) return false;
	}
	if (this->_selectedIndex != init._selectedIndex) return false;
	return true;
}

Web::ListViewItem& ListViewItemCollection::operator[](long index)
{
	return storage[index];
}

bool ListViewItemCollection::Delete(int index)
{
	const int len = storage.size();
	if (index < 0 || index >= len) return false;
	vector<Web::ListViewItem>::iterator p = storage.begin()+index;
	storage.erase(p);
	return true;
}

//___________________________ returns the index if the data is already set during LoadState
int ListViewItemCollection::GetLoadItemIndex(const wchar_t* data)
{
	if (data == NULL) return -1;
	const vector<Web::ListViewItem>::iterator itemEnd = storage.end();
	vector<Web::ListViewItem>::iterator p;
	int colCount = 0;
	int index = 0;
	int i = 0;
	bool isPreLoad = true;
	for(p = storage.begin(); p != itemEnd; p++, index++)
	{
		if (index == 0) colCount = p->Text.size();
		isPreLoad = true;
		for(i = 0; i < colCount; i++)
		{
			if (p->Text[i].length() != 1)
			{
				isPreLoad = false;
				break;
			}
			if (p->Text[i][0] != '-')
			{
				isPreLoad = false;
				break;
			}
		}
		if (isPreLoad == true)
		{
			if (p->Data == data) return index;
		}
	}
	return -1;
}

void ListViewItemCollection::Add(const wchar_t* text, const wchar_t* data, bool selected)
{
	Web::ListViewItem item;
	if (this->colsCollection != NULL) item.Text.resize(colsCollection->size());
	item.Text[0] = text;
	item.Data = data;
	item.Selected = selected;
	const int index = GetLoadItemIndex(data);
	if (index == -1)
	{
		storage.push_back(item);
		if (selected == true)
		{
			_selectedIndex = storage.size()-1;
		}
	}
	else
	{
		storage[index] = item;
		if (selected == true)
		{
			_selectedIndex = index;
		}
	}
}

void ListViewItemCollection::Add(const wstring& text, const wstring& data, bool selected)
{
	Add(text.c_str(), data.c_str(), selected);
}

void ListViewItemCollection::Add(const wchar_t* text, const wchar_t* data)
{
	Web::ListViewItem item;
	if (this->colsCollection != NULL) item.Text.resize(colsCollection->size());
	item.Text[0] = text;
	item.Data = data;
	const int index = GetLoadItemIndex(data);
	if (index == -1)
	{
		if (storage.size() > 0 && _selectedIndex == storage.size()-1)
		{
			item.Selected = true;
		}
		else
		{
			item.Selected = false;
		}
		storage.push_back(item);
	}
	else
	{
		if (index == _selectedIndex)
		{
			item.Selected = true;
		}
		else
		{
			item.Selected = false;
		}
		storage[index] = item;
	}
}

void ListViewItemCollection::Add(const wstring& text, const wstring& data)
{
	Add(text.c_str(), data.c_str());
}

int ListViewItemCollection::GetCount()
{
	return storage.size();
}

//The return value is the zero-based index of the matching item. If the search is unsuccessful, it is -1
int ListViewItemCollection::GetIndex(const wchar_t* text)
{
	vector<Web::ListViewItem>::iterator pEnd = storage.end();
	int index = 0;
	for (vector<Web::ListViewItem>::iterator p = storage.begin(); p != pEnd; p++, index++)
	{
		if (p->Text[0] == text)
		{
			return index;
		}
	}
	return -1;
}

void ListViewItemCollection::DeleteAll()
{
	storage.clear();
	_selectedIndex = -1;
}

//_____________________________________________________________________ CheckBoxItemCollection
CheckBoxItemCollection::CheckBoxItemCollection(void)
{
	colsCollection = NULL;
}

CheckBoxItemCollection::~CheckBoxItemCollection(void)
{
}

bool CheckBoxItemCollection::operator==(const CheckBoxItemCollection& init) const
{
	const size_t len = storage.size();
	if (len != init.storage.size()) return false;
	for(size_t i = 0; i<len; i++)
	{
		if (storage[i] != init.storage[i]) return false;
	}
	return true;
}

Web::CheckBoxItem& CheckBoxItemCollection::operator[](long index)
{
	return storage[index];
}

bool CheckBoxItemCollection::Delete(int index)
{
	const int len = storage.size();
	if (index < 0 || index >= len) return false;
	vector<Web::CheckBoxItem>::iterator p = storage.begin()+index;
	storage.erase(p);
	return true;
}

//___________________________ returns the index if the data is already set during LoadState
int CheckBoxItemCollection::GetLoadItemIndex(const wchar_t* data)
{
	if (data == NULL) return -1;
	const vector<Web::CheckBoxItem>::iterator itemEnd = storage.end();
	vector<Web::CheckBoxItem>::iterator p;
	int colCount = 0;
	int index = 0;
	int i = 0;
	bool isPreLoad = true;
	for(p = storage.begin(); p != itemEnd; p++, index++)
	{
		if (index == 0) colCount = p->Text.size();
		isPreLoad = true;
		for(i = 0; i < colCount; i++)
		{
			if (p->Text[i].length() != 1)
			{
				isPreLoad = false;
				break;
			}
			if (p->Text[i][0] != '-')
			{
				isPreLoad = false;
				break;
			}
		}
		if (isPreLoad == true)
		{
			if (p->Data == data) return index;
		}
	}
	return -1;
}

void CheckBoxItemCollection::Add(const wchar_t* text, const wchar_t* data, bool checked)
{
	Web::CheckBoxItem item;
	if (this->colsCollection != NULL) item.Text.resize(colsCollection->size());
	item.Text[0] = text;
	item.Data = data;
	item.Checked = checked;
	const int index = GetLoadItemIndex(data);
	if (index == -1)
	{
		storage.push_back(item);
	}
	else
	{
		storage[index] = item;
	}
}

void CheckBoxItemCollection::Add(const wstring& text, const wstring& data, bool checked)
{
	Add(text.c_str(), data.c_str(), checked);
}

void CheckBoxItemCollection::Add(const wchar_t* text, const wchar_t* data)
{
	Web::CheckBoxItem item;
	if (this->colsCollection != NULL) item.Text.resize(colsCollection->size());
	item.Text[0] = text;
	item.Data = data;
	item.Checked = false;
	const int index = GetLoadItemIndex(data);
	if (index == -1)
	{
		storage.push_back(item);
	}
	else
	{
		storage[index] = item;
	}
}

void CheckBoxItemCollection::Add(const wstring& text, const wstring& data)
{
	Add(text.c_str(), data.c_str());
}

int CheckBoxItemCollection::GetCount()
{
	return storage.size();
}

//The return value is the zero-based index of the matching item. If the search is unsuccessful, it is -1
int CheckBoxItemCollection::GetIndex(const wchar_t* text)
{
	vector<Web::CheckBoxItem>::iterator pEnd = storage.end();
	int index = 0;
	for (vector<Web::CheckBoxItem>::iterator p = storage.begin(); p != pEnd; p++, index++)
	{
		if (p->Text[0] == text)
		{
			return index;
		}
	}
	return -1;
}

void CheckBoxItemCollection::DeleteAll()
{
	storage.clear();
}

//_____________________________________________________________________ ListViewColCollection
ListViewColCollection::ListViewColCollection(void)
{
}

ListViewColCollection::~ListViewColCollection(void)
{
}

//format: LVCFMT_LEFT, LVCFMT_CENTER, LVCFMT_RIGHT
bool ListViewColCollection::Add(int format, int width, const wchar_t* text)
{

	ListViewColumn col;
	col.format = format;
	col.width = width;
	col.Text = text;
	try
	{
		storage.push_back(col);
	}
	catch(const std::bad_alloc&)
	{
		return false;
	}
	return true;
}

//format: LVCFMT_LEFT, LVCFMT_CENTER, LVCFMT_RIGHT
bool ListViewColCollection::Add(int format, int width, wstring& text)
{
	ListViewColumn col;
	col.format = format;
	col.width = width;
	col.Text = text;
	try
	{
		storage.push_back(col);
	}
	catch(const std::bad_alloc&)
	{
		return false;
	}
	return true;
}

bool ListViewColCollection::Delete(int index)
{
	const int len = storage.size();
	if (index<0 || index >= len) return false;
	vector<ListViewColumn>::iterator p = storage.begin()+index;
	storage.erase(p);
	return true;
}

void ListViewColCollection::DeleteAll(void)
{
	storage.clear();
}

int ListViewColCollection::GetCount()
{
	return storage.size();
}

Web::ListViewColumn& ListViewColCollection::operator[](long index)
{
	return storage[index];
}

//_____________________________________________________________________ CheckBoxColCollection
CheckBoxColCollection::CheckBoxColCollection(void)
{
}

CheckBoxColCollection::~CheckBoxColCollection(void)
{
}

//format: LVCFMT_LEFT, LVCFMT_CENTER, LVCFMT_RIGHT
bool CheckBoxColCollection::Add(int format, const wchar_t* text)
{

	CheckBoxColumn col;
	col.format = format;
	col.Text = text;
	try
	{
		storage.push_back(col);
	}
	catch(const std::bad_alloc&)
	{
		return false;
	}
	return true;
}

//format: LVCFMT_LEFT, LVCFMT_CENTER, LVCFMT_RIGHT
bool CheckBoxColCollection::Add(int format, wstring& text)
{
	CheckBoxColumn col;
	col.format = format;
	col.Text = text;
	try
	{
		storage.push_back(col);
	}
	catch(const std::bad_alloc&)
	{
		return false;
	}
	return true;
}

bool CheckBoxColCollection::Delete(int index)
{
	const int len = storage.size();
	if (index<0 || index >= len) return false;
	vector<CheckBoxColumn>::iterator p = storage.begin()+index;
	storage.erase(p);
	return true;
}

void CheckBoxColCollection::DeleteAll(void)
{
	storage.clear();
}

int CheckBoxColCollection::GetCount()
{
	return storage.size();
}

Web::CheckBoxColumn& CheckBoxColCollection::operator[](long index)
{
	return storage[index];
}

//________________________________________________________ ListView
ListView::ListView()
{
	Items.colsCollection = &Cols.storage;
	Height = 10;
	FontSize = 16;
	cssClass = L"Data";
	AjaxUpdate = false;
	MultipleSelection = false;
}

ListView::~ListView()
{
}

void ListView::OnNavigateAway(Web::HttpConnector& httpConnector)
{
}

void ListView::SetAjaxUpdate(bool update)
{
	// memoryBlock2: 0000 0000 0000 0000 00000 0010 0000 0000
	if (update == true)
	{
		memoryBlock2 |= 0x00000200;
	}
	else
	{
		memoryBlock2 &= 0xFFFFFDFF;
	}
}

bool ListView::GetAjaxUpdate()
{
	// memoryBlock2: 0000 0000 0000 0000 00000 0010 0000 0000
	return ((memoryBlock2 & 0x00000200) != 0);
}

int ListView::GetTotalWidth()
{
	const vector<Web::ListViewColumn>::iterator colEnd = Cols.storage.end();
	int totalLen = 0;
	for(vector<Web::ListViewColumn>::iterator col = Cols.storage.begin(); col != colEnd; col++)
	{
		totalLen += col->width;
	}
	return totalLen;
}

void ListView::RenderHeader(int& indentCount, Sys::ITextWriterW& out_html)
{
	//_____________________________________________ Compute Total length
	int i = 0;
	vector<Web::ListViewColumn>::iterator col;
	const vector<Web::ListViewColumn>::iterator colEnd = Cols.storage.end();
	const int totalLen = GetTotalWidth();

	////_____________________________________________ Table Text (Table Title)
	//Indent(indentCount, out_html);
	//const int titleLen = Text.length();
	//if (titleLen > 0)
	//{
	//	out_html.WriteText(L"<option>");
	//	const int beginCount = (totalLen - titleLen)/2;
	//	for(i=0; i < beginCount; i++) out_html.WriteText(L"&nbsp;");
	//	out_html.WriteText(Text);
	//	const int remainCount = totalLen - titleLen - beginCount;
	//	for(i=0; i < remainCount; i++) out_html.WriteText(L"&nbsp;");
	//	out_html.WriteText(L"</option>");
	//}
	//else
	//{
	//	out_html.WriteText(L"<option>&nbsp;</option>");
	//}
	////____________________________________________ Separator
	//Indent(indentCount, out_html);
	//out_html.WriteText(L"<option>");
	//for(i = 0; i < totalLen; i++) out_html.WriteText(L"&macr;");
	//out_html.WriteText(L"</option>");

	//____________________________________________ Column
	Indent(indentCount, out_html);
	out_html.WriteText(L"<option value=\"0\">");
	wstring truncated;

	for(col = Cols.storage.begin(); col != colEnd; col++)
	{
		RenderColumn(col->Text, col,  L"&nbsp;", truncated, out_html);
	}
	out_html.WriteText(L"</option>");
}

void ListView::RenderItem(Web::ListViewItem& item, const wchar_t * space, Sys::ITextWriterW& out_html)
{
	if (Cols.storage.empty() == true) return;
	vector<Web::ListViewColumn>::iterator col;
	const vector<Web::ListViewColumn>::iterator colEnd = Cols.storage.end();
	wstring truncated;

	int itemIndex = 0;
	for(col = Cols.storage.begin(); col != colEnd; col++, itemIndex++)
	{
		RenderColumn(item.Text[itemIndex], col,  space, truncated, out_html);
	}
}

// truncated is passed to reduce memory allocation time at each function call
void ListView::RenderColumn(const wstring& text, vector<Web::ListViewColumn>::iterator& col, const wchar_t * space, wstring& truncated, Sys::ITextWriterW& out_html)
{
	const int len = text.length();
	const int remaining = col->width - len-1; //left one space between columns
	if (remaining < 0)//__________________________________________________ Truncate Text
	{
		const int lenTruncated = col->width - 4; // ...&nbsp;
		truncated.assign(text.begin(), text.begin()+lenTruncated);
		out_html.WriteText(truncated);
		out_html.WriteText(L"... ");
	}
	else if (remaining == 0)//__________________________________________________ Exact Text
	{
		out_html.WriteText(text);
		out_html.WriteText(space);
	}
	else//______________________________________________________________ Complete Text
	{
		int i;
		if (col->format == LVCFMT_LEFT)//________________ LEFT
		{
			out_html.WriteText(text);
			for(i = 0; i < remaining+1; i++) out_html.WriteText(space);
		}
		else if (col->format == LVCFMT_RIGHT)//____________ RIGHT
		{
			for(i = 0; i < remaining; i++) out_html.WriteText(space);
			out_html.WriteText(text);
			out_html.WriteText(space);
		}
		else //_________________________________________ CENTER
		{
			const int beginCount = remaining/2;
			for(i=0; i < beginCount; i++) out_html.WriteText(space);
			out_html.WriteText(text);
			const int remainCount = remaining - beginCount;
			for(i=0; i < remainCount+1; i++) out_html.WriteText(space);
		}
	}
}

void ListView::GetPreview(int& indentCount, Sys::ITextWriterW& out_html, bool isBrowserView)
{
	if (Visible == false) return;
	wchar_t text[128];
	//______________________________________________ table
	RenderTagAndId(true, indentCount, out_html);
	indentCount++;
	RenderClassAndStyle(out_html);
	out_html.WriteText(L">");
	//_____________________________________________ caption
	if (Text.length() > 0)
	{
		Indent(indentCount, out_html);
		out_html.WriteText(L"<caption>");
		out_html.WriteText(Text);
		out_html.WriteText(L"</caption>");
	}
	//________________________________________ Head
	Indent(indentCount, out_html);
	out_html.WriteText(L"<tr><td colspan=2>");
	out_html.WriteText(ID);
	out_html.WriteText(L"</td></tr>");
	//________________________________________ Items
	const int rows = (isBrowserView == true) ? Height : 0;
	for(int i = 0; i<rows; i++)
	{
		Indent(indentCount, out_html);
		if (isBrowserView == true) 
		{
			_snwprintf_s(text, 128, _TRUNCATE, L"<tr style='background:#FFFFFF'><td>Item %d</td><td>Description</td></tr>", i+1);
		}
		else
		{
			_snwprintf_s(text, 128, _TRUNCATE, L"<tr><td>Item %d</td><td>Description</td></tr>", i+1);
		}
		out_html.WriteText(text);
	}
	//____________________________________________________ </table>
	indentCount--;
	Indent(indentCount, out_html);
	out_html.WriteText(L"</table>");
	if (EndHtml.length() > 0) out_html.WriteText(EndHtml);
}

void ListView::GetHtml(int& indentCount, Sys::ITextWriterW& out_html, Web::HttpConnector& httpConnector)
{
	if (Visible == false)
	{
		const vector<ListViewItem>::iterator itemEnd = Items.storage.end();
		for(vector<ListViewItem>::iterator item = Items.storage.begin(); item != itemEnd; item++)
		{
			if (item->Selected == true)
			{
				RenderHiddenValue(false, indentCount, item->Data.c_str(), out_html);
			}
		}
		return;
	}
	//______________________________________________ table
	Indent(indentCount, out_html);
	if (BeginHtml.length() > 0) out_html.WriteText(BeginHtml);
	//______________________________________ tag
	out_html.WriteText(L"<table");
	RenderClassAndStyle(out_html);
	out_html.WriteText(L">");
	//
	//_____________________________________________ caption
	if (Text.length() > 0)
	{
		Indent(indentCount, out_html);
		out_html.WriteText(L"<caption>");
		out_html.WriteText(Text);
		out_html.WriteText(L"</caption>");
	}
	indentCount++;
	Indent(indentCount, out_html);
	//________________________________________ First Row (Head)
	//wchar_t text[96];
	//_snwprintf_s(text, 96, _TRUNCATE, L"<tr><td style=\"font-family:'Courier';font-size:%dpx;padding-left:%dpx\">", 
	//	FontSize, FontSize/3);
	//out_html.WriteText(text);
	//RenderHeader(out_html);
	//out_html.WriteText(L"</td></tr>");
	wchar_t text[256];
	
	//________________________________________________ You add this because IE does not properly compute the
	//________________________________________________ control width. You may remove if the problem is solved
	//________________________________________________ by Microsoft in the future
	const int _fontSize = (FontSize == HTML_SIZE_AUTO) ? 16 : FontSize;
	const int totalWidth = (int)(GetTotalWidth()*_fontSize*0.65+0.5);
	const int explorerID = httpConnector.GetExplorerID();
	if (explorerID == HTML_BROWSER_IE)
	{
		_snwprintf_s(text, 256, _TRUNCATE, 
			L"<tr><td><select size=\"1\" class=\"Header\" style=\"width:%dpx;font-size:%dpx;white-space:pre;font-family:'Courier'\" name=\"%sHead\" />", 
			totalWidth, _fontSize, ID.c_str());
	}
	else
	{
		_snwprintf_s(text, 256, _TRUNCATE, 
			L"<tr><td><select size=\"1\" class=\"Header\" style=\"width:100%%;font-size:%dpx;white-space:pre;font-family:'Courier'\" name=\"%sHead\" />", 
			 _fontSize, ID.c_str());
	}
	out_html.WriteText(text);
	//
	RenderHeader(indentCount, out_html);
	out_html.WriteText(L"</select></td></tr>");
	//________________________________________ Secont Row (Items)
	Indent(indentCount, out_html);
	//
	if (explorerID == HTML_BROWSER_IE)
	{
		_snwprintf_s(text, 256, _TRUNCATE, L"<tr><td><select style=\"width:%dpx;font-size:%dpx;white-space:pre;font-family:'Courier'\"", 
				totalWidth, _fontSize);
	}
	else
	{
		_snwprintf_s(text, 256, _TRUNCATE, L"<tr><td><select style=\"width:100%%;font-size:%dpx;white-space:pre;font-family:'Courier'\"", 
				_fontSize);
	}
	out_html.WriteText(text);
	//
	if (MultipleSelection == true) out_html.WriteText(L" multiple=\"multiple\"");
	//
	RenderName(out_html);
	RenderPair(L"ID", ID, out_html);
	if (Enabled == false) RenderPair(L"disabled", L"true", out_html);
	if (Height == HTML_SIZE_AUTO)
	{
		RenderPair(L"size", 10, out_html);
	}
	else
	{
		RenderPair(L"size", Height, out_html);
	}
	RenderJavascriptEvents(out_html, httpConnector.url.c_str());
	out_html.WriteText(L"/>");
	indentCount++;
	//____________________________________________________ Options
	vector<Web::ListViewItem>::iterator item = Items.storage.begin();
	const vector<Web::ListViewItem>::iterator pEnd = Items.storage.end();
	for(; item != pEnd; item++)
	{
		Indent(indentCount, out_html);
		out_html.WriteText(L"<option value=\"");
		out_html.WriteText(item->Data);
		out_html.WriteText(L"\"");
		if (item->Selected == true) out_html.WriteText(L" selected=\"true\"");
		out_html.WriteText(L">");
		RenderItem(*item, L"&nbsp;", out_html);
		out_html.WriteText(L"</option>");
	}
	indentCount--;
	Indent(indentCount, out_html);
	out_html.WriteText(L"</select></td></tr>");
	//____________________________________________________ </table>
	indentCount--;
	Indent(indentCount, out_html);
	out_html.WriteText(L"</table>");
	if (EndHtml.length() > 0) out_html.WriteText(EndHtml);
}

void ListView::GetXml(Web::HttpConnector& httpConnector)
{
	if (GetAjaxUpdate() == false) return;
	const int itemCount = Items.storage.size();

	//_________________________________________________ Handle empty list view
	if (itemCount == 0)
	{
		httpConnector.WriteText(L"<control><id>");
		httpConnector.WriteText(ID);
		httpConnector.WriteText(L"</id><type>");
		httpConnector.WriteText(L"Select");
		httpConnector.WriteText(L"</type><value>None</value></control>");
		return;
	}

	const vector<Web::ListViewItem>::iterator itemEnd = Items.storage.end();
	vector<Web::ListViewItem>::iterator item;
	wstring xmlValue;
	Sys::TextBufferW itemText;
	
	httpConnector.WriteText(L"<control><id>");
	httpConnector.WriteText(ID);
	httpConnector.WriteText(L"</id><type>");
	httpConnector.WriteText(L"Select");
	httpConnector.WriteText(L"</type><value>None</value><options>");

	//_____________________________________________________ separator for blank spaces
	wchar_t * separator = L" ";
	//__________________________________ Items (Options)
	for(item = Items.storage.begin(); item != itemEnd; item++)
	{
		httpConnector.WriteText(L"<option><name xml:space=\"preserve\">");
		itemText.buffer.clear();
		RenderItem(*item, separator, itemText);
		Sys::Convert::ToXml(itemText.buffer, xmlValue);
		httpConnector.WriteText(xmlValue);
		httpConnector.WriteText(L"</name><value>");
		Sys::Convert::ToXml(item->Data, xmlValue);
		httpConnector.WriteText(xmlValue);
		if (item->Selected == true)
		{
			httpConnector.WriteText(L"</value><selected>true</selected></option>");
		}
		else
		{
			httpConnector.WriteText(L"</value><selected>false</selected></option>");
		}
	}
	httpConnector.WriteText(L"</options></control>");
}

void ListView::LoadState(Web::HttpConnector& httpConnector)
{
	SelectedIndex = -1;
	//const int len = Items.storage.size();
	const int colCount = Cols.storage.size();
	int i = 0;
	wstring name(ID);
	name += L"Data";
	//SetSelected(-1, false); // Unselect All
	pair<multimap<wstring,wstring>::iterator,multimap<wstring,wstring>::iterator> ret; // Return to iterators:  the beginning and the end of the values
	ret = httpConnector.value.equal_range(name);
	//bool found = false;
	if (ret.first == httpConnector.value.end()) return;
	if (ret.second == httpConnector.value.end()) return;

	//if (len == 0) //__________________________________ If empty, then insert all the selected items
	//{
		Web::ListViewItem listViewItem;
		listViewItem.Selected = true;
		listViewItem.Text.resize(colCount);
		for(i=0; i < colCount; i++) listViewItem.Text[i] = L"-";
		for (multimap<wstring, wstring>::iterator state = ret.first; state != ret.second; ++state)
		{
			listViewItem.Data = (*state).second;
			Items.storage.push_back(listViewItem);
		}
		if (Items.storage.size() > 0) Items._selectedIndex = 0;
	//}
	//else//__________________________________ If NOT empty, then sync the selection
	//{
	//	for (multimap<wstring, wstring>::iterator state = ret.first; state != ret.second; state++)
	//	{
	//		for(i = 0; i<len; i++)
	//		{
	//			if (Items.storage[i].Data ==  (*state).second)
	//			{
	//				Items.storage[i].Selected = true;
	//				if (found == false) // Set the selected index to the first selected element
	//				{
	//					Items._selectedIndex = i;
	//					found = true;
	//				}
	//			}
	//		}
	//	}
	//}
}

wchar_t* ListView::GetTag()
{
	return L"table";
}

void ListView::Enumerate(wchar_t** data, int colCount, int rowIndex)
{
	int itemCount = 0;
	if (colCount==Cols.GetCount()+1)
	{
		this->Items.Add(data[1], data[0]);
		itemCount = Items.storage.size();
		for(int i=2; i<colCount; i++) this->Items[itemCount-1].Text[i-1] = data[i];
	}
	else if (colCount==Cols.GetCount())
	{
		this->Items.Add(data[0], L"");
		itemCount = Items.storage.size();
		for(int i=1; i<colCount; i++) this->Items[itemCount-1].Text[i] = data[i];
	}
}

bool ListView::SetSelected(int itemIndex, bool selected)// Indexes start at 0. Use itemIndex=-1 to affect all rows
{
	if (itemIndex == -1)
	{
		if (selected == true)
		{
			for_each(Items.storage.begin(), Items.storage.end(), [] (Web::ListViewItem& n) { n.Selected = true; });
			Items._selectedIndex = 0;
		}
		else
		{
			for_each(Items.storage.begin(), Items.storage.end(), [] (Web::ListViewItem& n) { n.Selected = false; });
			Items._selectedIndex = -1;
		}
		return true;
	}
	else
	{
		const int len = Items.storage.size();
		if (itemIndex < 0 || itemIndex >= len) return false;
		Items.storage[itemIndex].Selected = selected;
		Items._selectedIndex = itemIndex;
	}
	return true;
}

wstring& ListView::GetSelectedData()
{
	vector<Web::ListViewItem>::iterator pEnd = Items.storage.end();
	for (vector<Web::ListViewItem>::iterator p = Items.storage.begin(); p != pEnd; p++)
	{
		if (p->Selected == true)
		{
			return p->Data;
		}
	}
	return Items.storage.begin()->Data;
}

bool ListView::SetSelected(int index)
{
	const int len = Items.storage.size();
	bool ok = false;
	for(int i = 0; i<len; i++)
	{
		if (i == index)
		{
			Items.storage[i].Selected =  true;
			Items._selectedIndex = i;
			ok = true;
		}
		else
		{
			Items.storage[i].Selected = false;
		}
	}
	return ok;
}

int ListView::GetSelectedIndex()
{
	const int len = Items.storage.size();
	bool ok = false;
	for(int i = 0; i<len; i++)
	{
		if (Items.storage[i].Selected ==  true) return i;
	}
	return -1;
}

bool ListView::SetSelected(const wchar_t* text)
{
	const int len = Items.storage.size();
	bool ok = false;
	for(int i = 0; i<len; i++)
	{
		if (Items.storage[i].Text[0] ==  text)
		{
			Items.storage[i].Selected = true;
			Items._selectedIndex = i;
			ok = true;
		}
		else
		{
			Items.storage[i].Selected = false;
		}
	}
	return ok;
}

bool ListView::SetSelectedByData(const wstring& data)
{
	const int len = Items.storage.size();
	bool ok = false;
	for(int i = 0; i<len; i++)
	{
		if (Items.storage[i].Data==  data)
		{
			Items.storage[i].Selected = true;
			Items._selectedIndex = i;
			ok = true;
		}
		else
		{
			Items.storage[i].Selected = false;
		}
	}
	return ok;
}

//________________________________________________________ RadioButton
RadioButton::RadioButton()
{
	Checked = false;
}

RadioButton::~RadioButton()
{
}

void RadioButton::OnNavigateAway(Web::HttpConnector& httpConnector)
{
}

//_____________________________________________________________________ ISelectBool
bool& RadioButton::SqlGetBool()
{
	return Checked;
}

void RadioButton::SqlUpdate(bool toGui)
{
}

//void RadioButton::SetChecked(bool checked)
//{
//	// memoryBlock2: 0000 0000 0000 0000 00000 0000 1000 0000
//	if (checked == true)
//	{
//		memoryBlock2 |= 0x00000080;
//	}
//	else
//	{
//		memoryBlock2 &= 0xFFFFFF7F;
//	}
//}

//bool RadioButton::GetChecked()
//{
//	// memoryBlock2: 0000 0000 0000 0000 00000 0000 1000 0000
//	return ((memoryBlock2 & 0x00000080) != 0);
//}

void RadioButton::GetHtml(int& indentCount, Sys::ITextWriterW& out_html, Web::HttpConnector& httpConnector)
{
	if (Visible == false)
	{
		if (Checked == true) RenderHiddenValue(false, indentCount, L"true", out_html);
		return;
	}
	RenderTagAndId(false, indentCount, out_html);
	out_html.WriteText(L" type=\"radio\"");
	//RenderName(out_html);
	if (Name.find(L"Data") != std::wstring::npos)
	{
		RenderPair(L"name", Name, out_html);
	}
	else
	{
		RenderPair(L"name", Name+L"Data", out_html);
	}
	RenderPair(L"accesskey", AccessKey, out_html);
	if (Checked == true) RenderPair(L"checked", L"true", out_html);
	if (Enabled == false) RenderPair(L"disabled", L"true", out_html);
	//___________________________________ value
	if (Data.length() == 0)
	{
		RenderPair(L"value", Text, out_html);
	}
	else
	{
		RenderPair(L"value", Data, out_html);
	}

	//_________________
	RenderJavascriptEvents(out_html, httpConnector.url.c_str());
	out_html.WriteText(L" />");
	if (Text.length() > 0)
	{
		out_html.WriteText(L"<span");
		RenderClassAndStyle(out_html);
		out_html.WriteText(L">");
		out_html.WriteText(Text);
		out_html.WriteText(L"</span>");
	}
	if (EndHtml.length() > 0) out_html.WriteText(EndHtml);
}

void RadioButton::GetXml(Web::HttpConnector& httpConnector)
{
	//____ If value is the same as original, Xml Data for this control is not necessary
	wstring name(Name);
	name += L"Data";
	multimap<wstring, wstring>::iterator state = httpConnector.value.find(name);
	if (state == httpConnector.value.end()) return;
	if (state->second.length() == 0)
	{
		if (Checked == false) return;
	}
	else
	{
		if (Checked == (state->second == Data)) return;
	}
	//_____ Create a Control Node for the Xml Data
	httpConnector.WriteText(L"<control><id>");
	httpConnector.WriteText(ID);
	
	if (Checked == true)
	{
		httpConnector.WriteText(L"</id><type>RadioButton</type><value>true</value></control>");
	}
	else
	{
		httpConnector.WriteText(L"</id><type>RadioButton</type><value>false</value></control>");
	}
}

void RadioButton::LoadState(Web::HttpConnector& httpConnector)
{
	wstring name(Name);
	name += L"Data";
	multimap<wstring, wstring>::iterator state = httpConnector.value.find(name);
	if (state == httpConnector.value.end()) return;
	if (state->second.length() == 0)
	{
		Checked = false;
	}
	else
	{
		Checked = (state->second == Data);
	}
}

wchar_t* RadioButton::GetTag()
{
	return L"input";
}

//________________________________________________________ CheckBox
CheckBox::CheckBox()
{
	Checked = false;
}

CheckBox::~CheckBox()
{
}

void CheckBox::OnNavigateAway(Web::HttpConnector& httpConnector)
{
}

//_____________________________________________________________________ ISelectBool
bool& CheckBox::SqlGetBool()
{
	return Checked;
}

void CheckBox::SqlUpdate(bool toGui)
{
}

//void CheckBox::SetChecked(bool checked)
//{
//	// memoryBlock2: 0000 0000 0000 0000 00000 0000 1000 0000
//	if (checked == true)
//	{
//		memoryBlock2 |= 0x00000080;
//	}
//	else
//	{
//		memoryBlock2 &= 0xFFFFFF7F;
//	}
//}

//bool CheckBox::GetChecked()
//{
//	// memoryBlock2: 0000 0000 0000 0000 00000 0000 1000 0000
//	return ((memoryBlock2 & 0x00000080) != 0);
//}

void CheckBox::GetHtml(int& indentCount, Sys::ITextWriterW& out_html, Web::HttpConnector& httpConnector)
{
	if (Visible == false)
	{
		if (Checked == true) RenderHiddenValue(false, indentCount, L"true", out_html);
		return;
	}
	RenderTagAndId(false, indentCount, out_html);
	out_html.WriteText(L" type=\"checkbox\"");
	//RenderClassAndStyle(out_html);
	RenderName(out_html);
	//RenderPair(L"value", Data, out_html);
	if (Checked == true) RenderPair(L"checked", L"true", out_html);
	if (Enabled == false) RenderPair(L"disabled", L"true", out_html);
	RenderJavascriptEvents(out_html, httpConnector.url.c_str());
	out_html.WriteText(L" />");
	if (Text.length() > 0)
	{
		out_html.WriteText(L"&nbsp;<span");
		RenderClassAndStyle(out_html);
		out_html.WriteText(L">");
		out_html.WriteText(Text);
		out_html.WriteText(L"</span>");
	}
	if (EndHtml.length() > 0) out_html.WriteText(EndHtml);
}

void CheckBox::GetXml(Web::HttpConnector& httpConnector)
{
	//____ If value is the same as original, Xml Data for this control is not necessary
	wstring name(ID);
	name += L"Data";
	multimap<wstring, wstring>::iterator state = httpConnector.value.find(name);
	if (state == httpConnector.value.end()) return;
	if (state->second.length() == 0)
	{
		if (Checked == false) return;
	}
	else
	{
		if (Checked == Sys::Convert::ToBool(state->second)) return;
	}
	//_____ Create a Control Node for the Xml Data
	httpConnector.WriteText(L"<control><id>");
	httpConnector.WriteText(ID);
	
	if (Checked == true)
	{
		httpConnector.WriteText(L"</id><type>CheckBox</type><value>true</value></control>");
	}
	else
	{
		httpConnector.WriteText(L"</id><type>CheckBox</type><value>false</value></control>");
	}
}

void CheckBox::LoadState(Web::HttpConnector& httpConnector)
{
	wstring name(ID);
	name += L"Data";
	multimap<wstring, wstring>::iterator state = httpConnector.value.find(name);
	if (state == httpConnector.value.end()) return;
	if (state->second.length() == 0)
	{
		Checked = false;
	}
	else
	{
		Checked = Sys::Convert::ToBool(state->second);
	}
}

wchar_t* CheckBox::GetTag()
{
	return L"input";
}

//________________________________________________________ HiddenValue
HiddenValue::HiddenValue()
{
}

HiddenValue::~HiddenValue()
{
}

void HiddenValue::OnNavigateAway(Web::HttpConnector& httpConnector)
{
	wstring name(ID);
	name+=L"Data";
	if (Data.length() > 0)
	{
		httpConnector.AddVariable(name.c_str(), Data.c_str());
	}
}

void HiddenValue::GetHtml(int& indentCount, Sys::ITextWriterW& out_html, Web::HttpConnector& httpConnector)
{
	//RenderHiddenValue(false, indentCount, Text.c_str(), out_html);
	RenderTagAndId(false, indentCount, out_html);
	out_html.WriteText(L" type=\"hidden\"");
	RenderPair(L"value", Data, out_html);
	wstring name(ID);
	name+= L"Data";
	RenderPair(L"name", name, out_html);
	out_html.WriteText(L" />");
	if (EndHtml.length() > 0) out_html.WriteText(EndHtml);
}

void HiddenValue::GetXml(Web::HttpConnector& httpConnector)
{
	//____ If value is the same as original, Xml Data for this control is not necessary
	wstring name(ID);
	name += L"Data";
	multimap<wstring, wstring>::iterator state = httpConnector.value.find(name);
	if (state == httpConnector.value.end()) return;
	if (state->second.length() == 0)
	{
		if (Data.length() == 0) return;
	}
	else
	{
		if (Data == state->second) return;
	}
	//_____ Create a Control Node for the Xml Data
	httpConnector.WriteText(L"<control><id>");
	httpConnector.WriteText(ID);
	httpConnector.WriteText(L"</id><type>Hidden</type><value>");
	if (Data.length() > 0)
	{
		wstring xmlValue;
		Sys::Convert::ToXml(Data.c_str(), xmlValue);
		httpConnector.WriteText(xmlValue);
	}
	httpConnector.WriteText(L"</value></control>");
}

void HiddenValue::LoadState(Web::HttpConnector& httpConnector)
{
	wstring name(ID);
	name += L"Data";
	multimap<wstring, wstring>::iterator state = httpConnector.value.find(name);
	if (state == httpConnector.value.end()) return;
	if (state->second.length() == 0)
	{
		Data = L"";
	}
	else
	{
		Data = state->second;
	}
}

wchar_t* HiddenValue::GetTag()
{
	return L"input";
}

//________________________________________________________ Image
Image::Image()
{
}
	
Image::~Image()
{
}

void Image::OnNavigateAway(Web::HttpConnector& httpConnector)
{
}

void Image::GetHtml(int& indentCount, Sys::ITextWriterW& out_html, Web::HttpConnector& httpConnector)
{
	if (Visible == false) return;
	RenderTagAndId(false, indentCount, out_html);
	RenderClassAndStyle(out_html);
	RenderPair(L"src", src, out_html);
	RenderPair(L"alt", Text, out_html);
	RenderPair(L"title", Text, out_html);
	RenderJavascriptEvents(out_html, httpConnector.url.c_str());
	out_html.WriteText(L" />");
	if (EndHtml.length() > 0) out_html.WriteText(EndHtml);
}

void Image::GetXml(Web::HttpConnector& httpConnector)
{
}

void Image::LoadState(Web::HttpConnector& httpConnector)
{
}

wchar_t* Image::GetTag()
{
	return L"img";
}

//________________________________________________________ ImageLink
ImageLink::ImageLink()
{
}

ImageLink::~ImageLink()
{
}

void ImageLink::OnNavigateAway(Web::HttpConnector& httpConnector)
{
}

bool ImageLink::HrefNavigateTo(Sys::ITextWriterW& out_html, Web::HttpConnector& httpConnector)
{
	const int len = href.size();
	wchar_t c;
	for(int i = 0; i < len; i++)
	{
		c = href[i];
		if (c == '.') return false;
		if (c == ':') return false;
		if (c == '/') return false;
		if (c == '\\') return false;
		if (c == ' ') return false;
	}
	wstring script_name;
	httpConnector.GetServerVariable("SCRIPT_NAME", script_name);
	script_name += L"?windowID=";
	script_name += href;
	RenderPair(L"href", script_name, out_html);
	return true;
}

void ImageLink::GetHtml(int& indentCount, Sys::ITextWriterW& out_html, Web::HttpConnector& httpConnector)
{
	if (Visible == false) return;
	RenderTagAndId(false, indentCount, out_html);
	RenderClassAndStyle(out_html);
	if (HrefNavigateTo(out_html, httpConnector) == false) RenderPair(L"href", href, out_html);
	RenderPair(L"target", targetWindowName, out_html);
	RenderPair(L"accesskey", AccessKey, out_html);
	RenderPair(L"tabindex", tabIndex, out_html);
	RenderPair(L"title", Text, out_html);
	//___________________________________________ img
	out_html.WriteText(L"><img");
	//imageCss.GetHtml(out_html);
	if (imageCssClass.length()>0)
	{
		out_html.WriteText(L" class=\"");
		out_html.WriteText(imageCssClass);
		out_html.WriteText(L"\"");
	}
	RenderPair(L"src", src, out_html);
	RenderPair(L"alt", Text, out_html);
	RenderPair(L"title", Text, out_html);

	//________________________________________________ close the tag
	out_html.WriteText(L" /></a>");
	//if (indentCount == -1)
	//{
	//	out_html.WriteText(L" /></a>");
	//}
	//else
	//{
	//	out_html.WriteText(L" /></a>\r\n");
	//}
	if (EndHtml.length() > 0) out_html.WriteText(EndHtml);
}

void ImageLink::GetXml(Web::HttpConnector& httpConnector)
{
}

void ImageLink::LoadState(Web::HttpConnector& httpConnector)
{
}

wchar_t* ImageLink::GetTag()
{
	return L"a";
}

//________________________________________________________ TextLink
TextLink::TextLink()
{
}

TextLink::~TextLink()
{
}

void TextLink::OnNavigateAway(Web::HttpConnector& httpConnector)
{
}

bool TextLink::HrefNavigateTo(Sys::ITextWriterW& out_html, Web::HttpConnector& httpConnector)
{
	const int len = href.size();
	wchar_t c;
	for(int i = 0; i < len; i++)
	{
		c = href[i];
		if (c == '.') return false;
		if (c == ':') return false;
		if (c == '/') return false;
		if (c == '\\') return false;
		if (c == ' ') return false;
	}
	wstring script_name;
	httpConnector.GetServerVariable("SCRIPT_NAME", script_name);
	script_name += L"?windowID=";
	script_name += href;
	RenderPair(L"href", script_name, out_html);
	return true;
}

void TextLink::GetHtml(int& indentCount, Sys::ITextWriterW& out_html, Web::HttpConnector& httpConnector)
{
	if (Visible == false) return;
	RenderTagAndId(false, indentCount, out_html);
	RenderClassAndStyle(out_html);
	if (HrefNavigateTo(out_html, httpConnector) == false) RenderPair(L"href", href, out_html);
	RenderPair(L"target", targetWindowName, out_html);
	RenderPair(L"accesskey", AccessKey, out_html);
	RenderPair(L"tabindex", tabIndex, out_html);
	RenderPair(L"title", Text, out_html);
	out_html.WriteText(L">");
	out_html.WriteText(Text);
	//________________________________________________ close the tag
	if (indentCount == -1)
	{
		out_html.WriteText(L"</a>");
	}
	else
	{
		out_html.WriteText(L" </a>\r\n");
	}
	if (EndHtml.length() > 0) out_html.WriteText(EndHtml);
}

void TextLink::GetXml(Web::HttpConnector& httpConnector)
{
}

void TextLink::LoadState(Web::HttpConnector& httpConnector)
{
}

wchar_t* TextLink::GetTag()
{
	return L"a";
}

#ifdef WIN_GDI_PLUS_ON
//________________________________________________________ DynamicImage
DynamicImage::DynamicImage()
{
	this->css.font_size = 12;
	this->css.background = RGB(250, 250, 250);
	this->css.color = RGB(0, 0, 200);
	this->css.width = 400;
	this->css.height = 300;
	this->LineColor = RGB(235, 235, 255);
	this->css.font_family = Web::CssType::FontFamilyArial;
	this->WhiteAndBlack = false;
	//
	this->css.border_color=RGB(192, 192, 192);
	this->css.border_width=1;
	this->css.border_style=Web::CssType::BorderStyleSolid;
}

DynamicImage::~DynamicImage()
{
}

void DynamicImage::OnNavigateAway(Web::HttpConnector& httpConnector)
{
}

void DynamicImage::RenderValue(const wchar_t* name, wstring& value, wstring& output)
{
	if (value.length() <= 0) return;
	output += L"&";
	output += name;
	output += L"=";
	Sys::Convert::WstringToHex(value.c_str(), encodedText);
	output += encodedText;
}

void DynamicImage::RenderValue(const wchar_t* name, double value, wstring& output)
{
	output += L"&";
	output += name;
	output += L"=";
	wchar_t text[32];
	_snwprintf_s(text, 32, _TRUNCATE, L"%g", value);
	Sys::Convert::WstringToHex(text, encodedText);
	output += encodedText;
}

void DynamicImage::RenderValue(const wchar_t* name, int value, wstring& output)
{
	output += L"&";
	output += name;
	output += L"=";
	wchar_t text[32];
	_snwprintf_s(text, 32, _TRUNCATE, L"%d", value);
	Sys::Convert::WstringToHex(text, encodedText);
	output += encodedText;
}

void DynamicImage::RenderValue(const wchar_t* name, bool value, wstring& output)
{
	output += L"&";
	output += name;
	if (value == true)
	{
		output += L"=true";
	}
	else
	{
		output += L"=false";
	}
}

bool DynamicImage::ColorSync(Web::HttpConnector& h, const wchar_t* red, const wchar_t* green, const wchar_t* blue, COLORREF& color)
{
	multimap<wstring, wstring>::iterator p;
	const multimap<wstring, wstring>::iterator valueEnd = h.value.end();

	p = h.value.find(red);
	if (p == valueEnd) return false;
	const int color_red = Sys::Convert::ToInt(p->second);
	//
	p = h.value.find(green);
	if (p == valueEnd) return false;
	const int color_green = Sys::Convert::ToInt(p->second);
	//
	p = h.value.find(blue);
	if (p == valueEnd) return false;
	const int color_blue = Sys::Convert::ToInt(p->second);
	//
	color = RGB(color_red, color_green, color_blue);
	return true;
}

void DynamicImage::BasicSync(Web::HttpConnector& h)
{
	multimap<wstring, wstring>::iterator p;
	const multimap<wstring, wstring>::iterator valueEnd = h.value.end();
	COLORREF a = RGB(0, 0, 0);
	//__________________________________________ FontSize
	p = h.value.find(L"FontSize"); 
	if (p != valueEnd) css.font_size = Sys::Convert::ToInt(p->second);
	//__________________________________________ Background
	if (ColorSync(h, L"BkRed", L"BkGreen", L"BkBlue", a) == true) css.background = a;
	//__________________________________________ Color
	if (ColorSync(h, L"Red", L"Green", L"Blue", a) == true) css.color = a;
	//__________________________________________ Width
	p = h.value.find(L"Width"); 
	if (p != valueEnd) css.width = Sys::Convert::ToInt(p->second);

	//__________________________________________ Height
	p = h.value.find(L"Height"); 
	if (p != valueEnd) css.height = Sys::Convert::ToInt(p->second);

	//__________________________________________ Line Color
	if (ColorSync(h, L"LRed", L"LGreen", L"LBlue", a) == true) LineColor = a;
	//__________________________________________ Font Family
	p = h.value.find(L"FontFamily"); 
	if (p != valueEnd) css.font_family = (Web::CssType::FontFamily)Sys::Convert::ToInt(p->second);

	//__________________________________________ isWhiteAndBlack
	p = h.value.find(L"WB"); 
	if (p != valueEnd) WhiteAndBlack = (Web::CssType::FontFamily)Sys::Convert::ToBool(p->second);

	//__________________________________________ Border Color
	if (ColorSync(h, L"BdRed", L"BdGreen", L"BdBlue", a) == true) css.border_color = a;

	//__________________________________________ Border Width
	p = h.value.find(L"BorderWidth"); 
	if (p != valueEnd) css.border_width = Sys::Convert::ToInt(p->second);

	//__________________________________________ Border Style
	p = h.value.find(L"BorderStyle"); 
	if (p != valueEnd) css.border_style = (Web::CssType::BorderStyle)Sys::Convert::ToInt(p->second);

	//__________________________________________ Text
	p = h.value.find(L"Text"); 
	if (p != valueEnd)
	{
		if (p->second.length() > 0) Text = p->second;
	}
}

void DynamicImage::RenderImage(string& data)
{	
	COLORREF _backColor = css.background;
	COLORREF _textColor = css.color;
	COLORREF _lineColor = LineColor;

	if (WhiteAndBlack == true)
	{
		_backColor = RGB(255, 255, 255);
		_textColor = RGB(0, 0, 0);
		_lineColor = RGB(180, 180, 180);
	}

	const int width = abs(css.width);
	const int height = abs(css.height);
	IStream* pIs = Sys::ImageStream::CreateAllocator(&data);
	Gdiplus::Bitmap bitmap(width, height);
	Gdiplus::Graphics imageGraphics(&bitmap);

	//________________________________________________________ Background
	Gdiplus::SolidBrush brushBackground(Gdiplus::Color(255, GetRValue(_backColor), GetGValue(_backColor), GetBValue(_backColor)));
	imageGraphics.FillRectangle(&brushBackground, 0, 0, width, height);
	//________________________________________________________ Font
	wchar_t * fontFamily = L"Arial";
	if (css.font_family == Web::CssType::FontFamilyCourier)
	{
		fontFamily = L"Courier";
	}
	else if (css.font_family == Web::CssType::FontFamilyTimesNewRoman)
	{
		fontFamily = L"Times New Roman";
	}
	Gdiplus::FontFamily gdiFontFamily(fontFamily);
	Gdiplus::Font font(&gdiFontFamily, (Gdiplus::REAL)css.font_size, Gdiplus::FontStyleRegular, Gdiplus::UnitPixel); 
	//________________________________________________________ Font Brush
	Gdiplus::SolidBrush brushFont(Gdiplus::Color(255, GetRValue(_textColor), GetGValue(_textColor), GetBValue(_textColor)));
	//________________________________________________________ Line Pen
	Gdiplus::Pen penLine(Gdiplus::Color(255, GetRValue(_lineColor), GetGValue(_lineColor), GetBValue(_lineColor)), 1.0f);
	//________________________________________________________ Text Pen
	Gdiplus::Pen penText(Gdiplus::Color(255, GetRValue(_textColor), GetGValue(_textColor), GetBValue(_textColor)), 1.0f);
	
	//
	BuildBitmap(imageGraphics, font, brushFont, penLine, penText);

   CLSID imgClsid;
   if (Sys::ImageStream::GetEncoderClsid(L"image/png", &imgClsid) != -1) //L"image/jpeg", L"image/png", 
   {
	     //________________________________________________ Set the quality of the encoder
		Gdiplus::EncoderParameters encoderParameters;
		ULONG quality;
		encoderParameters.Count = 1;
		encoderParameters.Parameter[0].Guid = Gdiplus::EncoderQuality;
		encoderParameters.Parameter[0].Type = Gdiplus::EncoderParameterValueTypeLong;
		encoderParameters.Parameter[0].NumberOfValues = 1;
  
		 quality = 100; // 0 most compresion, 100 Best quality
		 encoderParameters.Parameter[0].Value = &quality;

		bitmap.Save(pIs, &imgClsid, &encoderParameters);
	}
	pIs->Release();
}

void DynamicImage::GetHtml(int& indentCount, Sys::ITextWriterW& out_html, Web::HttpConnector& httpConnector)
{
	if (Visible == false) return;
	RenderTagAndId(false, indentCount, out_html);
	RenderClassAndStyle(out_html);
	wstring src;
	GetSource(src, httpConnector.url.c_str());
	RenderPair(L"src", src, out_html);


	RenderPair(L"alt", Text, out_html);
	RenderJavascriptEvents(out_html, httpConnector.url.c_str());
	out_html.WriteText(L" />");
	if (EndHtml.length() > 0) out_html.WriteText(EndHtml);
}

void DynamicImage::RenderProperties(Web::DynamicImage& di, wstring& text)
{
	wchar_t tmp[128];
	//__________________________________________ Font Size
	if (this->css.font_size != di.css.font_size)
	{
		_snwprintf_s(tmp, 128, _TRUNCATE, L"&FontSize=%d", css.font_size);
		text += tmp;
	}
	//__________________________________________ Background
	if (this->css.background != di.css.background)
	{
		_snwprintf_s(tmp, 128, _TRUNCATE, L"&BkRed=%d&BkGreen=%d&BkBlue=%d", 
			GetRValue(css.background), GetGValue(css.background), GetBValue(css.background));
		text += tmp;
	}
	//__________________________________________ Color
	if (this->css.color != di.css.color)
	{
		_snwprintf_s(tmp, 128, _TRUNCATE, L"&Red=%d&Green=%d&Blue=%d", 
			GetRValue(css.color), GetGValue(css.color), GetBValue(css.color));
		text += tmp;
	}
	//__________________________________________ Width
	if (this->css.width != di.css.width)
	{
		_snwprintf_s(tmp, 128, _TRUNCATE, L"&Width=%d", css.width);
		text += tmp;
	}
	//__________________________________________ Height
	if (this->css.height != di.css.height)
	{
		_snwprintf_s(tmp, 128, _TRUNCATE, L"&Height=%d", css.height);
		text += tmp;
	}
	//__________________________________________ Line Color
	if (this->LineColor != di.LineColor)
	{
		_snwprintf_s(tmp, 128, _TRUNCATE, L"&LRed=%d&LGreen=%d&LBlue=%d", 
			GetRValue(LineColor), GetGValue(LineColor), GetBValue(LineColor));
		text += tmp;
	}
	//__________________________________________ Font Family
	if (this->css.font_family != di.css.font_family)
	{
		_snwprintf_s(tmp, 128, _TRUNCATE, L"&FontFamily=%d", css.font_family);
		text += tmp;
	}
	//__________________________________________ isWhiteAndBlack
	if (this->WhiteAndBlack != di.WhiteAndBlack)
	{
		if (WhiteAndBlack == true)
		{
			text +=L"&WB=true";
		}
		else
		{
			text +=L"&WB=false";
		}
	}
	//__________________________________________ Border Color
	if (this->css.border_color != di.css.border_color)
	{
		_snwprintf_s(tmp, 128, _TRUNCATE, L"&BdRed=%d&BdGreen=%d&BdBlue=%d", 
			GetRValue(css.border_color), GetGValue(css.border_color), GetBValue(css.border_color));
		text += tmp;
	}
	//__________________________________________ Border Width
	if (this->css.border_width != di.css.border_width)
	{
		_snwprintf_s(tmp, 128, _TRUNCATE, L"&BorderWidth=%d", css.border_width);
		text += tmp;
	}
	//__________________________________________ Border Style
	if (this->css.border_style != di.css.border_style)
	{
		_snwprintf_s(tmp, 128, _TRUNCATE, L"&BorderStyle=%d", css.border_style);
		text += tmp;
	}
	//___________________________________________ Text
	if (Text.length() > 0)
	{
		wstring encodedText;
		Sys::Convert::WstringToHex(Text.c_str(), encodedText);
		_snwprintf_s(tmp, 128, _TRUNCATE, L"&Text=%s", encodedText.c_str());
		text += tmp;
	}
}

void DynamicImage::GetXml(Web::HttpConnector& httpConnector)
{
}

void DynamicImage::LoadState(Web::HttpConnector& httpConnector)
{
}

wchar_t* DynamicImage::GetTag()
{
	return L"img";
}

#endif

//________________________________________________________ Bar
Bar::Bar()
{
}

Bar::~Bar()
{
}

bool Bar::operator<(const Web::Bar& bar) const
{
	return (Value < bar.Value);
}

//________________________________________________________ BarCollection
BarCollection::BarCollection()
{
}

BarCollection::~BarCollection()
{
}

void BarCollection::Add(const wstring& text, COLORREF color, double value)
{
	Web::Bar bar;
	bar.Color = color;
	bar.Text = text;
	bar.Value = value;
	storage.push_back(bar);
}

void BarCollection::DeleteAll()
{
	storage.clear();
}

Web::Bar& BarCollection::operator[](long index)
{
	return storage[index];
}

int BarCollection::GetCount()
{
	return storage.size();
}

#ifdef WIN_GDI_PLUS_ON
//________________________________________________________ BarChart
BarChart::BarChart()
{
	DivYCount = 5;
	MaxY = 0.0;
	AutoScale = true;
}

BarChart::~BarChart()
{
}

void BarChart::BuildBitmap(Gdiplus::Graphics& graphics, Gdiplus::Font& font, Gdiplus::SolidBrush& brushFont, Gdiplus::Pen& penLine, Gdiplus::Pen& penText)
{
	const double maxY = GetMaxY();
	Gdiplus::RectF box;
	Gdiplus::RectF rect;
	ComputeBox(box);
	const int barCount = Bars.Count;
	int i= 0;

	const Gdiplus::REAL deltaX = (barCount > 0) ? (box.Width/barCount) : 0.0f;
	const Gdiplus::REAL deltaY = (DivYCount > 0) ? (box.Height/DivYCount) : 0.0f;
	const Gdiplus::REAL barWidth = 0.8f*deltaX;
	Gdiplus::REAL x = 0.0f;
	Gdiplus::REAL y = 0.0f;
	//______________________________________________ Grid
	for(i = 0; i < DivYCount-1; i++)
	{
		y = box.Y + box.Height - (i+1)*deltaY;
		graphics.DrawLine(&penLine, box.X, y, box.X+box.Width, y);
	}

	//______________________________________________CaptionX
	Gdiplus::StringFormat sfCaptionX;
	sfCaptionX.SetAlignment(Gdiplus::StringAlignmentCenter);
	sfCaptionX.SetLineAlignment(Gdiplus::StringAlignmentCenter);
	if (barCount > 0)
	{
		rect.Y = box.Y+box.Height;
		rect.Height = abs(css.height) - box.Y - box.Height;
		y = css.font_size * 0.1f;
		rect.Width = deltaX;
		for(i = 0; i< barCount; i++)
		{
			rect.X = box.X + deltaX*i;
			if (Bars[i].Text.empty() == false)
			{
				graphics.DrawString(Bars[i].Text.c_str(), -1, &font, rect, &sfCaptionX, &brushFont);
			}
			//if (m_bTickX)
			//{
			//	x = (int)((rect.left + rect.right)/2+0.5);
			//	gdi.MoveToEx(x, m_box.bottom-y);
			//	gdi.LineTo(x, m_box.bottom + y);
			//}
		}
	}

	//______________________________________________CaptionY
	if (barCount  > 0)
	{
		Gdiplus::RectF rectCaptionY;
		rectCaptionY.X = 0.0f;
		rectCaptionY.Y = 0.0f;
		rectCaptionY.Width = box.X;
		rectCaptionY.Height = deltaY;
		//
		Gdiplus::StringFormat sfCaptionY;
		sfCaptionY.SetAlignment(Gdiplus::StringAlignmentFar);
		sfCaptionY.SetLineAlignment(Gdiplus::StringAlignmentCenter);
		//
		double captionYScale = (DivYCount == 0) ? 1.0 : (maxY/DivYCount);
		wchar_t text[64];

		x = box.X - css.font_size  / 4;
		for(i= 0 ; i<= DivYCount; i++) 
		{
			y = box.Y + i * deltaY;
			rectCaptionY.Y = box.Y + i *deltaY - 0.5f*deltaY;
			if (y > (box.Y + box.Height))  break;
			Sys::Convert::ToString(maxY - captionYScale*i, text, 64, true);
			graphics.DrawString(text, -1, &font, rectCaptionY, &sfCaptionY, &brushFont);
		}
	}

	//_____________________________________________________ Bars
	if (barCount>0)
	{
		bool paint = false;
		double dotsPerY = box.Height / maxY;
		double barPositionX, barPositionY, barSizeY;
		double offset = (deltaX- barWidth)/2.0;

		for (i = 0; i < barCount; i++)
		{
			if (Bars[i].Value > 0)
			{
				barPositionX = deltaX * i + box.X + offset;
				barSizeY = dotsPerY * Bars[i].Value;
				barPositionY = box.Y + box.Height  - (int) (barSizeY + 0.5);
				Gdiplus::SolidBrush brush(Gdiplus::Color(255, GetRValue(Bars[i].Color), GetGValue(Bars[i].Color), GetBValue(Bars[i].Color)));

				rect.X = (Gdiplus::REAL)barPositionX;
				rect.Y = (Gdiplus::REAL)barPositionY;
				rect.Height = (Gdiplus::REAL)(barSizeY);
				rect.Width = (Gdiplus::REAL)(barWidth);

				graphics.FillRectangle(&brush, rect);
			}
		}
	}

	//_____________________________________________________ Sourrounding Box
	graphics.DrawRectangle(&penText, box);

	//_____________________________________________________ Title
	if (Text.length()>0)
	{
		rect.X = 0.0f;
		rect.Y = 0.0f;
		rect.Width = (Gdiplus::REAL)abs(css.width);
		rect.Height = box.Y;
		graphics.DrawString(Text.c_str(), -1, &font, rect, &sfCaptionX, &brushFont);
	}
}

void BarChart::Sync(Web::HttpConnector& h)
{
	BasicSync(h);

	multimap<wstring, wstring>::iterator p;
	const multimap<wstring, wstring>::iterator valueEnd = h.value.end();

	//__________________________________________ DivYCount
	p = h.value.find(L"DivYCount"); 
	if (p != valueEnd) DivYCount = Sys::Convert::ToInt(p->second);

	//___________________________________________ MaxY
	p = h.value.find(L"MaxY"); 
	if (p != valueEnd) MaxY = Sys::Convert::ToDouble(p->second);

	//___________________________________________ AutoScale
	p = h.value.find(L"AutoScale"); 
	if (p != valueEnd) AutoScale = Sys::Convert::ToBool(p->second);

	//___________________________________________ Data
	p = h.value.find(L"Data"); 
	if (p == valueEnd) return;
	const int len = p->second.length();
	double value = 0.0;
	int red = 0;
	int green = 0;
	int blue = 0;
	wstring tmp;
	int i = 0;
	int state = 0;
	wchar_t c;
	for(i = 0; i < len; i++)
	{
		c = p->second[i];
		if (state == 0) //_____________________ Value
		{
			if (c == '#')
			{
				value = Sys::Convert::ToDouble(tmp);
				tmp.clear();
				state = 1;
			}
			else
			{
				tmp += c;
			}
		}
		else if (state== 1)//_____________________ Red
		{
			if (c == '#')
			{
				red = Sys::Convert::ToInt(tmp);
				tmp.clear();
				state = 2;
			}
			else
			{
				tmp += c;
			}
		}
		else if (state== 2)//_____________________ Green
		{
			if (c == '#')
			{
				green = Sys::Convert::ToInt(tmp);
				tmp.clear();
				state = 3;
			}
			else
			{
				tmp += c;
			}
		}
		else if (state== 3)//_____________________ Blue
		{
			if (c == '#')
			{
				blue = Sys::Convert::ToInt(tmp);
				tmp.clear();
				state = 4;
			}
			else
			{
				tmp += c;
			}
		}
		else if (state== 4)//_____________________ Text
		{
			if (c == '#')
			{
				Bars.Add(tmp, RGB(red, green, blue), value);
				tmp.clear();
				state = 0;
			}
			else
			{
				tmp += c;
			}
		}
	}
}

double BarChart::GetMaxY()
{
	double _maxY = 0.0;
	if (AutoScale == true) 
	{
		vector<Web::Bar>::iterator p = std::max_element(Bars.storage.begin(), Bars.storage.end());
		if (p != Bars.storage.end())
		{
			_maxY = p->Value;
		}
	}
	else
	{
		_maxY= MaxY;
	}
	return _maxY;
}

void BarChart::GetSource(wstring& source, const wchar_t* url)
{
	const vector<Web::Bar>::iterator barEnd = Bars.storage.end();
	wchar_t text[256];
	wstring encodedText;

	source = L"http://";
	source += url;
	source += L"?windowID=BarChart";
	
	Web::BarChart chart;
	if (chart.DivYCount != this->DivYCount) RenderValue(L"DivYCount", DivYCount, source);
	if (chart.MaxY != this->MaxY) RenderValue(L"MaxY", MaxY, source);
	if (chart.AutoScale != this->AutoScale) RenderValue(L"AutoScale", AutoScale, source);

	this->RenderProperties(chart, source);
	source += L"&Data=";
	
	for(vector<Web::Bar>::iterator bar = Bars.storage.begin(); bar != barEnd; bar++)
	{
		Sys::TextAssistant::ReplaceChar(bar->Text, '#', ' ');
		_snwprintf_s(text, 256, _TRUNCATE, L"%g#%d#%d#%d#%s#",
			bar->Value, GetRValue(bar->Color), GetGValue(bar->Color), GetBValue(bar->Color), bar->Text.c_str());
		Sys::Convert::WstringToHex(text, encodedText);
		source += encodedText;
	}
}

void BarChart::ComputeBox(Gdiplus::RectF& box)
{
	const int charWidth = (int)(abs(css.font_size)/2.0+0.5);
	const int charHeight = abs(css.font_size);
	box.X = (Gdiplus::REAL)(8.0*charWidth);
	box.Width = (Gdiplus::REAL)(abs(css.width) - 12.0*charWidth);
	box.Y = (Gdiplus::REAL)(2.0*charHeight);
	box.Height = (Gdiplus::REAL)(abs(css.height)-4.0*charHeight);
}
#endif

//________________________________________________________ CheckBoxList
CheckBoxList::CheckBoxList()
{
	Items.colsCollection = &Cols.storage;
	css.height = 200;
	css.width = 120;
	cssClass = L"Data";
	AjaxUpdate = false;
}

CheckBoxList::~CheckBoxList()
{
}

void CheckBoxList::OnNavigateAway(Web::HttpConnector& httpConnector)
{
}

wchar_t* CheckBoxList::GetTag()
{
	if (Cols.storage.size() == 1) return L"div";
	return L"table";
}

void CheckBoxList::Enumerate(wchar_t** data, int colCount, int rowIndex)
{
	int itemCount = 0;
	if (colCount==Cols.GetCount()+1)
	{
		this->Items.Add(data[1], data[0]);
		itemCount = Items.storage.size();
		for(int i=2; i<colCount; i++) this->Items[itemCount-1].Text[i-1] = data[i];
	}
	else if (colCount==Cols.GetCount())
	{
		this->Items.Add(data[0], L"");
		itemCount = Items.storage.size();
		for(int i=1; i<colCount; i++) this->Items[itemCount-1].Text[i] = data[i];
	}
}

void CheckBoxList::SetAjaxUpdate(bool update)
{
	// memoryBlock2: 0000 0000 0000 0000 00000 0010 0000 0000
	if (update == true)
	{
		memoryBlock2 |= 0x00000200;
	}
	else
	{
		memoryBlock2 &= 0xFFFFFDFF;
	}
}

bool CheckBoxList::GetAjaxUpdate()
{
	// memoryBlock2: 0000 0000 0000 0000 00000 0010 0000 0000
	return ((memoryBlock2 & 0x00000200) != 0);
}

void CheckBoxList::GetPreview(int& indentCount, Sys::ITextWriterW& out_html, bool isBrowserView)
{
	if (Visible == false) return;
	wchar_t text[128];
	//______________________________________________ table
	RenderTagAndId(true, indentCount, out_html);
	indentCount++;
	RenderClassAndStyle(out_html);
	out_html.WriteText(L">");
	//_____________________________________________ caption
	if (Text.length() > 0)
	{
		Indent(indentCount, out_html);
		out_html.WriteText(L"<caption>");
		out_html.WriteText(Text);
		out_html.WriteText(L"</caption>");
	}
	//________________________________________ Head
	Indent(indentCount, out_html);
	out_html.WriteText(L"<tr><td colspan=2>");
	out_html.WriteText(ID);
	out_html.WriteText(L"</td></tr>");
	//________________________________________ Items
	const int rows = 3;//(isBrowserView == true) ? 5 : 3;
	for(int i = 0; i<rows; i++)
	{
		Indent(indentCount, out_html);
		if (isBrowserView == true) 
		{
			_snwprintf_s(text, 128, _TRUNCATE, 
				L"<tr style='background:#FFFFFF'><td><input type=\"checkbox\" />&nbsp;Item %d</td><td>Description</td></tr>", i+1);
		}
		else
		{
			_snwprintf_s(text, 128, _TRUNCATE, 
				L"<tr><td><input type=\"checkbox\" />&nbsp;Item %d</td><td>Description</td></tr>", i+1);
		}
		out_html.WriteText(text);
	}
	//____________________________________________________ </table>
	indentCount--;
	Indent(indentCount, out_html);
	out_html.WriteText(L"</table>");
	if (EndHtml.length() > 0) out_html.WriteText(EndHtml);
}

void CheckBoxList::GetXml(Web::HttpConnector& httpConnector)
{
	if (GetAjaxUpdate() == false) return;
	vector<Web::CheckBoxItem>::iterator item = Items.storage.begin();
	const vector<Web::CheckBoxItem>::iterator pEnd = Items.storage.end();
	wchar_t text[128];
	for(int i = 0; item != pEnd; item++, i++)
	{
		httpConnector.WriteText(L"<control><id>");
		_snwprintf_s(text, 128, _TRUNCATE, L"%s%03d", ID.c_str(), i);
		httpConnector.WriteText(text);
		if (item->Checked == true)
		{
			httpConnector.WriteText(L"</id><type>CheckBox</type><value>true</value></control>");
		}
		else
		{
			httpConnector.WriteText(L"</id><type>CheckBox</type><value>false</value></control>");
		}
	}
}

void CheckBoxList::GetHtml(int& indentCount, Sys::ITextWriterW& out_html, Web::HttpConnector& httpConnector)
{
	if (Visible == false)
	{
		RenderState(indentCount, out_html);
		RenderData(indentCount, out_html);
		return;
	}
	const bool isDiv = (Cols.storage.size() == 1);
	const int colCount = Cols.storage.size();
	int i = 0, j = 0;
	//______________________________________________ table or div
	RenderTagAndId(true, indentCount, out_html);
	indentCount++;
	//______________________________________________ class and style
	this->RenderClassAndStyle(out_html);
	//
	out_html.WriteText(L">");
	//_____________________________________________ caption
	if (Text.length() > 0 && isDiv == true)
	{
		Indent(indentCount, out_html);
		out_html.WriteText(L"<caption>");
		out_html.WriteText(Text);
		out_html.WriteText(L"</caption>");
	}
	Indent(indentCount, out_html);
	//________________________________________ First Row (Head)
	if (isDiv == false)
	{
		out_html.WriteText(L"<tr>");
		for(i = 0; i < colCount; i++)
		{
			if (Cols[i].format == LVCFMT_LEFT)
			{
				out_html.WriteText(L"<td style=\"text-align:left\">&nbsp;");
			}
			else if (Cols[i].format == LVCFMT_CENTER)
			{
				out_html.WriteText(L"<td style=\"text-align:center\">&nbsp;");
			}
			else if (Cols[i].format == LVCFMT_RIGHT)
			{
				out_html.WriteText(L"<td style=\"text-align:right\">&nbsp;");
			}
			out_html.WriteText(Cols[i].Text);
			out_html.WriteText(L"&nbsp;</td>");
		}
		out_html.WriteText(L"</tr>");
	}
	//____________________________________________________ Options
	vector<Web::CheckBoxItem>::iterator item = Items.storage.begin();
	const vector<Web::CheckBoxItem>::iterator pEnd = Items.storage.end();
	wchar_t text[128];
	for(i = 0; item != pEnd; item++, i++)
	{
		if (isDiv == false)
		{
			Indent(indentCount, out_html);
			out_html.WriteText(L"<tr class=\"Data\">");
		}
		for(j = 0; j < colCount; j++)
		{
			if (isDiv == false)
			{
				if (Cols[j].format == LVCFMT_LEFT)
				{
					out_html.WriteText(L"<td style=\"text-align:left\">&nbsp;");
				}
				else if (Cols[j].format == LVCFMT_CENTER)
				{
					out_html.WriteText(L"<td style=\"text-align:center\">&nbsp;");
				}
				else if (Cols[j].format == LVCFMT_RIGHT)
				{
					out_html.WriteText(L"<td style=\"text-align:right\">&nbsp;");
				}
			}
			if (j == 0) //________________ Render a checkbox
			{
				_snwprintf_s(text, 128, _TRUNCATE, 
					L"<input type=\"checkbox\" name=\"%s%03d\" id=\"%s%03d\"", 
					ID.c_str(), i, ID.c_str(), i);
				out_html.WriteText(text);
				//
				if (Items[i].Checked == true) RenderPair(L"checked", L"true", out_html);
				RenderJavascriptEvents(out_html, httpConnector.url.c_str());
				out_html.WriteText(L" />");
			}
			out_html.WriteText(Items[i].Text[j]);
			if (isDiv == true)
			{
				out_html.WriteText(L"<br />");
			}
			else
			{
				out_html.WriteText(L"&nbsp;</td>");
			}
		}
		if (isDiv == false) out_html.WriteText(L"</tr>");
	}
	//____________________________________________________ </table>
	indentCount--;
	Indent(indentCount, out_html);
	if (isDiv == true)
	{
		out_html.WriteText(L"</div>");
	}
	else
	{
		out_html.WriteText(L"</table>");
	}
	//____________________________________________________ count
	Indent(indentCount, out_html);
	_snwprintf_s(text, 128, _TRUNCATE, L"<input ID=\"%sCount\" type=\"hidden\" name=\"%sCount\" value=\"%d\" >", 
		ID.c_str(), ID.c_str(), Items.storage.size());
	out_html.WriteText(text);
	//
	RenderData(indentCount, out_html);
	//
	if (EndHtml.length() > 0) out_html.WriteText(EndHtml);
}

void CheckBoxList::RenderState(int& indentCount, Sys::ITextWriterW& out_html)
{
	wchar_t text[128];
	int i = 0;
	vector<Web::CheckBoxItem>::iterator item = Items.storage.begin();
	const vector<Web::CheckBoxItem>::iterator pEnd = Items.storage.end();
	item = Items.storage.begin();
	for(i = 0; item != pEnd; item++, i++)
	{
		Indent(indentCount, out_html);
		if (item->Checked == true)
		{
			_snwprintf_s(text, 128, _TRUNCATE,
				L"<input ID=\"%s%03d\" type=\"hidden\" name=\"%s%03d\" value=\"on\" >", 
				ID.c_str(), i, ID.c_str(), i);
		}
		//else
		//{
		//	_snwprintf_s(text, 128, _TRUNCATE,
		//		L"<input ID=\"%s%03d\" type=\"hidden\" name=\"%s%03d\" value=\"%s\" >", 
		//		ID.c_str(), i, ID.c_str(), i, item->Data.c_str());
		//}
		out_html.WriteText(text);
	}
}

void CheckBoxList::RenderData(int& indentCount, Sys::ITextWriterW& out_html)
{
	wchar_t text[128];
	int i = 0;
	vector<Web::CheckBoxItem>::iterator item = Items.storage.begin();
	const vector<Web::CheckBoxItem>::iterator pEnd = Items.storage.end();
	item = Items.storage.begin();
	for(i = 0; item != pEnd; item++, i++)
	{
		Indent(indentCount, out_html);
		_snwprintf_s(text, 128, _TRUNCATE,
			L"<input ID=\"%s%03dData\" type=\"hidden\" name=\"%s%03dData\" value=\"%s\" >", 
			ID.c_str(), i, ID.c_str(), i, item->Data.c_str());
		out_html.WriteText(text);
	}
}

void CheckBoxList::LoadState(Web::HttpConnector& httpConnector)
{
	//const int len = Items.storage.size();
	const int colCount = Cols.storage.size();
	wchar_t text[128];
	multimap<wstring, wstring>::iterator p;
	int i = 0;

	//___________________________________________ Get Count
	_snwprintf_s(text, 128, _TRUNCATE, L"%sCount", ID.c_str());
	p = httpConnector.value.find(text);
	if (p == httpConnector.value.end()) return;
	const int count = Sys::Convert::ToInt(p->second);
	if (count <= 0) return;

	//if (len == 0) //__________________________________ If empty, then insert all the selected items
	//{
	Web::CheckBoxItem checkBoxItem;
	checkBoxItem.Checked = true;
	checkBoxItem.Text.resize(colCount);
	for(i=0; i < colCount; i++) checkBoxItem.Text[i] = L"-";
	for(i = 0; i < count; i++)
	{
		_snwprintf_s(text, 128, _TRUNCATE, L"%s%03d", ID.c_str(), i);
		p = httpConnector.value.find(text);
		if (p == httpConnector.value.end()) continue;
		checkBoxItem.Checked = Sys::Convert::ToBool(p->second);		
		//__________________ try to get data
		_snwprintf_s(text, 128, _TRUNCATE, L"%s%03dData", ID.c_str(), i);
		p = httpConnector.value.find(text);
		if (p == httpConnector.value.end()) continue;
		checkBoxItem.Data = p->second;
		//
		Items.storage.push_back(checkBoxItem);
	}
	//}
	//else
	//{
	//	for(i = 0; i < count; i++)
	//	{
	//		_snwprintf_s(text, 128, _TRUNCATE, L"%s%03d", ID.c_str(), i);
	//		p = httpConnector.value.find(text);
	//		if (p == httpConnector.value.end())
	//		{
	//			Items[i].Checked = false;
	//			continue;
	//		}
	//		if (p->second.length() == 0)
	//		{
	//			Items[i].Checked = false;
	//		}
	//		else
	//		{
	//			Items[i].Checked = Sys::Convert::ToBool(p->second);
	//		}
	//	}
	//}
}

//________________________________________________________ DateTimeBox
DateTimeBox::DateTimeBox()
{
	Language = WIN_LANGUAGE_ENGLISH;
	CssFile = L"blue.css";
}

DateTimeBox::~DateTimeBox()
{
}

void DateTimeBox::OnNavigateAway(Web::HttpConnector& httpConnector)
{
}

//_______________________________________ ISelectTime
Sys::SqlTime& DateTimeBox::SqlGetTime()
{
	return _sqltime;
}

Sys::Time& DateTimeBox::SqlGetSysTime()
{
	return SelectedDate;
}

void DateTimeBox::SqlUpdate(bool toGui)
{
	if (toGui == true)
	{
		Sys::Convert::SqlTimeToSysTime(_sqltime, SelectedDate);
	}
	else
	{
		Sys::Convert::SysTimeToSqlTime(SelectedDate, _sqltime);
	}
}

void DateTimeBox::GetCurrentSelection(int& month, int& day, int& year)
{
	month = SelectedDate.wMonth;
	day = SelectedDate.wDay;
	year = SelectedDate.wYear;
}
	
void DateTimeBox::SetCurrentSelection(int month, int day, int year)
{
	SelectedDate.wMonth = month;
	SelectedDate.wYear = year;
	SelectedDate.wDay = day;
}

//void DateTimeBox::GetCurrentSelection(Sys::Time& systime)
//{
//	systime = _systemtime;
//}
//
//void DateTimeBox::SetCurrentSelection(Sys::Time& systime)
//{
//	_systemtime = systime;
//}
//
//Sys::Time DateTimeBox::GetCurrentSelection()
//{
//	return _systemtime;
//}

void DateTimeBox::GetPreview(int& indentCount, Sys::ITextWriterW& out_html, bool isBrowserView)
{
	RenderTagAndId(false, indentCount, out_html);
	RenderClassAndStyle(out_html);
	RenderName(out_html);
	if (Enabled == false) RenderPair(L"disabled", L"true", out_html);

	RenderPair(L"type", L"text", out_html);
	if (isBrowserView == true)
	{
		RenderPair(L"size", 14, out_html);
		RenderPair(L"value", ID, out_html);
	}
	if (isBrowserView == true)
	{
		//_____________________________________________ A Button
		if (Language == WIN_LANGUAGE_SPANISH)
		{
			out_html.WriteText(L" />&nbsp;<input type=\"button\" value=\"Cambiar\"");
		}
		else
		{
			out_html.WriteText(L" />&nbsp;<input type=\"button\" value=\"Change\"");
		}
		RenderClassAndStyle(out_html);
		out_html.WriteText(L" />");	
	}
	else
	{
		out_html.WriteText(L" />");
	}	
	if (EndHtml.length() > 0) out_html.WriteText(EndHtml);
}

void DateTimeBox::GetText(wchar_t* buffer, int bufferLength)
{
	const wchar_t* months[]={L"Jan", L"Feb", L"Mar", L"Apr", L"May", L"Jun", L"Jul", L"Aug", L"Sep", L"Oct", L"Nov", L"Dec"};
	const wchar_t* meses[]={L"Ene", L"Feb", L"Mar", L"Abr", L"May", L"Jun", L"Jul", L"Ago", L"Sep", L"Oct", L"Nov", L"Dic"};

	if (Language == WIN_LANGUAGE_SPANISH)
	{
		_snwprintf_s(buffer, bufferLength, _TRUNCATE, L"%s %d, %d", meses[SelectedDate.wMonth-1], SelectedDate.wDay, SelectedDate.wYear);
	}
	else // WIN_LANGUAGE_ENGLISH
	{
		_snwprintf_s(buffer, bufferLength, _TRUNCATE, L"%s %d, %d", months[SelectedDate.wMonth-1], SelectedDate.wDay, SelectedDate.wYear);
	}
}

void DateTimeBox::GetHtml(int& indentCount, Sys::ITextWriterW& out_html, Web::HttpConnector& httpConnector)
{
	//const char* days[]={"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};
	wchar_t text[64];
	GetText(text, 64);
	if (Visible == false)
	{
		RenderHiddenValue(false, indentCount, text, out_html);
		return;
	}
	RenderTagAndId(false, indentCount, out_html);
	RenderClassAndStyle(out_html);
	RenderName(out_html);
	if (Enabled == false) RenderPair(L"disabled", L"true", out_html);
	RenderPair(L"readonly", L"true", out_html);
	//RenderJavascriptEvents(out_html);

	RenderPair(L"type", L"text", out_html);
	RenderPair(L"size", 14, out_html);
	RenderPair(L"value", text, out_html);
	//_____________________________________________ A Button
	if (Language == WIN_LANGUAGE_SPANISH)
	{
		out_html.WriteText(L" />&nbsp;<input type=\"button\" value=\"Cambiar\"");
	}
	else
	{
		out_html.WriteText(L" />&nbsp;<input type=\"button\" value=\"Change\"");
	}
	RenderClassAndStyle(out_html);
	if (Enabled == false) RenderPair(L"disabled", L"true", out_html);
	//out_html.WriteText(L" onclick=\"Hola()\" />");
	out_html.WriteText(L" onclick=\"DisplayCalendar('");
	out_html.WriteText(ID);
	if (Language == WIN_LANGUAGE_SPANISH)
	{
		out_html.WriteText(L"', 'spanish', ");
	}
	else
	{
		out_html.WriteText(L"', 'english', '");
	}
	out_html.WriteText(CssFile);
	out_html.WriteText(L"')\" />");
	if (EndHtml.length() > 0) out_html.WriteText(EndHtml);
}

void DateTimeBox::GetXml(Web::HttpConnector& httpConnector)
{
	wchar_t text[64];
	GetText(text, 64);

	httpConnector.WriteText(L"<control><id>");
	httpConnector.WriteText(ID);
	httpConnector.WriteText(L"</id><type>Textbox</type><value>");
	if (wcslen(text) > 0)
	{
		wstring xmlValue;
		Sys::Convert::ToXml(text, xmlValue);
		httpConnector.WriteText(xmlValue);
	}
	httpConnector.WriteText(L"</value></control>");
}

void DateTimeBox::LoadState(Web::HttpConnector& httpConnector)
{
	wstring name(ID);
	name += L"Data";
	multimap<wstring, wstring>::iterator state = httpConnector.value.find(name);
	if (state == httpConnector.value.end()) return;
	if (state->second.length() <= 0) return; 
	Sys::Convert::ToTime(state->second, SelectedDate);
}

wchar_t* DateTimeBox::GetTag()
{
	return L"input";
}

//________________________________________________________ DateView
DateView::DateView()
{
}

DateView::~DateView()
{
}

void DateView::GetPreview(int& indentCount, Sys::ITextWriterW& out_html, bool isBrowserView)
{
	//if (Visible == false) return;
	//RenderTagAndId(false, indentCount, out_html);
	//if (Submit == true)
	//{
	//	out_html.WriteText(L" type=\"submit\"");
	//}
	//else
	//{
	//	out_html.WriteText(L" type=\"button\"");
	//}
	//RenderClassAndStyle(out_html);
	//RenderPair(L"value", Text, out_html);
	//if (Enabled == false) RenderPair(L"disabled", L"true", out_html);
	//
	//out_html.WriteText(L" />");
	//if (EndHtml.length() > 0) out_html.WriteText(EndHtml);
}

void DateView::GetHtml(int& indentCount, Sys::ITextWriterW& out_html, Web::HttpConnector& httpConnector)
{
	//if (Visible == false) return;
	//RenderTagAndId(false, indentCount, out_html);
	//RenderClassAndStyle(out_html);
	//RenderPair(L"src", src, out_html);
	//RenderPair(L"alt", Text, out_html);
	//RenderJavascriptEvents(out_html);
	//out_html.WriteText(L" />");
	//if (EndHtml.length() > 0) out_html.WriteText(EndHtml);
}

//________________________________________________________ PlugIn: FlashPlayer, ...
PlugIn::PlugIn()
{
	//Type = L"application/x-shockwave-flash";
	css.width = 400;
	css.height = 220;
}

PlugIn::~PlugIn()
{
}

void PlugIn::OnNavigateAway(Web::HttpConnector& httpConnector)
{
}

void PlugIn::GetPreview(int& indentCount, Sys::ITextWriterW& out_html, bool isBrowserView)
{
	if (BeginHtml.length() > 0) out_html.WriteText(BeginHtml);
	Indent(indentCount, out_html);
	if (isBrowserView == true)
	{
		out_html.WriteText(L"<span");
	}
	else
	{
		out_html.WriteText(L"<object");
	}
	
	//______________________________________ id
	RenderPair(L"id", ID, out_html);

	RenderClassAndStyle(out_html);
	out_html.WriteText(L" />");

	if (isBrowserView == true)
	{
		out_html.WriteText(ID);
		out_html.WriteText(L"</span>");
	}
	else
	{
		out_html.WriteText(L"</object>");
	}
	if (EndHtml.length() > 0) out_html.WriteText(EndHtml);
}

void PlugIn::GetHtml(int& indentCount, Sys::ITextWriterW& out_html, Web::HttpConnector& httpConnector)
{
	if (Visible == false) return;
	RenderTagAndId(false, indentCount, out_html);
	RenderClassAndStyle(out_html);
	RenderPair(L"type", Type, out_html);
	RenderPair(L"data", Data, out_html);
	out_html.WriteText(L" />");
	//__________________________ params
	const vector<Web::ObjectParam>::iterator paramEnd = param.end();
	vector<Web::ObjectParam>::iterator par;
	indentCount++;
	for(par = param.begin(); par != paramEnd; par++)
	{
		Indent(indentCount, out_html);
		out_html.WriteText(L"<param name=\"");
		out_html.WriteText(par->name);
		out_html.WriteText(L"\" value=\"");
		out_html.WriteText(par->value);
		out_html.WriteText(L"\" >");
	}
	indentCount--;
	Indent(indentCount, out_html);
	out_html.WriteText(L"</object>");
	if (EndHtml.length() > 0) out_html.WriteText(EndHtml);
}

void PlugIn::AddParam(const wchar_t* name, const wchar_t* value)
{
	Web::ObjectParam op;
	op.name = name;
	op.value = value;
	param.push_back(op);
}

void PlugIn::AddParam(const wstring& name, const wstring& value)
{
	Web::ObjectParam op;
	op.name = name;
	op.value = value;
	param.push_back(op);
}

void PlugIn::GetXml(Web::HttpConnector& httpConnector)
{
}

void PlugIn::LoadState(Web::HttpConnector& httpConnector)
{
}

wchar_t* PlugIn::GetTag()
{
	return L"object";
}

//________________________________________________________ Pie
Pie::Pie()
{
}

Pie::~Pie()
{
}

bool Pie::operator<(const Web::Pie& pie) const
{
	return (Value < pie.Value);
}

//________________________________________________________ PieCollection
PieCollection::PieCollection()
{
}

PieCollection::~PieCollection()
{
}

void PieCollection::Add(const wstring& text, COLORREF color, double value)
{
	Web::Pie pie;
	pie.Color = color;
	pie.Text = text;
	pie.Value = value;
	storage.push_back(pie);
}

void PieCollection::DeleteAll()
{
	storage.clear();
}

Web::Pie& PieCollection::operator[](long index)
{
	return storage[index];
}

int PieCollection::GetCount()
{
	return storage.size();
}

#ifdef WIN_GDI_PLUS_ON
//_____________________________________________________________________ Graph
Graph::Graph()
{
	type = Web::Graph::TypeLine;
	color = RGB(200, 60, 60);
	penWidth = 1;
}

Graph::~Graph()
{
}

double Graph::GetMaxX(void)
{
	const int pointCount = point.size();
	if (pointCount== 0) return 0.0;
	double maximum = point[0].x;
	for(int i = 1; i<pointCount; i++)
	{
		if (maximum<point[i].x) maximum = point[i].x;
	}
	return maximum;
}

double Graph::GetMaxY(void)
{
	const int pointCount = point.size();
	if (pointCount== 0) return 0.0;
	double maximum = point[0].y;
	for(int i = 1; i<pointCount; i++)
	{
		if (maximum<point[i].y) maximum = point[i].y;
	}
	return maximum;
}

//_____________________________________________________________________ GraphCollection
GraphCollection::GraphCollection()
{
}

GraphCollection::~GraphCollection()
{
}

int GraphCollection::GetCount()
{
	return storage.size();
}

int GraphCollection::Add()
{
	Web::Graph graph;
	storage.push_back(graph);
	return storage.size();
}

int GraphCollection::Add(int graphPointCount)
{
	Web::Graph graph;
	storage.push_back(graph);
	storage.back().point.resize(graphPointCount);
	return storage.size();
}

void GraphCollection::Delete(long index)
{
	vector<Web::Graph>::iterator p = storage.begin() +index;
	if (p == storage.end()) return;
	storage.erase(p);
}

void GraphCollection::DeleteAll()
{
	storage.clear();
}

Web::Graph& GraphCollection::operator[](long index)
{
	return storage[index];
}

//________________________________________________________ PieChart
PieChart::PieChart()
{
}

PieChart::~PieChart()
{
}

void PieChart::BuildBitmap(Gdiplus::Graphics& graphics, Gdiplus::Font& font, Gdiplus::SolidBrush& brushFont, Gdiplus::Pen& penLine, Gdiplus::Pen& penText)
{

	double _xCaption = (int)(12*css.font_size);//(0.4*width+0.5);
	const double pieWidth = abs(css.width) - _xCaption;
	const double _dimension = MINIMUM(pieWidth, abs(css.height));
	const int radius = (int)(_dimension*0.95/2.0+0.5);
	const int xCenter = (int)(radius + 0.05*_dimension+0.5);
	const int yCenter = (int)(abs(css.height)/2.0+0.5);
	_xCaption = (int)(1.05 * _dimension+0.5);
	double _yCaption = _dimension*0.05;
	int i=0;
	double angleIni = 0.0;

	Gdiplus::PointF point;
	Gdiplus::StringFormat sf;
	sf.SetAlignment(Gdiplus::StringAlignmentNear);
	sf.SetLineAlignment(Gdiplus::StringAlignmentNear);

	const int pieCount = Pies.storage.size();

	//________________________________________compute total
	double _total = 0.0;
	for(i=0; i<pieCount; i++)
    {
		_total += fabs(Pies.storage[i].Value);
    }
	const double spacing =  font.GetHeight(0.0);
	//_________________________________________ title
	if (Text.length() > 0)
	{
		point.X = (Gdiplus::REAL)_xCaption;
		point.Y = (Gdiplus::REAL)_yCaption;
		graphics.DrawString(Text.c_str(), -1, &font, point, &sf, &brushFont);
		point.Y += (Gdiplus::REAL)(1.5*spacing);
	}

	double value = 0.0;
	double angleDelta = 0.0;
	wchar_t texto[128];
	double percentaje = 0.0;
	wstring wpercent;
	Gdiplus::RectF rect;
	point.X = (Gdiplus::REAL)(_xCaption + 1.05*spacing);
	rect.X = (Gdiplus::REAL)(_xCaption+0.1*spacing);
	rect.Width = (Gdiplus::REAL)(0.8*spacing);
	rect.Height = (Gdiplus::REAL)(0.8*spacing);
	for(i=0; i<pieCount; i++)
    {
		percentaje = fabs(Pies.storage[i].Value*100.0/_total);
		angleDelta = percentaje*360.0/100.0;
		//
		Gdiplus::SolidBrush brush(Gdiplus::Color(255, GetRValue(Pies.storage[i].Color), GetGValue(Pies.storage[i].Color), GetBValue(Pies.storage[i].Color)));
		if (percentaje > 0.0)
		{
			graphics.FillPie(&brush,
			xCenter-radius, 
			yCenter-radius, 
			2*radius, 
			2*radius,
			(Gdiplus::REAL)angleIni,
			(Gdiplus::REAL)angleDelta);
			angleIni += angleDelta;
		}

		//____________________________________________ Caption Square
		rect.Y = (Gdiplus::REAL)(point.Y+0.1*spacing);
		graphics.FillRectangle(&brush, rect);
		//____________________________________________ Caption
		if (percentaje>1.0)
		{
			_snwprintf_s(texto, 128, _TRUNCATE, L"%s %.0f%%", Pies.storage[i].Text.c_str(), percentaje);
		}
		else
		{
			_snwprintf_s(texto, 128, _TRUNCATE, L"%s %.1f%%", Pies.storage[i].Text.c_str(), percentaje);
		}
		//Sys::Convert::ToString(percentaje, texto, 128, true);
		//wpercent = Pies.storage[i].Text;
		//wpercent += ' ';
		//wpercent += texto;
		//wpercent += '%';
		//graphics.DrawString(wpercent.c_str(), -1, &font, point, &sf, &brushFont);
		graphics.DrawString(texto, -1, &font, point, &sf, &brushFont);
		//
		point.Y += (Gdiplus::REAL)(1.1*spacing);
	}
}

void PieChart::Sync(Web::HttpConnector& h)
{
	BasicSync(h);

	multimap<wstring, wstring>::iterator p;
	const multimap<wstring, wstring>::iterator valueEnd = h.value.end();

	//___________________________________________ Data
	p = h.value.find(L"Data"); 
	if (p == valueEnd) return;
	const int len = p->second.length();
	double value = 0.0;
	int red = 0;
	int green = 0;
	int blue = 0;
	wstring tmp;
	int i = 0;
	int state = 0;
	wchar_t c;
	for(i = 0; i < len; i++)
	{
		c = p->second[i];
		if (state == 0) //_____________________ Value
		{
			if (c == '#')
			{
				value = Sys::Convert::ToDouble(tmp);
				tmp.clear();
				state = 1;
			}
			else
			{
				tmp += c;
			}
		}
		else if (state== 1)//_____________________ Red
		{
			if (c == '#')
			{
				red = Sys::Convert::ToInt(tmp);
				tmp.clear();
				state = 2;
			}
			else
			{
				tmp += c;
			}
		}
		else if (state== 2)//_____________________ Green
		{
			if (c == '#')
			{
				green = Sys::Convert::ToInt(tmp);
				tmp.clear();
				state = 3;
			}
			else
			{
				tmp += c;
			}
		}
		else if (state== 3)//_____________________ Blue
		{
			if (c == '#')
			{
				blue = Sys::Convert::ToInt(tmp);
				tmp.clear();
				state = 4;
			}
			else
			{
				tmp += c;
			}
		}
		else if (state== 4)//_____________________ Text
		{
			if (c == '#')
			{
				Pies.Add(tmp, RGB(red, green, blue), value);
				tmp.clear();
				state = 0;
			}
			else
			{
				tmp += c;
			}
		}
	}
}

void PieChart::GetSource(wstring& source, const wchar_t* url)
{
	const vector<Web::Pie>::iterator pieEnd = Pies.storage.end();
	wchar_t text[256];
	wstring encodedText;

	source = L"http://";
	source += url;
	source += L"?windowID=PieChart";

	Web::PieChart chart;
	this->RenderProperties(chart, source);

	source += L"&Data=";
	
	for(vector<Web::Pie>::iterator pie = Pies.storage.begin(); pie != pieEnd; pie++)
	{
		Sys::TextAssistant::ReplaceChar(pie->Text, '#', ' ');
		_snwprintf_s(text, 256, _TRUNCATE, L"%g#%d#%d#%d#%s#",
			pie->Value, GetRValue(pie->Color), GetGValue(pie->Color), GetBValue(pie->Color), pie->Text.c_str());
		Sys::Convert::WstringToHex(text, encodedText);
		source += encodedText;
	}
}

//________________________________________________________ PolarChart
PolarChart::PolarChart()
{
	AutoScale = true;
	_scale = 1.0;
	_centerX = 100.0;
	_centerY = 100.0;
	MaxRadius = 1.0;
	MinRadius = 0.0;
	LineColor = RGB(225, 225, 255);
	SubgridColor = RGB(240, 240, 245);
	ShowSubgrid = true;
}

PolarChart::~PolarChart()
{
}

void PolarChart::BuildBitmap(Gdiplus::Graphics& graphics, Gdiplus::Font& font, Gdiplus::SolidBrush& brushFont, Gdiplus::Pen& penLine, Gdiplus::Pen& penText)
{
	const int graphCount = Graphs.storage.size();
	double minR=MinRadius;
	double maxR=MaxRadius;
	int i = 0, j, n;
	//int index = 0;
	if (AutoScale == true && graphCount > 0)
	{
		minR = maxR = Graphs[0].point[0].y;
		for(i=0; i<graphCount; i++)
		{
			n = Graphs[i].point.size();
			for(j = 0; j<n; j++)
			{
				if (Graphs[i].point[j].y<minR) minR = Graphs[i].point[j].y;
				if (Graphs[i].point[j].y>maxR) maxR = Graphs[i].point[j].y;
			}
		}
	}
	if (minR == maxR)
	{
		minR = 0.0;
		maxR = 1.0;
	}

	const int max_r = (int)((MINIMUM(abs(css.width), abs(css.height)))/2.1);
	_centerX = abs(css.width)/2.0;
	_centerY = abs(css.height)/2.0;
	_scale = max_r/(maxR - minR);

	const int markCount = 10;
	const double radius = maxR - minR;
	double r = 0.0;
	//___________________________________________________ Sub Grid
	if (ShowSubgrid == true)
	{
		Gdiplus::Pen penSubgrid(Gdiplus::Color(255, GetRValue(SubgridColor), GetGValue(SubgridColor), GetBValue(SubgridColor)), 1.0f);
		for(i = 1; i <= markCount; i+=2)
		{
			r = i*radius* _scale/markCount;
			graphics.DrawEllipse(&penSubgrid, (Gdiplus::REAL)(_centerX-r), (Gdiplus::REAL)(_centerY-r), 
				(Gdiplus::REAL)(2.0*r), (Gdiplus::REAL)(2.0*r));
		}
		ShortLine(graphics, penSubgrid, 10.0, radius);
		ShortLine(graphics, penSubgrid, 20.0, radius);
		ShortLine(graphics, penSubgrid, 40.0, radius);
		ShortLine(graphics, penSubgrid, 50.0, radius);
		ShortLine(graphics, penSubgrid, 70.0, radius);;
		ShortLine(graphics, penSubgrid, 80.0, radius);
	}


	//__________________________________________________ Grid
	for(i = 2; i <= markCount; i += 2)
	{
		r = i*radius* _scale/markCount;
		graphics.DrawEllipse(&penLine, (Gdiplus::REAL)(_centerX-r), (Gdiplus::REAL)(_centerY-r), 
				(Gdiplus::REAL)(2.0*r), (Gdiplus::REAL)(2.0*r));
	}
	//________________________________________________ X Axis
	graphics.DrawLine(&penLine, 
		(Gdiplus::REAL)(_centerX-radius* _scale), (Gdiplus::REAL)(_centerY), 
		(Gdiplus::REAL)(_centerX+radius* _scale), (Gdiplus::REAL)(_centerY));

	//________________________________________________ Y Axis
	graphics.DrawLine(&penLine, 
		(Gdiplus::REAL)(_centerX), (Gdiplus::REAL)(_centerY-radius* _scale), 
		(Gdiplus::REAL)(_centerX), (Gdiplus::REAL)(_centerY+radius* _scale));


	Line(graphics, penLine, 30.0, radius);
	Line(graphics, penLine, 60.0, radius);

	//_______________________________________________________________ Paint Window Text
	if (Text.length() > 0)
	{
		Gdiplus::StringFormat stringFormat;
		stringFormat.SetAlignment(Gdiplus::StringAlignmentNear);
		stringFormat.SetLineAlignment(Gdiplus::StringAlignmentNear);
		Gdiplus::PointF point;
		point.X = (Gdiplus::REAL)(css.font_size/2);
		point.Y = (Gdiplus::REAL)(css.font_size/4);
		graphics.DrawString(Text.c_str(), -1, &font, point, &stringFormat, &brushFont);
	}


	//_______________________________________________________________ Paint Scale
	Gdiplus::PointF position;
	const double cosp = cos(45.0*M_PI/180.0);
	const double sinp = sin(45.0*M_PI/180.0);
	for(i = 2; i <= markCount; i += 2) 
	{
		position.X = (Gdiplus::REAL)(_centerX+i*sinp*radius* _scale/markCount);
		position.Y = (Gdiplus::REAL)(_centerY+i*cosp*radius* _scale/markCount);
		OnPaintScaleR(graphics, font, brushFont, position, minR + i*radius/markCount);
	}
	//
	double tetha = 0.0;
	wchar_t texto[64];
	Gdiplus::StringFormat stringFormatC;
	stringFormatC.SetAlignment(Gdiplus::StringAlignmentCenter);
	stringFormatC.SetLineAlignment(Gdiplus::StringAlignmentCenter);
	for(i=0; i<12; i++)
	{
		//if (i==9) continue; // skip 270
		tetha = i *(2.0*M_PI)/12.0;
		_snwprintf_s(texto, 64, _TRUNCATE, L"%d", i*30);
		position.X = (Gdiplus::REAL)(radius* _scale*cos(tetha)+ _centerX);
		position.Y = (Gdiplus::REAL)(-radius* _scale*sin(tetha)+ _centerY);
		graphics.DrawString(texto, -1, &font, position, &stringFormatC, &brushFont);
	}
	this->PaintGraphs(graphics);
}

void PolarChart::Sync(Web::HttpConnector& h)
{
	BasicSync(h);
	COLORREF a;

	multimap<wstring, wstring>::iterator p;
	const multimap<wstring, wstring>::iterator valueEnd = h.value.end();

	//__________________________________________ MinRadius
	p = h.value.find(L"MinRadius"); 
	if (p != valueEnd) MinRadius = Sys::Convert::ToDouble(p->second);

	//__________________________________________ MaxRadius
	p = h.value.find(L"MaxRadius"); 
	if (p != valueEnd) MaxRadius = Sys::Convert::ToDouble(p->second);

	//___________________________________________ Autoscale
	p = h.value.find(L"AutoScale"); 
	if (p != valueEnd) AutoScale = Sys::Convert::ToBool(p->second);

	//___________________________________________ ShowSubgrid
	p = h.value.find(L"ShowSubgrid"); 
	if (p != valueEnd) ShowSubgrid = Sys::Convert::ToBool(p->second);

	//__________________________________________ SubgridColor
	if (ColorSync(h, L"SgRed", L"SgGreen", L"SgBlue", a) == true) SubgridColor = a;

	//___________________________________________ Data

	int i = 0;
	int j = 0;
	wchar_t text[256];
	int len = 0;
	Sys::PointF point;
	wstring tmp;
	int state = 0;
	wchar_t c;
	int red = 0;
	int green = 0;
	int blue = 0;
	int type = 0;
	for(i = 0; i < 4; i++)
	{
		_snwprintf_s(text, 256, _TRUNCATE, L"Data%d", i);
		p = h.value.find(text); 
		if (p == valueEnd) break;
		len = p->second.length();
		Graphs.Add();
		state = 0;
		for(j= 0; j < len; j++)
		{
			c = p->second[j];
			if (state == 0) //_____________________ type
			{
				if (c == 's')
				{
					type = Sys::Convert::ToInt(tmp);
					tmp.clear();
					state = 1;
					Graphs[i].type = (Web::Graph::Type)type;
				}
				else
				{
					tmp += c;
				}
			}
			else if (state == 1) //_____________________ red
			{
				if (c == 's')
				{
					red = Sys::Convert::ToInt(tmp);
					tmp.clear();
					state = 2;
				}
				else
				{
					tmp += c;
				}
			}
			else if (state == 2) //_____________________ green
			{
				if (c == 's')
				{
					green = Sys::Convert::ToInt(tmp);
					tmp.clear();
					state = 3;
				}
				else
				{
					tmp += c;
				}
			}
			else if (state== 3)//_____________________ blue
			{
				if (c == 's')
				{
					blue = Sys::Convert::ToInt(tmp);
					tmp.clear();
					state = 4;
					Graphs[i].color = RGB(red, green, blue);
				}
				else
				{
					tmp += c;
				}
			}
			else if (state == 4) //_____________________ X
			{
				if (c == 's')
				{
					point.x = Sys::Convert::ToDouble(tmp);
					tmp.clear();
					state = 5;
				}
				else
				{
					tmp += c;
				}
			}
			else if (state== 5)//_____________________ Y
			{
				if (c == 's')
				{
					point.y = Sys::Convert::ToDouble(tmp);
					tmp.clear();
					state = 4;
					Graphs[i].point.push_back(point);
				}
				else
				{
					tmp += c;
				}
			}
		}
	}
}

void PolarChart::GetSource(wstring& source, const wchar_t* url)
{
	wchar_t text[256];
	wstring encodedText;

	source = L"http://";
	source += url;
	source += L"?windowID=PolarChart";

	Web::PolarChart chart;
	if (chart.MinRadius != this->MinRadius) RenderValue(L"MinRadius", MinRadius, source);
	if (chart.MaxRadius != this->MaxRadius) RenderValue(L"MaxRadius", MaxRadius, source);
	if (chart.AutoScale != this->AutoScale) RenderValue(L"AutoScale", AutoScale, source);
	if (chart.ShowSubgrid != this->ShowSubgrid) RenderValue(L"ShowSubgrid", ShowSubgrid, source);
	if (this->SubgridColor != chart.SubgridColor)
	{
		_snwprintf_s(text, 256, _TRUNCATE, L"&SgRed=%d&SgGreen=%d&SgBlue=%d", 
			GetRValue(SubgridColor), GetGValue(SubgridColor), GetBValue(SubgridColor));
		source += text;
	}

	this->RenderProperties(chart, source);
	const int graphCount = Graphs.storage.size();
	if (graphCount <= 0) return;
	int pointCount = 0;
	int i = 0, j = 0;
	for(i = 0; i < graphCount; i++)
	{
		pointCount = Graphs[i].point.size();
		_snwprintf_s(text, 256, _TRUNCATE, L"&Data%d=%ds%ds%ds%ds", i, (int)Graphs[i].type, (int)GetRValue(Graphs[i].color), 
			(int)GetGValue(Graphs[i].color), (int)GetBValue(Graphs[i].color));
		source += text;
		for(j = 0; j < pointCount; j++)
		{
			_snwprintf_s(text, 256, _TRUNCATE, L"%gs%gs", Graphs[i].point[j].x, Graphs[i].point[j].y);
			Sys::Convert::WstringToHex(text, encodedText);
			source += encodedText;
		}
	}
}

void PolarChart::Line(Gdiplus::Graphics& graphics, Gdiplus::Pen& pen, double angle, double radius)
{
	angle = M_PI*angle/180.0;
	const double x = radius* _scale*cos(angle);
	const double y = radius* _scale*sin(angle);

	graphics.DrawLine(&pen, 
		(Gdiplus::REAL)(_centerX-x), (Gdiplus::REAL)(_centerY-y), 
		(Gdiplus::REAL)(_centerX+x), (Gdiplus::REAL)(_centerY+y));

	graphics.DrawLine(&pen, 
		(Gdiplus::REAL)(_centerX-x), (Gdiplus::REAL)(_centerY+y), 
		(Gdiplus::REAL)(_centerX+x), (Gdiplus::REAL)(_centerY-y));

//	points[index].x = (int)(_centerX-x+0.5);
//	points[index].y = (int)(_centerY-y+0.5);
//	index++;
//	//
//	points[index].x = (int)(_centerX+x+0.5);
//	points[index].y = (int)(_centerY+y-0.5);
//	index++;
//	//
//	points[index].x = (int)(_centerX-x+0.5);
//	points[index].y = (int)(_centerY+y+0.5);
//	index++;
//	//
//	points[index].x = (int)(_centerX+x+0.5);
//	points[index].y = (int)(_centerY-y-0.5);
//	index++;
	//return index;
}

void PolarChart::ShortLine(Gdiplus::Graphics& graphics, Gdiplus::Pen& pen, double angle, double radius)
{
	angle = M_PI*angle/180.0;
	const double x = radius* _scale*cos(angle);
	const double y = radius* _scale*sin(angle);
	const double lengthX = 2.0* _scale*cos(angle)*radius/5.0;
	const double lengthY = 2.0* _scale*sin(angle)*radius/5.0;
	//points[index].X = (Gdiplus::REAL)(_centerX-x+0.5);
	//points[index].Y = (Gdiplus::REAL)(_centerY-y+0.5);
	//index++;
	////
	//points[index].X = (Gdiplus::REAL)(_centerX-lengthX+0.5);
	//points[index].Y = (Gdiplus::REAL)(_centerY-lengthY-0.5);
	//index++;
	////
	//points[index].X = (Gdiplus::REAL)(_centerX+lengthX+0.5);
	//points[index].Y = (Gdiplus::REAL)(_centerY+lengthY+0.5);
	//index++;
	////
	//points[index].X = (Gdiplus::REAL)(_centerX+x+0.5);
	//points[index].Y = (Gdiplus::REAL)(_centerY+y-0.5);
	//index++;
	////
	//points[index].X = (Gdiplus::REAL)(_centerX-x+0.5);
	//points[index].Y = (Gdiplus::REAL)(_centerY+y+0.5);
	//index++;
	////
	//points[index].X = (Gdiplus::REAL)(_centerX-lengthX+0.5);
	//points[index].Y = (Gdiplus::REAL)(_centerY+lengthY-0.5);
	//index++;
	////
	//points[index].X = (Gdiplus::REAL)(_centerX+lengthX+0.5);
	//points[index].Y = (Gdiplus::REAL)(_centerY-lengthY+0.5);
	//index++;
	////
	//points[index].X = (Gdiplus::REAL)(_centerX+x+0.5);
	//points[index].Y = (Gdiplus::REAL)(_centerY-y-0.5);
	//index++;
	////
	//return index;
	graphics.DrawLine(&pen, (Gdiplus::REAL)(_centerX-x), (Gdiplus::REAL)(_centerY-y), (Gdiplus::REAL)(_centerX-lengthX), (Gdiplus::REAL)(_centerY-lengthY));
	graphics.DrawLine(&pen, (Gdiplus::REAL)(_centerX+lengthX), (Gdiplus::REAL)(_centerY+lengthY), (Gdiplus::REAL)(_centerX+x), (Gdiplus::REAL)(_centerY+y));
	//
	graphics.DrawLine(&pen, (Gdiplus::REAL)(_centerX-x), (Gdiplus::REAL)(_centerY+y), (Gdiplus::REAL)(_centerX-lengthX), (Gdiplus::REAL)(_centerY+lengthY));
	graphics.DrawLine(&pen, (Gdiplus::REAL)(_centerX+lengthX), (Gdiplus::REAL)(_centerY-lengthY), (Gdiplus::REAL)(_centerX+x), (Gdiplus::REAL)(_centerY-y));
}

//
void PolarChart::OnPaintScaleR(Gdiplus::Graphics& graphics, Gdiplus::Font& font, Gdiplus::SolidBrush& brushFont, Gdiplus::PointF& center, double value)
{
	wchar_t texto[64];
	Sys::Convert::ToString(value, texto, 64, true);
	Gdiplus::StringFormat stringFormat;
	stringFormat.SetAlignment(Gdiplus::StringAlignmentCenter);
	stringFormat.SetLineAlignment(Gdiplus::StringAlignmentCenter);
	graphics.DrawString(texto, -1, &font, center, &stringFormat, &brushFont);
}

void PolarChart::PaintGraphs(Gdiplus::Graphics& graphics)
{
//	//HRGN hRgn = CreateRectRgnIndirect(&this->m_rcMain);
//	//if (!bPrintting) gdi.SelectClipRgn(hRgn);
	int pointCount = 0;
	const int graphCount = Graphs.GetCount();
	COLORREF graphColor;
	for(int i = 0; i<graphCount; i++)
	{
		graphColor = (WhiteAndBlack == true) ? RGB(0, 0, 0) : Graphs.storage[i].color;
		Gdiplus::Pen pen(Gdiplus::Color(255, GetRValue(graphColor), GetGValue(graphColor), GetBValue(graphColor)), 1.0f);
		this->DrawGraph(graphics, pen, i);
	}
//	//DeleteObject(hRgn);
}


void PolarChart::DrawGraph(Gdiplus::Graphics& graphics, Gdiplus::Pen& pen, int graphIndex)
{
	int i = 0;
	const int pointCount = Graphs.storage[graphIndex].point.size();
	if (pointCount==0) return;
	Gdiplus::REAL dimension = 0.015f*abs(css.height);

	Gdiplus::PointF *screenPoints = new Gdiplus::PointF[pointCount];
	if (screenPoints == NULL) return;

	for(i = 0; i<pointCount; i++)
	{
		screenPoints[i].X= (Gdiplus::REAL)TransformToScreenCoordinatesX(Graphs.storage[graphIndex].point[i].x, Graphs.storage[graphIndex].point[i].y);
		screenPoints[i].Y= (Gdiplus::REAL)TransformToScreenCoordinatesY(Graphs.storage[graphIndex].point[i].x, Graphs.storage[graphIndex].point[i].y);
	}

	switch(Graphs.storage[graphIndex].type)
	{
	case Web::Graph::TypeCircle:
			for(i = 0; i<pointCount; i++)
			{
				graphics.DrawEllipse(&pen, screenPoints[i].X-dimension, screenPoints[i].Y-dimension, dimension, dimension);
			}
		break;
	case Web::Graph::TypeCross:
		for(i = 0; i<pointCount; i++)
		{
			graphics.DrawLine(&pen, screenPoints[i].X, screenPoints[i].Y-dimension, screenPoints[i].X, screenPoints[i].Y + dimension);
			graphics.DrawLine(&pen, screenPoints[i].X-dimension, screenPoints[i].Y, screenPoints[i].X + dimension, screenPoints[i].Y);
		}
		break;
	case Web::Graph::TypeDot:
		for(i = 0; i<pointCount; i++)
		{
			graphics.DrawEllipse(&pen, screenPoints[i].X-dimension, screenPoints[i].Y-dimension, 0.3f*dimension, 0.3f*dimension);
		}
		break;
	case Web::Graph::TypeSquare:
		for(i = 0; i<pointCount; i++)
			{
				graphics.DrawRectangle(&pen, screenPoints[i].X-dimension, screenPoints[i].Y-dimension, dimension, dimension);
			}
		break;
	case Web::Graph::TypeLine:
		graphics.DrawLines(&pen, screenPoints, pointCount);
		break;
	}
	if (screenPoints != NULL) delete [] screenPoints;
}

//________________________________________________________ XyChart
XyChart::XyChart()
{
	_minX = 0.0;
	_maxX = 10.0;
	_minY = 0.0;
	_maxY = 10.0;
	_scaleX = 1.0;
	_scaleY = 1.0;
	_originX = 0.0;
	_originY = 0.0;
	//
	css.color = RGB(0, 0, 200);
	LineColor = RGB(235, 235, 255);
	//
	MinX = _minX;
	MaxX = _maxX;
	MinY = _minY;
	MaxY = _maxY;
	DivisionCountX = 5;
	DivisionCountY = 5;
	SubDivisionCountX = 4;
	SubDivisionCountY = 4;
	CaptionX = L"X";
	CaptionY = L"Y";
	LogScaleX = false;
	LogScaleY = false;
	SubgridColor = RGB(245, 245, 245);
	AutoScaleX = false;
	AutoScaleY = false;
	//
	_boxCaptionHeight = 1.0;
}

XyChart::~XyChart()
{
}

void XyChart::Sync(Web::HttpConnector& h)
{
	BasicSync(h);
	COLORREF a;

	multimap<wstring, wstring>::iterator p;
	multimap<wstring, wstring>::iterator caption;
	const multimap<wstring, wstring>::iterator valueEnd = h.value.end();

	//__________________________________________ CaptionX
	p = h.value.find(L"CaptionX"); 
	if (p != valueEnd)
	{
		if (p->second.length() > 0) CaptionX = p->second;
	}

	//__________________________________________ CaptionY
	p = h.value.find(L"CaptionY"); 
	if (p != valueEnd)
	{
		if (p->second.length() > 0) CaptionY = p->second;
	}

	//__________________________________________ MinX
	p = h.value.find(L"MinX"); 
	if (p != valueEnd) MinX = Sys::Convert::ToDouble(p->second);

	//__________________________________________ MaxX
	p = h.value.find(L"MaxX"); 
	if (p != valueEnd) MaxX = Sys::Convert::ToDouble(p->second);

	//__________________________________________ MinY
	p = h.value.find(L"MinY"); 
	if (p != valueEnd) MinY = Sys::Convert::ToDouble(p->second);

	//__________________________________________ MaxY
	p = h.value.find(L"MaxY"); 
	if (p != valueEnd) MaxY = Sys::Convert::ToDouble(p->second);

	//__________________________________________ DivisionCountX
	p = h.value.find(L"DivisionCountX"); 
	if (p != valueEnd) DivisionCountX = Sys::Convert::ToInt(p->second);

	//__________________________________________ DivisionCountY
	p = h.value.find(L"DivisionCountY"); 
	if (p != valueEnd) DivisionCountY = Sys::Convert::ToInt(p->second);

	//__________________________________________ SubDivisionCountX
	p = h.value.find(L"SubDivisionCountX"); 
	if (p != valueEnd) SubDivisionCountX = Sys::Convert::ToInt(p->second);

	//__________________________________________ SubDivisionCountY
	p = h.value.find(L"SubDivisionCountY"); 
	if (p != valueEnd) SubDivisionCountY = Sys::Convert::ToInt(p->second);

	//___________________________________________ LogScaleX
	p = h.value.find(L"LogScaleX"); 
	if (p != valueEnd) LogScaleX = Sys::Convert::ToBool(p->second);

	//___________________________________________ LogScaleY
	p = h.value.find(L"LogScaleY"); 
	if (p != valueEnd) LogScaleY = Sys::Convert::ToBool(p->second);

	//___________________________________________ AutoScaleX
	p = h.value.find(L"AutoScaleX"); 
	if (p != valueEnd) AutoScaleX = Sys::Convert::ToBool(p->second);

	//___________________________________________ AutoScaleY
	p = h.value.find(L"AutoScaleY"); 
	if (p != valueEnd) AutoScaleY = Sys::Convert::ToBool(p->second);

	//__________________________________________ SubgridColor
	if (ColorSync(h, L"SgRed", L"SgGreen", L"SgBlue", a) == true) SubgridColor = a;

	//___________________________________________ Data

	int i = 0;
	int j = 0;
	wchar_t text[256];
	int len = 0;
	Sys::PointF point;
	wstring tmp;
	int state = 0;
	wchar_t c;
	int red = 0;
	int green = 0;
	int blue = 0;
	int type = 0;
	for(i = 0; i < 4; i++)
	{
		_snwprintf_s(text, 256, _TRUNCATE, L"Data%d", i);
		p = h.value.find(text); 
		if (p == valueEnd) break;
		len = p->second.length();
		Graphs.Add();
		//___________________________ Caption
		_snwprintf_s(text, 256, _TRUNCATE, L"Caption%d", i);
		caption = h.value.find(text); 
		if (caption != valueEnd) Graphs[i].caption =caption->second;
		//
		state = 0;
		for(j= 0; j < len; j++)
		{
			c = p->second[j];
			if (state == 0) //_____________________ type
			{
				if (c == 's')
				{
					type = Sys::Convert::ToInt(tmp);
					tmp.clear();
					state = 1;
					Graphs[i].type = (Web::Graph::Type)type;
				}
				else
				{
					tmp += c;
				}
			}
			else if (state == 1) //_____________________ red
			{
				if (c == 's')
				{
					red = Sys::Convert::ToInt(tmp);
					tmp.clear();
					state = 2;
				}
				else
				{
					tmp += c;
				}
			}
			else if (state == 2) //_____________________ green
			{
				if (c == 's')
				{
					green = Sys::Convert::ToInt(tmp);
					tmp.clear();
					state = 3;
				}
				else
				{
					tmp += c;
				}
			}
			else if (state== 3)//_____________________ blue
			{
				if (c == 's')
				{
					blue = Sys::Convert::ToInt(tmp);
					tmp.clear();
					state = 4;
					Graphs[i].color = RGB(red, green, blue);
				}
				else
				{
					tmp += c;
				}
			}
			else if (state == 4) //_____________________ X
			{
				if (c == 's')
				{
					point.x = Sys::Convert::ToDouble(tmp);
					tmp.clear();
					state = 5;
				}
				else
				{
					tmp += c;
				}
			}
			else if (state== 5)//_____________________ Y
			{
				if (c == 's')
				{
					point.y = Sys::Convert::ToDouble(tmp);
					tmp.clear();
					state = 4;
					Graphs[i].point.push_back(point);
				}
				else
				{
					tmp += c;
				}
			}
		}
	}
}

void XyChart::BuildBitmap(Gdiplus::Graphics& graphics, Gdiplus::Font& font, Gdiplus::SolidBrush& brushFont, Gdiplus::Pen& penLine, Gdiplus::Pen& penText)
{
	OnSizePrivate();

	Gdiplus::Pen penSubDiv(Gdiplus::Color(255, GetRValue(SubgridColor), GetGValue(SubgridColor), GetBValue(SubgridColor)), 1.0f);

	const double deltaX = (_rcMain.right-_rcMain.left)/(double)DivisionCountX;
	const double deltaY = (_rcMain.bottom-_rcMain.top)/(double)DivisionCountY;
	this->PaintCaptionY(graphics, font, brushFont);
	this->PaintCaptionX(graphics, font, brushFont);
	//
	this->PaintScaleX(graphics, font, brushFont, deltaX);
	this->PaintScaleY(graphics, font, brushFont, deltaY);
	//
	this->PaintSubDivX(graphics, penSubDiv);
	this->PaintSubDivY(graphics, penSubDiv);
	//
	this->PaintDivX(graphics, penLine);
	this->PaintDivY(graphics, penLine);
	//
	Gdiplus::RectF rc;
	rc.X = (Gdiplus::REAL)_rcMain.left;
	rc.Y = (Gdiplus::REAL)_rcMain.top;
	rc.Width = (Gdiplus::REAL)(_rcMain.right - _rcMain.left);
	rc.Height = (Gdiplus::REAL)(_rcMain.bottom - _rcMain.top);
	graphics.DrawRectangle(&penText, rc);
//		gdi.Rectangle(_rcMain.left, _rcMain.top, _rcMain.right+1, _rcMain.bottom+1);
	this->PaintGraphs(graphics, font);

}

void XyChart::GetSource(wstring& source, const wchar_t* url)
{
	wchar_t text[256];
	wstring encodedText;

	source = L"http://";
	source += url;
	source += L"?windowID=XyChart";
	Web::XyChart chart;

	//__________________________________________ SubgridColor
	if (chart.SubgridColor != SubgridColor)
	{
		_snwprintf_s(text, 256, _TRUNCATE, L"&SgRed=%d&SgGreen=%d&SgBlue=%d", 
			GetRValue(SubgridColor), GetGValue(SubgridColor), GetBValue(SubgridColor));
		source += text;
	}
	RenderValue(L"CaptionX", CaptionX, source);
	RenderValue(L"CaptionY", CaptionY, source);
	if (chart.MinX != this->MinX) RenderValue(L"MinX", MinX, source);
	if (chart.MaxX != this->MaxX) RenderValue(L"MaxX", MaxX, source);
	if (chart.MinY != this->MinY) RenderValue(L"MinY", MinY, source);
	if (chart.MaxY != this->MaxY) RenderValue(L"MaxY", MaxY, source);
	if (chart.DivisionCountX != this->DivisionCountX) RenderValue(L"DivisionCountX", DivisionCountX, source);
	if (chart.DivisionCountY != this->DivisionCountY) RenderValue(L"DivisionCountY", DivisionCountY, source);
	if (chart.SubDivisionCountX != this->SubDivisionCountX) RenderValue(L"SubDivisionCountX", SubDivisionCountX, source);
	if (chart.SubDivisionCountY != this->SubDivisionCountY) RenderValue(L"SubDivisionCountY", SubDivisionCountY, source);
	if (chart.LogScaleX != this->LogScaleX) RenderValue(L"LogScaleX", LogScaleX, source);
	if (chart.LogScaleY != this->LogScaleY) RenderValue(L"LogScaleY", LogScaleY, source);
	if (chart.AutoScaleX != this->AutoScaleX) RenderValue(L"AutoScaleX", AutoScaleX, source);
	if (chart.AutoScaleY != this->AutoScaleY) RenderValue(L"AutoScaleY", AutoScaleY, source);
	this->RenderProperties(chart, source);
	const int graphCount = Graphs.storage.size();
	if (graphCount <= 0) return;
	int pointCount = 0;
	int i = 0, j = 0;
	for(i = 0; i < graphCount; i++)
	{
		pointCount = Graphs[i].point.size();
		//_______________________________________ Caption
		if (Graphs.storage[i].caption.length() > 0)
		{
			_snwprintf_s(text, 256, _TRUNCATE, L"Caption%d", i);
			RenderValue(text, Graphs.storage[i].caption, source);
		}

		//_______________________________________ Data
		_snwprintf_s(text, 256, _TRUNCATE, L"&Data%d=%ds%ds%ds%ds", i, (int)Graphs[i].type, (int)GetRValue(Graphs[i].color), 
			(int)GetGValue(Graphs[i].color), (int)GetBValue(Graphs[i].color));
		source += text;
		for(j = 0; j < pointCount; j++)
		{
			_snwprintf_s(text, 256, _TRUNCATE, L"%gs%gs", Graphs[i].point[j].x, Graphs[i].point[j].y);
			Sys::Convert::WstringToHex(text, encodedText);
			source += encodedText;
		}
	}
}

double XyChart::TransformFromScreenCoordinatesX(int x) 
{
	return (x - _originX)/_scaleX + _minX;
}

double XyChart::TransformFromScreenCoordinatesY(int y) 
{
	return (y - _originY)/_scaleY + _minY;
}

void XyChart::_AutoScaleX()
{
//	double minX=0.0, maxX=0.0;
//	const int graphCount = Graphs.Count;
//	if (graphCount == 0) return;
//	if (Graphs[0].GetPointCount()<=0) return;
//	int i, j, n;
//	
//	minX = maxX = Graphs[0][0].x;
//	for(i=0; i<graphCount; i++)
//	{
//		n = Graphs[i].GetPointCount();
//		for(j = 0; j<n; j++)
//		{
//			if (Graphs[i][j].x<minX) minX = Graphs[i][j].x;
//			if (Graphs[i][j].x>maxX) maxX = Graphs[i][j].x;
//		}
//	}
//	if (minX==maxX)
//	{
//		minX = minX- minX/2;
//		maxX = maxX + maxX/2;
//		if (minX==maxX)
//		{
//			minX = 0.0;
//			maxX = 10.0;
//		}
//	}
//	else
//	{
//		//double tmp = maxX-minX;
//		//minX = minX- tmp/20;
//		//maxX = maxX + tmp/20;
//	}
//	SetMinX(minX);
//	SetMaxX(maxX);
}

void XyChart::_AutoScaleY()
{
//	double minY=0.0, maxY=0.0;
//	const int graphCount = Graphs.Count;
//	if (graphCount== 0) return;
//	if (Graphs[0].GetPointCount()<=0) return;
//	int i, j, n;
//
//	minY = maxY = Graphs[0][0].y;
//	for(i=0; i<graphCount; i++)
//	{
//		n = Graphs[i].GetPointCount();
//		for(j = 0; j<n; j++)
//		{
//			if (Graphs[i][j].y<minY) minY = Graphs[i][j].y;
//			if (Graphs[i][j].y>maxY) maxY = Graphs[i][j].y;
//		}
//	}
//	//minY = maxY = graph[0].y;
//	//for(int i = 1; i<n; i++)
//	//{
//	//	if (graph[i].x<minX) minX = graph[i].x;
//	//	if (graph[i].y<minY) minY = graph[i].y;
//	//	//
//	//	if (graph[i].x>maxX) maxX = graph[i].x;
//	//	if (graph[i].y>maxY) maxY = graph[i].y;
//	//}
//	if (minY==maxY)
//	{
//		minY = minY- minY/2;
//		maxY = maxY + maxY/2;
//		if (minY==maxY)
//		{
//			minY = 0.0;
//			maxY = 10.0;
//		}
//	}
//	else
//	{
//		//double tmp = maxY-minY;
//		//minY = minY- tmp/20;
//		//maxY = maxY + tmp/20;
//	}
//	this->SetMinY(minY);
//	this->SetMaxY(maxY);
}

void XyChart::OnSizePrivate()
{
	if (LogScaleX == true)
	{
		if (MinX <= 0.0)
		{
			_minX = -1.0;
		}
		else
		{
			_minX = log10(MinX);
		}
		if (MaxX <= 0.0)
		{
			_maxX = 1.0;
		}
		else
		{
			_maxX = log10(MaxX);
		}
	}
	else
	{
		_minX = MinX;
		_maxX = MaxX;	
	}

	if (LogScaleY)
	{
		if (MinY <= 0.0)
		{
			_minY = -1.0;
		}
		else
		{
			_minY = log10(MinY);
		}
		if (MaxY <= 0.0)
		{
			_maxY = 1.0;
		}
		else
		{
			_maxY = log10(MaxY);
		}
	}
	else
	{
		_minY = MinY;
		_maxY = MaxY;
	}

//	if (_printerFormat || height>WINFONT_MAXRES || width>WINFONT_MAXRES)
//	{
//		_boxCaptionHeight = 0.05*this->height;
//	} 
//	else // Display
//	{
		_boxCaptionHeight = 1.5*abs(css.font_size); // Each row is 1.5*_fontHeight
//	}
//
	const double offsetLeft = _boxCaptionHeight + 7.0*_boxCaptionHeight/2.0;
	const double offsetRight = 7.0 * _boxCaptionHeight/4.0;
	const double offsetTop = _boxCaptionHeight;
	const double offsetBottom = 2.0 * _boxCaptionHeight;

	//if (_printerFormat == true)
	//{
	//	_originX = offsetLeft + printInfo.position.x;
	//	_originY = this->height-offsetBottom+printInfo.position.y;
	//}
	//else
	//{
		_originX = offsetLeft;
		_originY = abs(css.height) - offsetBottom;
	//}
	
	_scaleX = (abs(css.width)-offsetLeft-offsetRight)/(_maxX - _minX);
	_scaleY =  - (abs(css.height)-offsetBottom-offsetTop)/(_maxY - _minY);

	//___________________________________________________ Graph Box
	_rcMain.top = (int)TransformToScreenCoordinatesY(_maxY);
	_rcMain.left = (int)TransformToScreenCoordinatesX(_minX);
	_rcMain.bottom = (int)TransformToScreenCoordinatesY(_minY);
	_rcMain.right = (int)TransformToScreenCoordinatesX(_maxX);
}

void XyChart::PaintCaptionX(Gdiplus::Graphics& graphics, Gdiplus::Font& font, Gdiplus::Brush& brush)
{
	if (CaptionX.length() <= 0) return;
	const Gdiplus::REAL captionHeight = (abs(css.height) -_rcMain.bottom)/2.0f;
	Gdiplus::RectF rect;
	rect.X = (Gdiplus::REAL)_rcMain.left;
	rect.Y = (Gdiplus::REAL)(_rcMain.bottom+captionHeight);
	rect.Width = (Gdiplus::REAL)(_rcMain.right - _rcMain.left);
	rect.Height = captionHeight;
	//
	Gdiplus::StringFormat sf;
	sf.SetAlignment(Gdiplus::StringAlignmentCenter);
	sf.SetLineAlignment(Gdiplus::StringAlignmentCenter);

	graphics.DrawString(CaptionX.c_str(), -1, &font, rect, &sf, &brush);
}

void XyChart::PaintCaptionY(Gdiplus::Graphics& graphics, Gdiplus::Font& font, Gdiplus::Brush& brush)
{
	if (CaptionY.length() <= 0) return;
	//____________________________________________________ Compute Text Size
	Gdiplus::RectF origin;
	origin.X = 0.0f;
	origin.Y = 0.0f;
	origin.Width = 1000;
	origin.Height = 1000;
	//
	Gdiplus::RectF box;
	//
	Gdiplus::StringFormat sf;
	sf.SetAlignment(Gdiplus::StringAlignmentNear);
	sf.SetLineAlignment(Gdiplus::StringAlignmentNear);
	//
	graphics.MeasureString(CaptionY.c_str(), -1, &font, origin, &sf, &box);
	const Gdiplus::REAL x = abs(css.font_size)/5.0f;
	const Gdiplus::REAL y = ((_rcMain.bottom + _rcMain.top)/2.0f + box.Width/2.0f); //y

	Gdiplus::PointF point;
	point.X = 0.0f;
	point.Y = 0.0f;
	graphics.TranslateTransform(x, y);  
	graphics.RotateTransform(270);  
	graphics.DrawString(CaptionY.c_str(), -1, &font, point, &brush);  
	graphics.ResetTransform();  
}

void XyChart::PaintScaleX(Gdiplus::Graphics& graphics, Gdiplus::Font& font, Gdiplus::Brush& brush, double deltaX)
{
	const Gdiplus::REAL captionHeight = (Gdiplus::REAL)(  (abs(css.height) - _rcMain.bottom)/2.0  );
	double value;
	const double delta = (_maxX - _minX)/(DivisionCountX);

	for(int i = 0; i<DivisionCountX+1; i++)
	{
		value = (LogScaleX == true) ? pow(10.0, _minX + i * delta) : _minX + i * delta;
		this->OnPaintScaleX(graphics, font, brush, i, deltaX, value);
	}
}

void XyChart::PaintScaleY(Gdiplus::Graphics& graphics, Gdiplus::Font& font, Gdiplus::Brush& brush, double deltaY)
{
	const double delta = (_maxY - _minY)/ DivisionCountY;
	double value;

	for(int i = 0; i < DivisionCountY+1; i++)
	{
		value = (LogScaleY== true) ? pow(10.0, _minY + i * delta) : _minY + i * delta;
		this->OnPaintScaleY(graphics, font, brush, i, deltaY, value);
	}
}

void XyChart::OnPaintScaleX(Gdiplus::Graphics& graphics, Gdiplus::Font& font, Gdiplus::Brush& brush, int index, double delta, double value)
{
	Gdiplus::RectF rc;
	rc.X = (Gdiplus::REAL)(_originX + index * delta - delta/2.0);
	rc.Y = (Gdiplus::REAL)_rcMain.bottom;
	rc.Width = (Gdiplus::REAL)delta;
	rc.Height = (Gdiplus::REAL)(abs(css.height - _rcMain.bottom)/2.0f);
	wchar_t text[256];
	Sys::Convert::ToString(value, text, 256, true);
	Gdiplus::StringFormat sf;
	sf.SetAlignment(Gdiplus::StringAlignmentCenter);
	sf.SetLineAlignment(Gdiplus::StringAlignmentCenter);
	graphics.DrawString(text, -1, &font, rc, &sf, &brush); 
}

void XyChart::OnPaintScaleY(Gdiplus::Graphics& graphics, Gdiplus::Font& font, Gdiplus::Brush& brush, int index, double delta, double value)
{
	wchar_t text[256];
	Sys::Convert::ToString(value, text, 256, true);

	Gdiplus::RectF box;
	Gdiplus::PointF origin;
	origin.X = 0.0f;
	origin.Y = 0.0f;
	graphics.MeasureString(text, -1, &font, origin, &box); 

	origin.X = (Gdiplus::REAL)(_originX-box.Width - abs(css.font_size)/2.0);
	origin.Y = (Gdiplus::REAL)(_originY - index*delta - box.Height/2.0);
	graphics.DrawString(text, -1, &font, origin, &brush); 
}

void XyChart::PaintDivY(Gdiplus::Graphics& graphics, Gdiplus::Pen& pen)
{
	const double delta = (_maxY-_minY)/DivisionCountY;
	double deltaSub = 0.0;
	double y = 0;
	int j=0;
	int nY = 0;

	for(double d= _minY; d< _maxY; d+=delta)
	{
		y = TransformToScreenCoordinatesY(d);
		if (d != _minY) 
		{
			nY = (int)(y+0.5);
			graphics.DrawLine(&pen, (Gdiplus::REAL)_rcMain.left, (Gdiplus::REAL)nY, 
				(Gdiplus::REAL)_rcMain.right-1, (Gdiplus::REAL)nY); 
		}
	}
}

void XyChart::PaintDivX(Gdiplus::Graphics& graphics, Gdiplus::Pen& pen)
{
	const double delta = (_maxX - _minX)/ DivisionCountX;
	double deltaSub = 0.0;
	double x = 0;
	int j=0;
	int nX = 0;

	for(double d= _minX; d < _maxX; d += delta)
	{
		x = TransformToScreenCoordinatesX(d);
		if (d !=  _minX) 
		{
			nX = (int)(x+0.5);
			graphics.DrawLine(&pen, (Gdiplus::REAL)nX, (Gdiplus::REAL)_rcMain.top, 
				(Gdiplus::REAL)nX, (Gdiplus::REAL)_rcMain.bottom-1); 
		}
	}
}

void XyChart::PaintSubDivY(Gdiplus::Graphics& graphics, Gdiplus::Pen& pen)
{
	const double delta = (_maxY - _minY)/ DivisionCountY;
	double deltaSub = 0.0;
	double y = 0;
	int j=0;
	int nY = 0;

	for(double d= _minY; d < _maxY; d += delta)
	{
		y = TransformToScreenCoordinatesY(d);	
		if (LogScaleY) 
		{
			deltaSub = 9.0/SubDivisionCountY;
			for(j = 1; j<SubDivisionCountY; j++)
			{
				nY = (int)(y+ (delta * _scaleY)* log10(1.0+j*deltaSub) + 0.5);
				if (nY <= _rcMain.top) continue;
				if (nY >= _rcMain.bottom) continue; 
				graphics.DrawLine(&pen, (Gdiplus::REAL)_rcMain.left, (Gdiplus::REAL)nY, 
					(Gdiplus::REAL)_rcMain.right-1, (Gdiplus::REAL)nY); 
				//gdi.MoveToEx(_rcMain.left, nY); 
				//gdi.LineTo(_rcMain.right-1, nY);
			}	
		}
		else
		{
			deltaSub = _scaleY*delta/ SubDivisionCountY;
			for(j = 1; j < SubDivisionCountY; j++)
			{
				nY = (int)(y+ j*deltaSub+0.5);
				if (nY>_rcMain.top && nY<_rcMain.bottom)
				{
					graphics.DrawLine(&pen, (Gdiplus::REAL)_rcMain.left, (Gdiplus::REAL)nY, 
						(Gdiplus::REAL)_rcMain.right-1, (Gdiplus::REAL)nY); 
					//gdi.MoveToEx(_rcMain.left, nY); 
					//gdi.LineTo(_rcMain.right-1, nY);
				}
			}
		}
	}
}

void XyChart::PaintSubDivX(Gdiplus::Graphics& graphics, Gdiplus::Pen& pen)
{
	const double delta = (_maxX - _minX)/ DivisionCountX;
	double deltaSub = 0.0;
	double x = 0;
	int j=0;
	int nX = 0;

	for(double d = _minX; d < _maxX; d += delta)
	{
		x = TransformToScreenCoordinatesX(d);
		if (LogScaleX)
		{
			deltaSub = 9.0/SubDivisionCountX;
			for(j = 1; j<SubDivisionCountX; j++)
			{
				nX = (int)(x+ (delta*_scaleX)* log10(1.0+j*deltaSub) + 0.5);
				if (nX <= _rcMain.left) continue;
				if (nX >= _rcMain.right) continue; 
				graphics.DrawLine(&pen, (Gdiplus::REAL)nX, (Gdiplus::REAL)_rcMain.top, 
						(Gdiplus::REAL)nX, (Gdiplus::REAL)_rcMain.bottom-1); 
				//gdi.MoveToEx(nX, _rcMain.top); 
				//gdi.LineTo(nX, _rcMain.bottom-1);
			}	
		}
		else
		{
			deltaSub = _scaleX*delta/SubDivisionCountX;
			for(j = 1; j < SubDivisionCountX; j++)
			{
				nX = (int)(x+j*deltaSub+0.5);
				if (nX>_rcMain.left && nX<_rcMain.right)
				{
					graphics.DrawLine(&pen, (Gdiplus::REAL)nX, (Gdiplus::REAL)_rcMain.top, 
						(Gdiplus::REAL)nX, (Gdiplus::REAL)_rcMain.bottom-1); 
					//gdi.MoveToEx(nX, _rcMain.top); 
					//gdi.LineTo(nX, _rcMain.bottom-1);
				}
			}
		}
	}
}

void XyChart::PaintGraphs(Gdiplus::Graphics& graphics, Gdiplus::Font& font)
{
	const int graphCount = Graphs.storage.size();
	int i = 0;
//	//Win::Gdi::Color3D color3D(bPrintting? RGB(220, 220, 220) : RGB(128, 128, 128));
//	//Win::Gdi::Brush brocha(RGB(20, 20, 20));
	wchar_t *caption = NULL;
	Gdiplus::RectF rect;
	Gdiplus::PointF point;
	point.X = 0.0f;
	point.Y = 0.0f;
//	RECT rect;
//
//	rect.top = 0;
//	rect.left = 0;
//	rect.right = this->width;
//	rect.bottom = _rcMain.top;
//
	const Gdiplus::REAL space = (Gdiplus::REAL)(css.font_size);
	//________________________________________ Find graph caption width
	Gdiplus::REAL captionWidth = 0.0f;
	
	for(i = 0; i<graphCount; i++)
	{
		if (Graphs.storage[i].caption.length() == 0) continue;
		graphics.MeasureString(Graphs[i].caption.c_str(), -1, &font, point, &rect);
		captionWidth += (Gdiplus::REAL)(rect.Width + 2*space);
	}

	//_____________________________________________________Draw graph caption	
	Gdiplus::REAL xCaption = _rcMain.left +  space + (_rcMain.right - _rcMain.left - captionWidth)/2.2f;

	Gdiplus::StringFormat stringFormat;
	stringFormat.SetAlignment(Gdiplus::StringAlignmentNear);
	stringFormat.SetLineAlignment(Gdiplus::StringAlignmentFar);

	point.Y = (Gdiplus::REAL)_rcMain.top;
	for(i = 0; i<graphCount; i++)
	{
		if (Graphs.storage[i].caption.length() == 0) continue;
		graphics.MeasureString(Graphs[i].caption.c_str(), -1, &font, point, &rect);
		Gdiplus::SolidBrush brush(Gdiplus::Color(255, GetRValue(Graphs.storage[i].color), GetGValue(Graphs.storage[i].color), GetBValue(Graphs.storage[i].color)));
		//gdi.SetTextColor(Graphs[i].color);
		//	gdi.TextOut(xCaption, _rcMain.top, pszCaption);
		point.X = xCaption;
		graphics.DrawString(Graphs.storage[i].caption.c_str(), -1, &font, point, &stringFormat, &brush);
		xCaption += (rect.Width + 2.0f*space);
	}

	//__________________________________________________ Draw Graphs
	Gdiplus::RectF rcClipping;
	rcClipping.X = (Gdiplus::REAL)(_rcMain.left);
	rcClipping.Y = (Gdiplus::REAL)(_rcMain.top);
	rcClipping.Width = (Gdiplus::REAL)(_rcMain.right - _rcMain.left);
	rcClipping.Height = (Gdiplus::REAL)(_rcMain.bottom - _rcMain.top);

	graphics.SetClip(rcClipping, Gdiplus::CombineModeReplace);
	for(i = 0; i<graphCount; i++)
	{	
		this->DrawGraph(graphics, i);
	}
}



void XyChart::DrawGraph(Gdiplus::Graphics& graphics, int graphIndex)
{
	const int pointCount = Graphs.storage[graphIndex].point.size();
	if (pointCount == 0) return;
	Gdiplus::Pen pen(Gdiplus::Color(255, GetRValue(Graphs.storage[graphIndex].color), GetGValue(Graphs.storage[graphIndex].color), GetBValue(Graphs.storage[graphIndex].color)), 1.0f);
	//_____________________________________________________ Transform Graphs
	int i;

	Gdiplus::PointF *screenPoints = new Gdiplus::PointF[pointCount];
	if (screenPoints == NULL) return;

	double x, y;
	for(i = 0; i < pointCount; i++)
	{
		x = Graphs.storage[graphIndex].point[i].x;
		y = Graphs.storage[graphIndex].point[i].y;
		//________________________________________________ Transform X
		if (LogScaleX)
		{
			if (x>0)
				screenPoints[i].X = this->TransformToScreenCoordinatesX(log10(fabs(x)));
			else
				screenPoints[i].X = this->TransformToScreenCoordinatesX(_originX);
		}
		else
		{
			screenPoints[i].X = this->TransformToScreenCoordinatesX(x);
		}
		//________________________________________________ Transform Y
		if (LogScaleY)
		{
			if (y>0)
				screenPoints[i].Y= this->TransformToScreenCoordinatesY(log10(fabs(y)));
			else
				screenPoints[i].Y= this->TransformToScreenCoordinatesY(_originY);
		}
		else
		{
			screenPoints[i].Y= this->TransformToScreenCoordinatesY(y);
		}	
	}

	Gdiplus::REAL dimension = 0.015f*abs(css.height);

		switch(Graphs.storage[graphIndex].type)
	{
	case Web::Graph::TypeCircle:
			for(i = 0; i<pointCount; i++)
			{
				graphics.DrawEllipse(&pen, screenPoints[i].X-dimension, screenPoints[i].Y-dimension, dimension, dimension);
			}
		break;
	case Web::Graph::TypeCross:
		for(i = 0; i<pointCount; i++)
		{
			graphics.DrawLine(&pen, screenPoints[i].X, screenPoints[i].Y-dimension, screenPoints[i].X, screenPoints[i].Y + dimension);
			graphics.DrawLine(&pen, screenPoints[i].X-dimension, screenPoints[i].Y, screenPoints[i].X + dimension, screenPoints[i].Y);
		}
		break;
	case Web::Graph::TypeDot:
		for(i = 0; i<pointCount; i++)
		{
			graphics.DrawEllipse(&pen, screenPoints[i].X-dimension, screenPoints[i].Y-dimension, 0.3f*dimension, 0.3f*dimension);
		}
		break;
	case Web::Graph::TypeSquare:
		for(i = 0; i<pointCount; i++)
			{
				graphics.DrawRectangle(&pen, screenPoints[i].X-dimension, screenPoints[i].Y-dimension, dimension, dimension);
			}
		break;
	case Web::Graph::TypeLine:
		graphics.DrawLines(&pen, screenPoints, pointCount);
		break;
	case Web::Graph::TypeHistogram:
		{
			const Gdiplus::REAL yzero = _rcMain.bottom-1.0f;
			for(i = 0; i<pointCount; i++)
			{
				graphics.DrawLine(&pen, screenPoints[i].X, yzero, screenPoints[i].X, screenPoints[i].Y);
			}
		}
		break;
	}

//	Win::Graph& graph = Graphs[graphIndex];
//	int i = 0;
//	POINT * p = graph.GetScreenPoints();
//	const int pointCount = graph.GetPointCount();
//	if (pointCount==0) return;
//	int dimension = (int)(((int)(0.10*this->height/3.7+0.5))/4.0 + 0.5);
//	
//
//	switch(graph.GetType())
//	{
//	case Win::Graph::circle:
//			for(i = 0; i<pointCount; i++) gdi.Circle(p[i].x, p[i].y, dimension);
//		break;
//	case Win::Graph::cross:
//		for(i = 0; i<pointCount; i++)
//		{
//			gdi.MoveToEx(p[i].x, (int)(p[i].y-dimension));
//			gdi.LineTo(p[i].x, (int)(p[i].y+dimension+1));
//			gdi.MoveToEx((int)(p[i].x-dimension), p[i].y);
//			gdi.LineTo((int)(p[i].x+dimension+1), p[i].y);
//		}
//		break;
//	case Win::Graph::dot:
//		for(i = 0; i<pointCount; i++)
//		{
//			gdi.SetPixel(p[i].x, p[i].y, graph.color);
//		}
//		break;
//	case Win::Graph::square:
//		for(i = 0; i<pointCount; i++)
//		{
//			gdi.Rectangle(p[i].x-dimension, p[i].y-dimension,
//				p[i].x+dimension+1, p[i].y+dimension+1);
//		}
//		break;
//	case Win::Graph::line:
//		gdi.Polyline(graph.GetScreenPoints(), pointCount);
//		break;
//	case Win::Graph::histogram:
//		{
//			const int yzero = _rcMain.bottom-1;
//			for(i = 0; i<pointCount; i++)
//			{
//				gdi.Line(p[i].x, yzero, p[i].x, p[i].y);
//			}
//		}
//		break;
//	}
	if (screenPoints != NULL) delete [] screenPoints;
}

//________________________________________________________ Histogram
Histogram::Histogram()
{
	this->Graphs.Add();
	this->Graphs[0].type = Web::Graph::TypeHistogram;
}

Histogram::~Histogram()
{
}

void Histogram::SetData(valarray<double>& data, int resolution, bool percentDisplay)
{
	if (Graphs.Count != 1)
	{
		Graphs.DeleteAll();
		Graphs.Add();
	}
	int i;
	const int data_size = data.size();
	if (data_size <= 1) 
	{
		Graphs[0].point.clear();
		return;
	}
	if (resolution<=0)
	{
		Graphs[0].point.clear();
		return;
	}
	//_______________________________Find minimum and maximum
	double minimum = data[0];
	double maximum = data[0];
	for(i=0; i<data_size; i++)
	{
		if (data[i]<minimum) minimum = data[i];
		if (data[i]>maximum) maximum = data[i];
	}
	if (maximum==minimum)
	{
		Graphs[0].point.clear();
		return;
	}
	Graphs[0].point.resize(resolution);
	//_______________________________ compute x values and clean y
	const double deltaX = (maximum-minimum)/resolution;
	for(i=0; i<resolution; i++)
	{
		Graphs[0].point[i].x = minimum+i*deltaX+deltaX/2.0;
		Graphs[0].point[i].y = 0.0;
	}

	//______________________________ Find Histogram
	int index;
	for(i=0; i<data_size; i++)
	{
		index = (int)((data[i]-minimum)/deltaX);
		if (0<=index && index<resolution)
		{
			Graphs[0].point[index].y ++;
		}
	}
	if (percentDisplay)
	{
		for(i=0; i<resolution; i++)
		{
			Graphs[0].point[i].y = Graphs[0].point[i].y * 100.0 / data_size;
		}
		MinY = 0.0;
		MaxY = 100.0;
		AutoScaleY = false;
	}
	//this->RefreshAll();
}

#endif

//________________________________________________________ ProgressBar
ProgressBar::ProgressBar()
{
}

ProgressBar::~ProgressBar()
{
}

void ProgressBar::RenderImage(string& data)
{
	const unsigned char gifdata[] = {0x47, 0x49, 0x46, 0x38, 0x39, 0x61, 0x64, 0x00, 0x01, 0x00, 0x91, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x35, 0x35, 0x35, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21, 0xFF, 0x0B, 0x4E, 0x45, 0x54, 0x53, 0x43, 0x41, 0x50, 0x45, 0x32, 
	0x2E, 0x30, 0x03, 0x01, 0x00, 0x00, 0x00, 0x21, 0xF9, 0x04, 0x09, 0x14, 0x00, 0x01, 0x00, 0x2C, 0x00, 0x00, 
	0x00, 0x00, 0x64, 0x00, 0x01, 0x00, 0x00, 0x08, 0x12, 0x00, 0x03, 0x08, 0x1C, 0x48, 0xB0, 0xA0, 0xC1, 0x83, 
	0x08, 0x13, 0x2A, 0x5C, 0xC8, 0xB0, 0x61, 0xC2, 0x80, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 
	0x2C, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 
	0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 
	0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x02, 0x00, 0x00, 
	0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 
	0x00, 0x00, 0x00, 0x2C, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 
	0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x04, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 
	0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 
	0x05, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 
	0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x06, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 
	0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x07, 0x00, 0x00, 0x00, 
	0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 
	0x00, 0x00, 0x2C, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 
	0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x09, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 
	0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x0A, 
	0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 
	0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x0B, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 
	0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x0C, 0x00, 0x00, 0x00, 0x01, 
	0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 
	0x00, 0x2C, 0x0D, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 
	0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x0E, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 
	0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x0F, 0x00, 
	0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 
	0x14, 0x00, 0x00, 0x00, 0x2C, 0x10, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 
	0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x11, 0x00, 0x00, 0x00, 0x01, 0x00, 
	0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 
	0x2C, 0x12, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 
	0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x13, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 
	0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x14, 0x00, 0x00, 
	0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 
	0x00, 0x00, 0x00, 0x2C, 0x15, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 
	0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x16, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 
	0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 
	0x17, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 
	0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x18, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 
	0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x19, 0x00, 0x00, 0x00, 
	0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 
	0x00, 0x00, 0x2C, 0x1A, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 
	0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x1B, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 
	0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x1C, 
	0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 
	0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x1D, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 
	0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x1E, 0x00, 0x00, 0x00, 0x01, 
	0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 
	0x00, 0x2C, 0x1F, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 
	0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x20, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 
	0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x21, 0x00, 
	0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 
	0x14, 0x00, 0x00, 0x00, 0x2C, 0x22, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 
	0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x23, 0x00, 0x00, 0x00, 0x01, 0x00, 
	0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 
	0x2C, 0x24, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 
	0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x25, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 
	0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x26, 0x00, 0x00, 
	0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 
	0x00, 0x00, 0x00, 0x2C, 0x27, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 
	0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x28, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 
	0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 
	0x29, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 
	0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x2A, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 
	0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x2B, 0x00, 0x00, 0x00, 
	0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 
	0x00, 0x00, 0x2C, 0x2C, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 
	0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x2D, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 
	0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x2E, 
	0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 
	0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x2F, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 
	0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x30, 0x00, 0x00, 0x00, 0x01, 
	0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 
	0x00, 0x2C, 0x31, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 
	0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x32, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 
	0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x33, 0x00, 
	0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 
	0x14, 0x00, 0x00, 0x00, 0x2C, 0x34, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 
	0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x35, 0x00, 0x00, 0x00, 0x01, 0x00, 
	0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 
	0x2C, 0x36, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 
	0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x37, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 
	0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x38, 0x00, 0x00, 
	0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 
	0x00, 0x00, 0x00, 0x2C, 0x39, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 
	0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x3A, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 
	0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 
	0x3B, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 
	0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x3C, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 
	0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x3D, 0x00, 0x00, 0x00, 
	0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 
	0x00, 0x00, 0x2C, 0x3E, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 
	0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x3F, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 
	0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x40, 
	0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 
	0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x41, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 
	0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x42, 0x00, 0x00, 0x00, 0x01, 
	0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 
	0x00, 0x2C, 0x43, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 
	0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x44, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 
	0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x45, 0x00, 
	0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 
	0x14, 0x00, 0x00, 0x00, 0x2C, 0x46, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 
	0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x47, 0x00, 0x00, 0x00, 0x01, 0x00, 
	0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 
	0x2C, 0x48, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 
	0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x49, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 
	0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x4A, 0x00, 0x00, 
	0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 
	0x00, 0x00, 0x00, 0x2C, 0x4B, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 
	0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x4C, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 
	0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 
	0x4D, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 
	0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x4E, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 
	0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x4F, 0x00, 0x00, 0x00, 
	0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 
	0x00, 0x00, 0x2C, 0x50, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 
	0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x51, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 
	0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x52, 
	0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 
	0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x53, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 
	0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x54, 0x00, 0x00, 0x00, 0x01, 
	0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 
	0x00, 0x2C, 0x55, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 
	0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x56, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 
	0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x57, 0x00, 
	0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 
	0x14, 0x00, 0x00, 0x00, 0x2C, 0x58, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 
	0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x59, 0x00, 0x00, 0x00, 0x01, 0x00, 
	0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 
	0x2C, 0x5A, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 
	0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x5B, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 
	0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x5C, 0x00, 0x00, 
	0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 
	0x00, 0x00, 0x00, 0x2C, 0x5D, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 
	0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x5E, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 
	0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 
	0x5F, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 
	0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x60, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 
	0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x61, 0x00, 0x00, 0x00, 
	0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 
	0x00, 0x00, 0x2C, 0x62, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 
	0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x63, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 
	0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x3B};
	data.assign((char*)gifdata, 2584);
}

//________________________________________________________ Label
Label::Label()
{
	Type = HTML_TND_SPAN;
}

Label::~Label()
{
}

void Label::OnNavigateAway(Web::HttpConnector& httpConnector)
{
}

void Label::GetHtml(int& indentCount, Sys::ITextWriterW& out_html, Web::HttpConnector& httpConnector)
{
	if (Visible == false)
	{
		RenderHiddenValue(false, indentCount, Text.c_str(), out_html);
		return;
	}
	//_______________________________________ <tag>
	wchar_t* tag = RenderTagAndId(false, indentCount, out_html);
	if (tag != NULL)
	{
		RenderClassAndStyle(out_html);
		RenderJavascriptEvents(out_html, httpConnector.url.c_str());
		out_html.WriteText(L">");
	}
	//_______________________________________ Text
	if (Text.length() > 0) out_html.WriteText(Text);
	//_______________________________________ </tag>
	if (tag != NULL)
	{
		out_html.WriteText(L"</");
		out_html.WriteText(tag);
		out_html.WriteText(L">");
	}
	if (EndHtml.length() > 0) out_html.WriteText(EndHtml);
}

void Label::GetXml(Web::HttpConnector& httpConnector)
{
}

void Label::LoadState(Web::HttpConnector& httpConnector)
{
}

wchar_t* Label::GetTag()
{
	return Web::Helper::GetTag(Type);
}

//________________________________________________________ ParentNode
ParentNode::ParentNode()
{
	Type = HTML_PND_ONE_ROW_TABLE;
}

ParentNode::~ParentNode()
{
}

void ParentNode::OnNavigateAway(Web::HttpConnector& httpConnector)
{
	const list<Web::Object*>::iterator childEnd = child.end();
	list<Web::Object*>::iterator pChild = child.begin();

	for(; pChild != childEnd; pChild++)
	{
		(*pChild)->OnNavigateAway(httpConnector);
	}
}

void ParentNode::GetHtml(int& indentCount, Sys::ITextWriterW& out_html, Web::HttpConnector& httpConnector)
{
	if (Visible == false) return;
	GetPreHtml(indentCount, out_html);
	//_______________________________________ <tag>
	//wchar_t* tag = RenderTagAndId(false, indentCount, out_html);
	//if (tag != NULL)
	//{
	//	RenderClassAndStyle(out_html);
	//	out_html.WriteText(L">");
	//}
	//indentCount++;
	const list<Web::Object*>::iterator childEnd = child.end();
	const int count = child.size();
	int i = 0;
	list<Web::Object*>::iterator pChild = child.begin();
	switch(Type)
	{
	case HTML_PND_ONE_COLUMN_TABLE:
		for(; pChild != childEnd; pChild++)
		{
			Indent(indentCount, out_html);
			out_html.WriteText(L"<tr><td>");
			(*pChild)->GetHtml(indentCount, out_html, httpConnector);
			out_html.WriteText(L"</td></tr>");
		}
		break;
	case HTML_PND_ROW_CONTAINER_TABLE:
		for(; pChild != childEnd; pChild++)
		{
			Indent(indentCount, out_html);
			out_html.WriteText(L"<tr>");
			(*pChild)->GetHtml(indentCount, out_html, httpConnector);
			out_html.WriteText(L"</tr>");
		}
		break;
	case HTML_PND_UL:
	case HTML_PND_OL:
		for(; pChild != childEnd; pChild++)
		{
			Indent(indentCount, out_html);
			out_html.WriteText(L"<li>");
			(*pChild)->GetHtml(indentCount, out_html, httpConnector);
			out_html.WriteText(L"</li>");
		}
		break;
	case HTML_PND_DL:
		for(; pChild != childEnd; pChild++)
		{
			Indent(indentCount, out_html);
			out_html.WriteText(L"<dd>");
			(*pChild)->GetHtml(indentCount, out_html, httpConnector);
			out_html.WriteText(L"</dd>");
		}
		break;
	case HTML_PND_ONE_ROW_TABLE:
	case HTML_PND_ROW:
		for(; pChild != childEnd; pChild++)
		{
			Indent(indentCount, out_html);
			out_html.WriteText(L"<td>");
			(*pChild)->GetHtml(indentCount, out_html, httpConnector);
			out_html.WriteText(L"</td>");
		}
		break;
	case HTML_PND_HR:
		for(; pChild != childEnd; pChild++, i++)
		{
			if (i == count-2) break;
			Indent(indentCount, out_html);
			(*pChild)->GetHtml(indentCount, out_html, httpConnector);
			out_html.WriteText(L"<hr />");
		}
		break;
	case HTML_PND_BR:
		for(; pChild != childEnd; pChild++, i++)
		{
			if (i == count-2) break;
			Indent(indentCount, out_html);
			(*pChild)->GetHtml(indentCount, out_html, httpConnector);
			out_html.WriteText(L"<br />");
		}
		break;
	case HTML_PND_SPACE:
		for(; pChild != childEnd; pChild++, i++)
		{
			if (i == count-2) break;
			(*pChild)->GetHtml(indentCount, out_html, httpConnector);
			out_html.WriteText(L"&nbsp;");
		}
		break;
	case HTML_PND_COMMA:
		for(; pChild != childEnd; pChild++, i++)
		{
			if (i == count-2) break;
			(*pChild)->GetHtml(indentCount, out_html, httpConnector);
			out_html.WriteText(L",&nbsp");
		}
		break;
	case HTML_PND_SEMICOLON:
		for(; pChild != childEnd; pChild++, i++)
		{
			if (i == count-2) break;
			(*pChild)->GetHtml(indentCount, out_html, httpConnector);
			out_html.WriteText(L";&nbsp;");
		}
		break;
	case HTML_PND_PARENTHESIS:
		for(; pChild != childEnd; pChild++)
		{
			out_html.WriteText(L"(");
			(*pChild)->GetHtml(indentCount, out_html, httpConnector);
			out_html.WriteText(L")");
		}
		break;
	case HTML_PND_BRACKETS:
		for(; pChild != childEnd; pChild++)
		{
			out_html.WriteText(L"[");
			(*pChild)->GetHtml(indentCount, out_html, httpConnector);
			out_html.WriteText(L"]");
		}
		break;
	case HTML_PND_NONE:
		for(; pChild != childEnd; pChild++)
		{
			(*pChild)->GetHtml(indentCount, out_html, httpConnector);
		}
		break;
	}
	GetPostHtml(indentCount, out_html);
	//_______________________________________ </tag>
	//indentCount--;
	//Indent(indentCount, NULL, out_html);
	//if (tag != NULL)
	//{
	//	out_html.WriteText(L"</");
	//	out_html.WriteText(tag);
	//	out_html.WriteText(L">");
	//}
	//if (EndHtml.length() > 0) out_html.WriteText(EndHtml);
}

void ParentNode::GetPreHtml(int& indentCount, Sys::ITextWriterW& out_html)
{
	if (Visible == false) return;
	//_______________________________________ <tag>
	wchar_t* tag = RenderTagAndId(false, indentCount, out_html);
	if (tag != NULL)
	{
		RenderClassAndStyle(out_html);
		//RenderJavascriptEvents(out_html);
		out_html.WriteText(L">");
	}
	indentCount++;
	switch(Type)
	{
	case HTML_PND_ONE_ROW_TABLE:
		Indent(indentCount, out_html);
		out_html.WriteText(L"<tr>");
		break;
	//case HTML_PND_ONE_COLUMN_TABLE:
	//	//Indent(indentCount, out_html);
	//	out_html.WriteText(L"<tr><td>");
	//	break;
	//case HTML_PND_ROW_CONTAINER_TABLE:
	//	//Indent(indentCount, out_html);
	//	out_html.WriteText(L"<tr>");
	//	break;
	}
}

void ParentNode::GetPostHtml(int& indentCount, Sys::ITextWriterW& out_html)
{
	switch(Type)
	{
	case HTML_PND_ONE_ROW_TABLE:
		//Indent(indentCount, out_html);
		out_html.WriteText(L"</tr>");
		break;
	//case HTML_PND_ONE_COLUMN_TABLE:
	//	//Indent(indentCount, out_html);
	//	out_html.WriteText(L"<tr><td>");
	//	break;
	//case HTML_PND_ROW_CONTAINER_TABLE:
	//	//Indent(indentCount, out_html);
	//	out_html.WriteText(L"<tr>");
	//	break;
	}
	//_______________________________________ </tag>
	indentCount--;
	Indent(indentCount, out_html);
	wchar_t * tag = GetTag();
	if (tag != NULL)
	{
		out_html.WriteText(L"</");
		out_html.WriteText(tag);
		out_html.WriteText(L">");
	}
	if (EndHtml.length() > 0) out_html.WriteText(EndHtml);
}

void ParentNode::GetPreChildHtml(int childIndex, int childCount, int& indentCount, Sys::ITextWriterW& out_html)
{
	switch(Type)
	{
	case HTML_PND_ONE_ROW_TABLE:
		Indent(indentCount, out_html);
		out_html.WriteText(L"<td>");
		break;
	case HTML_PND_ONE_COLUMN_TABLE:
		Indent(indentCount, out_html);
		out_html.WriteText(L"<tr><td>");
		break;
	case HTML_PND_ROW_CONTAINER_TABLE:
		Indent(indentCount, out_html);
		out_html.WriteText(L"<tr>");
		break;
	case HTML_PND_UL:
	case HTML_PND_OL:
		Indent(indentCount, out_html);
		out_html.WriteText(L"<li>");
		break;
	case HTML_PND_DL:
		Indent(indentCount, out_html);
		out_html.WriteText(L"<dd>");
		break;
	case HTML_PND_ROW:
		Indent(indentCount, out_html);
		out_html.WriteText(L"<td>");
		break;
	//case HTML_PND_HR:
	//	if (childIndex == childCount-1) return;
	//	Indent(indentCount, out_html);
	//	break;
	//case HTML_PND_BR:
	//	if (childIndex == childCount-1) return;
	//	Indent(indentCount, out_html);
	//	break;
	//case HTML_PND_SPACE:
	//	if (childIndex == childCount-2) return;
	//	break;
	//case HTML_PND_COMMA:
	//	if (childIndex == childCount-2) return;
	//	break;
	//case HTML_PND_SEMICOLON:
	//	if (childIndex == childCount-2) return;
	//	break;
	case HTML_PND_PARENTHESIS:
		out_html.WriteText(L"(");
		break;
	case HTML_PND_BRACKETS:
		out_html.WriteText(L"[");
		break;
	//case HTML_PND_NONE:
	//	break;
	}
}

void ParentNode::GetPostChildHtml(int childIndex, int childCount, int& indentCount, Sys::ITextWriterW& out_html)
{
	switch(Type)
	{
	case HTML_PND_ONE_ROW_TABLE:
		out_html.WriteText(L"</td>");
		break;
	case HTML_PND_ONE_COLUMN_TABLE:
		out_html.WriteText(L"</td></tr>");
		break;
	case HTML_PND_ROW_CONTAINER_TABLE:
		out_html.WriteText(L"</tr>");
		break;
	case HTML_PND_UL:
	case HTML_PND_OL:
		out_html.WriteText(L"</li>");
		break;
	case HTML_PND_DL:
		out_html.WriteText(L"</dd>");
		break;
	case HTML_PND_ROW:
		//if (childIndex == childCount-1) return;
		out_html.WriteText(L"</td>");
		break;
	case HTML_PND_HR:
		if (childIndex == childCount-1) return;
		out_html.WriteText(L"<hr />");
		break;
	case HTML_PND_BR:
		if (childIndex == childCount-1) return;
		out_html.WriteText(L"<br />");
		break;
	case HTML_PND_SPACE:
		if (childIndex == childCount-1) return;
		out_html.WriteText(L"&nbsp;");
		break;
	case HTML_PND_COMMA:
		if (childIndex == childCount-1) return;
		out_html.WriteText(L",&nbsp");
		break;
	case HTML_PND_SEMICOLON:
		if (childIndex == childCount-1) return;
		out_html.WriteText(L";&nbsp;");
		break;
	case HTML_PND_PARENTHESIS:
		out_html.WriteText(L")");
		break;
	case HTML_PND_BRACKETS:
		out_html.WriteText(L"]");
		break;
	//case HTML_PND_NONE:
	//	for(; pChild != childEnd; pChild++)
	//	{
	//		(*pChild)->GetHtml(indentCount, out_html);
	//	}
	//	break;
	}
}

void ParentNode::GetXml(Web::HttpConnector& httpConnector)
{
}

void ParentNode::LoadState(Web::HttpConnector& httpConnector)
{
}

wchar_t* ParentNode::GetTag()
{
	return Web::Helper::GetTag(Type);
}

void ParentNode::AddChild(Web::Object& object)
{
	child.push_back(&object);
}

//________________________________________________________ MessageBoxInfo

//________________________________________________________ Page
Page::Page(void)
{
	memoryBlock = 0;
	isPreview = false;
}

Page::~Page(void)
{
}

void Page::OnNavigateAway(Web::HttpConnector& httpConnector)
{
	httpConnector.value.clear();
	list<Web::Object*>::iterator p;
	const list<Web::Object*>::iterator pEnd = child.end();
	for(p = child.begin(); p != pEnd; p++)
	{
		if ((*p) == NULL) continue;
		(*p)->OnNavigateAway(httpConnector);
	}
	if (wcslen(httpConnector.GetWindowID()) > 0)
	{
		httpConnector.AddVariable(L"windowID", httpConnector.GetWindowID());
	}
}

void Page::MessageBox(const wchar_t * text, const wchar_t * caption, UINT iconType)
{
	Web::MessageBoxInfo mbi;
	mbi.text = text;
	mbi.caption = caption;
	mbi.iconType = iconType & 0x000000F0L; // Use only seventh byte
	_msgbox.push_back(mbi);
}

void Page::MessageBox(const wstring& text, const wstring& caption, UINT iconType)
{
	Web::MessageBoxInfo mbi;
	mbi.text = text;
	mbi.caption = caption;
	mbi.iconType = iconType & 0x000000F0L; // Use only seventh byte
	_msgbox.push_back(mbi);
}

void Page::Run(Web::HttpConnector& h)
{
	h.SetRequestEvent();
	//_____________________________________________ Get script_name
	h.GetServerVariable("SCRIPT_NAME", script_name);
	//_____________________________________________ Check if server support GZIP Encoding
	GZipEncoding = false;
	char buffer[64];
	if (h.GetServerVariable("HTTP_ACCEPT_ENCODING", buffer, 64))
	{
		if (strstr(buffer, "GZIP") != NULL) GZipEncoding = true;
	}
	InitializeGui();
	//
	LoadState(h);
	Window_Open(h);
	if (h.httpCode != 200) return;
	if (h.HasRequestBeenHandled() == false)
	{
		OnNavigateAway(h);
		return;
	}
	//
	EventHandler(h);
	if (h.httpCode != 200) return;
	if (h.HasRequestBeenHandled() == false)
	{
		OnNavigateAway(h);
		return;
	}
	//
	if (h.ContentType == HTML_CONTENT_TYPE_TEXT_XML)
	{
		GetXml(h);
	}
	else
	{
		const bool indent = h.IsIndent();
		GetHtml(indent, h, h);
	}
}

void Page::EventHandler(Web::HttpConnector& h)
{
}

void Page::InitializeGui()
{
}

void Page::Window_Open(Web::HttpConnector& h)
{
}

void Page::HeadItem(int indentCount, wstring& variable, const wchar_t* tagini, const wchar_t* tagend, Sys::ITextWriterW& out_html)
{
	if (variable.length() == 0) return;
	Web::Object::Indent(indentCount, out_html);
	out_html.WriteText(tagini);
	out_html.WriteText(variable);
	out_html.WriteText(tagend);
}

//__________________________________ IObject
void Page::GetHtml(bool indent, Sys::ITextWriterW& out_html, Web::HttpConnector& httpConnector)
{
	int indentCount = (indent == true) ? 1 : -1;
	GetPreHtml(indentCount, out_html);
	//_________________________________________________________ RENDER CHILDREN
	list<Web::Object*>::iterator p;
	const list<Web::Object*>::iterator pEnd = child.end();
	for(p = child.begin(); p != pEnd; p++)
	{
		if ((*p) == NULL) continue;
		(*p)->GetHtml(indentCount, out_html, httpConnector);
	}
	GetPostHtml(indentCount, out_html, httpConnector);
}

void Page::RenderMessages(int& indentCount, Sys::ITextWriterW& out_html)
{
	vector<MessageBoxInfo>::iterator msg;
	const vector<MessageBoxInfo>::iterator msgEnd = _msgbox.end();
	for(msg = _msgbox.begin(); msg != msgEnd; msg++)
	{
		Web::Object::Indent(indentCount, out_html);
		out_html.WriteText(L"<table style=\"width:100%;background:#A0A0A0\"><tr style=\"background:#ECECEC;\"><td style=\"font-family:Arial;font-size:32px;background:#");
		if (msg->iconType == MB_ICONWARNING)
		{
			out_html.WriteText(L"FFFF20");
		}
		else if (msg->iconType == MB_ICONERROR)
		{
			out_html.WriteText(L"FF2020");
		}
		else if (msg->iconType == MB_ICONINFORMATION)
		{
			out_html.WriteText(L"3090FF");
		}
		out_html.WriteText(L";text-align:center;color:#000000;font-weight:900\">!</td><td style=\"padding:5px;\"><span style=\"font-family:Arial;font-size:16px;\">");
		out_html.WriteText(msg->caption);
		out_html.WriteText(L"</span><br/><span style=\"font-family:Arial;font-size:12px;\">");
		out_html.WriteText(msg->text);
		out_html.WriteText(L"</span></td></tr></table><br />");
	}
}

void Page::GetPreHtml(int& indentCount, Sys::ITextWriterW& out_html)
{
	if (isPreview == false)
	{
		out_html.WriteText(L"<!DOCTYPE html>\r\n<html>");
		if (GZipEncoding == true) out_html.WriteText(L"\r\n<!-- GZIP ENCODING -->");
	}
	else
	{
		out_html.WriteText(L"<html>");
	}
	//___________________________________________________________ Head
	Web::Object::Indent(indentCount, out_html);
	out_html.WriteText(L"<head>");
	indentCount++;
	//
	Web::Object::Indent(indentCount, out_html);
	out_html.WriteText(L"<meta charset=\"UTF-8\" />");
	//
	if (isPreview == false)
	{
		Web::Object::Indent(indentCount, out_html);
		out_html.WriteText(L"<meta http-equiv=\"content-type\" content=\"text/html;charset=UTF-8\" />");
	}
	//
	HeadItem(indentCount, Title, L"<title>", L"</title>", out_html);	
	HeadItem(indentCount, CssFile, L"<link rel=\"stylesheet\" type=\"text/css\" href=\"", L"\" />", out_html);	
	if (isPreview == false)
	{
		wstring commonJs(L"Wintempla.js");
		HeadItem(indentCount, commonJs, L"<script language=\"javascript\" type=\"text/javascript\" src=\"", L"\" ></script>", out_html);
		HeadItem(indentCount, JavascriptFile, L"<script language=\"javascript\" type=\"text/javascript\" src=\"", L"\" ></script>", out_html);	
		//
		//HeadItem(indentCount, commonJs, L"<script language=\"javascript\" type=\"text/javascript\" src=\"", L"\" charset=\"UTF-8\"></script>", out_html);
		//HeadItem(indentCount, JavascriptFile, L"<script language=\"javascript\" type=\"text/javascript\" src=\"", L"\" charset=\"UTF-8\"></script>", out_html);	
	}
	HeadItem(indentCount, Author, L"<meta name=\"author\" content=\"", L"\" />", out_html);	
	HeadItem(indentCount, Description, L"<meta name=\"description\" content=\"", L"\" />", out_html);	
	HeadItem(indentCount, Refresh, L"<meta http-equiv=\"refresh\" content=\"", L"\" />", out_html);	
	//
	if (Keywords.length() > 0)
	{
		Web::Object::Indent(indentCount, out_html);
		out_html.WriteText(L"<meta name=\"robots\" content=\"all, index, follow\" />");
		HeadItem(indentCount, Keywords, L"<meta name=\"keywords\" content=\"", L"\" />", out_html);	
	}
	//
	indentCount--;
	Web::Object::Indent(indentCount, out_html);
	out_html.WriteText(L"</head>");
	//
	//	o<<"\n   <meta HTTP-EQUIV=\"Refresh\" CONTENT='"
	//			<<cSeconds<<" URL=\"http://"
	//			<<ReadEnvironment("SERVER_NAME");
	//	o.flush();
	//			
	//__________________________________________________________ BODY
	Web::Object::Indent(indentCount, out_html);
	out_html.WriteText(L"<body>");
	indentCount++;
	//__________________________________________________________ MessageBox
	RenderMessages(indentCount, out_html);
	//__________________________________________________________ form
	if (script_name.length() > 0)
	{
		Web::Object::Indent(indentCount, out_html);
		out_html.WriteText(L"<form id=\"formMain\" method=\"get\" action=\"");
		//out_html.WriteText(L"<form id=\"formMain\" method=\"post\" action=\"");
		out_html.WriteText(script_name);
		out_html.WriteText(L"\" >");
		indentCount++;
	}
}

void Page::GetPostHtml(int& indentCount, Sys::ITextWriterW& out_html, Web::HttpConnector& httpConnector)
{
	if (script_name.length() > 0)
	{
		//_________________________________________________________  hidden for Buttons
		Web::Object::Indent(indentCount, out_html);
		out_html.WriteText(L"<input id=\"serverClick\" type=\"hidden\" name=\"onclickSrc\" value=\"0\" />");
		//_________________________________________________________  WindowID
		if (ID.length() > 0)
		{
			Web::Object::Indent(indentCount, out_html);
			out_html.WriteText(L"<input id=\"windowInfo\" type=\"hidden\" name=\"windowID\" value=\"");
			out_html.WriteText(ID);
			out_html.WriteText(L"\" />");
		}
		//
		indentCount--;
		Web::Object::Indent(indentCount, out_html);
		out_html.WriteText(L"</form>");
	}
	//_______________________________________________________ ProgressBar
	if (isPreview == false)
	{
		Web::Object::Indent(indentCount, out_html);
		out_html.WriteText(L"<img id=\"WebProgressBar\" src=\"http://");
		out_html.WriteText(httpConnector.url);
		out_html.WriteText(L"?windowID=ProgressBar\" style=\"width:300px;height:3px;border-width:1px;border-style:solid;border-color:#909090;background-color:#205020;visibility:hidden\">");
	}
	//_______________________________________________________ body End
	indentCount--;
	Web::Object::Indent(indentCount, out_html);
	out_html.WriteText(L"</body>");
	//_______________________________________________________ html End
	out_html.WriteText(L"\r\n</html>");
}

void Page::AddChild(Web::Object& object)
{
	child.push_back(&object);
}

void Page::RenderXmlMessages(Web::HttpConnector& httpConnector)
{
	const int count = _msgbox.size();
	if (count == 0) return;
	vector<MessageBoxInfo>::iterator msg;
	const vector<MessageBoxInfo>::iterator msgEnd = _msgbox.end();
	wstring text;
	wstring xmlValue;
	for(msg = _msgbox.begin(); msg != msgEnd; msg++)
	{
		httpConnector.WriteText(L"<control><id>");
		httpConnector.WriteText(ID);
		httpConnector.WriteText(L"</id><type>MessageBox</type><value>");
		text = msg->caption;
		text += L": ";
		text += msg->text;
		Sys::Convert::ToXml(text.c_str(), xmlValue);
		httpConnector.WriteText(xmlValue);
		httpConnector.WriteText(L"</value></control>");
	}
}

void Page::GetXml(Web::HttpConnector& httpConnector)
{
	httpConnector.WriteText(L"<?xml version=\"1.0\" encoding=\"UTF-8\"?><controls>");

	RenderXmlMessages(httpConnector);
	//
	list<Web::Object*>::iterator p;
	const list<Web::Object*>::iterator pEnd = child.end();
	for(p = child.begin(); p != pEnd; p++)
	{
		if ((*p) == NULL) continue;
		(*p)->GetXml(httpConnector);
	}
	httpConnector.WriteText(L"</controls>");
}

void Page::LoadState(Web::HttpConnector& httpConnector)
{
	list<Web::Object*>::iterator p;
	const list<Web::Object*>::iterator pEnd = child.end();
	for(p = child.begin(); p != pEnd; p++)
	{
		if ((*p) == NULL) continue;
		(*p)->LoadState(httpConnector);
	}
}

void Page::SetOnSubmit(bool fireEvent)
{
	// 1000 0000 0000 0000 0000 0000 0000 0000
	if (fireEvent == true)
	{
		memoryBlock |= 0x80000000;
	}
	else
	{
		memoryBlock &= 0x7FFFFFFF;
	}
}

bool Page::GetOnSubmit()
{
	// 1000 0000 0000 0000 0000 0000 0000 0000
	return ((memoryBlock & 0x80000000) != 0);
}

void Page::SetOnReset(bool fireEvent)
{
	// 0100 0000 0000 0000 0000 0000 0000 0000
	if (fireEvent == true)
	{
		memoryBlock |= 0x40000000;
	}
	else
	{
		memoryBlock &= 0xBFFFFFFF;
	}
}

bool Page::GetOnReset()
{
	// 0100 0000 0000 0000 0000 0000 0000 0000
	return ((memoryBlock & 0x40000000) != 0);
}

void Page::SetOnLoad(bool fireEvent)
{
	// 0010 0000 0000 0000 0000 0000 0000 0000
	if (fireEvent == true)
	{
		memoryBlock |= 0x20000000;
	}
	else
	{
		memoryBlock &= 0xDFFFFFFF;
	}
}

bool Page::GetOnLoad()
{
	// 0010 0000 0000 0000 0000 0000 0000 0000
	return ((memoryBlock & 0x20000000) != 0);
}
void Page::SetOnUnload(bool fireEvent)
{
	// 0001 0000 0000 0000 0000 0000 0000 0000
	if (fireEvent == true)
	{
		memoryBlock |= 0x10000000;
	}
	else
	{
		memoryBlock &= 0xEFFFFFFF;
	}
}

bool Page::GetOnUnload()
{
	// 0001 0000 0000 0000 0000 0000 0000 0000
	return ((memoryBlock & 0x10000000) != 0);
}

void Page::SetGZipEncoding(bool gzipEncoding)
{
	// 0000 1000 0000 0000 0000 0000 0000 0000
	if (gzipEncoding == true)
	{
		memoryBlock |= 0x08000000;
	}
	else
	{
		memoryBlock &= 0xF7FFFFFF;
	}
}

bool Page::GetGZipEncoding()
{
	// 0000 1000 0000 0000 0000 0000 0000 0000
	return ((memoryBlock & 0x08000000) != 0);
}

}  //____________________________________________________ namespace Web::End


////________________________________________________________ SimpleBarChart
//SimpleBarChart::SimpleBarChart(void)
//{
//	m_pBar = NULL;
//	this->CustomData+=L"valign=\"bottom\"");
//	m_min = 0.0;
//	m_max = 0.0;
//	m_bFirst = true;
//	m_scale = 0.0;
//	m_tableEx.Create(2, 1);
//	m_tableEx.css.width.Set(L"100%"));
//	m_tableEx.css.height.Set(L"100%"));
//	m_tableEx.CustomData+=L"cellpadding=\"0\" cellspacing=\"0\"");
//	m_tableEx.css.border.Set(L"1px solid #d0d0d5"));
//	//
//	m_span.css.border.Set(L"1px solid #707070"));
//	m_span.css.fontSize = 1;
//	m_span.css.width.Set(L"100%"));
//	m_span.css.height.Set(L"100%"));
//	m_span.SetInnerText(L"&nbsp;"), false);
//	//
//	m_tableEx.GetTd(0, 0).css.background.Set(L"e0e0e0"));
//	//
//	//*************************************************** Layout
//	this->AddChild(this->m_td);
//	this->m_td.AddChild(this->m_tableEx);
//	this->m_tableEx.GetTd(1, 0).AddChild(m_span);
//}
//
//bool SimpleBarChart::Create(int nCount)
//{
//	Destructor();
//	if (nCount<=0) return false;
//	m_pBar = new Web::SimpleBarChart::Bar[nCount];
//	ZeroMemory(m_pBar, nCount*sizeof(Web::SimpleBarChart::Bar));
//	if  (m_pBar==NULL) return false;
//	this->RepeatCount = nCount;
//	return true;
//}
//
//bool SimpleBarChart::SetValue(int index, double value, const wchar_t* pszColor)
//{
//	if (0<=index && index<this->RepeatCount)
//	{
//		m_pBar[index].value = value;
//		lstrcpyn(m_pBar[index].color, pszColor, 7);
//		if (m_bFirst)
//		{
//			m_bFirst = false;
//			m_min = value;
//			m_max = value;
//		}
//		else
//		{
//			if (value<m_min) m_min = value;
//			if (value>m_max) m_max = value;
//		}
//		return true;
//	}
//	return false;
//}
//
//void SimpleBarChart::SetMinMax(double MINIMUM, double MAXIMUM)
//{
//	m_min = MINIMUM;
//	m_max = MAXIMUM;
//}
//
//SimpleBarChart::~SimpleBarChart(void)
//{
//	Destructor();
//}
//
//void SimpleBarChart::Destructor()
//{
//	if (m_pBar)
//	{
//		delete [] m_pBar;
//		m_pBar = NULL;
//	}
//	this->RepeatCount= 0;
//	m_min = 0.0;
//	m_max = 0.0;
//	m_bFirst = true;
//	m_scale = 0.0;
//}
//
//void SimpleBarChart::OnIniRender()
//{
//	Web::Node::OnIniRender();
//}
//
//void SimpleBarChart::OnEndRender()
//{
//	Web::Node::OnEndRender();
//}
//
//double SimpleBarChart::GetMin()
//{
//	return m_min;
//}
//
//double SimpleBarChart::GetMax()
//{
//	return m_max;
//}
//
//void SimpleBarChart::OnPreRender(int nIndex)
//{
//	int i = 0;
//	int height = 0;
//	std::vector<Data::StrArray>::iterator p = NULL;
//	int nBarHeight = 0;
//	wchar_t sz[64];
//	
//	if (nIndex ==0) //************************************************** Find scale
//	{
//		if (m_max>m_min) 
//			m_scale = 100.0 / (m_max-m_min);
//		else
//			m_scale = 1;
//	}
//	//************************************************************* Render the bar
//	nBarHeight = (int)((m_pBar[nIndex].value-m_min)*m_scale+0.5);
//	if (nBarHeight<0) nBarHeight = 0;
//	if (nBarHeight>100) nBarHeight = 100;
//	m_tableEx.GetTd(1, 0).css.background.Set(m_pBar[nIndex].color);
//	_sntprintf(sz, 64, L"%d%%"), 100-nBarHeight);
//	m_tableEx.GetTd(0, 0).css.height.Set(sz);
//	_sntprintf(sz, 64, L"%d%%"), nBarHeight);
//	m_tableEx.GetTd(1, 0).css.height.Set(sz);
//}
//
//}
////________________________________________________________ BarChart
//BarChart::BarChart(void)
//{
//	Web::TableEx::Create(2, 3);
//	//
//	this->GetTd(0, 0).AddChild(tableCaptionY);
//	this->GetTd(0, 1).AddChild(m_tableMark);
//	this->GetTd(0, 2).AddChild(tableChart);
//	this->GetTd(1, 2).AddChild(tableCaptionX);
//	tableChart.AddChild(m_sbc);
//
//	this->GetTd(0, 2).css.width.Set(L"100%"));
//	this->GetTd(1, 2).css.width.Set(L"100%"));
//	tableCaptionX.css.width.Set(L"100%"));
//	tableCaptionX.css.textAlign.Set(L"center"));
//	tableCaptionX.css.fontSize=10;
//	tableChart.css.border.Set(L"1px solid #a0a0a0"));
//	this->css.background.Set(L"ffffff"));
//	this->css.border.Set(L"2px outset #c0c0c0"));
//	formatCaptionY.Set(L"%.1f"));
//	tableCaptionY.css.height.Set(L"100%"));
//	this->GetTd(0, 0).css.height.Set(L"100%"));
//	this->GetTd(0, 1).css.height.Set(L"100%"));
//	tableCaptionY.css.fontSize=10;
//	tableCaptionY.css.width.Set(L"50%"));
//	//
//	tableCaptionX.CustomData+=L"cellpadding=\"0\" cellspacing=\"0\"");
//	this->CustomData+=L"cellpadding=\"0\" cellspacing=\"0\"");
//	tableCaptionY.CustomData+=L"cellpadding=\"0\" cellspacing=\"0\"");
//	tableChart.CustomData+=L"cellpadding=\"0\" cellspacing=\"0\"");
//	this->GetTd(0, 2).css.paddingRight = 10;
//	this->GetTd(0, 2).css.paddingTop = 10;
//	this->GetTd(0, 1).css.paddingTop = 10;
//	this->GetTd(0, 0).css.paddingTop = 4;
//	this->GetTd(0, 0).css.paddingBottom = 6;
//	this->GetTd(1, 2).css.paddingRight = 10;
//	//
//	m_tableMark.css.width.Set(L"50%"));
//	m_tableMark.css.height.Set(L"100%"));
//	m_tableMark.CustomData+=L"cellpadding=\"0\" cellspacing=\"0\"");
//	m_tableMark.css.fontSize=10;
//}
//
//void BarChart::OnIniRender()
//{
//	Web::Node::OnIniRender();
//
//	//********************************* Calculate Caption Y
//	wchar_t sz[256];
//	double deltaY = (m_sbc.GetMax()-m_sbc.GetMin())/WEB_BARCHART_CAPTIONYCOUNT;
//	double y = 0;
//	if (deltaY<0) deltaY=1;
//
//	for(int i = 0; i<WEB_BARCHART_CAPTIONYCOUNT; i++)
//	{
//		y = m_sbc.GetMin()+(WEB_BARCHART_CAPTIONYCOUNT-i)*deltaY;
//		_sntprintf(sz, 256, formatCaptionY.Get(), y);
//		if (tableCaptionY.GetRowCount()>0) tableCaptionY.GetTd(i, 0).SetInnerText(sz, true);
//	}
//}
//
//bool BarChart::Create(int nCount)
//{
//	if (m_sbc.Create(nCount)==false) return false;
//	if (tableCaptionX.Create(1, nCount)==false) return false;
//	if (tableCaptionY.Create(WEB_BARCHART_CAPTIONYCOUNT, 1)==false) return false;
//	if (m_tableMark.Create(WEB_BARCHART_CAPTIONYCOUNT, 1)==false) return false;
//	wchar_t sz[256];
//	int nWidth = (int)(100.0/nCount+0.5);
//	_sntprintf(sz, 256, L"%d%%"), nWidth);
//	for(int i = 0; i<WEB_BARCHART_CAPTIONYCOUNT; i++)
//	{
//		tableCaptionY.GetTd(i, 0).css.textAlign.Set(L"center"));
//		tableCaptionY.GetTd(i, 0).css.paddingLeft = 10;
//		tableCaptionY.GetTd(i, 0).css.paddingRight = 2;
//		tableCaptionY.GetTd(i, 0).css.verticalAlign.Set(L"top"));
//		m_tableMark.GetTd(i, 0).css.borderTop.Set(L"1px solid #000000"));
//		m_tableMark.GetTd(i, 0).SetInnerText(L"&nbsp;"), false);
//	}
//	for(int i = 0; i<nCount; i++)
//	{
//		tableCaptionX.GetTd(0, i).css.width.Set(sz);
//		tableCaptionX.GetTd(0, i).css.padding = 5;
//	}
//	return true;
//}
//
//bool BarChart::SetValue(int index, double value, const wchar_t* pszColor, const wchar_t* pszCaptionX)
//{
//	if (m_sbc.SetValue(index, value, pszColor))
//	{
//		tableCaptionX.GetTd(0, index).SetInnerText(pszCaptionX, true);
//		return true;
//	}
//	return false;
//}
//
//void BarChart::SetMinMax(double MINIMUM, double MAXIMUM)
//{
//	m_sbc.SetMinMax(MINIMUM, MAXIMUM);
//}
//
//BarChart::~BarChart(void)
//{
//}

//}


////________________________________________________________ CalendarView
//CalendarView::CalendarView(void)
//{
//	m_nTdCount = 0;
//	Web::TableEx::Create(3, 1);
//
//	//********************************************** main table css setup
//	this->css.background.Set(L"d0d0ff"));
//	this->css.border.Set(L"3px outset #c0c0c0"));
//	this->css.width.Set("100%");
//	this->css.height.Set("100%");
//	//this->CustomData+=("border=\"1\"");
//	//********************************************** Header setup
//	m_tableHeader.css.width.Set(L"100%"));
//	m_tableHeader.Create(1, 3);
//	//
//	// Prev
//	m_tableHeader.GetTd(0, 0).css.textAlign.Set(L"left"));
//	m_tableHeader.GetTd(0, 0).AddChild(m_alPrev);
//	m_alPrev.AddChild(m_spanPrev);
//	m_spanPrev.css.border.Set(L"0px solid #ffffff"));
//	m_spanPrev.css.textDecoration.Set(L"none"));
//	m_spanPrev.SetInnerText(L"<b>&lt;&lt;Prev</b>"), false);
//	//
//	// Header Month, Year
//	m_tableHeader.GetTd(0, 1).css.textAlign.Set(L"center"));
//	//
//	// Next
//	m_tableHeader.GetTd(0, 2).css.textAlign.Set(L"right"));
//	m_tableHeader.GetTd(0, 2).AddChild(m_alNext);
//	m_alNext.AddChild(m_spanNext);
//	m_spanNext.css.border.Set(L"0px solid #ffffff"));
//	m_spanNext.css.textDecoration.Set(L"none"));
//	m_spanNext.SetInnerText(L"<b>Next&gt;&gt;</b>"), false);
//	this->GetTd(0, 0).AddChild(m_tableHeader);
//	this->GetTd(1, 0).AddChild(m_tableDayNames);
//	this->GetTd(2, 0).AddChild(m_tableDays);
//	//
//	this->GetTd(2, 0).css.width.Set(L"100%"));
//	this->GetTr(2).css.width.Set(L"100%"));
//	//
//	m_tableDayNames.css.border.Set(L"1px groove #ffffff"));
//	m_tableDayNames.css.width.Set(L"100%"));
//	m_tableDayNames.css.height.Set(L"100%"));
//	//
//	m_tableDays.css.width.Set(L"100%"));
//	m_tableDays.css.height.Set(L"100%"));
//}
//
//CalendarView::~CalendarView(void)
//{
//}
//
//void CalendarView::Create(bool bDisplayDayNames, bool bDisplayWeekend, int nCalendarPage, bool bSpanish)
//{
//	int nDay = 0;
//	int nMonth = server.GetIntVariable(L"nCalendarMonth"));
//	int nYear = server.GetIntVariable(L"nCalendarYear"));
//	__time64_t lTime, lLocalTime;
//	const int nColCount = bDisplayWeekend ? 7 : 5;
//	m_tableDayNames.Visible = bDisplayDayNames;
//	tm * today;
//	tm When;
//	bool bOk = false;
//	wchar_t szMonth[32];
//	wchar_t szYear[32];
//	wchar_t sz[256];
//	Web::Value wvMonth;
//	Web::Value wvYear;
//	wchar_t szMonthYear[128];
//	Data::DateAndTime dt;
//	int nLocalDay, nLocalMonth, nLocalYear, index, i, j;
//	int nCurrentMonth, nCurrentDay, nCurrentYear;
//
//	if (bDisplayDayNames)
//	{
//		this->GetTr(0).css.height.Set(L"20px"));
//		this->GetTr(1).css.height.Set(L"30px"));
//	}
//	else
//	{
//		this->GetTr(0).css.height.Set(L"20px"));
//		this->GetTr(1).css.height.Set(L"0px"));
//	}
//
//	//
//	if ((nMonth==0) && (nDay==0) && (nYear==0))
//	{
//		_time64(&lTime);
//		today=_localtime64(&lTime);
//		nMonth=today->tm_mon;
//		nDay=today->tm_mday;
//		nYear=today->tm_year;
//		lLocalTime=Data::DateAndTime::FindFirstSunday(lTime);
//		bOk=true;
//	}
//
//	if  (  (0<nMonth) && (nMonth<=12) && (1900<nYear) && (nYear<=9999))
//	{
//		nMonth--;
//		nYear-=1900;
//		When.tm_year=nYear;
//		When.tm_mon=nMonth;
//		When.tm_mday=1;
//		When.tm_hour=12;
//		When.tm_min=0;
//		When.tm_sec=0;
//
//		if ( (lLocalTime=mktime(&When))  !=(time_t)-1)
//		{
//			lLocalTime=Data::DateAndTime::FindFirstSunday(lLocalTime);
//			bOk=true;
//		}
//		else
//			bOk=false;
//	}
//
//	//************************************************ Prev button
//	if (nMonth==0)
//	{	
//		_itot(nYear+1900-1, szYear, 10);
//		lstrcpy(szMonth, L"12"));
//	}
//	else
//	{
//		itoa(nYear+1900, szYear, 10);
//		_itot(nMonth, szMonth, 10); // it should be (nMonth+1)-1
//	}
//	wvMonth.Set(L"nCalendarMonth"), szMonth);
//	wvYear.Set(L"nCalendarYear"), szYear);
//	m_alPrev.AddWebValue(wvMonth);
//	m_alPrev.AddWebValue(wvYear);
//	m_alPrev.Create(false, nCalendarPage);
//
//	//**************************************************** Month, Year
//	_sntprintf(szMonthYear, 128, L"<b>%s, %d</b>"), dt.GetMonthName(nMonth, true), nYear+1900);
//	m_tableHeader.GetTd(0, 1).SetInnerText(szMonthYear, true);
//
//	//************************************************ Next button
//	if (nMonth==11)
//	{	
//		_itot(nYear+1900+1, szYear, 10);
//		lstrcpy(szMonth, L"1"));
//	}
//	else
//	{
//		itoa(nYear+1900, szYear, 10);
//		_itot(nMonth+2, szMonth, 10); // it should be (nMonth+1)+1
//	}
//	wvMonth.Set(L"nCalendarMonth"), szMonth);
//	wvYear.Set(L"nCalendarYear"), szYear);
//	m_alNext.AddWebValue(wvMonth);
//	m_alNext.AddWebValue(wvYear);
//	m_alNext.Create(false, nCalendarPage);
//
//	//************************************************ Sun, Mon ... Sat
//	m_tableDayNames.Create(1, nColCount);
//	m_tableDayNames.GetTr(0).css.height.Set(L"30px"));
//	for(i= 0; i< nColCount; i++)
//	{
//		m_tableDayNames.GetTd(0, i).css.border.Set(L"1px groove #ffffff"));
//		m_tableDayNames.GetTd(0, i).css.textAlign.Set(L"center"));
//		if (bDisplayWeekend)
//		{
//			m_tableDayNames.GetTd(0, i).css.width.Set(L"14.29%"));
//			if (i==0 || i==6)
//			{
//				m_tableDayNames.GetTd(0, i).css.background.Set(L"c0d0ff"));
//			}
//			else
//			{
//				m_tableDayNames.GetTd(0, i).css.background.Set(L"d0f0ff"));
//			}
//		}
//		else
//		{
//			m_tableDayNames.GetTd(0, i).css.width.Set(L"20%"));
//			m_tableDayNames.GetTd(0, i).css.background.Set(L"d0f0ff"));
//		}
//	}
//	if (bDisplayWeekend)
//	{
//		m_tableDayNames.GetTd(0, 0).SetInnerText(L"Sunday"), false);
//		m_tableDayNames.GetTd(0, 1).SetInnerText(L"Monday"), false);
//		m_tableDayNames.GetTd(0, 2).SetInnerText(L"&nbsp;Tuesday&nbsp;"), false);
//		m_tableDayNames.GetTd(0, 3).SetInnerText(L"Wednesday"), false);
//		m_tableDayNames.GetTd(0, 4).SetInnerText(L"Thursday"), false);
//		m_tableDayNames.GetTd(0, 5).SetInnerText(L"&nbsp;&nbsp;Friday&nbsp;&nbsp;"), false);
//		m_tableDayNames.GetTd(0, 6).SetInnerText(L"Saturday"), false);
//	}
//	else
//	{
//		m_tableDayNames.GetTd(0, 0).SetInnerText(L"Monday"), false);
//		m_tableDayNames.GetTd(0, 1).SetInnerText(L"&nbsp;Tuesday&nbsp;"), false);
//		m_tableDayNames.GetTd(0, 2).SetInnerText(L"Wednesday"), false);
//		m_tableDayNames.GetTd(0, 3).SetInnerText(L"Thursday"), false);
//		m_tableDayNames.GetTd(0, 4).SetInnerText(L"&nbsp;&nbsp;Friday&nbsp;&nbsp;"), false);
//	}
//
//	//****************************************** point m_td and css setup
//	index = 0;
//	m_tableDays.Create(6, nColCount);
//	m_nTdCount = 6*nColCount;
//	for(i = 0; i<6; i++)
//	{
//		m_tableDays.GetTr(i).css.verticalAlign.Set(L"top"));
//		for(j = 0; j<nColCount; j++)
//		{
//			m_tdCell[index] = &m_tableDays.GetTd(i, j);
//			//
//			m_tdCell[index]->AddChild(m_span[index]);
//			//
//			if (bDisplayWeekend)
//				m_tdCell[index]->css.width.Set(L"14.29%"));
//			else
//				m_tdCell[index]->css.width.Set(L"20%"));
//			index++;
//		}
//	}
//
//	//********************************************************** tds setup
//	today=_localtime64(&lLocalTime);
//	nLocalDay=today->tm_mday;
//	nLocalMonth=today->tm_mon;
//	nLocalYear=today->tm_year;
//	index = 0;
//	bool bIsWeekend = false;
//	bool bIsToday = false;
//	Data::DateAndTime::GetCurrentDate(nCurrentMonth, nCurrentDay, nCurrentYear);
//	for (i=0; i<42; i++)
//	{
//		bIsWeekend = ((i%7)==0 || ((i+1)%7==0));
//		bIsToday = (nLocalDay == nCurrentDay && nLocalMonth == nCurrentMonth && nLocalYear+1900==nCurrentYear);
//		if (bDisplayWeekend)//***************************** Display working days and weekend
//		{
//			m_tm[index]=lLocalTime;
//			if (bIsToday)
//			{
//				_sntprintf(sz, 256, L"<b><u>%d</u></b>"), nLocalDay);
//			}
//			else
//			{
//				_sntprintf(sz, 256, L"%d"), nLocalDay);
//			}
//			m_span[index].css.SetFont(L"Times New Roman"), 17);
//			m_span[index].SetInnerText(sz, true);
//			//		
//			if (nLocalMonth==nMonth)
//			{
//				if (bIsToday)
//				{
//					m_tdCell[index]->css.background.Set(L"ffffe0"));
//				}
//				else
//				{
//					m_tdCell[index]->css.background.Set(L"ffffff"));
//				}
//			}
//			else
//				m_tdCell[index]->css.background.Set(L"c0c0c0"));
//
//			m_tdCell[index]->css.border.Set(L"1px groove #ffffff"));
//			//
//			if (bIsWeekend)
//			{
//				m_span[index].css.color.Set(L"b0b0b0"));
//			}
//			else
//			{
//				m_span[index].css.color.Set(L"f00000"));
//			}
//			index++;
//		}
//		else//**************************************************Display only working days
//		{
//			if (!bIsWeekend)
//			{
//				m_tm[index]=lLocalTime;
//				m_span[index].css.SetFont(L"Times New Roman"), 17);
//				if (bIsToday)
//				{
//					_sntprintf(sz, 256, L"<b><u>%d</u></b>"), nLocalDay);
//				}
//				else
//				{
//					_sntprintf(sz, 256, L"%d"), nLocalDay);
//				}
//				m_span[index].SetInnerText(sz, true);
//				//		
//				if (nLocalMonth==nMonth)
//				{
//					if (bIsToday)
//					{
//						m_tdCell[index]->css.background.Set(L"ffffe0"));
//					}
//					else
//					{
//						m_tdCell[index]->css.background.Set(L"ffffff"));
//					}
//				}
//				else
//				{
//					m_tdCell[index]->css.background.Set(L"c0c0c0"));
//				}
//
//				m_tdCell[index]->css.border.Set(L"1px groove #ffffff"));
//				//
//				m_span[index].css.color.Set(L"f00000"));
//
//				index++;
//			}
//		}
//		lLocalTime=lLocalTime+86400;
//		today=_localtime64(&lLocalTime);
//		nLocalDay=today->tm_mday;
//		nLocalMonth=today->tm_mon;
//		nLocalYear=today->tm_year;
//	}
//}
//
//int CalendarView::GetCellCount()
//{
//	return m_nTdCount;
//}
//
//Web::Td* CalendarView::GetCell(int index)
//{
//	if (0<=index && index<m_nTdCount)
//	{
//		return m_tdCell[index];
//	}
//	else
//	{
//		return NULL;
//	}
//}
//
//__time64_t CalendarView::GetCellInfo(int index)
//{
//	if (0<=index && index<m_nTdCount)
//	{
//		return m_tm[index];
//	}
//	else
//	{
//		return 0;
//	}
//}
//
